<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/air.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/air.svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/air.svg">
  <link rel="mask-icon" href="/images/air.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.kuga.fun","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="限流限流是保护高并发系统的三把利器之一（限流、缓存、降级）；其目的是通过对并发访问或请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务或进行流量整形 限流的类型可大致分为：  限制总并发数 - 数据库连接池、线程池 限制瞬时并发数 - nginx 的 limitconn 模块、Java Semaphore 限制并发 限制时间窗口内的平均速率 - Guava 的">
<meta property="og:type" content="article">
<meta property="og:title" content="Guava RateLimiter">
<meta property="og:url" content="https://www.kuga.fun/%E5%BC%80%E5%8F%91/%E5%B9%B6%E5%8F%91/Guava%20RateLimiter.html">
<meta property="og:site_name" content="贫瘠之地">
<meta property="og:description" content="限流限流是保护高并发系统的三把利器之一（限流、缓存、降级）；其目的是通过对并发访问或请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务或进行流量整形 限流的类型可大致分为：  限制总并发数 - 数据库连接池、线程池 限制瞬时并发数 - nginx 的 limitconn 模块、Java Semaphore 限制并发 限制时间窗口内的平均速率 - Guava 的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.kuga.fun/%E5%BC%80%E5%8F%91/%E5%B9%B6%E5%8F%91/Guava%20RateLimiter/RateLimiter%E7%B1%BB%E5%9B%BE.png">
<meta property="og:image" content="https://www.kuga.fun/%E5%BC%80%E5%8F%91/%E5%B9%B6%E5%8F%91/Guava%20RateLimiter/%E8%AE%B8%E5%8F%AF%E9%A2%84%E7%83%AD.drawio.png">
<meta property="og:image" content="https://www.kuga.fun/%E5%BC%80%E5%8F%91/%E5%B9%B6%E5%8F%91/Guava%20RateLimiter/%E8%AE%B8%E5%8F%AF%E9%A2%84%E7%83%AD%E8%8E%B7%E5%8F%96%E8%AE%B8%E5%8F%AF.drawio.png">
<meta property="article:published_time" content="2023-01-07T16:00:00.000Z">
<meta property="article:modified_time" content="2023-01-07T16:00:00.000Z">
<meta property="article:author" content="Kuga">
<meta property="article:tag" content="源码">
<meta property="article:tag" content="Guava">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.kuga.fun/%E5%BC%80%E5%8F%91/%E5%B9%B6%E5%8F%91/Guava%20RateLimiter/RateLimiter%E7%B1%BB%E5%9B%BE.png">

<link rel="canonical" href="https://www.kuga.fun/%E5%BC%80%E5%8F%91/%E5%B9%B6%E5%8F%91/Guava%20RateLimiter.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Guava RateLimiter | 贫瘠之地</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">贫瘠之地</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">华北无浪漫，死海扬起帆<br>多少个夜晚，独自望着天</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.kuga.fun/%E5%BC%80%E5%8F%91/%E5%B9%B6%E5%8F%91/Guava%20RateLimiter.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kuga">
      <meta itemprop="description" content="欢迎来到知识的荒漠">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="贫瘠之地">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Guava RateLimiter
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-08 00:00:00" itemprop="dateCreated datePublished" datetime="2023-01-08T00:00:00+08:00">2023-01-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
                </span>
                  >
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E5%8F%91/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><p>限流是保护高并发系统的三把利器之一（限流、缓存、降级）；其目的是通过对并发访问或请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务或进行流量整形</p>
<p>限流的类型可大致分为：</p>
<ul>
<li>限制总并发数 - 数据库连接池、线程池</li>
<li>限制瞬时并发数 - nginx 的 limitconn 模块、Java Semaphore 限制并发</li>
<li>限制时间窗口内的平均速率 - Guava 的 RateLimiter</li>
<li>其他 - 根据网络流量、CPU 占用率、内存占用率等作为标准来进行限流</li>
</ul>
<h1 id="桶漏-amp-令牌桶"><a href="#桶漏-amp-令牌桶" class="headerlink" title="桶漏 &amp; 令牌桶"></a>桶漏 &amp; 令牌桶</h1><p>桶漏和令牌桶指的是限流的两种模型，其目的都是限流以达到限制时间窗口内的平均速率的目的</p>
<p>桶漏是接收请求，并按照一定的速率通过请求</p>
<p>令牌桶是按照固定的速率生产令牌，请求需要获取对应的令牌才能通过</p>
<h1 id="RateLimiter"><a href="#RateLimiter" class="headerlink" title="RateLimiter"></a>RateLimiter</h1><p>Guava 是 Java 领域优秀的开源项目，它包含了 Google 在 Java 项目中使用一些核心库</p>
<p>其中就有限流相关的 <code>RateLimiter</code> 工具，底层基于令牌桶思想，提供了平滑突发限流（SmoothBursty）和平滑预热限流（SmoothWarmingUp）多种实现</p>
<p>类图属性如下：</p>
<img src="/%E5%BC%80%E5%8F%91/%E5%B9%B6%E5%8F%91/Guava%20RateLimiter/RateLimiter%E7%B1%BB%E5%9B%BE.png" class="">



<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>最终的实现类都是 <code>SmoothRateLimiter</code> 的内部类，但是创建方法放在了更上层的 <code>RateLimiter</code> 中（工厂）</p>
<p>调用 <code>RateLimiter.create()</code> 静态方法进行创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NO.1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RateLimiter <span class="title function_">create</span><span class="params">(<span class="type">double</span> permitsPerSecond)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> create(SleepingStopwatch.createFromSystemTimer(), permitsPerSecond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NO.2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RateLimiter <span class="title function_">create</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">long</span> warmupPeriod, TimeUnit unit)</span> &#123;</span><br><span class="line">    checkArgument(warmupPeriod &gt;= <span class="number">0</span>, <span class="string">&quot;warmupPeriod must not be negative: %s&quot;</span>, warmupPeriod);</span><br><span class="line">    <span class="keyword">return</span> create(</span><br><span class="line">        SleepingStopwatch.createFromSystemTimer(), permitsPerSecond, warmupPeriod, unit, <span class="number">3.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>SmoothBursty</strong></p>
<p>先看参数列表为 <code>double permitsPerSecond</code> 的方法，<code>SleepingStopwatch.createFromSystemTimer()</code> 创建了一个 <code>SleepingStopwatch</code> 后调用了下一层创建方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> RateLimiter <span class="title function_">create</span><span class="params">(SleepingStopwatch stopwatch, <span class="type">double</span> permitsPerSecond)</span> &#123;</span><br><span class="line">    <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmoothBursty</span>(stopwatch, <span class="number">1.0</span> <span class="comment">/* maxBurstSeconds */</span>);</span><br><span class="line">    rateLimiter.setRate(permitsPerSecond);</span><br><span class="line">    <span class="keyword">return</span> rateLimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SleepingStopwatch</code> 的目的是记录创建时间和计算相对时间，整个 <code>RateLimiter</code> 的时间都是相对创建时间而言的，也就是时间的运算依赖 <code>SleepingStopwatch</code> 对象</p>
<p><code>new SmoothBursty(stopwatch, 1.0)</code> 的参数除了时间相关的对象，就是 <code>maxBurstSeconds = 1</code> 了，可以看出默认的 <code>SmoothBursty</code> 其应对突发流量的设置是多存储时间为 1s 的许可</p>
<p>而后调用了 <code>rateLimiter.setRate(permitsPerSecond)</code>，这个先放在后面</p>
<p><strong>SmoothWarmingUp</strong></p>
<p>参数列表为 <code>double permitsPerSecond, long warmupPeriod, TimeUnit unit</code> 的方法，先对参数进行了校验，随后也调用了下一层的创建方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> RateLimiter <span class="title function_">create</span><span class="params">(</span></span><br><span class="line"><span class="params">    SleepingStopwatch stopwatch,</span></span><br><span class="line"><span class="params">    <span class="type">double</span> permitsPerSecond,</span></span><br><span class="line"><span class="params">    <span class="type">long</span> warmupPeriod,</span></span><br><span class="line"><span class="params">    TimeUnit unit,</span></span><br><span class="line"><span class="params">    <span class="type">double</span> coldFactor)</span> &#123;</span><br><span class="line">    <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmoothWarmingUp</span>(stopwatch, warmupPeriod, unit, coldFactor);</span><br><span class="line">    rateLimiter.setRate(permitsPerSecond);</span><br><span class="line">    <span class="keyword">return</span> rateLimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程和 <code>SmoothBursty</code> 类似，多了 <code>warmupPeriod</code> 相关的参数，也是用来实现 WarmingUp 的关键参数</p>
<p>后面也调用了 <code>rateLimiter.setRate(permitsPerSecond)</code></p>
<h2 id="设置-rate"><a href="#设置-rate" class="headerlink" title="设置 rate"></a>设置 rate</h2><p>rate 的设置关键参数是 <code>permitsPerSecond</code>，这是使用者传入的参数，代表每秒希望生产的许可数量（不一定代表 QPS，因为每次请求许可不一定请求一个）</p>
<p>调用 <code>RateLimiter</code> 的 <code>setRate</code> 方法进行设置，在每次创建 <code>RateLimiter</code> 时，创建方法在实例化后也会调用一次该方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setRate</span><span class="params">(<span class="type">double</span> permitsPerSecond)</span> &#123;</span><br><span class="line">    checkArgument(</span><br><span class="line">        permitsPerSecond &gt; <span class="number">0.0</span> &amp;&amp; !Double.isNaN(permitsPerSecond), <span class="string">&quot;rate must be positive&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex()) &#123; <span class="comment">// 获取锁</span></span><br><span class="line">        doSetRate(permitsPerSecond, stopwatch.readMicros());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先进行参数校验，随后获取锁调用 <code>doSetRate</code> 方法；这里可以进行一个猜想，设置 rate 和获取许可保证并发的锁一定是同一把，看起来统一封装到了 <code>mutex()</code> 方法里，而后调用了 <code>doSetRate</code></p>
<p><strong>SmoothRateLimiter 的 doSetRate</strong></p>
<p>在 <code>RateLimiter</code> 中，<code>doSetRate</code> 是一个抽象方法，<code>SmoothRateLimiter </code> 进行了实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doSetRate</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">long</span> nowMicros)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doSetRate</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">    resync(nowMicros);</span><br><span class="line">    <span class="type">double</span> <span class="variable">stableIntervalMicros</span> <span class="operator">=</span> SECONDS.toMicros(<span class="number">1L</span>) / permitsPerSecond;</span><br><span class="line">    <span class="built_in">this</span>.stableIntervalMicros = stableIntervalMicros;</span><br><span class="line">    doSetRate(permitsPerSecond, stableIntervalMicros);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先调用 <code>resync</code> 方法重新计算 <code>this.storedPermits</code> 和 <code>this.nextFreeTicketMicros</code> 这两个重要属性；这是一个常用的方法，在后续流程中会有多个操作都调用该方法，具体实现在后面进行分析</p>
<p>根据参数 <code>permitsPerSecond</code> 计算出一秒内许可生产的间隔，赋值给 <code>this.stableIntervalMicros</code></p>
<p>继续调用 <code>doSetRate</code></p>
<p><strong>SmoothBursty 的 doSetRate</strong></p>
<p><code>SmoothRateLimiter</code>  的 <code>doSetRate</code> 也是一个抽象方法，<code>SmoothBursty </code> 进行了实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doSetRate</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">double</span> stableIntervalMicros)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doSetRate</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">double</span> stableIntervalMicros)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">oldMaxPermits</span> <span class="operator">=</span> <span class="built_in">this</span>.maxPermits;</span><br><span class="line">    maxPermits = maxBurstSeconds * permitsPerSecond;</span><br><span class="line">    <span class="keyword">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class="line">        <span class="comment">// if we don&#x27;t special-case this, we would get storedPermits == NaN, below</span></span><br><span class="line">        storedPermits = maxPermits;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 等比缩放已经存储的许可数量</span></span><br><span class="line">        storedPermits =</span><br><span class="line">            (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">            ? <span class="number">0.0</span> <span class="comment">// initial state</span></span><br><span class="line">            : storedPermits * maxPermits / oldMaxPermits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要计算了新的 <code>maxPermits</code>，并根据旧的 <code>maxPermits</code>，即 <code>oldMaxPermits</code> 计算了 <code>storedPermits</code> 的值</p>
<p>相当于设置了新的 <code>permitsPerSecond</code>，需要计算新的 <code>maxPermits</code>，并等比缩放已经存储的许可数量</p>
<h2 id="获取许可（permits）"><a href="#获取许可（permits）" class="headerlink" title="获取许可（permits）"></a>获取许可（permits）</h2><p>创建 <code>RateLimiter</code> 对象后，使用 <code>acquire</code> 或者 <code>tryAcquire</code> 方法来获取许可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">10</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">sleepTime</span> <span class="operator">=</span> rateLimiter.acquire(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>最终的返回值是等待的时间，并且在返回之前该线程一直在等待</p>
<p>着重看下 <code>acquire</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> permits)</span> &#123; <span class="comment">// 参数 permits 代表一次需要获取的许可数量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">microsToWait</span> <span class="operator">=</span> reserve(permits); <span class="comment">// 调用 reserve 方法</span></span><br><span class="line">    stopwatch.sleepMicrosUninterruptibly(microsToWait); <span class="comment">// microsToWait &gt; 0 则 sleep</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * microsToWait / SECONDS.toMicros(<span class="number">1L</span>); <span class="comment">// 换算成 s 返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是通过 <code>reserve</code> 方法，返回的是一个需要等待的微秒值 <code>microsToWait</code>，如果大于 0 则进行 sleep 操作（使用的同样是 Guava 包下的 <code>Uninterruptibles</code>，先不关注）</p>
<p>最终将等待的微秒换算成单位秒返回</p>
<p><strong>reserve</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserve</span><span class="params">(<span class="type">int</span> permits)</span> &#123;</span><br><span class="line">    checkPermits(permits); <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mutex()) &#123; <span class="comment">// 上锁</span></span><br><span class="line">        <span class="keyword">return</span> reserveAndGetWaitLength(permits, stopwatch.readMicros());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法里主要做了两部分操作</p>
<ol>
<li>校验参数 <code>permits</code> 合法性，其实就是是否大于 0 <code>checkArgument(permits &gt; 0, &quot;Requested permits (%s) must be positive&quot;, permits);</code></li>
<li>使用 <code>synchronized</code> 关键字上锁（<code>mutex</code> 方法返回的是 <code>this.mutexDoNotUseDirectly</code> 一个 <code>Object</code> 对象），上锁后执行 <code>reserveAndGetWaitLength</code> 方法</li>
</ol>
<p><strong>reserveAndGetWaitLength</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserveAndGetWaitLength</span><span class="params">(<span class="type">int</span> permits, <span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">momentAvailable</span> <span class="operator">=</span> reserveEarliestAvailable(permits, nowMicros);</span><br><span class="line">    <span class="keyword">return</span> max(momentAvailable - nowMicros, <span class="number">0</span>); <span class="comment">// 计算一下是不是需要 wait</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过方法名 “获取等待长度”，可以知道这里主要是通过 <code>reserveEarliestAvailable</code> 获取一个时间（这个时间在后面的方法中可知是下一次获取许可的时间）后，在次方法最终确认需要等待的时间并返回 <code>max(momentAvailable - nowMicros, 0)</code>，如果不需要等待（<code>momentAvailable - nowMicros &lt; 0</code>），则返回 0</p>
<p><strong>arliestAvailable</strong></p>
<p><code>RateLimiter</code> 是一个抽象类，这个方法是一个抽象方法，由 <code>SmoothRateLimiter</code> 进行了实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="type">long</span> <span class="title function_">reserveEarliestAvailable</span><span class="params">(<span class="type">int</span> permits, <span class="type">long</span> nowMicros)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserveEarliestAvailable</span><span class="params">(<span class="type">int</span> requiredPermits, <span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">    resync(nowMicros); <span class="comment">// 重新计算 storedPermits 和 nextFreeTicketMicros</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">returnValue</span> <span class="operator">=</span> nextFreeTicketMicros; <span class="comment">// 保存 nextFreeTicketMicros，因为后面可能会被更新</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">storedPermitsToSpend</span> <span class="operator">=</span> min(requiredPermits, <span class="built_in">this</span>.storedPermits); <span class="comment">// 仓库能提供的许可</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">freshPermits</span> <span class="operator">=</span> requiredPermits - storedPermitsToSpend; <span class="comment">// 这次请求超出仓库能力的许可</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">waitMicros</span> <span class="operator">=</span> <span class="comment">// 等待时间</span></span><br><span class="line">        storedPermitsToWaitTime(<span class="built_in">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class="line">        + (<span class="type">long</span>) (freshPermits * stableIntervalMicros);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros); <span class="comment">// 根据等待时间延长下一次能够获取许可的时间</span></span><br><span class="line">    <span class="built_in">this</span>.storedPermits -= storedPermitsToSpend; <span class="comment">// 调整仓库许可数量；即 freshPermits &gt; 0，storedPermits 一定 = 0</span></span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一行就调用了方法 <code>resync()</code>，该方法的目的是重新计算 <code>this.storedPermits</code> 和 <code>this.nextFreeTicketMicros</code> 这两个重要属性</p>
<p>接下来的几行操作可以概括为：如果需要获取的许可大于当前已经存储的许可，那么计算出超出的许可数量 <code>freshPermits</code>，调用 <code>storedPermitsToWaitTime</code> 方法返回值加上 <code>超出的许可数量 × 许可生产间隔</code> 即可算出需要额外等待的时长；这里对于 <code>SmoothBursty</code> 来说，返回固定是 0，也就是额外的等待时间就是 <code>超出的许可数量 × 许可生产间隔</code></p>
<p>最后更新这次操作后 <code>this.nextFreeTicketMicros</code> 和 <code>this.storedPermits</code> 的值，返回一开始保存的 <code>this.nextFreeTicketMicros</code></p>
<p><strong>这里需要思考一个问题</strong>：为什么返回的是 <code>resync</code> 后的 <code>nextFreeTicketMicros</code>？如果令牌数量不够，这个值不是被向后更新了吗？这里就体现出 <code>RateLimiter</code> 整体的一个思想，即每一个请求过来本质上都能拿到许可，无非是等待多长时间才能执行，对于超出部分来说，当前线程不用等待，将这部分时间全部交给下一个线程来进行等待了，我自己概括起来就是 <strong>惰性计算 + 以当前线程为主</strong></p>
<p><strong>resync</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resync</span><span class="params">(<span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">    <span class="comment">// if nextFreeTicket is in the past, resync to now</span></span><br><span class="line">    <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">newPermits</span> <span class="operator">=</span> (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();</span><br><span class="line">        storedPermits = min(maxPermits, storedPermits + newPermits);</span><br><span class="line">        nextFreeTicketMicros = nowMicros;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的目的是重新计算 <code>this.storedPermits</code> 和 <code>this.nextFreeTicketMicros</code> 这两个重要属性</p>
<p>如果当前时间超过了之前计算的下一次获取许可的时间，则开始更新：</p>
<ol>
<li>先计算新产生的许可数量（<code>coolDownIntervalMicros()</code> 返回的是许可生产的固定间隔）</li>
<li>更新 <code>this.storedPermits</code> 为合适的值（<code>SmoothBursty</code> 最多只能多存储 1s 的许可）</li>
<li>更新 <code>this.nextFreeTicketMicros</code> 为参数 <code>nowMicros</code></li>
</ol>
<h2 id="预热（WarmingUp）"><a href="#预热（WarmingUp）" class="headerlink" title="预热（WarmingUp）"></a>预热（WarmingUp）</h2><p>上面的分析主要是对 <code>SmoothBursty</code> 进行了分析，还提供了一种实现是 <code>SmoothWarmingUp</code></p>
<p><code>SmoothWarmingUp</code> 适用于资源需要预热的场景，相比 <code>SmoothBursty</code> 是对突发流量进行保证，通过 <code>maxBurstSeconds</code> 来计算额外存储的令牌数量，<code>SmoothWarmingUp</code> 使用 <code>warmupPeriod</code> 参数来设置预热的时长</p>
<p>由于预热机制的存在，其生产许可的速度是应该是动态的，如下图</p>
<img src="/%E5%BC%80%E5%8F%91/%E5%B9%B6%E5%8F%91/Guava%20RateLimiter/%E8%AE%B8%E5%8F%AF%E9%A2%84%E7%83%AD.drawio.png" class="" title="许可预热.drawio">

<p>其许可数量越多，说明还没到稳定时期，许可的生产间隔就要越长；许可少说明处于稳定期</p>
<p><strong>关键属性计算</strong></p>
<p>根据该图可以计算出一些数值，首先需要确定的是，从 <code>thresholdPermits</code> 到 0 的时间，是从 <code>maxPermits</code> 到 <code>thresholdPermits</code> 时间的一半，也就是梯形的面积是长方形面积的 2 倍，梯形的面积是 <code>warmupPeriod</code></p>
<p>因为在创建 <code>SmoothWarmingUp</code> 默认的 coldFactor 为 3 <code>SleepingStopwatch.createFromSystemTimer(), permitsPerSecond, warmupPeriod, unit, 3.0);</code> </p>
<p>梯形面积为 <code>warmupPeriod</code>，而长方形面积为 <code>stableInterval × thresholdPermits</code>，即：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warmupPeriod = <span class="number">2</span> * stableInterval * thresholdPermits</span><br></pre></td></tr></table></figure>

<p>由此，我们得出 <code>thresholdPermits</code> 的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thresholdPermits = <span class="number">0.5</span> * warmupPeriod / stableInterval</span><br></pre></td></tr></table></figure>

<p>然后我们根据梯形面积的计算公式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warmupPeriod = <span class="number">0.5</span> * (stableInterval + coldInterval) * (maxPermits - thresholdPermits)</span><br></pre></td></tr></table></figure>

<p>得出 <code>maxPermits</code> 为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxPermits = thresholdPermits + <span class="number">2.0</span> * warmupPeriod / (stableInterval + coldInterval)</span><br></pre></td></tr></table></figure>

<p>这样，我们就得到了 <code>thresholdPermits</code> 和 <code>maxPermits</code> 的值</p>
<p>最后是冷却时间的间隔，对应到图中代表的是斜线的斜率，即由稳定到冷却中的速度；在代码中为：</p>
<p>该方法 <code>SmoothBursty</code> 的实现始终返回 0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">coolDownIntervalMicros</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> warmupPeriodMicros / maxPermits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>doSetRate</strong></p>
<p>上面分析了 <code>SmoothBursty</code> 的 <code>doSetRate</code> 实现，这里来看 <code>SmoothWarmingUp</code> 的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doSetRate</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">double</span> stableIntervalMicros)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">oldMaxPermits</span> <span class="operator">=</span> maxPermits;</span><br><span class="line">    <span class="type">double</span> <span class="variable">coldIntervalMicros</span> <span class="operator">=</span> stableIntervalMicros * coldFactor; <span class="comment">// coldFactor 是固定的 3</span></span><br><span class="line">    thresholdPermits = <span class="number">0.5</span> * warmupPeriodMicros / stableIntervalMicros;</span><br><span class="line">    maxPermits =</span><br><span class="line">        thresholdPermits + <span class="number">2.0</span> * warmupPeriodMicros / (stableIntervalMicros + coldIntervalMicros);</span><br><span class="line">    slope = (coldIntervalMicros - stableIntervalMicros) / (maxPermits - thresholdPermits); <span class="comment">// 计算斜率，对边 / 临边</span></span><br><span class="line">    <span class="keyword">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class="line">        <span class="comment">// if we don&#x27;t special-case this, we would get storedPermits == NaN, below</span></span><br><span class="line">        storedPermits = <span class="number">0.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        storedPermits =</span><br><span class="line">            (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">            ? maxPermits <span class="comment">// initial state is cold</span></span><br><span class="line">            : storedPermits * maxPermits / oldMaxPermits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是计算了相关的属性并赋值给成员变量，计算方法都和上图一致</p>
<p><strong>acquire 的 storedPermitsToWaitTime</strong></p>
<p><code>acquire</code> 流程和 <code>SmoothBursty</code> 基本一致，区别在于 <code>storedPermitsToWaitTime</code> 方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserveEarliestAvailable</span><span class="params">(<span class="type">int</span> requiredPermits, <span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">    resync(nowMicros);</span><br><span class="line">    <span class="type">long</span> <span class="variable">returnValue</span> <span class="operator">=</span> nextFreeTicketMicros;</span><br><span class="line">    <span class="type">double</span> <span class="variable">storedPermitsToSpend</span> <span class="operator">=</span> min(requiredPermits, <span class="built_in">this</span>.storedPermits);</span><br><span class="line">    <span class="type">double</span> <span class="variable">freshPermits</span> <span class="operator">=</span> requiredPermits - storedPermitsToSpend;</span><br><span class="line">    <span class="type">long</span> <span class="variable">waitMicros</span> <span class="operator">=</span></span><br><span class="line">        storedPermitsToWaitTime(<span class="built_in">this</span>.storedPermits, storedPermitsToSpend) <span class="comment">// 在于这里的方法</span></span><br><span class="line">        + (<span class="type">long</span>) (freshPermits * stableIntervalMicros);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);</span><br><span class="line">    <span class="built_in">this</span>.storedPermits -= storedPermitsToSpend;</span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>waitMicros</code> 由两部分组成，一部分是从 <code>storedPermits</code> 中获取花费的时间，一部分是等待 <code>freshPermits</code> 产生花费的时间；<code>SmoothBursty</code> 的该方法实现固定返回 0，即不存在从 <code>storedPermits</code> 获取许可的花费，而 <code>SmoothWarmingUp</code> 实现较为复杂</p>
<p>由于需要预热，所以从存储的许可中中取许可需要花费一定的时间，其实就是要计算下图中，阴影部分的面积</p>
<img src="/%E5%BC%80%E5%8F%91/%E5%B9%B6%E5%8F%91/Guava%20RateLimiter/%E8%AE%B8%E5%8F%AF%E9%A2%84%E7%83%AD%E8%8E%B7%E5%8F%96%E8%AE%B8%E5%8F%AF.drawio.png" class="" title="许可预热获取许可.drawio">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">storedPermitsToWaitTime</span><span class="params">(<span class="type">double</span> storedPermits, <span class="type">double</span> permitsToTake)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">availablePermitsAboveThreshold</span> <span class="operator">=</span> storedPermits - thresholdPermits;</span><br><span class="line">    <span class="type">long</span> <span class="variable">micros</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// measuring the integral on the right part of the function (the climbing line)</span></span><br><span class="line">    <span class="comment">// 如果右边梯形部分有 permits，那么先从右边部分获取 permits，计算梯形部分的阴影部分的面积</span></span><br><span class="line">    <span class="keyword">if</span> (availablePermitsAboveThreshold &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="comment">// 从右边部分获取的 permits 数量</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">permitsAboveThresholdToTake</span> <span class="operator">=</span> min(availablePermitsAboveThreshold, permitsToTake);</span><br><span class="line">        <span class="comment">// TODO(cpovirk): Figure out a good name for this variable.</span></span><br><span class="line">        <span class="comment">// 梯形面积公式：(上底 + 下底) × 高 / 2</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">length</span> <span class="operator">=</span> permitsToTime(availablePermitsAboveThreshold)</span><br><span class="line">            + permitsToTime(availablePermitsAboveThreshold - permitsAboveThresholdToTake);</span><br><span class="line">        micros = (<span class="type">long</span>) (permitsAboveThresholdToTake * length / <span class="number">2.0</span>);</span><br><span class="line">        permitsToTake -= permitsAboveThresholdToTake;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// measuring the integral on the left part of the function (the horizontal line)</span></span><br><span class="line">    <span class="comment">// 加上长方形部分的阴影面积</span></span><br><span class="line">    micros += (stableIntervalMicros * permitsToTake);</span><br><span class="line">    <span class="keyword">return</span> micros;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于给定的 x 值，计算 y 值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> <span class="title function_">permitsToTime</span><span class="params">(<span class="type">double</span> permits)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> stableIntervalMicros + permits * slope;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终将这部分等待时间返回，达到预热等待的目的</p>
<h1 id="重点问题"><a href="#重点问题" class="headerlink" title="重点问题"></a>重点问题</h1><h2 id="许可从哪来"><a href="#许可从哪来" class="headerlink" title="许可从哪来"></a>许可从哪来</h2><p>经过上面的分析，可以得出，所谓的许可是惰性的运算，并不是表面理解的可能存在一个线程在生产许可，而是当请求进入时才会计算许可相关的数据（下一次许可时间、存储的许可数量、满足当前请求许可需要等待的时间等），然后对该请求行为进行处理</p>
<h2 id="并发安全是如何保证的"><a href="#并发安全是如何保证的" class="headerlink" title="并发安全是如何保证的"></a>并发安全是如何保证的</h2><p>并发主要出现在两个地方，<code>setRate</code> 设置速率方法和 <code>acquire</code> 获取许可方法内，并且这两个方法也互斥</p>
<p>关键的方法在 <code>reserve()</code> 内</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserve</span><span class="params">(<span class="type">int</span> permits)</span> &#123;</span><br><span class="line">    checkPermits(permits);</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex()) &#123;</span><br><span class="line">        <span class="keyword">return</span> reserveAndGetWaitLength(permits, stopwatch.readMicros());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么着重关注 <code>mutex()</code> 返回了什么对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Can&#x27;t be initialized in the constructor because mocks don&#x27;t call the constructor.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Object mutexDoNotUseDirectly;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">mutex</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">mutex</span> <span class="operator">=</span> mutexDoNotUseDirectly;</span><br><span class="line">    <span class="keyword">if</span> (mutex == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            mutex = mutexDoNotUseDirectly;</span><br><span class="line">            <span class="keyword">if</span> (mutex == <span class="literal">null</span>) &#123;</span><br><span class="line">                mutexDoNotUseDirectly = mutex = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mutex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会有几个疑问与答案：</p>
<ul>
<li><code>Object mutex = mutexDoNotUseDirectly</code> 为什么不直接操作 <code>this.mutexDoNotUseDirectly</code>，要使用一个临时变量</li>
<li><code>mutexDoNotUseDirectly</code> 锁对象的创建有必要使用懒汉式吗？<code>RateLimiter</code> 在实例化后直接执行了 <code>reserve</code> 方法，那么这个懒加载的单例意义是什么</li>
<li>为什么不使用 <code>synchronized (this)</code>，包装了一个方法 <code>mutex()</code> 来返回锁对象</li>
</ul>
<p><strong>第一个问题</strong>：减少 <code>volatile</code> 对内存的读请求；<code>mutexDoNotUseDirectly</code> 是可见的，每次读取都会访问内存，使用临时变量对于不需要可见性的场景能减少访问内存的次数</p>
<blockquote>
<p>It avoids an additional volatile read of the field once it’s determined to be non-null.<br>详见 issue：<a target="_blank" rel="noopener" href="https://github.com/google/guava/issues/3381">https://github.com/google/guava/issues/3381</a></p>
</blockquote>
<p><strong>第二个问题</strong>：源代码注释中也已经解释了目的：<code>// Can&#39;t be initialized in the constructor because mocks don&#39;t call the constructor.</code></p>
<p>作者是考虑到使用 Mockito 框架时，用 mock 方法创建 <code>RateLimiter</code> 的 mock 对象不会执行其构造器，该锁对象不会被实例化；并且成员变量直接赋值也会被解释为构造器的一部分</p>
<blockquote>
<p>Inline field initialization is syntactic sugar for initializing from the constructor.<br>详见 issue：<a target="_blank" rel="noopener" href="https://github.com/google/guava/issues/3066">https://github.com/google/guava/issues/3066</a></p>
</blockquote>
<p><strong>第三个问题</strong>：更方便控制锁粒度，并且避免使用 <code>this</code> 作为锁对象是一种规范，因为无法得知外部是否也是用 <code>this</code> 作为锁来使用</p>
<blockquote>
<p>可以参考该回答：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12397427/what-is-different-between-method-synchronized-vs-object-synchronized">https://stackoverflow.com/questions/12397427/what-is-different-between-method-synchronized-vs-object-synchronized</a></p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60979444">超详细的Guava RateLimiter限流原理解析 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/egg1996911/article/details/103928573">Guava限流器RateLimiter中mutexDoNotUseDirectly&#x2F;锁的使用_DengDengLei的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/shenchaohao12321/article/details/112143092">RateLimiter 源码分析(Guava 和 Sentinel 实现)_一直不懂的博客-CSDN博客_sentinel ratelimiter</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%BA%90%E7%A0%81/" rel="tag"># 源码</a>
              <a href="/tags/Guava/" rel="tag"># Guava</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE.html" rel="prev" title="对象创建与属性设置">
      <i class="fa fa-chevron-left"></i> 对象创建与属性设置
    </a></div>
      <div class="post-nav-item">
    <a href="/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/%E5%95%A4%E9%85%92%E8%8A%B1%EF%BC%9A%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86.html" rel="next" title="啤酒花：你需要知道的知识">
      啤酒花：你需要知道的知识 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%90%E6%B5%81"><span class="nav-number">1.</span> <span class="nav-text">限流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A1%B6%E6%BC%8F-amp-%E4%BB%A4%E7%89%8C%E6%A1%B6"><span class="nav-number">2.</span> <span class="nav-text">桶漏 &amp; 令牌桶</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RateLimiter"><span class="nav-number">3.</span> <span class="nav-text">RateLimiter</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA"><span class="nav-number">3.1.</span> <span class="nav-text">创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE-rate"><span class="nav-number">3.2.</span> <span class="nav-text">设置 rate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%AE%B8%E5%8F%AF%EF%BC%88permits%EF%BC%89"><span class="nav-number">3.3.</span> <span class="nav-text">获取许可（permits）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E7%83%AD%EF%BC%88WarmingUp%EF%BC%89"><span class="nav-number">3.4.</span> <span class="nav-text">预热（WarmingUp）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E7%82%B9%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">重点问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B8%E5%8F%AF%E4%BB%8E%E5%93%AA%E6%9D%A5"><span class="nav-number">4.1.</span> <span class="nav-text">许可从哪来</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%9A%84"><span class="nav-number">4.2.</span> <span class="nav-text">并发安全是如何保证的</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">5.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Kuga</p>
  <div class="site-description" itemprop="description">欢迎来到知识的荒漠</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
    </div>

    <div>
      <div style="margin-top:15px">
        <a href="https://www.foreverblog.cn/go.html" target="_blank">
          <img alt="穿梭虫洞" src="https://img.foreverblog.cn/wormhole_2_tp.gif" style="width:auto;height:38px;" title="穿梭虫洞 - 随机访问十年之约友链博客">
        </a>
      </div>

      <div style="margin-top:10px">
        <a href="https://bjcp.kuga.fun" target="_blank">
          <img alt="BJCP Hub" src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/bjcp_hub_logo.png" style="width:auto;height:30px;" title="BJCP Hub">
        </a>
      </div>

      <div style="margin-top:17px">
        <a href="https://github.com/Kugaaa" target="_blank">
          <img alt="Hello World" src="https://img.shields.io/badge/today-Earn%20this.%20Earn%20it-red?&labelColor=white&cacheSeconds=300" style="width:auto;height:20px;" title="Hello World">
        </a>
      </div>

      <div style="margin-top:20px">
          <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=400 src="//music.163.com/outchain/player?type=0&id=7776310945&auto=0&height=430"></iframe>
      </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-solid fa-user-secret"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kuga</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

    </div>
</body>
</html>
