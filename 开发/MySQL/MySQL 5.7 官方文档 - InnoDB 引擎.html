<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/air.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/air.svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/air.svg">
  <link rel="mask-icon" href="/images/air.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.kuga.fun","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言摘自 MySQL 5.7 官方文档 14 章 The InnoDB Storage Engine 下的 InnoDB Locking and Transaction Model 主要内容为 InnoDB 引擎下的锁机制和事务模型 MySQL :: MySQL 5.7 Reference Manual :: 14.7 InnoDB Locking and Transaction Model In">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL 5.7 官方文档 - InnoDB 引擎.md">
<meta property="og:url" content="https://www.kuga.fun/%E5%BC%80%E5%8F%91/MySQL/MySQL%205.7%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%20-%20InnoDB%20%E5%BC%95%E6%93%8E.html">
<meta property="og:site_name" content="贫瘠之地">
<meta property="og:description" content="前言摘自 MySQL 5.7 官方文档 14 章 The InnoDB Storage Engine 下的 InnoDB Locking and Transaction Model 主要内容为 InnoDB 引擎下的锁机制和事务模型 MySQL :: MySQL 5.7 Reference Manual :: 14.7 InnoDB Locking and Transaction Model In">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-12-24T16:00:00.000Z">
<meta property="article:modified_time" content="2023-12-24T16:00:00.000Z">
<meta property="article:author" content="Kuga">
<meta property="article:tag" content="DB">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.kuga.fun/%E5%BC%80%E5%8F%91/MySQL/MySQL%205.7%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%20-%20InnoDB%20%E5%BC%95%E6%93%8E.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MySQL 5.7 官方文档 - InnoDB 引擎.md | 贫瘠之地</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">贫瘠之地</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">华北无浪漫，死海扬起帆<br>多少个夜晚，独自望着天</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.kuga.fun/%E5%BC%80%E5%8F%91/MySQL/MySQL%205.7%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%20-%20InnoDB%20%E5%BC%95%E6%93%8E.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kuga">
      <meta itemprop="description" content="欢迎来到知识的荒漠">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="贫瘠之地">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL 5.7 官方文档 - InnoDB 引擎.md
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-25 00:00:00" itemprop="dateCreated datePublished" datetime="2023-12-25T00:00:00+08:00">2023-12-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
                </span>
                  >
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E5%8F%91/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>摘自 MySQL 5.7 官方文档 14 章 <em>The InnoDB Storage Engine</em> 下的 <em>InnoDB Locking and Transaction Model</em></p>
<p>主要内容为 InnoDB 引擎下的锁机制和事务模型</p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-transaction-model.html">MySQL :: MySQL 5.7 Reference Manual :: 14.7 InnoDB Locking and Transaction Model</a></p>
<h1 id="InnoDB-的锁机制和事务模型"><a href="#InnoDB-的锁机制和事务模型" class="headerlink" title="InnoDB 的锁机制和事务模型"></a>InnoDB 的锁机制和事务模型</h1><p>要实现大规模（large-scale）、繁忙或高可用（highly reliable）的数据库应用程序、从不同的数据库系统移植大量代码，或调整 MySQL 性能，了解 InnoDB 锁定和 InnoDB 事务模型是很重要的。</p>
<p>本节讨论了与 InnoDB 锁机制和您应该熟悉的 InnoDB 事务模型相关的几个主题</p>
<ul>
<li>14.7.1 - InnoDB 的锁机制</li>
<li>14.7.2 - InnoDB 的事务模型</li>
<li>14.7.3 - InnoDB 中不同 SQL 语句设置的锁</li>
<li>14.7.4 - 幻影行</li>
<li>14.7.5 - InnoDB 中的死锁</li>
</ul>
<h2 id="InnoDB-的锁机制"><a href="#InnoDB-的锁机制" class="headerlink" title="InnoDB 的锁机制"></a>InnoDB 的锁机制</h2><h3 id="共享锁-amp-排它锁"><a href="#共享锁-amp-排它锁" class="headerlink" title="共享锁 &amp; 排它锁"></a>共享锁 &amp; 排它锁</h3><p>InnoDB 实现了标准的行级锁，有两种类型：<strong>共享锁 S</strong>（shared locks）和<strong>排他锁 X</strong>（exclusive locks）</p>
<ul>
<li>共享锁：允许事务读取一行</li>
<li>排他锁：允许事务更新或删除一行</li>
</ul>
<p>如果事务 T1 对数据行 r 持有 S 锁，则如下处理来自某个不同事务 T2 的对数据行 r 的锁的请求：</p>
<ul>
<li>立即对 T2 签发 S 锁；此时 T1 和 T2 都持有对 r 的 S 锁</li>
<li>不会立即对 T2 签发 X 锁</li>
</ul>
<p>如果 T1 持有的是 X 锁，那么 T2 对任意类型的锁都不会被立即签发，相反 T2 只能等待 T1 释放它针对 r 的锁</p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>InnoDB 支持多粒度锁（multiple granularity locking），允许行锁和表锁共存；举一个例子，SQL <code>LOCK TABLE ... WRITE</code> 会获取一个排他锁（X 锁）对于该指定的表；为了使多粒度级别的锁定变得实用，InnoDB 使用了意向锁，意向锁是表级锁，用于指示事务稍后需要表中某行使用哪种类型的锁（共享或排他），意向锁有两种类型：</p>
<ul>
<li>意向共享锁（IS）表示事务意图针对表中的数据行设置共享锁</li>
<li>意向排他锁（IX）表示事务意图针对表中的数据行设置排他锁</li>
</ul>
<p>例如，<code>SELECT ... LOCK IN SHARE MODE</code> 设置 IS 锁，而 <code>SELECT ... FOR UPDATE</code> 设置排他锁</p>
<p>意向锁定协议如下：</p>
<ul>
<li>在事务可以获取表中某行的共享锁之前，它必须首先获取表上的 IS 锁或更强的锁</li>
<li>在事务可以获取表中某行的排他锁之前，它必须首先获取表上的 IX 锁</li>
</ul>
<p>表级锁类型兼容性总结如下表所示</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">X</th>
<th align="center">IX</th>
<th align="center">S</th>
<th align="center">IS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X</td>
<td align="center">Conflict</td>
<td align="center">Conflict</td>
<td align="center">Conflict</td>
<td align="center">Conflict</td>
</tr>
<tr>
<td align="center">IX</td>
<td align="center">Conflict</td>
<td align="center">Compatible</td>
<td align="center">Conflict</td>
<td align="center">Compatible</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">Conflict</td>
<td align="center">Conflict</td>
<td align="center">Compatible</td>
<td align="center">Compatible</td>
</tr>
<tr>
<td align="center">IS</td>
<td align="center">Conflict</td>
<td align="center">Compatible</td>
<td align="center">Compatible</td>
<td align="center">Compatible</td>
</tr>
</tbody></table>
<p>如果请求事务与现有锁兼容，则会将锁授予该事务，但如果它与现有锁冲突，则不会授予该事务；事务将会等待直到导致冲突的锁被释放；如果锁请求与现有锁冲突，并且由于会导致死锁而无法授予，则会发生错误</p>
<p>意向锁不会阻塞除全表请求之外的任何内容（例如，<code>LOCK TABLES…WRITE</code>），意向锁的主要目的是显示有人正在锁定一行，或者要锁定表中的一行（即表达意图）</p>
<p>在 <code>SHOW ENGINE INNODB STATUS</code> 和 InnoDB monitor 输出中，意向锁的事务数据与以下内容类似：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TABLE</span> LOCK <span class="keyword">table</span> `test`.`t` trx id <span class="number">10080</span> lock mode IX</span><br></pre></td></tr></table></figure>



<h3 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h3><p>记录锁用于锁住一条索引记录，举一个例子 <code>SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;</code> 获取的锁将防止任何其他的事务对 <code>t.c1 = 10</code> 的行记录进行插入、更新、删除</p>
<p>记录锁总是锁定索引记录，即使是没有索引的表，InnoDB 会创建隐式的聚集索引（hidden clustered index）然后使用该索引来进行记录上锁</p>
<p>在 <code>SHOW ENGINE INNODB STATUS</code> 和 InnoDB monitor 输出中，记录锁的事务数据与以下内容类似：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id <span class="number">58</span> page <span class="keyword">no</span> <span class="number">3</span> n bits <span class="number">72</span> index `<span class="keyword">PRIMARY</span>` <span class="keyword">of</span> <span class="keyword">table</span> `test`.`t`</span><br><span class="line">trx id <span class="number">10078</span> lock_mode X locks rec but <span class="keyword">not</span> gap</span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">2</span> PHYSICAL RECORD: n_fields <span class="number">3</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">4</span>; hex <span class="number">8000000</span>a; <span class="keyword">asc</span>     ;;</span><br><span class="line"> <span class="number">1</span>: len <span class="number">6</span>; hex <span class="number">00000000274</span>f; <span class="keyword">asc</span>     <span class="string">&#x27;O;;</span></span><br><span class="line"><span class="string"> 2: len 7; hex b60000019d0110; asc        ;;</span></span><br></pre></td></tr></table></figure>



<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>一个间隙锁锁住的是索引记录之间的范围，或者锁定第一个索引记录之前或者最后一个索引记录之后的范围</p>
<p>举个例子，<code>SELECT c1 FROM t1 WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code>，将会防止其他事务将 value 为 15 的数据插入 t.c1，无论这一列是否已经存在该值，因为该范围中的所有值都被锁定了</p>
<p>间隙可能跨越单个索引值、多个索引值，甚至为空</p>
<p>间隙锁是性能和并发之间权衡的一部分，用于某些事务隔离级别中</p>
<p><strong>间隙锁与唯一索引</strong></p>
<p>间隙锁在对于使用唯一索引查询一行数据的情况下不会加锁（不包括组合唯一索引，只在查询条件中覆盖了部分字段的情况）</p>
<p>举个例子，如果字段 <code>id</code> 是一个唯一索引，以下语句仅对 <code>id</code> 为 100 的行使用索引记录锁，并且其他会话是否在 id &#x3D; 100 前面的间隙中插入行并不重要：<code>SELECT * FROM child WHERE id = 100;</code></p>
<p>如果 <code>id</code> 没有索引或者不是唯一索引，则该语句会锁住前面的间隙</p>
<p><strong>间隙锁不互斥</strong></p>
<p>这里同时需要注意，<strong>不同的事务可能同时持有互相冲突的间隙锁</strong></p>
<p>举个例子，事务 A 可以持有一个共享间隙锁（gap S-lock），而事务 B 持有一个相同范围的排他间隙锁（gap X-lock），允许间隙锁冲突的原因是如果从索引中清除记录，则必须合并不同事务在记录上持有的间隙锁</p>
<p>InnoDB 中的间隙锁的功能是 “纯粹禁止”（purely inhibitive），这意味着它们的唯一目的是防止其他事务插入到锁定的范围中，所以间隙锁可以共存；一个事务获取的间隙锁定不会阻止另一个事务对同一间隙获取间隙锁定；共享和排他间隙锁之间没有区别，它们彼此不冲突，并且执行相同的功能</p>
<p><strong>禁用间隙锁</strong></p>
<p>间隙锁定可以明确禁用，如果将事务隔离级别更改为 READ COMMITTED 或启用 <code>innodb_locks_unsaf_for_binlog</code> 系统变量（现已废弃）即可；在这种情况下，间隙锁对于查询和索引扫描是禁用的，仅用于外键约束检查和唯一键检查</p>
<p>使用 READ COMMITTED 隔离级别或启用 <code>innodb_locks_unsaf_for_binlog</code> 也会产生其他影响</p>
<ul>
<li>MySQL 评估 WHERE 条件后，将释放不匹配行的记录锁</li>
<li>对于 UPDATE 语句，InnoDB 会进行 semi-consistent 读取，从而将最新提交的版本返回给 MySQL，以便MySQL 可以确定该行是否符合 UPDATE 的 WHERE 条件</li>
</ul>
<h3 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h3><p>临键锁是当前索引记录的<strong>记录锁</strong>和该记录之前范围的<strong>间隙锁</strong>的组合</p>
<p>InnoDB 的行级锁实现当进行查询或者对索引进行扫描，是这样来进行加锁操作：首先对于扫描的索引行设置共享或者排他锁，因此行级锁实际上是索引记录锁；一个锁住索引行的临键锁同样会<strong>影响索引记录之前的区间</strong></p>
<p>如果一个会话对索引中的记录 R 具有共享或排他锁定，则另一个会话将无法在索引顺序中 R 之前的间隙中插入新的索引记录</p>
<p>假设一个索引包含值 10、11、13 和 20，此索引可能的下一个键锁定涵盖以下区间，其中圆括号表示排除区间端点，方括号表示包含端点（开区间闭区间）：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative <span class="literal">infinity</span>, <span class="number">10</span>]</span><br><span class="line">(<span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line">(<span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line">(<span class="number">13</span>, <span class="number">20</span>]</span><br><span class="line">(<span class="number">20</span>, positive <span class="literal">infinity</span>)</span><br></pre></td></tr></table></figure>

<p>对于最后一个间隔，临键锁锁定索引中最大值上方的间隙，以及值高于索引中实际任何值的 “上确界” 伪记录（“supremum” pseudo-record），上确界并不是真实的索引记录，所以实际上，临键锁只锁定了最大索引值后面的间隙</p>
<p>InnoDB 默认的隔离级别为 REPEATABLE READ，在这种情况下 InnoDB 会在查询或者扫描索引时使用临键锁来防止出现幻影行</p>
<p>临键锁锁的事务数据在 <code>SHOW ENGINE INNODB STATUS</code> 和 InnoDB monitor 输出中显示如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id <span class="number">58</span> page <span class="keyword">no</span> <span class="number">3</span> n bits <span class="number">72</span> index `<span class="keyword">PRIMARY</span>` <span class="keyword">of</span> <span class="keyword">table</span> `test`.`t`</span><br><span class="line">trx id <span class="number">10080</span> lock_mode X</span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">1</span> PHYSICAL RECORD: n_fields <span class="number">1</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">8</span>; hex <span class="number">73757072656</span>d756d; <span class="keyword">asc</span> supremum;;</span><br><span class="line"></span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">2</span> PHYSICAL RECORD: n_fields <span class="number">3</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">4</span>; hex <span class="number">8000000</span>a; <span class="keyword">asc</span>     ;;</span><br><span class="line"> <span class="number">1</span>: len <span class="number">6</span>; hex <span class="number">00000000274</span>f; <span class="keyword">asc</span>     <span class="string">&#x27;O;;</span></span><br><span class="line"><span class="string"> 2: len 7; hex b60000019d0110; asc        ;;</span></span><br></pre></td></tr></table></figure>



<h3 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h3><p>插入意向锁是在插入行之前由 INSERT 操作设置的一种间隙锁</p>
<p>该锁以这样一种方式发出插入意图的信号，即如果插入到同一索引间隙的多个事务不在间隙内的同一位置插入，则不需要等待彼此；举个例子，存在索引行 value 为 4 和 7，独立的事务打算查询 value 5 和 6，每个事务都会在获得插入行上的排他锁定之前用插入意向锁定来锁定 4 和 7 之间的间隙，但是并不会互相阻塞，因为插入的行是不冲突的</p>
<p>下面的示例演示了一个事务，该事务在获得插入记录的独占锁之前使用插入意向锁，该示例涉及两个客户端，A 和 B</p>
<ol>
<li><p>客户端 A 创建一个包含两个索引记录（90 和 102）的表，然后启动一个事务，对 ID 大于 100 的索引记录进行排他锁定，排他性锁定包括记录 102 之前的间隙锁定：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> child (id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, <span class="keyword">PRIMARY</span> KEY(id)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> child (id) <span class="keyword">values</span> (<span class="number">90</span>),(<span class="number">102</span>);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> child <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+</span></span><br><span class="line"><span class="operator">|</span> id  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">102</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端 B 开启一个事务，将一条记录插入到间隙中，事务在等待获得排他锁的同时获得插入意向锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> child (id) <span class="keyword">VALUES</span> (<span class="number">101</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>插入意向锁的事务数据在 <code>SHOW ENGINE INNODB STATUS</code> 和 InnoDB monitor 输出中显示如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id <span class="number">31</span> page <span class="keyword">no</span> <span class="number">3</span> n bits <span class="number">72</span> index `<span class="keyword">PRIMARY</span>` <span class="keyword">of</span> <span class="keyword">table</span> `test`.`child`</span><br><span class="line">trx id <span class="number">8731</span> lock_mode X locks gap before rec <span class="keyword">insert</span> intention waiting</span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">3</span> PHYSICAL RECORD: n_fields <span class="number">3</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">4</span>; hex <span class="number">80000066</span>; <span class="keyword">asc</span>    f;;</span><br><span class="line"> <span class="number">1</span>: len <span class="number">6</span>; hex <span class="number">000000002215</span>; <span class="keyword">asc</span>     &quot; ;;</span><br><span class="line"> 2: len 7; hex 9000000172011c; asc     r  ;;...</span><br></pre></td></tr></table></figure>



<h3 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h3><p>自增锁是特殊的表级锁，当事务在表中插入 <code>AUTO_INCREMENT</code> 列时将会获取</p>
<p>在最简单的情况下，如果一个事务正在向表中插入值，那么任何其他事务都必须等待自己向该表中插入，以便第一个事务插入的行接收连续的主键值</p>
<p><code>innodb_autoinc_lock_mode</code> 变量控制用于自动增量锁定的算法，它允许您选择如何在可预测的自动增量值序列和插入操作的最大并发性之间进行权衡</p>
<h3 id="空间索引的谓词锁"><a href="#空间索引的谓词锁" class="headerlink" title="空间索引的谓词锁"></a>空间索引的谓词锁</h3><p>InnoDB 支持以空间数据（spatial data）为列的 <code>SPATIAL</code> 索引</p>
<p>为了处理涉及 SPATIAL 索引的操作的锁定，临键锁不能很好地支持 REPEATABLE READ 或 SERIALIZABLE 事务隔离级别，因为多维数据中没有绝对的排序概念，因此不清楚哪个是 “下一个” 键</p>
<p>为了支持具有 <code>SPATIAL</code> 索引的表的隔离级别，InnoDB 使用了谓词锁（predicate locks）；<code>SPATIAL</code> 索引包含最小边界矩形（MBR）值，因此 InnoDB 通过在用于查询的 MBR 值上设置谓词锁来强制对索引进行一致读取，此时其他事务处理无法插入或修改与查询条件匹配的行</p>
<h2 id="InnoDB-的事务模型"><a href="#InnoDB-的事务模型" class="headerlink" title="InnoDB 的事务模型"></a>InnoDB 的事务模型</h2><p>InnoDB 的事务模型旨在将多版本特性（multi-versioning）和传统的两阶段锁定相结合</p>
<p>InnoDB 在行级别执行锁定，并以 Oracle 的风格默认作为非锁定一致读（nonlocking consistent reads）来运行查询</p>
<p>InnoDB 中的锁信息被有效地存储在空间中，因此不需要升级锁，通常允许几个用户锁定 InnoDB 表中的每一行，或行的任何随机子集，并不会导致 InnoDB 内存耗尽</p>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>隔离级别是数据库处理的基础，</p>
<p>InnoDB 提供了 <em>SQL:1992 标准</em> 所描述的四种隔离级别：</p>
<ul>
<li>READ UNCOMMITTED</li>
<li>READ COMMITTED</li>
<li>REPEATABLE READ (DEFAULT)</li>
<li>SERIALIZABLE</li>
</ul>
<p>用户可以使用 <code>SET TRANSACTION</code> 语句来更改单个会话或所有后续连接的隔离级别，在命令行或配置文件使用 <code>--trsaction</code> 配置可以设置服务器的隔离级别</p>
<p>InnoDB 支持不同的隔离事务级别使用不同的锁策略，可以使用默认的 RR 级别强调高度一致性，用于进行对于 ACID 要求较高的关键数据操作；在批量情况下，也可以使用 RC 或者 RU 级别来放宽一致性原则，在这种情况下精确的一致性和重复结果不如最小化上锁开销那么重要；S 级别会比 RR 更加严格，它经常被用于特殊的场景，例如 XA 事务或者解决并发和死锁问题</p>
<p><strong>REAPEATABLE READ</strong></p>
<p>这是 InnoDB 的默认隔离级别；同一事务中都读取由第一次读取建立的快照版本，这意味着如果在同一事务中发出多个非锁定的 SELECT 语句，那么这些 SELECT 操作查询到的数据集彼此是一致的；这被称为 “一致的非锁定读取”（Consistent Nonlocking Reads）</p>
<p>对于锁定读取（SELECT … FOR UPDATE 或者 LOCK IN SHARE MODE）、UPDATE、DELETE 语句，会根据索引类型和查询范围进行上锁：</p>
<ul>
<li>对于具有唯一搜索条件的唯一索引，InnoDB 只锁定找到的索引记录，而不锁定之前的间隙</li>
<li>对于其他搜索条件，InnoDB 会锁定扫描的索引范围，使用间隙锁或临键锁来阻止其他会话插入到范围所覆盖的间隙中</li>
</ul>
<p><strong>READ COMMITTED</strong></p>
<p>即使在同一事务中，每次一致读取都会设置新的快照</p>
<p>对于锁定读取（SELECT … FOR UPDATE 或者 LOCK IN SHARE MODE）、UPDATE、DELETE 语句，InnoDB 只锁定索引记录，而不锁定它们的间隙，因此允许在锁定记录附近插入新记录；间隙锁定仅用于外键约束检查和重复 key 检查</p>
<p>由于不锁定间隙（间隙锁被禁用），所以可能会出现幻读问题，因为其他会话可以将新行插入间隙中</p>
<p>RC 隔离级别仅支持基于行的二进制日志记录；如果将 RC 与 binlog_format&#x3D;MIXED 一起使用，则服务器会自动使用基于行的日志记录</p>
<p>使用 RC 隔离级别可能存在的影响：</p>
<ul>
<li>对于 UPDATE 或 DELETE 语句，InnoDB 只为更新或删除的行保留锁记录，MySQL 会在评估 WHERE 条件后释放不匹配行的记录锁，这大大降低了死锁的概率，但死锁仍然可能发生</li>
<li>对于 UPDATE 语句，如果一行已经被锁定，InnoDB 会执行 “半一致”（semi-consistent） 读取，将最新提交的版本返回给 MySQL，以便 MySQL 可以确定该行是否符合 UPDATE 的 WHERE 条件，如果行匹配（必须更新）MySQL 将再次读取该行，这一次 InnoDB 要么将其锁定，要么等待锁定</li>
</ul>
<p><strong>READ UNCOMMITTED</strong></p>
<p>SELECT 操作会以无锁方式执行，但是可以使用行的可能的早期版本，所以使用这种隔离级别可能导致读取是不一致的，被称为脏读</p>
<p><strong>SERIALIZABLE</strong></p>
<p>该级别类似 RR，但是如果禁用了自动提交 InnoDB 隐式地将 SELECT 转换为了 SELECT … LOCK IN SHARE MODE；如果自动提交是启用状态，SELECT 是它自己的事务</p>
<p>因此已知它是只读的，一致（非锁定）读取执行串行化不会阻塞其他的事务（若要在其他事务已修改所选行的情况下进行锁定读取，需要禁用自动提交）</p>
<h3 id="自动提交、提交和回滚"><a href="#自动提交、提交和回滚" class="headerlink" title="自动提交、提交和回滚"></a>自动提交、提交和回滚</h3><p>InnoDB 中所有的用户操作都发生在事务中</p>
<p>如果启用了自动提交模式，则每条 SQL 语句都会自己形成一个事务，默认情况下 MySQL 会为每个新连接的 Session 开启自动提交，因此 MySQL 会在每个执行成功的 SQL 语句后自动提交事务；如果执行发生了错误，那么提交或者回滚取决于错误类型</p>
<p>启用了自动提交的会话也可以执行多语句事务，方法是以显式 START transaction 或 BEGIN 语句开始，然后以 COMMIT 或 ROLLBACK 语句结束</p>
<p>如果在 <code>SET autocommit=0</code> 的会话中禁用了自动提交模式，则该会话始终打开一个事务；COMMIT 或 ROLLBACK 语句会结束当前事务，并启动新事务</p>
<p>如果事务禁用了自动提交，并且结束时也没有针对该事务明确的 COMMIT 操作，那么 MySQL 会回滚该事务</p>
<h3 id="一致非锁定读"><a href="#一致非锁定读" class="headerlink" title="一致非锁定读"></a>一致非锁定读</h3><p>一致读取意味着 InnoDB 使用多版本控制在某个时间点（timepoint）向查询显示数据库的快照，查询会看到在此时间点之前提交的事务所做的修改，而不会看到以后或未提交的事务进行的修改</p>
<p>您可以通过提交事务，然后使用一致快照执行另一个 SELECT 或开启一个新事务来推进时间点</p>
<p>不同隔离级别的快照策略：</p>
<ul>
<li>REPEATABLE READ：第一次读取设置快照；提交事务后的读取则会使用最新数据</li>
<li>READ COMMITTED：事务中的每个一致读取都会设置并读取自己的新快照</li>
</ul>
<p><strong>举一个例子说明一致性读</strong></p>
<p>事务 A 只有在 B 提交了事务，并且 A 也提交了事务时才看到由 B 插入的行</p>
<table>
<thead>
<tr>
<th>事务 A</th>
<th>事务 B</th>
</tr>
</thead>
<tbody><tr>
<td>开启事务</td>
<td>开启事务</td>
</tr>
<tr>
<td>SELECT * FROM t;（empty set）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>INSERT INTO tVALUES (1, 2);</td>
</tr>
<tr>
<td>SELECT * FROM t;（empty set）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>COMMIT;</td>
</tr>
<tr>
<td>SELECT * FROM t;（empty set）</td>
<td></td>
</tr>
<tr>
<td>COMMIT;</td>
<td></td>
</tr>
<tr>
<td>SELECT * FROM t;（1,2）</td>
<td></td>
</tr>
</tbody></table>
<p>如果您想查看数据库的“最新”状态，请使用 READ COMMITTED 隔离级别或使用锁定读</p>
<p><strong>需要注意 DML 对数据可见的影响</strong></p>
<p>数据库状态的快照应用于事务中的 SELECT 语句，而不一定应用于 DML 语句</p>
<p>如果插入或修改某些行，然后提交该事务，则从另一个并发的 REPEATABLE READ 事务发出的 DELETE 或 UPDATE 语句可能会影响那些刚刚提交的行，即使会话无法查询到这些数据（因为快照）</p>
<p>如果事务确实更新或删除了由其他事务提交的行，则这些更改对当前事务可见</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(c1) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 <span class="operator">=</span> <span class="string">&#x27;xyz&#x27;</span>;</span><br><span class="line"><span class="comment">-- 0 行</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 <span class="operator">=</span> <span class="string">&#x27;xyz&#x27;</span>;</span><br><span class="line"><span class="comment">-- 可能会删除最近由其他事务提交的匹配到的行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(c2) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c2 <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="comment">-- 0 行</span></span><br><span class="line"><span class="keyword">UPDATE</span> t1 <span class="keyword">SET</span> c2 <span class="operator">=</span> <span class="string">&#x27;cba&#x27;</span> <span class="keyword">WHERE</span> c2 <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="comment">-- 如果另一个事务刚刚提交了 abc 值的 10 行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(c2) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c2 <span class="operator">=</span> <span class="string">&#x27;cba&#x27;</span>;</span><br><span class="line"><span class="comment">-- 10 行；这个事务现在可以看到它刚刚更新的行</span></span><br></pre></td></tr></table></figure>



<h3 id="锁定读"><a href="#锁定读" class="headerlink" title="锁定读"></a>锁定读</h3><p>如果查询数据后希望在同一事务中插入或更新相关数据，则常规 SELECT 语句无法提供足够的保护，其他事务可以更新或删除您刚才查询的同一行</p>
<p>InnoDB 引擎提供了两种锁定读的方式来提供额外的安全保证：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE</code><br>在读取到的所有行上设置共享锁（shared mode lock）其他事务可以进行读取，但是在事务提交之前都不能进行修改，如果查询过程中这些行中的任意行被另一个尚未提交的事务修改，则查询将等待该事务结束，然后使用更新后的值</li>
<li><code>SELECT ... FOR UPDATE</code><br>对于查询到的索引记录，锁定行和任何关联的索引条目，就像为这些行进行 UPDATE 语句一样<br>对其他事务被阻止更新这些行、进行查询、在共享模式下锁定或读取特定事务隔离级别的数据<br>一致读（快照读）将忽略在读取视图中存在的记录上设置的任何锁（记录的旧版本无法锁定，因为它们是通过在记录的内存副本上应用 undo log 来重建的）</li>
</ul>
<p>这些子句在处理树结构或图结构数据时非常有用，无论是在单个表中还是在多个表中拆分；可以从一个位置遍历边或树枝到另一个位置，同时保留返回并更改任何这些“指针”值的权利</p>
<p>当事务被提交或回滚时，由 LOCK IN SHARE MODE 和 FOR UPDATE 查询设置的所有锁都会被释放</p>
<p><strong>FOR UPDATE 不会传递</strong></p>
<p>外部语句中的锁定读取子句不会锁定嵌套子查询中表的行，除非在子查询中也指定了锁定读取子句</p>
<p>例如，以下语句不会锁定表 t2 中的行</p>
<p><code>SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2) FOR UPDATE;</code></p>
<p>要锁定表 t2 中的行，请向子查询添加一个锁定读取子句</p>
<p><code>SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2 FOR UPDATE) FOR UPDATE;</code></p>
<blockquote>
<p>locking read</p>
<p>A <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/select.html"><code>SELECT</code></a> statement that also performs a <strong>locking</strong> operation on an <code>InnoDB</code> table. Either <code>SELECT ... FOR UPDATE</code> or <code>SELECT ... LOCK IN SHARE MODE</code>. It has the potential to produce a <strong>deadlock</strong>, depending on the <strong>isolation level</strong> of the transaction. The opposite of a <strong>non-locking read</strong>*. Not allowed for global tables in a <strong>read-only transaction</strong>.</p>
<p><code>SELECT ... FOR SHARE</code> replaces <code>SELECT ... LOCK IN SHARE MODE</code> in MySQL 8.0.1, but <code>LOCK IN SHARE MODE</code> remains available for backward compatibility.</p>
<p>See <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html">Section 14.7.2.4, “Locking Reads”</a>.</p>
<p>See Also <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_deadlock">deadlock</a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_isolation_level">isolation level</a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_locking">locking</a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_non_locking_read">non-locking read</a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_read_only_transaction">read-only transaction</a>.</p>
</blockquote>
<h2 id="InnoDB-中不同语句设置的锁"><a href="#InnoDB-中不同语句设置的锁" class="headerlink" title="InnoDB 中不同语句设置的锁"></a>InnoDB 中不同语句设置的锁</h2><p>如果在查询中使用了二级索引，并且要设置的索引记录锁（record locks）是排他的，那么 InnoDB 还会检索相应的聚集索引记录并对其设置锁</p>
<p>如果你的语句没有合适的索引，MySQL 必须扫描整个表，该表的每一行都会被锁住，将会阻止其他用户对该表的所有插入，所以创建良好的索引非常重要，这样查询操作就不会扫描超出需求范围的记录行</p>
<p>InnoDB 设置特定类型的锁，如下所示：</p>
<ul>
<li><p><code>SELECT ... FROM</code><br>一致性读，读取数据库的快照不会上锁，除非隔离级别为 SERIALIZABLE；对于 SERIALIZABLE 级别，该查询将会在遇到的索引记录上设置共享的临键锁；但是对于使用唯一索引锁定行来查询唯一行的语句，只需要索引记录锁</p>
</li>
<li><p><code>SELECT ... FOR UPDATE</code> 或 <code>SELECT ... LOCK IN SHARE MODE</code><br>为扫描的行获取锁，并可能为不符合结果集中包含条件的行释放锁（例如，如果它们不符合 WHERE 子句中给定的条件<br>但是在某些情况下可能不会立即解锁，因为结果行与其原始源之间的关系在查询执行过程中丢失，例如在 UNION 中，在评估表中扫描（和锁定）的行是否符合结果集之前，可能会将这些行插入到临时表中；在这种情况下，临时表中的行与原始表中的列之间的关系将丢失，而后的行直到查询执行结束才被解锁</p>
</li>
<li><p><code>SELECT ... LOCK IN SHARE MODE</code><br>在查询遇到的所有索引记录上设置共享的临键锁，但是对于使用唯一索引锁定行来查询唯一行的语句，只需要索引记录锁</p>
</li>
<li><p><code>SELECT ... FOR UPDATE</code><br>在查询遇到的所有索引记录上设置排他的临键锁，但是对于使用唯一索引锁定行来查询唯一行的语句，只需要索引记录锁</p>
</li>
<li><p><code>UPDATE ... WHERE ...</code><br>在遇到的每一行索引记录上设置排他的临键锁；但是对于使用唯一索引锁定行来查询唯一行的语句，只需要索引记录锁</p>
</li>
<li><p><code>UPDATE</code><br>修改聚集索引记录时，会对受影响的辅助索引记录使用隐式锁，在查询新的辅助索引记录之前执行重复检测时、或者在插入新的辅助索引记录时，更新操作还会对受影响的辅助索引记录获取共享锁</p>
</li>
<li><p><code>DELETE FROM ... WHERE ...</code><br>对遇到的索引记录设置排他临键锁；但是对于使用唯一索引锁定行来查询唯一行的语句，只需要索引记录锁</p>
</li>
<li><p><code>INSERT</code><br>对插入的行设置排他记录锁，而不是临键锁（即没有间隙锁），并且不会阻止其他会话插入插入行之前的间隙中</p>
<p>在插入行之前，设置类型为间隙锁的插入意向锁；该锁相当于发出插入意向的信号，即如果插入到同一索引间隙中的多个事务并不在间隙内的同一位置插入，则它们不需要彼此等待；假设存在值为 4 和 7 的索引记录，当尝试插入值为 5 和 6 的单独事务，在获得排他记录锁之前，每个事务都使用插入意向锁来锁定 4 和 7 之间的间隙，但不会互相阻止，因为插入行不冲突</p>
<p>如果出现重复键错误，则会对重复索引记录设置共享锁，如果有多个会话试图插入同一行，而另一个会话已经具有排他锁，则这种共享锁的使用可能会导致死锁，如果另一个会话删除该行，则可能会发生如下情况；假设一个 InnoDB 表 t1 具有以下结构：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (i <span class="type">INT</span>, <span class="keyword">PRIMARY</span> KEY (i)) ENGINE <span class="operator">=</span> InnoDB;</span><br></pre></td></tr></table></figure>

<p>现在假设三个事务按顺序执行以下操作：</p>
<ol>
<li><p>事务 1</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>事务 2</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>事务 3</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>事务 1</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>流程分析</strong>：事务 1 的第一个操作会获取 <code>1</code> 记录行的排他锁，而后事务 2 和 事务 3 也会插入 <code>1</code> 导致重复键错误，各自获取针对 <code>1</code> 的共享锁，事务 1 进行回滚，此时事务 2 和事务 3 出现死锁：由于另一方持有共享锁，因此两方都无法获取该行的排他锁</p>
<p>如果表中已经包含键值为 <code>1</code> 的行，并且三个事务按顺序执行以下操作，则会出现类似的情况：</p>
<ol>
<li><p>事务 1</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> i <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事务 2</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>事务 3</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>事务 1</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>流程分析</strong>：事务 1 的第一个操作会获取 <code>1</code> 记录行的排他锁，而后事务 2 和 事务 3 也会插入 <code>1</code> 导致重复键错误，各自获取针对 <code>1</code> 的共享锁，当事务 1 提交时，它会释放其在行上的排他锁，并授予事务 2 和 3 的排队共享锁请求；此事务 2和事务 3 出现死锁：由于另一方持有共享锁，因此两方都无法获取该行的独占锁</p>
</li>
<li><p><code>INSERT ... ON DUPLICATE KEY UPDATE</code><br>不同于简单的 INSERT 操作，当发生重复键错误时，会在需要更新的行上设置排他锁，而不是共享锁；对重复的主键值使用排他记录锁，对于重复的唯一索引值，将使用排他临键锁</p>
</li>
<li><p><code>REPLACE</code><br>如果唯一键没有冲突则和一个 INSERT 操作一致，否则会在需要 replace 的行上加排他临键锁</p>
</li>
<li><p><code>INSERT INTO T SELECT ... FROM S WHERE ...</code></p>
</li>
</ul>
<h2 id="幻影行"><a href="#幻影行" class="headerlink" title="幻影行"></a>幻影行</h2><p>之所以称呼为 “幻影读问题” 是因为一个事务在<strong>不同的时间</strong>进行<strong>相同的查询请求</strong>返回的结果集不同；举个例子，如果一个 <code>SELECT</code> 操作执行了两次，但是第一次查询返回了 1 行数据，第二次查询没有返回数据，那么这行数据就被称为 “幻影行”（phantom row）</p>
<p>假设子表的 id 列上有一个索引，并且希望读取并锁定表中标识符值大于 100 的所有行，以便稍后更新所选行中的某些列：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> child <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>该查询会从 id 大于 100 的第一条记录开始扫描索引；假设这个表存在一些数据，id 的值为 90 和 102，如果在扫描范围内的索引记录上设置的锁不锁定在间隙（在这种情况下是 90 和 102 之间的间隙）中进行的插入，那么另一个事务就可以查询一个新行例如 id 为 101；如果随后同一个事务内执行了相同的 <code>SELECT</code> 操作，将会看到新插入的数据 101（幻影）也在返回结果中，这样其实违反了事务的隔离原则</p>
<p>为了防止幻影，InnoDB 使用了一种被称为 next-key locking 的算法，即结合了记录锁和间隙锁的临键锁；当查询进行扫描索引时，InnoDB 提供了这样的行级锁，将会对需要的行设置共享或者排他锁</p>
<p>因此行级锁实际上是索引记录锁，此外索引记录上的下一个键锁定也会影响索引记录之前的间隔，也就是说，下一个键锁是索引记录锁加上索引记录之前间隙上的间隙，如果一个会话对索引中的记录 R 持有共享或独占锁，则另一个会话无法在索引顺序中 R 之前的间隙中插入新的索引记录</p>
<p>当 InnoDB 扫描索引时，它还可以锁定索引中最后一条记录之后的间隙。正如前面的例子所发生的那样：为了防止在 id 大于 100 的表中插入任何内容，InnoDB 设置的锁包括 id 值 102 后面的间隙上的锁</p>
<p>可以使用临键锁在应用程序中实现唯一性检查：如果在共享模式下读取数据，但没有看到要插入的行的重复项，那么您可以安全地插入行，并知道在读取期间在行的后续行上设置的临键锁可以防止其他事务同时插入重复项，临键锁可以锁住表中不存在的数据</p>
<p>间隙锁可以被禁用，但这可能会导致幻读问题的出现</p>
<h2 id="InnoDB-中的死锁"><a href="#InnoDB-中的死锁" class="headerlink" title="InnoDB 中的死锁"></a>InnoDB 中的死锁</h2><h3 id="死锁示例"><a href="#死锁示例" class="headerlink" title="死锁示例"></a>死锁示例</h3><p>以下示例说明了当锁定请求导致死锁时，错误是如何发生的，该示例涉及两个客户端，A 和 B</p>
<ol>
<li><p>首先，客户端 A 创建一个包含一行的表，然后开始一个事务，在事务中 A 通过在共享模式下选择行来获得该行的 S 锁：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t (i <span class="type">INT</span>) ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">1.07</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t (i) <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.09</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> i <span class="operator">=</span> <span class="number">1</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> i    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下一步，客户端 B 开启事务，尝试从表中删除该行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> i <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除操作需要 X 锁，现状是无法授予该锁，因为它与客户端 A 持有的 S 锁互斥，因此该请求会出现在行和客户端 B 块的锁请求队列中</p>
</li>
<li><p>最后客户端 A 也试图删除该行数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> i <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>死锁之所以会出现是因为客户端 A 需要 X 锁来删除该行，不过该锁不会被签发因为客户端 B 的一个请求已经已经获取了 X 锁并且在等待客户端 A 释放它的 S 锁，也无法将 A 持有的 S 锁升级为 X 锁，因为此时 B 已经持有了 X 锁，所以 InnoDB 为其中一个客户端返回错误并释放其锁</p>
<p>客户端返回此错误：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR <span class="number">1213</span> (<span class="number">40001</span>): Deadlock found <span class="keyword">when</span> trying <span class="keyword">to</span> <span class="keyword">get</span> lock;</span><br><span class="line">try restarting transaction</span><br></pre></td></tr></table></figure>

<p>此时就可以将锁签发给另一个客户端，让它从表中删除该行</p>
<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>当启用死锁检测（默认启用）时，InnoDB 会自动检测事务死锁，并回滚一个或多个事务以打破死锁；InnoDB 试图选择要回滚的小事务，其中事务的大小由插入、更新或删除的行数决定</p>
<p>如果 <code>InnoDB_table_locks=1</code>（默认值）和 <code>autocommit=0</code>，则 InnoDB 可以感知表锁，并且引擎上层的 MySQL 层可以感知行级锁；否则当涉及 MySQL lock TABLES 语句设置的表锁或 InnoDB 以外的存储引擎设置的锁时，InnoDB 无法检测到死锁；通过设置 <code>innodb_lock_wait_timeout</code> 系统变量的值来解决这些情况</p>
<p>在高并发系统上，当多个线程等待同一个锁时，死锁检测可能会导致速度减慢；有时当死锁发生时，禁用死锁检测并依靠 <code>innodb_lock_wait_timeout</code> 设置进行事务回滚可能会更有效；可以使用 <code>innodb_Deadlock_detect</code> 变量禁用死锁检测</p>
<h3 id="如何减少和解决死锁"><a href="#如何减少和解决死锁" class="headerlink" title="如何减少和解决死锁"></a>如何减少和解决死锁</h3><p>死锁是事务数据库中的一个经典问题，但除非它们非常频繁以至于根本无法成功执行某些事务，否则它们并不危险</p>
<p>通常必须编写逻辑用于在事务因死锁而回滚时，可以重新执行事务</p>
<p>InnoDB 使用自动行级锁定（automatic row-level locking），所以即使在只插入或删除一行的事务的情况下，也可能出现死锁；这是因为这些操作并不是真正的“原子”操作；它们会自动对插入或删除的行的（可能有几个）索引记录设置锁</p>
<p>可以使用以下技术来处理死锁并降低其发生的可能性：</p>
<ul>
<li><p>随时使用 <code>SHOW ENGINE INNODB STATUS</code> 指令以确定最近死锁的原因；这可以帮助调整应用程序以避免死锁</p>
</li>
<li><p>如果频繁的死锁警告引起问题，请通过启用 <code>innodb_print_all_deadlocks</code> 变量来收集更广泛的调试信息；MySQL 错误日志中记录了每个死锁的信息，而不仅仅是最新的死锁；调试完成后禁用此选项</p>
</li>
<li><p>如果事务由于死锁而失败，请始终做好重新执行事务的准备；死锁并不危险，只需要再试一次</p>
</li>
<li><p>保持事务的规模小且持续时间短，以减少它们发生冲突的可能性；即避免大事务</p>
</li>
<li><p>在进行一组相关更改后立即提交事务，以减少它们发生冲突的可能性；特别是，不要让交互式 MySQL 会话与未提交的事务长时间开启</p>
</li>
<li><p>如果使用锁定读（<code>SELECT…FOR UPDATE</code> 或 <code>SELECT…LOCK IN SHARE MODE</code>），请尝试使用较低的隔离级别，例如 READ COMMITTED</p>
</li>
<li><p>当修改事务中的多个表或同一表中的不同行集时，每次都要以一致的顺序执行这些操作，可以让事务的执行形成定义良好的队列，从而避免死锁；即应用中的按照表顺序、字段值顺序排序</p>
</li>
<li><p>精心设置索引，避免过多索引导致的死锁；使用 <code>EXPLAIN SELECT</code> 来确定 MySQL 服务器认为哪些索引最适合查询</p>
</li>
<li><p>不使用锁；如果业务可以允许查询从旧快照返回数据，不要使用 <code>FOR UPDATE</code> 或 <code>LOCK IN SHARE MODE</code> 子句，并且推荐使用 READ COMMITTED 隔离级别，因为同一事务中的每个一致读都从自己的新快照中读取</p>
</li>
<li><p>如果上述建议没有帮助，可以使用表级锁序列化事务，将 <code>LOCK TABLES</code> 与事务性表（如 InnoDB 表）一起使用的正确方法是以 <code>SET autocommit=0</code>（而不是 <code>START transaction</code>）开头，后跟 <code>LOCK TABLES</code>，然后在显式提交事务之前不调用 <code>UNLOCK TABLES</code><br>例如，如果您需要写入表 t1 并从表 t2 读取，则可以执行以下操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">LOCK TABLES t1 WRITE, t2 READ, ...;</span><br><span class="line">... do something <span class="keyword">with</span> tables t1 <span class="keyword">and</span> t2 here ...</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>

<p>表级锁防止对表进行并发更新，从而避免死锁，而代价是并发响应能力较低</p>
</li>
<li><p>序列化事务的另一种方法是创建一个只包含一行的辅助“信号量”（semaphore）表；在访问其他表之前首先让每个事务更新该行；这样所有事务都以串行方式发生；需要注意 InnoDB 死锁检测算法也适用于这种情况，因为序列化锁是行级锁，对于 MySQL 表级锁则必须使用 timeout 方法来解决死锁</p>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-transaction-model.html">MySQL :: MySQL 5.7 Reference Manual :: 14.7 InnoDB Locking and Transaction Model</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/DB/" rel="tag"># DB</a>
              <a href="/tags/MySQL/" rel="tag"># MySQL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/%E5%BC%80%E5%8F%91/MySQL/MySQL%20%E5%B0%8F%E5%BF%83%20FOR%20UPDATE%20%E7%9A%84%20Record%20%E9%94%81.html" rel="prev" title="MySQL 小心 FOR UPDATE 的 Record 锁">
      <i class="fa fa-chevron-left"></i> MySQL 小心 FOR UPDATE 的 Record 锁
    </a></div>
      <div class="post-nav-item">
    <a href="/%E5%BC%80%E5%8F%91/LangChain/LangChain%20%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%20No.5%20-%20%E8%AE%B0%E5%BF%86.html" rel="next" title="LangChain 文档学习 No.5 - 记忆">
      LangChain 文档学习 No.5 - 记忆 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#InnoDB-%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">InnoDB 的锁机制和事务模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB-%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6"><span class="nav-number">2.1.</span> <span class="nav-text">InnoDB 的锁机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81-amp-%E6%8E%92%E5%AE%83%E9%94%81"><span class="nav-number">2.1.1.</span> <span class="nav-text">共享锁 &amp; 排它锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="nav-number">2.1.2.</span> <span class="nav-text">意向锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81"><span class="nav-number">2.1.3.</span> <span class="nav-text">记录锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%B4%E9%9A%99%E9%94%81"><span class="nav-number">2.1.4.</span> <span class="nav-text">间隙锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E9%94%AE%E9%94%81"><span class="nav-number">2.1.5.</span> <span class="nav-text">临键锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81"><span class="nav-number">2.1.6.</span> <span class="nav-text">插入意向锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%A2%9E%E9%94%81"><span class="nav-number">2.1.7.</span> <span class="nav-text">自增锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E7%B4%A2%E5%BC%95%E7%9A%84%E8%B0%93%E8%AF%8D%E9%94%81"><span class="nav-number">2.1.8.</span> <span class="nav-text">空间索引的谓词锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB-%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">InnoDB 的事务模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">2.2.1.</span> <span class="nav-text">隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E3%80%81%E6%8F%90%E4%BA%A4%E5%92%8C%E5%9B%9E%E6%BB%9A"><span class="nav-number">2.2.2.</span> <span class="nav-text">自动提交、提交和回滚</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="nav-number">2.2.3.</span> <span class="nav-text">一致非锁定读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="nav-number">2.2.4.</span> <span class="nav-text">锁定读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB-%E4%B8%AD%E4%B8%8D%E5%90%8C%E8%AF%AD%E5%8F%A5%E8%AE%BE%E7%BD%AE%E7%9A%84%E9%94%81"><span class="nav-number">2.3.</span> <span class="nav-text">InnoDB 中不同语句设置的锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BB%E5%BD%B1%E8%A1%8C"><span class="nav-number">2.4.</span> <span class="nav-text">幻影行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB-%E4%B8%AD%E7%9A%84%E6%AD%BB%E9%94%81"><span class="nav-number">2.5.</span> <span class="nav-text">InnoDB 中的死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.5.1.</span> <span class="nav-text">死锁示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="nav-number">2.5.2.</span> <span class="nav-text">死锁检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%92%8C%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81"><span class="nav-number">2.5.3.</span> <span class="nav-text">如何减少和解决死锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">3.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Kuga</p>
  <div class="site-description" itemprop="description">欢迎来到知识的荒漠</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
    </div>

    <div>
      <div style="margin-top:15px">
        <a href="https://www.foreverblog.cn/go.html" target="_blank">
          <img alt="穿梭虫洞" src="https://img.foreverblog.cn/wormhole_2_tp.gif" style="width:auto;height:38px;" title="穿梭虫洞 - 随机访问十年之约友链博客">
        </a>
      </div>

      <div style="margin-top:10px">
        <a href="https://bjcp.kuga.fun" target="_blank">
          <img alt="BJCP Hub" src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/bjcp_hub_logo.png" style="width:auto;height:30px;" title="BJCP Hub">
        </a>
      </div>

      <div style="margin-top:17px">
        <a href="https://github.com/Kugaaa" target="_blank">
          <img alt="Hello World" src="https://img.shields.io/badge/today-Earn%20this.%20Earn%20it-red?&labelColor=white&cacheSeconds=300" style="width:auto;height:20px;" title="Hello World">
        </a>
      </div>

      <div style="margin-top:20px">
          <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=400 src="//music.163.com/outchain/player?type=0&id=7776310945&auto=0&height=430"></iframe>
      </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-solid fa-user-secret"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kuga</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

    </div>
</body>
</html>
