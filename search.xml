<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>精酿啤酒入门</title>
    <url>/2022/12/25/%E4%BA%BA%E7%94%9F/%E9%85%92/%E7%B2%BE%E9%85%BF%E5%95%A4%E9%85%92/</url>
    <content><![CDATA[<h1 id="精酿"><a href="#精酿" class="headerlink" title="精酿"></a>精酿</h1><blockquote>
<p>在公司的技术分享周会上进行分享的文档</p>
<p>只是进了简单的介绍，并且很多地方都是简略地描述了一下</p>
<p>对于不了解精酿的朋友可以了解一下 Craft Beer</p>
</blockquote>
<h2 id="什么是-Craft-Beer"><a href="#什么是-Craft-Beer" class="headerlink" title="什么是 Craft Beer"></a>什么是 Craft Beer</h2><p><strong>美国的精酿运动</strong></p>
<p>20世纪开始，美国先后经历一战、禁酒令、二战，导致啤酒迅速退出市场</p>
<p>20世纪70年代，关于家酿啤酒的书籍从英国流出，书中呼吁使用糖浆之类奇特的原料；弗雷德.埃克哈德（Fred Eckhardt）出版了一本题为《拉格啤酒论》的书，虽是薄薄一册，但技术上描述非常详细。可以毫不夸张的说，家酿方式为精酿啤酒运动提供了思想、激情和人物，是重要的源泉</p>
<p>1976年，美国开始出现最早的精酿酒厂，生产瓶中发酵的波特、世涛和淡色艾尔供应给早已习惯淡味拉格的酒吧</p>
<p>1978年10月14号，总统 Jimmy Carter 签署了1337号议案。这份议案将家庭酿造小量自产自用的啤酒或红酒合法化。从此，美国见证了酿酒文化的复兴和小型酒厂的蓬勃发展。到1986年3月，5家自酿酒吧在美国营业</p>
<p>美国酒厂的总数从1978年的42家变成2012年的2750家，甚至超过了美国殖民地时代的大约数字；增长的其中绝大多数都是小型独立酒厂</p>
<p><strong>精酿的类官方定义</strong></p>
<p>精酿并不是啤酒的概念，而是啤酒厂的概念</p>
<p>美国啤酒酿造商协会（Brewers Association）出台的标准，对精酿酒厂的定义为：<strong>小型</strong>、<strong>独立</strong>、<strong>传统</strong></p>
<ul>
<li>小型：年产量在600万及600万桶以下</li>
<li>独立：其产权不能为其它非精酿酒厂的酒类企业购买，管理或控股超过25%</li>
<li>传统：要使用传统或创新的原材料，遵循传统或创新的酿造方法来实现其酿造出啤酒的口味</li>
</ul>
<blockquote>
<p>鹅岛：<a href="https://item.jd.com/100008724119.html">京东链接</a></p>
<p>拳击猫：<a href="http://www.boxingcatbrewery.com/cn/">Boxing Cat Brewery</a></p>
</blockquote>
<p><strong>和工业啤酒的区别</strong></p>
<ul>
<li>更高的原料成本</li>
<li>更丰富的啤酒风格</li>
<li>更多创意</li>
<li>啤酒 Pub 门店，提供简餐</li>
<li>更艺术的美学设计</li>
<li>更贵</li>
</ul>
<p><strong>工厂店</strong></p>
<p>Craft Beer 的酒厂规模较小，为了突出精酿的理念往往会将生产工厂对外开放，可以预约参观</p>
<p>工厂店摒弃了分级批发商、分级代理等中间繁冗环节可以降低成本</p>
<p><a href="https://vitaminseabrewing.com/">VSB (vitaminseabrewing.com)</a></p>
<p><a href="https://treehousebrew.com/">Tree House Brewing Company</a></p>
<h2 id="啤酒风格"><a href="#啤酒风格" class="headerlink" title="啤酒风格"></a>啤酒风格</h2><p><strong>BJCP</strong></p>
<p>啤酒品酒师资格认证协会(BJCP，Beer Judge Certification Program) 于1985年创建于美国</p>
<p>宗旨是推广与传播啤酒相关的各类知识与文化，提升大众对啤酒的认知、品酒和评估水平；创造一个啤酒行业规范的评价程序，引导啤酒爱好者如何正确评价及饮用啤酒，便于对这些酒类进行排名和评比</p>
<p>BJCP定期推出啤酒分类指南对啤酒加以科学分类，该指南也已成为世界啤酒市场的风向标，有助于啤友品鉴、自酿比赛筹办、酿友参赛、甚至新啤酒风格的创新</p>
<p><a href="D:\Relax\Beer\BJCP世界啤酒分类指南中文2015版.pdf">BJCP世界啤酒分类指南中文2015版</a></p>
<p><a href="https://www.bjcp.org/">Beer Judge Certification Program – Promoting beer literacy, recognizing beer tasting and evaluation skills. (bjcp.org)</a></p>
<p><strong>错误的分类方式</strong></p>
<p>啤酒经常会被按照颜色进行分类，比如黑啤、黄啤、白啤</p>
<p>但是这种分类方式是错误的，因为风格和颜色无关；一种风格往往有一定的色度范围，但并不决对，并且色度范围可能也很大，所以不可能通过颜色去区分啤酒的风格</p>
<p>啤酒的色度更多来源于酿造时所用的深色麦芽比重，想酿造黑色的 IPA、更浅的世涛也未尝不可</p>
<p><strong>工业啤酒也有风格</strong></p>
<p>常说的工业啤酒其实是属于拉格（Lager）这个大分类下</p>
<blockquote>
<p>拉格本身也是啤酒分类中的一种创新，本身拉格也是较难酿造的啤酒，因为它的难点在于低温。最早只有在德国北部一些偏冷地区将啤酒放在冰冷的山洞里窖藏才形成了这种风格（Lager 在德语里是窖藏的意思）</p>
</blockquote>
<p>那么拉格啤酒风靡世界的原因：</p>
<ul>
<li>口味清淡，更清爽</li>
<li>价格便宜</li>
<li>度数较低，社交属性</li>
<li>发酵难度小于艾尔啤酒</li>
<li>更容易工业生产</li>
<li>风格稳定</li>
<li>主流国家的推动，先入为主</li>
</ul>
<p><strong>艾尔和拉格</strong></p>
<p>艾尔（Ale）和拉格（Lager）最初指的是不同的酵母类型，而酵母类型能带来不同的风味</p>
<p><strong>艾尔</strong>酵母需要更高的温度（15℃~25℃），发酵过程中产生更多的代谢物质，其中包括给啤酒提供复杂香气的酯类、酚类、醛类等风味的物质，也包括不好的物质如双乙酰等；发酵时会产生更多的热量</p>
<p><strong>拉格</strong>酵母需要温度更低（4℃~12℃），发酵更加彻底，代谢产物较少，味道更加清冽，干净，爽口</p>
<p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252037761.jpg" alt="img"></p>
<p><strong>美式风格</strong></p>
<p>精酿运动发起于美国，所以如今的啤酒风格中经常能看到以 American 开头的风格名称</p>
<p>美式风格和传统风格（Pale Ale 和 American Pale Ale、Lager 和 American Lager）最大的区别在于使用<strong>美式酒花</strong>替代<strong>传统酒花</strong>，基于此啤酒风格也经常被分类为欧式和美式两大类（并不严谨）</p>
<p>美式酒花也被称为新世界酒花，传统的欧洲酒花更倾向于提供苦度、辛辣和草本风味，美式酒花更倾向于提供香味、柑橘类、瓜果、热带水果等味道</p>
<blockquote>
<p>卡斯卡特 1972年商品化</p>
<p>西楚 2008年商品化</p>
<p>金牌 1790年商品化</p>
</blockquote>
<img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/image-20220315235328107.png" alt="image-20220315235328107" style="zoom: 67%;" />

<img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252038370.png" alt="image-20220315235403042" style="zoom:67%;" />

<img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252038169.png" alt="image-20220315235344666" style="zoom: 67%;" />



<p><strong>举一些有特点的风格</strong></p>
<p>（下面的风格名称并不严谨，更多的是商业化风格的叫法）</p>
<ul>
<li><strong>印度淡色艾尔（IPA）</strong>：更多的啤酒花带来更高的苦度以及更多的风味 <a href="https://item.jd.com/100011983501.html">北平机器百花深处IPA</a></li>
<li><strong>古斯（Gose）</strong>：乳酸、盐水、香料 <a href="https://item.jd.com/10030440794661.html">牛啤堂帝都海盐</a></li>
<li><strong>兰比克（Lambics）</strong>：野菌发酵，更酸，变体是水果兰比克和法柔 <a href="https://item.jd.com/7907410.html">林德曼</a></li>
<li><strong>牛奶世涛（Milk Stout）</strong>：加了乳糖的世涛，往往追求更高的糊精比重 <a href="https://item.jd.com/100012559742.html">打嗝海狸花生牛奶世涛</a></li>
<li><strong>小麦啤酒（Wheat）</strong>：小麦作为重要原料，有一定酸度<ul>
<li><strong>德式小麦</strong>：原料单一（1516年《德国纯净啤酒法》） <a href="https://item.jd.com/100018726016.html">海底捞德式小麦</a></li>
<li><strong>比利时小麦</strong>：香料的加入，甜橙皮、芫荽籽 <a href="https://item.jd.com/100020388832.html">1664白啤</a></li>
</ul>
</li>
<li><strong>西打（Cider）</strong>：苹果酒（也可能是其他水果），更多的残糖 <a href="https://item.jd.com/53259108790.html">诱惑（TEMPT）7号</a></li>
<li><strong>修道院（Trappist &amp; Abbey）</strong>：比利时啤酒，由修道院（Trappist）或修道院授权（Abbey）酿造，收入用于慈善或社区服务，全球共有11家修道院酒厂；传统、高酒精度、厚重、焦糖，辅料大多数加入了比利时棕糖 <a href="https://item.jd.com/3306054.html">罗斯福（Rochefort）10号</a></li>
</ul>
<p><strong>更多创意</strong></p>
<p>精酿运动除了复刻历史上的传统啤酒风格（IPA-18世纪、古斯-16世纪），也带来了更多风格创意的探索</p>
<ul>
<li><strong>香槟IPA（Brut IPA）</strong>：2017年首创，使用葡萄糖淀粉酶，更低的苦味，更低的残糖意味着更干的口感</li>
<li><strong>酒花干投（Dry Hop）</strong>：一种酒花添加方式，适用于各种突出酒花风味类的风格，啤酒花不参与煮沸和旋沉阶段，而在冷却、发酵过程中加入啤酒花，目的是降低苦度增加香味</li>
<li><strong>燕麦世涛（Oatmeal Stout）</strong>：添加燕麦，追求更重的酒体</li>
<li><strong>酒花拉格（Hoppy Lager）</strong>：新时代风格，在传统拉格风格下加入大量新世界酒花，拉格的口感和更多的酒花香味和苦度</li>
<li><strong>水果啤酒（Fruit Beer）</strong>：酿造过程中加入水果甚至果泥（我觉得很难喝）</li>
</ul>
<h2 id="快点开喝"><a href="#快点开喝" class="headerlink" title="快点开喝"></a>快点开喝</h2><p><strong>啤酒的属性</strong></p>
<p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252038639.png" alt="img"></p>
<p>啤酒的酒标上标注了这瓶啤酒的基本信息</p>
<ul>
<li>酒厂（Brand）：Brew Dog</li>
<li>名称（Name）：Layer Cake</li>
<li>风格（Style）：Marshmallow &amp; Chocolate Stout 棉花糖 &amp; 巧克力世涛（酒厂自己定义的风格）</li>
<li>酒精度（ABV）：7%</li>
<li>容量（volume）：440ml</li>
</ul>
<p>除此之外啤酒的信息</p>
<ul>
<li><p>苦度（IBU）：不同的风格苦度差异会很大，IPA（40<del>100）、英式苦啤（30</del>70）、捷克拉格（20<del>40）、西打酒（5</del>20）</p>
</li>
<li><p>啤酒色度（EBC）：啤酒色度，白 -&gt; 黄 -&gt; 棕 -&gt; 黑</p>
</li>
<li><p>终了比重（FG）：数值越大意味着越高的残糖，也可能有更厚重的酒体</p>
</li>
<li><p>二次发酵方式：瓶中二发，还是只有一发后打入二氧化碳装瓶</p>
</li>
<li><p>罐装杀菌方式：国产啤酒，生啤、纯生</p>
</li>
<li><p>其他操作：原浆、一番榨</p>
</li>
</ul>
<p><strong>一些名词</strong></p>
<ul>
<li>干 &amp; 甜：干指的是更少的残糖，甜则相反（干红、半干、甜红）</li>
<li>轻 &amp; 重：酒体中糊精、蛋白质的含量，更重的酒体意味着更厚的口感</li>
<li>泡沫：一方面来自二氧化碳的含量，一般而言越清爽的风格越追求更多的二氧化碳；另一方面更重的酒体更能产生更绵密的泡沫</li>
</ul>
<p><strong>适饮温度</strong></p>
<p>一定要冰镇</p>
<p>艾尔类可以比拉格类温度稍高，有助于风味的散发，但肯定要远远低于室温（没有暖气的冬天除外）</p>
<p><strong>配餐</strong></p>
<p>啤酒本身就是大众的酒种，喝啤酒的时候搭配高热量的简餐感觉就更爽了，这也是为什么啤酒吧往往都提供简餐；也可以搭配甜品</p>
<p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039603.png"></p>
<p><a href="https://www.brewdog.com/uk/bar_pages/bar/locator">Bar Locator (brewdog.com)</a></p>
<h1 id="酿造"><a href="#酿造" class="headerlink" title="酿造"></a>酿造</h1><h2 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h2><p>酿造啤酒的本质就是粉碎麦芽、糖化麦芽、煮沸麦汁、冷却麦汁、发酵麦汁</p>
<p><strong>粉碎麦芽</strong>需要用到<strong>粉碎机</strong>，一般使用对碾结构，因为最好的粉碎程度是挤出麦胚但保留麸皮，因为麸皮在后续流程中可以对麦汁进行过滤，减少蛋白质等物质，使酒体更清澈、更稳定</p>
<p><strong>糖化麦芽</strong>需要<strong>保温桶</strong>，因为需要一定的温度（65℃左右）让麦芽内的酶进行工作，分解淀粉为麦芽糖、糊精以及其他产物，麦芽糖就是酒精的来源</p>
<p><strong>煮沸麦汁</strong>需要<strong>煮沸桶</strong>，保持高温煮沸，让异味物质蒸发（二甲基硫醚），以及投放酒花、辅料通过煮沸来萃取风味，还有最重要的一点就是杀菌</p>
<p><strong>冷却麦汁</strong>需要用到<strong>冷却盘管</strong>，更高级的设备可以使用<strong>换热器</strong>以及<strong>冷水机</strong>，目的是让麦汁尽可能快速地冷却到适宜投放酵母的温度，减少氧化</p>
<p><strong>发酵麦汁</strong>需要用到<strong>发酵桶</strong>，密闭、能够安装<strong>单向阀</strong>（发酵过程中会产生大量的热和二氧化碳需要排出）</p>
<h2 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h2><p><strong>基本原料</strong></p>
<p>啤酒的四大原料：</p>
<ul>
<li>麦芽：大麦麦芽，某些风格可能会使用小麦麦芽</li>
<li>啤酒花：蛇麻科植物，最早是用来保鲜，现在用来赋予啤酒香味和苦味</li>
<li>酵母：各种酵母，但总体分为艾尔和拉格两类，酵母生产厂家会有针对此类酵母的详细参数<br><a href="http://wxtest.seastad.com/fermentation-solutions/you-create-beer/you-create-beer.html?id=1">酿啤酒的你 • Fermentis (seastad.com)</a></li>
<li>水：这个就不解释了</li>
</ul>
<p><strong>各种辅料</strong></p>
<p>除了最基本的原料，啤酒中往往还加入不同的辅料，有的可能是因为风格需要，也有的可能是酿造者的创意</p>
<p>比如：</p>
<ul>
<li>比利时小麦需要加入甜橙皮和芫荽籽</li>
<li>比利时修道院啤酒需要加入棕糖</li>
<li>牛奶世涛需要加入乳糖</li>
<li>燕麦世涛需要加入燕麦</li>
<li>烟熏啤酒需要加入烟熏木</li>
<li>蜂蜜酒需要加入蜂蜜</li>
<li>以及各种创意加入花椒（<a href="https://item.jd.com/10028156058690.html">啤休酿造花椒生姜风味</a>）、花茶（<a href="https://item.jd.com/69394013613.html">高大师</a>）、果汁、香草等等</li>
</ul>
<p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039419.png" alt="image-20220316014349585"></p>
<p><strong>麦芽的种类</strong></p>
<p>酿造用的麦芽通常称为基础麦芽和特种麦芽，基础麦芽是麦汁中麦芽糖的主体和基本特征，而特种麦芽主要带来更多的风味和色度</p>
<p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039668.png" alt="image-20220316014132216"></p>
<p>比如很多名称中带有 “巧克力” 的啤酒，可能并不是添加了巧克力，而是特种麦芽带来的巧克力风味</p>
<p><strong>啤酒花的种类</strong></p>
<p>啤酒花的香味来自于植物中所包含的α—酸、β—酸和香精油，α—酸和β—酸经过高温后会成为啤酒中的苦味物质，但经过高温异构后才能更多溶于水，带来啤酒花的香味，所以啤酒花往往是苦味和香味并存</p>
<p>干投的方式可以避免啤酒花的苦味进入啤酒，但也减少了香味，所以干投往往需要更大量的啤酒花</p>
<p>啤酒花有不同的品种，在煮沸过程中不同的时间投入煮沸桶，来达到增加苦味和香味的目的</p>
<p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039251.png" alt="image-20220316015005883"></p>
<p><strong>单一酒花</strong></p>
<p>有的酒款会标注自己是<strong>单一酒花（Single-Hopped）</strong>，意思是所使用的原料里只包含一种品种的啤酒花</p>
<p>一般所使用的酒花是最新培育出的、风味更独特的新品种，能够更好的感知到这种酒花的风味</p>
<p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039769.png" alt="image-20220316015127042"></p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul>
<li><p>第一次发酵（2周）</p>
<ul>
<li><p>粉碎麦芽</p>
</li>
<li><p>糖化</p>
</li>
<li><p>洗糟</p>
</li>
<li><p>煮沸</p>
</li>
<li><p>添加辅料、酒花</p>
</li>
<li><p>冷却</p>
</li>
<li><p>测糖（初始比重）</p>
</li>
<li><p>装发酵桶</p>
</li>
<li><p>投放酵母</p>
</li>
<li><p>液封</p>
</li>
</ul>
</li>
<li><p>第二次发酵（至少2周，越久越好）</p>
<ul>
<li><p>测糖（终了比重）</p>
</li>
<li><p>配置二发用糖</p>
</li>
<li><p>装瓶</p>
</li>
<li><p>冷藏</p>
</li>
</ul>
</li>
</ul>
<p>从煮沸后的整个流程都需要对器材进行消毒，特别是发酵桶以及管道，如果这桶酒被杂菌污染，就该扔了</p>
<p><a href="https://www.youtube.com/watch?v=Wxo9PHc3jNw">How to Make Beer, the Animation. - YouTube</a></p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><strong>评分网站</strong></p>
<p><a href="https://untappd.com/">Untappd – Drink Socially – Free iOS and Android App</a></p>
<p><a href="https://www.jiuhuar.com/">精酿啤酒和啤酒世界-酒花儿 (jiuhuar.com)</a></p>
<p><strong>配方模拟</strong></p>
<p><a href="https://web.brewfather.app/tabs/tools">Brewfather</a></p>
<h2 id="还有"><a href="#还有" class="headerlink" title="还有"></a>还有</h2><p><strong>是否安全</strong></p>
<p>新闻经常报道喝假酒甲醇中毒的案例</p>
<p>家酿啤酒从工艺到设备肯定无法和酒厂相比，确实相对应的异味物质和不好的产物（甲醇等）会更多</p>
<p>但啤酒属于酿造酒，酿造酒所产生的酒精度就是比较低的，所以其他代谢产物会更少，甲醇中毒往往来自于蒸馏酒类，本身的甲醇浓度会在蒸馏后变得很高从而超过阈值；其次甲醛的主要来源是果胶，对于啤酒来说原料里果胶的来源非常少</p>
<p>所使用的酵母往往也是生物公司研制的产品，所带来的负面代谢产物会更少</p>
<p>食品检测也很方便，啤酒相关物质检测的价格在200元左右</p>
<p><strong>大师杯</strong></p>
<blockquote>
<p> 2012年，中国第一批家酿爱好者和啤酒发烧友开始成立社团、协会，组织各种交流活动。2012年8月，第一本中文啤酒家酿书《喝自己酿的啤酒》作者高岩，在南京创办了大师杯全国家酿啤酒大奖赛（以下简称大师杯），评选出优秀的家酿作品和酿造者，以颂扬酿造的艺术和科学</p>
<p>大师杯吸纳了诸多国内深耕于行业的先行者，形成大师杯全国家酿啤酒大奖赛组委会，制定并遵循组委会章程，秉承“公平、合理、科学”的价值观，不断提升大师杯的影响力和公信力。</p>
</blockquote>
<img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039610.jpg" style="zoom: 50%;" />



<p><a href="https://mp.weixin.qq.com/s/A2HxAoD_XUNVORqIWppcQA">2022 塔罗斯·大师杯 家酿赛，赛制说明&amp;分组规则</a></p>
<p><a href="https://mp.weixin.qq.com/s/vQdHVW-YuGWcpzzNXmcabA">2022 塔罗斯·大师杯 广州站报名开始</a></p>
<p><strong>我酿的啤酒</strong></p>
<p>曾经参过2020年大师杯，评分</p>
<p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039065.jpg" style="zoom:33%;" /><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039471.jpg" style="zoom:33%;" /></p>
<p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039794.jpg"></p>
<h1 id="艺术和文化"><a href="#艺术和文化" class="headerlink" title="艺术和文化"></a>艺术和文化</h1><h2 id="酒厂-amp-酒标"><a href="#酒厂-amp-酒标" class="headerlink" title="酒厂 &amp; 酒标"></a>酒厂 &amp; 酒标</h2><p><strong>打嗝海狸（Belching Beaver）</strong></p>
<p><a href="https://belchingbeaver.com/">Belching Beaver Brewery</a></p>
<p><strong>北酿（North Brewing）</strong></p>
<p><a href="https://shop.northbrewing.com/">North Brewing Co Online Shop</a></p>
<p><strong>岬角（Ballast Point）</strong></p>
<p><a href="https://ballastpoint.com/">Homepage - Ballast Point Brewing</a></p>
<p><strong>伟大理念（Great Notion）</strong></p>
<p><a href="https://greatnotion.com/">Great Notion | Home</a></p>
<p><strong>美奇乐（Mikkeller）</strong></p>
<p><a href="https://mikkeller.com/">Mikkeller</a></p>
<p><strong>联合艺术（Collective Arts）</strong></p>
<p><a href="https://collectiveartsbrewing.com/de/">Home - Collective Arts Germany (collectiveartsbrewing.com)</a></p>
<h2 id="衍生活动"><a href="#衍生活动" class="headerlink" title="衍生活动"></a>衍生活动</h2><p><strong>合酿</strong></p>
<p>合酿就是两个或多个不同的精酿厂牌在一起合作酿造一款酒，就有点儿像邻居之间的串门一样，今天我去你那儿，明天你来我这儿，大家坐一坐，聊一聊，吃个饭</p>
<p>除了联络感情，合酿还有一个重要意义就是能够将彼此的产品特点融合在一起，创造出更具特色的产品；合酿的过程其实也是个技术交流与分享的过程，取彼之长，补己之短</p>
<img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039709.png" alt="image-20220320171652123" style="zoom: 50%;" />

<img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039981.png" alt="image-20220320171714327" style="zoom:50%;" />

<img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039874.png" alt="image-20220320171722436" style="zoom: 50%;" />



<p><strong>酒头接管</strong></p>
<p>啤酒吧引入一批某酒厂的啤酒而举办的带有广告性质、主题性质、促销性质的营销活动</p>
<img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039483.png" alt="image-20220320171908796" style="zoom:50%;" />

<img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039798.png" alt="image-20220320171914991" style="zoom:50%;" />

<img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039116.png" alt="image-20220320171926205" style="zoom:50%;" />

<img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252040917.png" alt="image-20220320173347954" style="zoom:50%;" />



<p><strong>展览会 &amp; 啤酒节</strong></p>
<p><a href="https://www.jiuhuar.com/news/6225b9248ba5b044278b4569.html">「Design精酿」艺术展和春季啤酒畅饮大会来啦！ (jiuhuar.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s/8zT6i8Alnaw2D7Tg7nwPYg">2021京A八乘八参节指南，这个周末等你来玩！ (qq.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s/36PlJmIOa5tvlmFWGIVARQ">啤酒节来了！ | 第二届『跳啤拍档』广州精酿啤酒节，下周见！ (qq.com)</a></p>
<p><strong>啤酒跑</strong></p>
<img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252040418.png" alt="image-20220320172308492" style="zoom:50%;" />



<p><a href="https://mp.weixin.qq.com/s/DCBIJeQYdWRUF_XcpCydlQ">我们赞助了一场快乐的【2020厦门啤酒跑∣RUN FOR BEER】 (qq.com)</a></p>
<p><strong>节日活动</strong></p>
<img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252040128.png" alt="image-20220320173409737" style="zoom: 67%;" />

<img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252040081.png" alt="image-20220320173420348" style="zoom:50%;" />

<p><a href="https://mp.weixin.qq.com/s/woOyTmWUATl7-0p-K6EDkw">煎饼节后遗症｜京津大战全回顾 (qq.com)</a></p>
<p><strong>跨界</strong></p>
<img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252040229.png" alt="image-20220320173649555" style="zoom:50%;" />

<img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252040814.png" alt="image-20220320173657609" style="zoom:50%;" />

<p><a href="https://mp.weixin.qq.com/s/qW5M9Eduzz0jn2H-o9bZHw">文末有福利｜道酿 X FIRST青年电影展 (qq.com)</a></p>
<h2 id="《都在酒里》"><a href="#《都在酒里》" class="headerlink" title="《都在酒里》"></a>《都在酒里》</h2><p>最后推荐一部机核的纪录片</p>
<p><a href="https://www.bilibili.com/video/BV1R5411s7ZY?spm_id_from=333.999.0.0">「4K重制版」坐在一起，为生活干杯：精酿啤酒纪录片《都在酒里》第三集《美式周末》_哔哩哔哩_bilibili</a></p>
<p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252042908.jpg"></p>
]]></content>
      <categories>
        <category>生活</category>
        <category>酒</category>
      </categories>
      <tags>
        <tag>啤酒</tag>
      </tags>
  </entry>
  <entry>
    <title>ES cardinality 和 HyperLogLog</title>
    <url>/2022/12/03/%E5%AD%A6%E4%B9%A0/ES/ES%20cardinality%20%E5%92%8C%20HyperLogLog/</url>
    <content><![CDATA[<h1 id="基数聚合"><a href="#基数聚合" class="headerlink" title="基数聚合"></a>基数聚合</h1><p>基数聚合属于聚合中的度量聚合，计算不同值的<strong>近似计数</strong></p>
<p>需要注意，聚合出的结果是一个近似值，原因是底层结构使用的 HyperLogLog，具有一定误差</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>假定 index 存储的售卖数据，希望查询有多少种不同的商品类型</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /sales/_search?size=<span class="number">0</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;cardinality&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>以之前的学生 index 为例，查询有几个班级下有女学生</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;female&quot;</span> <span class="comment">// 结果集查询性别为女性</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="comment">// 不关注 hits 结果集</span></span><br><span class="line">	<span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;class_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;cardinality&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;class&quot;</span></span><br><span class="line">			<span class="punctuation">&#125;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>返回结果，选取 <code>hits</code> 和 <code>aggregations</code> 部分</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;relation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eq&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;max_score&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;aggregations&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;class_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>因为 <code>size</code> 为 0，所以 <code>hits</code> 中没有返回的文档</p>
<p><code>aggregations</code> 下自定义结果集名称 <code>class_count</code> 返回的值为 2，说明班级下有女学生的班级数量为 2</p>
<h2 id="近似值与精确阈值参数"><a href="#近似值与精确阈值参数" class="headerlink" title="近似值与精确阈值参数"></a>近似值与精确阈值参数</h2><p>由于返回结果是一个近似值，所以 <code>cardinality</code> 支持 <code>precision_threshold</code> 参数，用来设置精确阈值</p>
<p>阈值参数的本质是使用空间换取准确性，默认是 3000，最大支持 40000，超过 40000 的设置为按照 40000 来处理</p>
<p>低于阈值的计数更符合准确值，高于阈值的计数则会更加模糊</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;female&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;class_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;cardinality&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;class&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="attr">&quot;precision_threshold&quot;</span><span class="punctuation">:</span> <span class="number">200000</span> <span class="comment">// 精度阈值，事实上内部将该参数视为 40000</span></span><br><span class="line">			<span class="punctuation">&#125;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>计算精确的计数需要将值加载至哈希集合并返回大小，当基数特别大时，需要占用非常多资源</p>
<p>所以 ES 选择 HyperLogLog 算法来实现 <code>cardinality</code>，这种方式基于值的哈希计数，有一些特性：</p>
<ul>
<li>可配置的精度，可以选择用内存换取精度</li>
<li>低基数集合中是精准的</li>
<li>固定的内存使用率，无论唯一值有多少，只取决于设置的精度</li>
</ul>
<p>HyperLogLog + + 算法依赖于散列值的前导零，数据集中散列的精确分布会影响基数的准确性</p>
<p>ES 官方文档提供的数据显示，具体的准确性取决于数据集情况，但大部分场景的准确性都还是良好的，<strong>即使阈值设置为 100，在百万、千万基数下，误差范围也控制在了 1% ~ 6%；当阈值设置为 10000，误差基本在 1% 左右</strong></p>
<h2 id="脚本-runtime-field"><a href="#脚本-runtime-field" class="headerlink" title="脚本 runtime field"></a>脚本 runtime field</h2><p><code>cardinality</code> 像其他聚合操作一样，是可以使用脚本拼接字段的</p>
<p>如果希望对两个字段的组合进行操作，创建一个 runtime field 组合他们然后进行基数聚合</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;runtime_mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;gender_and_age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;script&quot;</span><span class="punctuation">:</span> <span class="string">&quot;emit(doc[&#x27;gender&#x27;].value + &#x27;&amp;&#x27; + doc[&#x27;age&#x27;].value)&quot;</span> <span class="comment">// 拼接 gender 和 age 字段</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;type_promoted_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;cardinality&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gender_and_age&quot;</span> <span class="comment">// 根据 runtime field 进行基数操作</span></span><br><span class="line">			<span class="punctuation">&#125;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>返回结果是 6，因为有两个文档的 runtime field <code>gender_and_age</code> 值都为 <code>male&amp;20</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;aggregations&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;type_promoted_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">6</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><p>HyperLogLog 是一种基数计数的算法，旨在使用较少内存的情况下得到基数数量的近似精确值</p>
<h2 id="基数计数方式"><a href="#基数计数方式" class="headerlink" title="基数计数方式"></a>基数计数方式</h2><p>基数计数（cardinality counting）通常用来统计一个集合中不重复的元素个数，例如统计某个网站的 UV，或者用户搜索网站的关键词数量等</p>
<p>如何计算计数常见的有多种方式</p>
<ul>
<li>B 树<ul>
<li>利用树存储具体元素</li>
<li>优点：插入和查找效率高，统计数据时可以快速做到记录与去重，计算基数时只需要统计叶子节点个数即可</li>
<li>缺点：没有节省内存，需要存储数据全集</li>
</ul>
</li>
<li>bitmap<ul>
<li>使用 bit 位进行标记，即抛弃具体元素内容只存储特征值</li>
<li>优点：节约内存，结果可以进行方便的位运算操作（合并 - 与，差集 - 或）</li>
<li>缺点：空间占用仍然较大</li>
</ul>
</li>
<li>概率算法<ul>
<li>目前用于基数计数的概率算法有：LC、LLC、HLL 等</li>
<li>优点：LL、HLL 等能够在空间更小的情况下进行基数计算</li>
<li>缺点：有一定误差</li>
</ul>
</li>
</ul>
<h2 id="HLL"><a href="#HLL" class="headerlink" title="HLL"></a>HLL</h2><p>HLL 中实际存储的是一个长度为 m 的大数组 S，将待统计的数据集合划分成 m 组，每组根据算法记录一个统计值存入数组中</p>
<p>数组的大小 m 由算法实现方自己确定，Redis 中这个数组的大小是 16834，m 越大误差越小，但需要的内存空间也越大</p>
<p>HLL 的数学原理看不懂，大致就是 n 重伯努利原理</p>
<p>通过多次抛硬币，直到抛到正面为止，这是一次伯努利过程；当一直抛硬币，直到多次出现正面，将出现正面的投掷次数值记为 k1、k2、k3…kn，最大值记为 kmax，那么可以得到以下结论：</p>
<ul>
<li>n 次伯努利过程的投掷次数都不大于 kmax</li>
<li>n 次伯努利过程，至少有一次投掷次数等于 kmax</li>
</ul>
<p>最后经过一系列复杂的推论，最终的结果就是：<strong>进行了 n 次进行抛硬币实验，每次分别记录下第一次抛到正面的抛掷次数 k，那么可以用 n 次实验中最大的抛掷次数 kmax 来预估实验组数量 n</strong>；这就是 HLL 算法的数学理论基础</p>
<p>此外 HLL 为了提高准确性也做了其他优化</p>
<p><strong>分桶平均</strong></p>
<p>HLL 的基本思想是利用集合中数字的比特串第一个1出现位置的最大值来预估整体基数，但是这种预估方法存在较大误差，为了改善误差情况，HLL 中引入分桶平均的概念</p>
<p>为了避免一组实验中的运气影响，将统计数据划分多个桶，每个桶各自统计自己的 kmax 计算基数预估值，最终对各个桶的基数预估值进行合并，使用调和平均数的方式进一步降低误差</p>
<p><strong>偏差修正</strong></p>
<p>虽然调和平均数能够适当修正算法误差，但作者给出一种分阶段修正算法</p>
<p>当 HLL 算法开始统计数据时，统计数组中大部分位置都是空数据，并且需要一段时间才能填满数组，这种阶段引入一种小范围修正方法；当 HLL 算法中统计数组已满的时候，需要统计的数据基数很大，这时候 hash 空间会出现很多碰撞情况，这种阶段引入一种大范围修正方法</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.5/search-aggregations-metrics-cardinality-aggregation.html#search-aggregations-metrics-cardinality-aggregation">Cardinality aggregation | Elasticsearch Guide 8.5 </a></p>
<p><a href="https://juejin.cn/post/7067816471128342564">神奇的HyperLogLog算法【转载 #涉及到数学原理】 - 掘金 (juejin.cn)</a></p>
<p><a href="http://content.research.neustar.biz/blog/hll.html">Sketch of the Day: HyperLogLog — Cornerstone of a Big Data Infrastructure – AK Tech Blog (neustar.biz)</a></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>ES</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>ES 碎片</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆 &amp; 布谷鸟过滤器</title>
    <url>/2022/12/11/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%83%E9%9A%86%20&amp;%20%E5%B8%83%E8%B0%B7%E9%B8%9F%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><strong>特征 or 全部</strong></p>
<p>在实际需求中，往往存在类似需求：</p>
<ul>
<li>黑白名单；例如手机号、网站等，需要过滤掉在黑名单中的数据，或者放行在白名单中的数据</li>
<li>推荐去重；首页新闻、视频等资源已经给用户推荐过的不进行重复推送</li>
<li>缓存穿透；保证缓存层能正常工作，不被特殊请求大量造成缓存穿透</li>
</ul>
<p>最容易想到的，就是通过一个集合例如 Map、List 等结构将数据存储起来，判断是否存在于集合中</p>
<p>这样相当于把所有的数据都进行了一遍存储，如果需要的只是过滤功能，而不需要将数据全部存储下来，只需要存储数据的特征值，就可以节省大量的空间</p>
<p>所以出现了布隆过滤器等概率型结构（probabilistic data structure），可以在使用很少空间的情况下对数据进行过滤操作，当然通过特征值进行存储可能会有以下问题：</p>
<ul>
<li>误判率</li>
<li>扩缩容依然需要数据全集（数据量不匹配会导致空间浪费或误判率上升）</li>
<li>删除操作难以实现</li>
</ul>
<p>需要在技术和业务两方面进行取舍</p>
<h1 id="布隆"><a href="#布隆" class="headerlink" title="布隆"></a>布隆</h1><p>布隆过滤器（bloom filter）由一串很长的二进制向量组成（位图 bitmap），可以将其看成一个二进制数组</p>
<p>当一个元素进入时，不是存储该元素本身，而是通过多个哈希算法，计算出该元素的多个下标，随后在位图中将对应的下标打上标记（bit 位置为 1），当需要判断是否存在某个元素时，也是进行哈希后，判断其需要的下标是否全为 1</p>
<p>可以看出，布隆过滤器带有一定的误判率，如果很多元素的下标正好复合了某一个元素的位置，那么该元素就会被误判存在：</p>
<ul>
<li>说存在但不一定存在</li>
<li>说不存在一定不存在</li>
</ul>
<p>图示模拟流程：<a href="https://www.jasondavies.com/bloomfilter/">https://www.jasondavies.com/bloomfilter/</a></p>
<p><strong>参数选择</strong></p>
<p>也可以看出布隆过滤器的误判率和以下参数相关：</p>
<ul>
<li>过滤器中位图的位数</li>
<li>哈希算法的数量和质量</li>
</ul>
<p><a href="https://hur.st/bloomfilter/?n=400000000&p=0.01&m=&k=">Bloom filter calculator (hur.st)</a> 可以进行布隆过滤器参数的预估</p>
<table>
<thead>
<tr>
<th align="center">参数值</th>
<th align="center">含义</th>
<th align="center">公式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">n</td>
<td align="center">过滤器中的元素数量</td>
<td align="center"><code>n = ceil(m / (-k / log(1 - exp(log(p) / k))))</code></td>
</tr>
<tr>
<td align="center">p</td>
<td align="center">误判率</td>
<td align="center"><code>p = pow(1 - exp(-k / (m / n)), k)</code></td>
</tr>
<tr>
<td align="center">m</td>
<td align="center">过滤器使用的空间大小</td>
<td align="center"><code>m = ceil((n * log(p)) / log(1 / pow(2, log(2))));</code></td>
</tr>
<tr>
<td align="center">k</td>
<td align="center">哈希算法数量</td>
<td align="center"><code>k = round((m / n) * log(2));</code></td>
</tr>
</tbody></table>
<p><strong>无法删除</strong></p>
<p>布隆过滤器是无法删除元素的，因为一旦存储特征后，删除会导致连带其他元素的标记一起删除</p>
<p>为了能让布隆过滤器支持删除操作，衍生出了变体结构，计数布隆过滤器（counting bloom filter）</p>
<p><strong>实际应用</strong></p>
<p><a href="https://toutiao.io/posts/mtrvsx/preview">Now 直播发现页短视频瀑布流优化 - 开发者头条 (toutiao.io)</a></p>
<h1 id="计数布隆"><a href="#计数布隆" class="headerlink" title="计数布隆"></a>计数布隆</h1><p>使用一个 counter 数组来替代之前的位图，在进行标记时可以记录一共标记了多少次，显而易见空间占用会扩大不少</p>
<p>在进行判断时 <code>counter &gt; 0</code> 即表示了之前的 <code>index == 1</code> 操作</p>
<p>计数器也无法避免误删，只是能大幅度降低误删概率</p>
<h1 id="布谷鸟"><a href="#布谷鸟" class="headerlink" title="布谷鸟"></a>布谷鸟</h1><p>布谷鸟过滤器是布隆过滤器的升级，有如下优势：</p>
<ul>
<li>支持动态的新增和删除元素</li>
<li>提供了比传统布隆过滤器更高的查找性能，即使在接近满空间的情况下（访问内存次数低）</li>
<li>要求一定误判率下，空间占用一般更小</li>
</ul>
<p><strong>布谷鸟 hash</strong></p>
<blockquote>
<p>当发现鸟蛋占用了自己的位置时，就把它推走</p>
</blockquote>
<p>假设有两个 hash 表，记为 T1 和 T2</p>
<p>同时有两套 hash 算法，记为 H1 和 H2</p>
<p>添加元素流程如下：</p>
<ol>
<li>根据 H1 计算其在 T1 的位置下标</li>
<li>如果该位置没有标记则进行标记，如果标记了则继续</li>
<li>根据 H2 计算其在 T2 的位置下标</li>
<li>如果该位置没有标记则进行标记，如果标记了则说明所有位置都已经被占用，随机踢出 T1 或者 T2 上该下标的元素，将自己放入下标</li>
<li>被踢出的元素重复上述流程查找自己的位置</li>
<li>经过 <code>MaxLoop </code> 阈值后还存在元素没有合适的位置，则元素添加失败，说明需要进行扩容了</li>
</ol>
<p>图示模拟流程：<a href="http://www.lkozma.net/cuckoo_hashing_visualization/">http://www.lkozma.net/cuckoo_hashing_visualization/</a></p>
<p><strong>过滤器的 hash</strong></p>
<p>布谷鸟过滤器的 hash 是对布谷鸟 hash 的改进</p>
<p>布谷鸟 hash 中，哈希表存储的是元素的原始值 x，下标 p1 p2 的计算公式为</p>
<ul>
<li><code>p1 = hash1(x) % L</code></li>
<li><code>p2 = hash2(x) % L</code></li>
</ul>
<p>而布谷鸟过滤器对于下标的计算为：</p>
<ul>
<li><code>h1(x) = hash(x)</code></li>
<li><code>h2(x) = h1(x) ⊕ hash(x&#39;s fingerprint)</code></li>
</ul>
<p>我们可以看到，计算 h2（位置 2）时，对 x 的 fingerprint 进行了一个 hash 计算，公式中的异或操作获得了一个重要的特性：位置 h2 可以通过位置 h1 和 h1 中存储的 fingerprint 计算出来，即当元素被踢出时，根据当前位置和元素的指纹，就可以得到元素的下一个位置</p>
<p><strong>异或与对偶</strong></p>
<p>由 h2 的计算公式 <code>h2(x) = h1(x) ⊕ hash(x&#39;s fingerprint)</code>，两个位置具有对偶性</p>
<p>只要保证 <code>hash(x&#39;s fingerprint) !=0</code>，那么就可以确保 <code>h2 != h1</code>，也就可以确保，不会出现自己踢自己的死循环问题</p>
<p>为什么需要对指纹进行哈希运算呢？因为如果指纹的长度是 8 bit，那么异或操作只会改变当前位置  h1(x)  的低 8 位，高位不会改变，就算低 8 位完全不一样，最后计算出来的位置最远也只有 256 位，为了散列更充分，所以对指纹先进行一次哈希操作</p>
<p><strong>指纹</strong></p>
<p>指纹其实就是元数据的特征值，进行哈希后取的固定 n 个 bit 位</p>
<p><strong>空间利用率</strong></p>
<p>由于指纹是对数据进行哈希运算后固定的 bit 位，所以必然会出现误判的情况</p>
<p>在完美的情况下，也就是没有发生哈希冲突之前，它的空间利用率最高只有 50%</p>
<p>如果对数组进行展开，当一个位置可以存放多个数据时，空间利用率会提升；如果一个下标可以放 2、4、8 个元素的时候，空间利用率就会飙升到 84%、95%、98%</p>
<p><strong>删除的限制</strong></p>
<p>如果需要布谷鸟过滤器支持删除，它必须知道一个数据插入过多少次（否则也会误删）</p>
<p>并且不能让同一个数据插入 <code>kb+1</code> 次；个人认为如果插入超过了 <code>kb+1</code> 次，就会导致插入一定失败</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>布谷鸟的优缺点：</p>
<p><strong>优点：</strong></p>
<ul>
<li>访问内存次数低</li>
<li>Hash 函数计算简单</li>
<li>支持删除操作</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>内存空间不联系，CPU 消耗大</li>
<li>容易出现装填循环问题，空间占用越多碰撞越多，插入效率越低</li>
<li>查询误判率</li>
<li>删除操作限制多，会影响插入性能和误删除</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf">https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/348865590">布隆，牛逼！布谷鸟，牛逼！ - 知乎 (zhihu.com)</a></p>
<p><a href="https://juejin.cn/post/6844903861749055502">布隆过滤器过时了，未来属于布谷鸟过滤器？ - 掘金 (juejin.cn)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/462815302">布隆过滤器与布谷鸟过滤器 - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>ES 的 from size 和 scroll 和 search after</title>
    <url>/2022/11/29/%E5%AD%A6%E4%B9%A0/ES/ES%20%E7%9A%84%20from%20size%20%E5%92%8C%20scroll%20%E5%92%8C%20search%20after/</url>
    <content><![CDATA[<h1 id="from-size"><a href="#from-size" class="headerlink" title="from size"></a>from size</h1><p>from size 是最常见的分页方式，类比 MySQL 的 offset limit</p>
<p>由于 ES 是天然分布式的，数据分散在各个 shards 上，所以需要查询 <code>from + size</code> 的条数时，coordinate node 就向该 index 的其余的  shards 发送同样的请求，等汇总到 <code>(shards × (from + size))</code> 条数时在 coordinate node 再进行一次排序，最终抽取出真正 from 后的 size 条结果</p>
<p>显而易见，当 shards 较多、分页深度很大时，这种方式存在很大的性能问题，这也是 ES 默认深度为 <code>from + size &lt;= 10000</code> 的原因</p>
<h2 id="Routing-机制"><a href="#Routing-机制" class="headerlink" title="Routing 机制"></a>Routing 机制</h2><p>写入文档时指定存储的分片</p>
<p>官方提供的公式如下：<code>shard_num = hash(_routing) % num_primary_shards</code></p>
<ul>
<li><code>_routing</code> 代表提供路由的字段。默认情况下为文档的 ID</li>
<li><code>num_primary_shards</code> 代表的为 primary shard 的个数，这个在每个索引类型创建之前就被设置了，可以手动设置也可以让 ES 默认设置。因为 ES 版本不同，设置的默认值也不同。该值在第一次创建索引类型被设置完成之后无法无法修改（修改路由机制就代表需要迁移数据）</li>
<li><code>shard_num</code> 代表数据落在的 shard 编号</li>
</ul>
<p>基本流程是 ES 根据路由字段计算其哈希值，再与主分片数量取余，计算得出数据落在的分片编号</p>
<p>此外如果只根据 <code>_routing</code> 会出现数据倾斜，可以采取折中方案，使用 <code>routing_partition_size</code> 参数，来使同一类 <code>_routing</code> 路由到主分片的一个子集中</p>
<p><code>shard_num = (hash(_routing) + hash(_id) % routing_partition_size) % num_primary_shards</code></p>
<h2 id="restful"><a href="#restful" class="headerlink" title="restful"></a>restful</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /hero-index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;must_not&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">				<span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">						<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">					<span class="punctuation">&#125;</span></span><br><span class="line">				<span class="punctuation">&#125;</span></span><br><span class="line">			<span class="punctuation">]</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// searchRequest</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hero-index&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询条件</span></span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">    <span class="comment">// 分页条件</span></span><br><span class="line">    searchSourceBuilder.from(<span class="number">0</span>);</span><br><span class="line">    searchSourceBuilder.size(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// term name = &quot;&quot;</span></span><br><span class="line">    <span class="type">TermQueryBuilder</span> <span class="variable">termQueryBuilder</span> <span class="operator">=</span> QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// bool 类型为 must not</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery().mustNot(termQueryBuilder);</span><br><span class="line">    <span class="comment">// 查询条件组装进 searchSourceBuilder</span></span><br><span class="line">    searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line">    searchSourceBuilder.timeout(<span class="keyword">new</span> <span class="title class_">TimeValue</span>(<span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">search</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;totalHits:&quot;</span> + search.getHits().getTotalHits().value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="search-after"><a href="#search-after" class="headerlink" title="search after"></a>search after</h1><p>ES 5 引入的新机制</p>
<p>简单概括 search after 如何使用：</p>
<ul>
<li>必须先指定排序规则（需要获取排序坐标）</li>
<li>比如从第一页开始（从中间开始也无法知道中间的具体位置）</li>
<li>从第一页开始以后每次都带上<code>search_after=lastEmittedDocFieldValue</code><br><code>lastEmittedDocFieldValue</code> 就是下一页开始的 keyset 坐标（也就是这个参数把深度分页变成了常数级分页）</li>
</ul>
<p><strong>和 from size 相比，无论去到第几页，coordinate node 向其它 node 发送的请求始终就是请求 size 个 docs；即无论分页深度是多少，都是常量级的开销</strong></p>
<p>其实现原理和关系型数据库常使用的 keyset 分页思想一致，业务妥协（只能按顺序分页而不能跳转页数）来实现性能的提升</p>
<p>但需要注意，看似 search after 是一个 O(1) 级别的操作，但随着分页深度的增加，其内部逻辑扫描的 doc 数量也在不断增加，依然会影响查询性能，只是相比 from size 方式有一定提升（MySQL 单表查询的分页也是如此）</p>
<p>此外，如果字段区分度不高，则会忽略某些数据；例如根据 age 作为排序条件，此时如果每页数据取 1000 条，而某个 age 数据 count &gt; 1000，则会忽略后续数据；<strong>解决方法是排序字段唯一，或者组合后的多个排序条件唯一</strong></p>
<h2 id="restful-1"><a href="#restful-1" class="headerlink" title="restful"></a>restful</h2><p>第一次查询和普通查询一致</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /hero-index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;must_not&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">				<span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">						<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">					<span class="punctuation">&#125;</span></span><br><span class="line">				<span class="punctuation">&#125;</span></span><br><span class="line">			<span class="punctuation">]</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">			<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">			<span class="punctuation">&#125;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>随后的查询增加 <code>search_after</code> 查询条件，值为最后一条数据排序字段的值</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /hero-index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;must_not&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">				<span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">						<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">					<span class="punctuation">&#125;</span></span><br><span class="line">				<span class="punctuation">&#125;</span></span><br><span class="line">			<span class="punctuation">]</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">			<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">			<span class="punctuation">&#125;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;search_after&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">		<span class="number">35</span><span class="punctuation">,</span></span><br><span class="line">		<span class="string">&quot;i-mnlIQBCTaFCHoWJhbM&quot;</span></span><br><span class="line">	<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h2><p>同 from size 一致</p>
<p>第二次查询及之后需要 <code>searchSourceBuilder.searchAfter(new Object[1]);</code> 来设置 <code>search_after</code> 参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">searchAfter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// searchRequest</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hero-index&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询条件</span></span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">    <span class="comment">// 分页条件</span></span><br><span class="line">    searchSourceBuilder.from(<span class="number">0</span>);</span><br><span class="line">    searchSourceBuilder.size(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// term name = &quot;&quot;</span></span><br><span class="line">    <span class="type">TermQueryBuilder</span> <span class="variable">termQueryBuilder</span> <span class="operator">=</span> QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// bool 类型为 must not</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery().mustNot(termQueryBuilder);</span><br><span class="line">    <span class="comment">// 查询条件组装进 searchSourceBuilder</span></span><br><span class="line">    searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line">    searchSourceBuilder.timeout(<span class="keyword">new</span> <span class="title class_">TimeValue</span>(<span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上批数据最后一条的排序字段值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastHitOrderFieldValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// set 进 searchAfter 属性中</span></span><br><span class="line">    searchSourceBuilder.searchAfter(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;lastHitOrderFieldValue&#125;);</span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">search</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;totalHits:&quot;</span> + search.getHits().getTotalHits().value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h1><p>如果一开始就明确地查询全量的数据，无论使用 from size 还是 search after 都不是一个好的选择，要么依然存在深度分页的问题，要么需要多次请求，所以引入了 scroll 方式</p>
<p>scroll 就是把一次的查询结果缓存一定的时间，如 <code>scroll = 1m</code> 则把查询结果在下一次请求上来时暂存 1 分钟</p>
<p>response 比传统的返回多了一个 <code>scroll_id</code>，下次带上这个 <code>scroll_id</code> 即可找回这个缓存的结果</p>
<p>本质上是让各个 shard 将结果缓存，此外也有很多优化（单 shard 减少请求数量、剪枝等）来提高性能</p>
<h2 id="restful-2"><a href="#restful-2" class="headerlink" title="restful"></a>restful</h2><p>第一次请求</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /hero-index/_search?scroll=<span class="number">1</span>m</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;must_not&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">				<span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">						<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">					<span class="punctuation">&#125;</span></span><br><span class="line">				<span class="punctuation">&#125;</span></span><br><span class="line">			<span class="punctuation">]</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">			<span class="punctuation">&#125;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>随后</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /_search/scroll</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;scroll&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1m&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;scroll_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;FGluY2x1ZGVfY29udGV4dF91dWlkDXF1ZXJ5QW5kRmV0Y2gBFlN0TlRCWW5pUktHLWxvMEdDN3Zya2cAAAAAAAAA_hZkVXh5THJ1SFR1dVVPQlJJX3JDZWRR&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scrollSearch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// searchRequest</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hero-index&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询条件</span></span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">    <span class="comment">// 分页条件</span></span><br><span class="line">    searchSourceBuilder.from(<span class="number">0</span>);</span><br><span class="line">    searchSourceBuilder.size(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// term name = &quot;&quot;</span></span><br><span class="line">    <span class="type">TermQueryBuilder</span> <span class="variable">termQueryBuilder</span> <span class="operator">=</span> QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// bool 类型为 must not</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery().mustNot(termQueryBuilder);</span><br><span class="line">    <span class="comment">// 查询条件组装进 searchSourceBuilder</span></span><br><span class="line">    searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line">    searchSourceBuilder.timeout(<span class="keyword">new</span> <span class="title class_">TimeValue</span>(<span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 scroll</span></span><br><span class="line">    <span class="type">Scroll</span> <span class="variable">scroll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scroll</span>(TimeValue.timeValueMinutes(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    searchRequest.scroll(scroll);</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">search</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;totalHits:&quot;</span> + search.getHits().getTotalHits().value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>随后应该循环查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scrollAfterSearch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义 scroll</span></span><br><span class="line">    <span class="type">Scroll</span> <span class="variable">scroll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scroll</span>(TimeValue.timeValueMinutes(<span class="number">1</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">scrollId</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">SearchScrollRequest</span> <span class="variable">searchScrollRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchScrollRequest</span>(scrollId);</span><br><span class="line">    searchScrollRequest.scroll(scroll);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    searchScrollRequest.scroll(scroll);</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">search</span> <span class="operator">=</span> client.scroll(searchScrollRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;totalHits:&quot;</span> + search.getHits().getTotalHits().value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>文章 <strong>《业界难题 - ”跨库分页” 的四种方案》</strong></p>
<h2 id="需求产生"><a href="#需求产生" class="headerlink" title="需求产生"></a>需求产生</h2><p><strong>分页需求</strong></p>
<p>对于数据的查询，很多业务都有分页拉取数据的需求，例如：分页拉取聊天记录、商品信息、图片数据等</p>
<p>除了对数据集拆分，往往还需要业务字段进行排序</p>
<p>比如取第 3 页的订单数据，每页 100 条，根据创建时间倒序；可以根据创建时间建立索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">order</span>` <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span> LIMIT <span class="number">200</span>,<span class="number">100</span>;</span><br></pre></td></tr></table></figure>



<p><strong>分库分表</strong></p>
<p>随着业务的发展，为了应对数据量大、请求量大等问题，对数据库进行了横向扩展</p>
<p>引入分库分表后，数据根据 patition key 路由规则写入不同的库表中</p>
<p>同时为了让读写压力尽可能均匀分布在各个库中，往往会设置合适的 patition key</p>
<p>当分库分表后需要进行示例的分页需求时，就无法通过简单的请求一个库实现目的了（假设分表键不是使用的创建时间，事实上使用创建时间范围作为分表键也没任何意义）</p>
<p>排序的依据是时间，分表的依据是其他字段，因此数据库丧失了创建时间排序的全局视野</p>
<p>本文就在讨论如何满足 跨越多个水平拆分数据库的分页查询问题</p>
<h2 id="全局视野"><a href="#全局视野" class="headerlink" title="全局视野"></a>全局视野</h2><p>当数据分布在两个库中，无论哪个分库的第三页，都不一定会是全局排序的第三页数据</p>
<p>情况如下：</p>
<ul>
<li>一般情况：两个库各占第三页数据的一部分</li>
<li>极端情况：两个库各占一半</li>
<li>极端情况：第三页数据完全来自于一个库</li>
</ul>
<p>由于查询前并不清楚数据到底是如何分布在各个分库上的，所以每个库都返回 3 页数据，所得到的 6 页数据再进行排序，此时获得了根据创建时间排序的全局视野，再从 6 页数据中抽取需要的第 3 页数据</p>
<p><strong>优点：</strong></p>
<ul>
<li>业务无损，精准返回</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>每次需要向各分库查询的数据量和 shard 数量倍数级相关，和页码（深度）指数级相关</p>
</li>
<li><p>需要二次排序</p>
</li>
<li><p>需要更多 IO 资源</p>
</li>
</ul>
<h2 id="禁止跳页"><a href="#禁止跳页" class="headerlink" title="禁止跳页"></a>禁止跳页</h2><p>由业务进行妥协，不允许进行页数的随意跳转，只允许依次进行 下一页 操作，就能减少深度分页带来的性能影响</p>
<p>被称为 keyset 分页、search after 等</p>
<p>首先这种方式需要先进行排序，比如使用创建时间作为排序字段，第一页时各分库执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">order</span>` <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span> LIMIT <span class="number">0</span>,<span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>当点击下一页时，根据第一页数据的最后一条，即第一页中最小创建时间的数据（假设是 1669820860000），各分库执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">order</span>` <span class="keyword">WHERE</span> `createdTime` <span class="operator">&gt;</span> <span class="number">1669820860000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span> LIMIT <span class="number">0</span>,<span class="number">100</span>;</span><br></pre></td></tr></table></figure>



<p>可以发现，除第一次查询时，后面每次查询都需要带上排序条件下，上一次查询最后数据的排序值，这也是无法进行跳页的原因，因为不通过查询无法知道所需页数据的 search after 条件是多少</p>
<p>禁止跳页后每个分库一次都只查询一页数据，查询数据量只和分库数量倍数级相关</p>
<p><strong>优点：</strong></p>
<ul>
<li>性能相对较好，不受全局视野中深度分页指数级影响</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>业务进行不能跳页的妥协</li>
<li>排序字段需要具有区分度</li>
</ul>
<h2 id="允许精度损失"><a href="#允许精度损失" class="headerlink" title="允许精度损失"></a>允许精度损失</h2><p>正常情况下，patition key 规则都尽可能使数据均匀分布在各分库中</p>
<p>所以可以理想认为，每个分库都完整包含了数据的一部分</p>
<p>假设需要取第 100 页数据，有 2 个分库，可以各取每个分库的半页数据再得到数据的并集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">order</span>` <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span> LIMIT <span class="number">9450</span>,<span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<p>这种方式最终结果只能是近似结果，并不精准</p>
<p><strong>优点：</strong></p>
<ul>
<li>性能相对较好，不受全局视野中深度分页指数级影响</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>业务进行精度损失的妥协</li>
</ul>
<h2 id="二次查询"><a href="#二次查询" class="headerlink" title="二次查询"></a>二次查询</h2><p>这种方式既能做到精准数据，也能减少查询量</p>
<p>基本的思想是通过多次查询来获得全局视野，再根据全局视野在结果集中抽取需要的数据</p>
<p>假设一页查询 5 条数据，查询第 201 页，有三个分库；单表查询如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">order</span>` <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span> LIMIT <span class="number">1000</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>



<p><strong>第一步：</strong></p>
<p>改写查询，各分库按理想情况下数据分布进行查询，即</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">order</span>` <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span> LIMIT <span class="number">333</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>返回结果</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
</tr>
</thead>
<tbody><tr>
<td align="center">523</td>
<td align="center">423</td>
<td align="center">500</td>
</tr>
<tr>
<td align="center">423</td>
<td align="center">421</td>
<td align="center">400</td>
</tr>
<tr>
<td align="center">323</td>
<td align="center">400</td>
<td align="center">300</td>
</tr>
<tr>
<td align="center">223</td>
<td align="center">320</td>
<td align="center">200</td>
</tr>
<tr>
<td align="center">123</td>
<td align="center">320</td>
<td align="center">100</td>
</tr>
</tbody></table>
<p><strong>第二步：</strong></p>
<p>结果集排序后，找到排序字段第一位的值，<code>createdTime DESC</code>，即创建时间的最大值</p>
<p>可以得到是分库 A 返回的 523</p>
<p><strong>第三步：</strong></p>
<p>扩大查询范围，查询条件使用 <code>between</code> 语句，最大值为全局最大值（523），最小值为该分库返回结果集的最大值（B-423，C-500）</p>
<p>因为最大值在分库 A 结果集中，所以 A 是不需要二次请求的（523 和 123 数据中必然还是上一次的结果集）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `order_B` <span class="keyword">WHERE</span> `createdTime` <span class="keyword">BETWEEN</span> <span class="number">523</span> <span class="keyword">AND</span> <span class="number">423</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `order_C` <span class="keyword">WHERE</span> `createdTime` <span class="keyword">BETWEEN</span> <span class="number">523</span> <span class="keyword">AND</span> <span class="number">500</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>B、C 可能会返回更多的数据，结果集更新为</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">520</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">499</td>
<td align="center">510</td>
</tr>
<tr>
<td align="center">523</td>
<td align="center">423</td>
<td align="center">500</td>
</tr>
<tr>
<td align="center">423</td>
<td align="center">421</td>
<td align="center">400</td>
</tr>
<tr>
<td align="center">323</td>
<td align="center">400</td>
<td align="center">300</td>
</tr>
<tr>
<td align="center">223</td>
<td align="center">320</td>
<td align="center">200</td>
</tr>
<tr>
<td align="center">123</td>
<td align="center">320</td>
<td align="center">100</td>
</tr>
</tbody></table>
<p><strong>第四步：</strong></p>
<p>推断全局视野</p>
<p>在分库 A 中，523 是第 333 条数据</p>
<p>在分库 B 中，加上新返回的 1 条数据，523 是第 333 - 1 - 1 &#x3D; 331 条数据</p>
<p>在分库 C 中，加上新返回的 2 条数据，523 是第 333 - 2 -1 &#x3D; 330 条数据</p>
<p>此时得到整个结果集中的最大值 523 在全局的 offset 应该是 333 + 331 + 330 &#x3D; 994</p>
<p><strong>第五步：</strong></p>
<p>已经有了 523 这个数据的全局视野，offset 994</p>
<p>又有了结果集 18 条数据</p>
<p>那么排序后就可以在结果集中找到 offset 1000 limit 5 的数据集了</p>
<p><strong>优点：</strong></p>
<ul>
<li>既能精准获取结果，又能避免深度分页</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>逻辑复杂</p>
</li>
<li><p>需要多次查询</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th align="center">方式</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">全局视野</td>
<td align="center">精确</td>
<td align="center">性能问题</td>
</tr>
<tr>
<td align="center">禁止跳页</td>
<td align="center">避免深度分页</td>
<td align="center">业务妥协</td>
</tr>
<tr>
<td align="center">允许精度损失</td>
<td align="center">避免深度分页</td>
<td align="center">业务妥协</td>
</tr>
<tr>
<td align="center">二次查询</td>
<td align="center">精确 + 避免深度分页</td>
<td align="center">多次查询</td>
</tr>
</tbody></table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/91d03b16af77">Elasticsearch 5.x 源码分析（3）from size, scroll 和 search after - 简书 (jianshu.com)</a></p>
<p><a href="https://developer.aliyun.com/article/713865">业界难题-“跨库分页”的四种方案-阿里云开发者社区 (aliyun.com)</a>	</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>ES</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>ES 碎片</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ 最佳实践</title>
    <url>/2022/12/04/%E5%AD%A6%E4%B9%A0/MQ/RocketMQ%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="Topic-与-Tag"><a href="#Topic-与-Tag" class="headerlink" title="Topic 与 Tag"></a>Topic 与 Tag</h1><p>在 RocketMQ 中，Topic 和 Tag 都是业务上用来归类的标识，通过合理的使用 Topic 和 Tag 可以让业务结构清晰，更可以提高效率</p>
<p><strong>Topic</strong> 是消息主题，通过 Topic 对不同的业务消息进行分类<br><strong>Tag</strong>  是消息标签，用来进一步区分某个 Topic 下的消息分类，是消息生产时即由消息生产者设置的属性  </p>
<p>Topic 和 Tag 的选择，建议从以下几个方面判断：</p>
<ul>
<li><strong>消息类型是否一致：</strong>普通消息、事务消息、延迟消息、顺序消息；不同消息使用不同的 Topic，无法通过 Tag 进行区分</li>
<li><strong>业务是否相关联：</strong>没有关联的业务应该使用不同的 Topic</li>
<li><strong>消息优先级是否一致：</strong>同一个 Topic 内应该是同样优先级的消息</li>
<li><strong>量级是否相当：</strong>业务量小但实时性高的消息和业务量大的消息放在一个 Topic 内，可能会导致饥饿</li>
</ul>
<p>以电商系统为例，订单消息和支付消息属于不同的业务，设置 TOPIC_ORDER 和 TOPIC_PAY<br>其中订单消息根据商品种类再划分为不同的 tag，例如电器类、服装类、图书类等<br>支付消息根据不同的支付渠道划分，例如银行卡、支付宝、微信支付等</p>
<h1 id="消费幂等"><a href="#消费幂等" class="headerlink" title="消费幂等"></a>消费幂等</h1><p>为了防止消息重复消费导致业务处理异常，RocketMQ 消费者在接收消息后，有必要根据业务上的唯一 Key 对消息进行幂等处理</p>
<p>个人认为需要注意的是，这个业务上的唯一 Key，无论是在 Consumer 层做去重实现业务幂等（去重表），还是业务逻辑上做幂等（状态机、版本校验），都应该是使用业务意义上的唯一标识，而不是依赖 Message ID</p>
<p><strong>消息重复的场景</strong></p>
<ul>
<li><strong>Producer 端：</strong>发送消息时，Brocker 已经收到消息并持久化，但 ACK 由于网络原因未成功返回给生产者，为了保证消息不丢失，生产者会再一次发送消息；或者上游业务认为失败重新进行了调用，就可能会发送重复的消息，并且是不同的 Message ID</li>
<li><strong>Brocker 端：</strong>投递消息给消费者，消费者的 offset 因为网络等原因提交失败，为了保证消息至少一次，Brocker 会再次投递消息</li>
<li><strong>Consumer 端：</strong>服务扩缩容导致的 rebalance 操作，本质上也是消费者的 offset 没有及时提交</li>
</ul>
<p>因为不同的 Message ID 对应的消息内容可能相同，有可能出现冲突（重复）的情况，所以真正安全的幂等处理，不建议以 Message ID 作为处理依据</p>
<p>最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息 Key 设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.subscribe(<span class="string">&quot;ons_test&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> message.getKey()</span><br><span class="line">        <span class="comment">// 根据业务唯一标识的 Key 做幂等处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h1 id="订阅关系"><a href="#订阅关系" class="headerlink" title="订阅关系"></a>订阅关系</h1><p>订阅关系需要保持一致，一致的定义是：<strong>同一个消费者组下所有 Consumer 实例所订阅的 Topic、Tag、Tag 的顺序必须完全一致</strong></p>
<p>如果订阅关系不一致，消息消费的逻辑就会混乱，甚至导致消息丢失</p>
<p><strong>为什么会丢失？</strong></p>
<p>当一个 Consumer 消费一个 Queue 时，会在 ConsumerQueue 中保存该消费者和消息的相关信息</p>
<p>ConsumerQueue 中保存了如下信息：</p>
<ul>
<li>前 8 个字节记录消息在 CommitLog 中的偏移量</li>
<li>中间 4 个字节记录消息大小</li>
<li>最后 8 个字节记录消息中 tag 的 hashcode</li>
</ul>
<p>假如一个 Consumer 订阅了 Topic1 中的 Tag1，那这个 Consumer 拉取消息时，首先从 Name Server 获取订阅关系，得到当前 Consumer 订阅的所有 tag 的 hashcode 集合 codeSet；每次从 ConsumerQueue 获取一条记录，就要判断最后 8 个字节 tag hashcode 是否在 codeSet 中，比如 Tag2 不在 codeSet 中，就会被过滤掉</p>
<p>所以不正确的订阅关系会导致该 ConsumerQueue 中的消息被错误丢弃了</p>
<h1 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h1><p>当客户端消费速度跟不上服务端消息发送的速度，便会出现消息堆积</p>
<p>消息堆积的主要影响：</p>
<ul>
<li>消费延迟</li>
<li>生产者无法成功发送消息（无法生产）</li>
</ul>
<p>以下场景需要着重关注消息堆积和延迟问题：</p>
<ul>
<li>业务系统上下游能力不匹配造成的持续堆积，且无法自行恢复</li>
<li>业务系统对消息的消费实时性要求较高，即使是短暂的堆积造成的消息延迟也无法接受</li>
</ul>
<p>客户端 Push 模式到消费消息有两个阶段：</p>
<ul>
<li><strong>获取消息：</strong>通过长轮询批量拉取的方式从 Brocker 拉取消息，这一阶段吞吐量较高，所以一般不会成为性能瓶颈</li>
<li><strong>消费 &amp; 提交：</strong>依赖业务的处理耗时和消费逻辑的并发度</li>
</ul>
<p>所以通过消息消费的两大步骤来看，消息堆积的主要问题出现在第二阶段，即<strong>消费耗时</strong>和<strong>消费并发度</strong>    </p>
<p><strong>消费耗时</strong></p>
<p>影响消费耗时的消费逻辑主要分为 CPU 内存计算和外部 IO 操作；由于大部分服务器场景都是 IO 密集型，业务代码在正常情况下不会涉及复杂的运算，内部耗时相比 IO 耗时来说可以忽略不记</p>
<p>IO 操作通常包含以下逻辑：</p>
<ul>
<li>读写外部数据库，例如 MySQL</li>
<li>读写外部缓存系统，例如 Redis</li>
<li>下游系统调用，例如 Dubbo 调用或者下游 HTTP 接口调用</li>
</ul>
<p><strong>消费并发度</strong></p>
<p>不同的消息类型对应不同的并发度配置策略</p>
<table>
<thead>
<tr>
<th>消息类型</th>
<th>并发度</th>
</tr>
</thead>
<tbody><tr>
<td>普通消息</td>
<td>单节点线程数 × 节点数量</td>
</tr>
<tr>
<td>定时和延时消息</td>
<td>单节点线程数 × 节点数量</td>
</tr>
<tr>
<td>事务消息</td>
<td>单节点线程数 × 节点数量</td>
</tr>
<tr>
<td>顺序消息</td>
<td>Min（单节点线程数 × 节点数量，分区数）</td>
</tr>
</tbody></table>
<p>此外单节点的并发度需要谨慎设置，不能盲目直接调大线程数，设置过大的线程数反而会带来大量的线程切换的开销</p>
<p>理想环境下单节点的最优线程数计算模型如下：</p>
<ul>
<li>单机 CPU 核数为 C</li>
<li>线程切换耗时忽略不计，IO 操作不消耗 CPU</li>
<li>线程有足够消息等待处理，且内存充足</li>
<li>逻辑中 CPU 计算耗时为 T1，外部 IO 操作为 T2</li>
</ul>
<p>则单个线程能达到的 TPS 为 <code>1 / (T1 + T2)</code>，如果CPU使用率达到理想状态 100%，那么单机达到最大能力时需要设置 <code>C × (T1 + T2) / T1</code> 个线程</p>
<h1 id="读写队列"><a href="#读写队列" class="headerlink" title="读写队列"></a>读写队列</h1><p>新建 Topic 需要配置相关的属性 <code>writeQueueNums</code> 和 <code>readQueueNums</code>，分别代表写队列的数量和读队列的数量</p>
<p>其中 <code>writeQueueNums</code> 和 <code>readQueueNums</code> 的参数可以自由配置，<strong>为什么可以自由配置呢而不是必须相等呢？</strong></p>
<blockquote>
<p><strong>备注</strong>：读写队列和读写分离不是同一个概念</p>
<p>读写分离指的是主节点和从节点关于读写请求分配的问题</p>
<p>读写队列在做路由信息时使用，在消息发送时，使用写队列个数返回路由信息，而消息消费时按照读队列个数返回路由信息，在物理文件层面，只有写队列才会创建文件</p>
</blockquote>
<p><strong>读写队列数量不匹配时会发生什么</strong></p>
<ul>
<li>写多读少：多出来的写队列无法被消费</li>
<li>读多写少：Consumer 对应的多出来的读队列没有消息，也就不会从该读队列消费任何消息</li>
</ul>
<p><strong>为什么要这么设计</strong></p>
<p>设置读写队列数的目的在于方便队列的缩容和扩容</p>
<p>一个 Topic 在每个 Brocker 上创建了 128 个队列，现在需要将队列缩容到 64 个，怎么做才能 100% 不会丢失消息，并且无需重启应用程序</p>
<p>解决办法：</p>
<ol>
<li>先将写队列缩容（128 调整为 64）；后续数据请求会进入 0 至 63 的写队列中，由之前的 Consumer 进行消费</li>
<li>等待 64 至 127 队列中的消息被消费完成</li>
<li>缩容读队列（128 调整为 64）；此时 Consumer 重新分配，对应 64 个写队列</li>
</ol>
<p><strong>同时缩容写队列和读队列可能会导致部分消息未被消费</strong></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://help.aliyun.com/document_detail/69109.html">最佳实践 (aliyun.com)</a></p>
<p><a href="https://www.cnblogs.com/liaowenhui/p/15717353.html">RocketMQ订阅关系不一致 - JustJavaIt - 博客园 (cnblogs.com)</a></p>
<p><a href="https://blog.csdn.net/qian_348840260/article/details/108975241">rocketmq中的读写队列_八荒六合唯我独尊-CSDN博客_rocketmq读写队列</a></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>MQ</category>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式 - bridge</title>
    <url>/2022/12/25/%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%88bridge%EF%BC%89/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>桥接（bridge）模式首先的场景是内部实现逻辑分为多个模块，每个模块又可能对应多种实现</p>
<p>在桥接内部，这些不同类型的模块按照组合或聚合的方式组织在一起，将逻辑模块抽象部分与实现部分相分离</p>
<p><strong>目的</strong><br>降低内部多种类型逻辑模块的耦合，扩展变成以各模块为单位，更为灵活</p>
<p><strong>现实世界类比</strong><br><a href="https://vans.com.cn/customs.html">Vans自由定制鞋_Vans(范斯)中国官方网站</a></p>
<p>球鞋定制，从选择款式开始，对不同的部位（鞋头、鞋腰、侧边条纹、鞋带等）选择不同的设计（颜色、图案、材质等），最终产出最终产品（桥接模式的最终成品可以认为是组合了多个模块逻辑的执行器）</p>
<p>针对不同部位选择不同的设计，而不是平铺出笛卡尔积式的配置表，就是桥接模式希望实现的解耦的目的</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>模拟一个场景，比如服务内希望实现一个消息通知功能</p>
<p>消息分为多种记录方式：缓存、数据库</p>
<p>通知的方式也分为多种方式：邮件、微信</p>
<p>服务内定义什么级别的消息通过什么方式进行通知</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果将所需要的发送方式进行实现，需要实现 4 种执行器（2 × 2），哪怕是服务中可以进行选择，也需要全部进行实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheEmailNotifier</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;缓存数据&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送电子邮件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheWeChatNotifier</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;缓存数据&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送微信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>如果后续有调整，增加了新的记录方式或者通知方式，那么需要需要创建的类就更多了，并且可能还存在相同的逻辑被实现了多份不便于维护</p>
<p>问题出现的原因是因为将记录方式和通知方式这两种互不关联的模块<strong>在实现中耦合在一起</strong></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="通知方式"><a href="#通知方式" class="headerlink" title="通知方式"></a>通知方式</h3><p><strong>定义接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String msg)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>进行实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 电子邮件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailSender</span> <span class="keyword">implements</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="keyword">final</span> String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送电子邮件:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeChatSender</span> <span class="keyword">implements</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="keyword">final</span> String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送微信:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="记录方式"><a href="#记录方式" class="headerlink" title="记录方式"></a>记录方式</h3><p><strong>定义接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Recorder</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>进行实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheRecorder</span> <span class="keyword">implements</span> <span class="title class_">Recorder</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(<span class="keyword">final</span> String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;记录到缓存:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DbRecorder</span> <span class="keyword">implements</span> <span class="title class_">Recorder</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(<span class="keyword">final</span> String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;记录到数据库:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="组织者"><a href="#组织者" class="headerlink" title="组织者"></a>组织者</h3><p><strong>抽象组织者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractNotifier</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Recorder recorder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Sender sender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractNotifier</span><span class="params">(<span class="keyword">final</span> Recorder recorder, <span class="keyword">final</span> Sender sender)</span> &#123;</span><br><span class="line">        Assert.notNull(recorder);</span><br><span class="line">        Assert.notNull(sender);</span><br><span class="line">        <span class="built_in">this</span>.recorder = recorder;</span><br><span class="line">        <span class="built_in">this</span>.sender = sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        recorder.record(msg);</span><br><span class="line">        sender.send(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>继承构造模块的实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomNotifier</span> <span class="keyword">extends</span> <span class="title class_">AbstractNotifier</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomNotifier</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">DbRecorder</span>(), <span class="keyword">new</span> <span class="title class_">EmailSender</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="业务扩展"><a href="#业务扩展" class="headerlink" title="业务扩展"></a>业务扩展</h3><p>需要增加新的发送方式，比如短信</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShortMessageSender</span> <span class="keyword">implements</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="keyword">final</span> String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送短信:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>需要进行新的 notifier 的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlusNotifier</span> <span class="keyword">extends</span> <span class="title class_">AbstractNotifier</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PlusNotifier</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">CacheRecorder</span>(), <span class="keyword">new</span> <span class="title class_">ShortMessageSender</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>JDBC 驱动为所有的关系型数据库提供一个通用的标准，这就是一个桥接模式的典型应用</p>
<h3 id="进行连接"><a href="#进行连接" class="headerlink" title="进行连接"></a>进行连接</h3><p>先回顾一下 JDBC 的使用，使用 JDBC 连接 MySQL 数据库主要分为这样几步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.加载 MySQL 驱动注入到 DriverManager</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.提供 JDBC 连接的 URL、用户名和密码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test_db?&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建数据库的连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.创建 statement 实例</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.执行 SQL 语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">query</span> <span class="operator">=</span> <span class="string">&quot;select * from test&quot;</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(query);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.关闭连接对象</span></span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>



<h3 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h3><p><code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</code> 获取了 Driver 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注册驱动</span></span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用 <code>DriverManager</code> 静态方法 <code>registerDriver()</code> 方法来将 MySQL 驱动注册到 <code>DriverManager</code></p>
<h3 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h3><p><code>registerDriver()</code> 方法具体如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">registerDriver</span><span class="params">(java.sql.Driver driver)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">	<span class="comment">// 直接调用下面的同名静态方法</span></span><br><span class="line">    registerDriver(driver, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">registerDriver</span><span class="params">(java.sql.Driver driver,DriverAction da)</span><span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">// registeredDrivers 是一个 list,用 DriverInfo 实例封装 Driver</span></span><br><span class="line">    <span class="keyword">if</span>(driver != <span class="literal">null</span>) &#123;</span><br><span class="line">        registeredDrivers.addIfAbsent(<span class="keyword">new</span> <span class="title class_">DriverInfo</span>(driver, da));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This is for compatibility with the original DriverManager</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;registerDriver: &quot;</span> + driver);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>registeredDrivers</code> 静态变量是一个 list</p>
<p>泛型 <code>DriverInfo</code> 是驱动信息的包装类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DriverManager</span> &#123;</span><br><span class="line">    <span class="comment">// List of registered JDBC drivers</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="DriverInfo"><a href="#DriverInfo" class="headerlink" title="DriverInfo"></a>DriverInfo</h3><p><code>DriverInfo</code> 类中封装了 <code>java.sql.Driver</code> 接口，类似 Driver 信息管理者的角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DriverInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Driver driver;</span><br><span class="line">    DriverAction da;</span><br><span class="line">    DriverInfo(Driver driver, DriverAction action) &#123;</span><br><span class="line">        <span class="built_in">this</span>.driver = driver;</span><br><span class="line">        da = action;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p>接下来进行连接的获取，<code>Connection connection = DriverManager.getConnection(url, username, password);</code></p>
<p><code>Connection</code> 接口是和特定数据库的连接会话，<strong>不同的数据库的连接会话都不相同</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Connection</span>  <span class="keyword">extends</span> <span class="title class_">Wrapper</span>, AutoCloseable &#123;</span><br><span class="line"></span><br><span class="line">    Statement <span class="title function_">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>DriverManager</code> 中的 <code>getConnection</code> 方法，从 <code>registeredDrivers</code> 进行选择对应数据库驱动下的连接实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">(String url,String user, String password)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    java.util.<span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Properties();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">        info.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="literal">null</span>) &#123;</span><br><span class="line">        info.put(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实际上调用的是下面的静态方法 getConnection</span></span><br><span class="line"><span class="comment">//  Worker method called by the public getConnection() methods.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">(</span></span><br><span class="line"><span class="params">    String url, java.util.Properties info, Class&lt;?&gt; caller)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * When callerCl is null, we should check the application&#x27;s</span></span><br><span class="line"><span class="comment">         * (which is invoking this class indirectly)</span></span><br><span class="line"><span class="comment">         * classloader, so that the JDBC driver class outside rt.jar</span></span><br><span class="line"><span class="comment">         * can be loaded from here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">callerCL</span> <span class="operator">=</span> caller != <span class="literal">null</span> ? caller.getClassLoader() : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(DriverManager.class) &#123;</span><br><span class="line">        <span class="comment">// synchronize loading of the correct classloader.</span></span><br><span class="line">        <span class="keyword">if</span> (callerCL == <span class="literal">null</span>) &#123;</span><br><span class="line">            callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(url == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;The url cannot be null&quot;</span>, <span class="string">&quot;08001&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;DriverManager.getConnection(\&quot;&quot;</span> + url + <span class="string">&quot;\&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Walk through the loaded registeredDrivers attempting to make a connection.</span></span><br><span class="line">    <span class="comment">// Remember the first exception that gets raised so we can reraise it.</span></span><br><span class="line">    <span class="type">SQLException</span> <span class="variable">reason</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">        <span class="comment">// If the caller does not have permission to load the driver then</span></span><br><span class="line">        <span class="comment">// skip it.</span></span><br><span class="line">        <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;    trying &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> aDriver.driver.connect(url, info);</span><br><span class="line">                <span class="keyword">if</span> (con != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Success!</span></span><br><span class="line">                    println(<span class="string">&quot;getConnection returning &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                    <span class="keyword">return</span> (con);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (reason == <span class="literal">null</span>) &#123;</span><br><span class="line">                    reason = ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;    skipping: &quot;</span> + aDriver.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we got here nobody could connect.</span></span><br><span class="line">    <span class="keyword">if</span> (reason != <span class="literal">null</span>)    &#123;</span><br><span class="line">        println(<span class="string">&quot;getConnection failed: &quot;</span> + reason);</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;getConnection: no suitable driver found for &quot;</span>+ url);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;No suitable driver found for &quot;</span>+ url, <span class="string">&quot;08001&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Connection-实现"><a href="#Connection-实现" class="headerlink" title="Connection 实现"></a>Connection 实现</h3><p>在 <code>Connection</code> 接口的具体实现部分，MySQL 的连接是通过两层实现完成抽象部分的实现</p>
<p>不同的数据库会进行不同的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionImpl</span> <span class="keyword">implements</span> <span class="title class_">JdbcConnection</span>, SessionEventListener, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">4009476458425101761L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SQLPermission</span> <span class="variable">SET_NETWORK_TIMEOUT_PERM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SQLPermission</span>(<span class="string">&quot;setNetworkTimeout&quot;</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JdbcConnection</span> <span class="keyword">extends</span> <span class="title class_">Connection</span>, MysqlConnection, TransactionEventHandler &#123;</span><br><span class="line">    JdbcPropertySet <span class="title function_">getPropertySet</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">changeUser</span><span class="params">(String var1, String var2)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>DriverManager</code> 作为组织者，组织了 <code>Driver</code>（由管理者 <code>DriverInfo</code> 进行管理）和 <code>Connection</code> 两类模块</p>
<p>根据使用的数据库不同灵活地进行连接的选择</p>
<p>对应的类图：</p>
<img src="/2022/12/25/%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%88bridge%EF%BC%89/jdbc%E7%B1%BB%E5%9B%BE.drawio.png" class="" title="jdbc类图.drawio">

<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>当存在一段逻辑中分为多类模块时，可以考虑将各模块分别实现再进行组织降低耦合</p>
<ul>
<li><p>优点</p>
<ul>
<li>可以将庞大的类拆分成更有层次的结构，层次之间不存在耦合</li>
<li>便于模块实现的扩展（开闭）</li>
<li>切换不同的实现更加方便</li>
<li>每个模块又可以定义出抽象部分和实现部分（单一职责）</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>在已存在的功能上进行改造工程量较大（不同于适配器模式）</li>
<li>高内聚的类进行桥接设计会使代码更加复杂</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://refactoringguru.cn/design-patterns/bridge">桥接设计模式 (refactoringguru.cn)</a></p>
<p><a href="https://blog.csdn.net/MY9526/article/details/108738263">桥接模式的实际使用_最后一个NPE的博客-CSDN博客_桥接模式实战</a></p>
<p><a href="https://www.cnblogs.com/EthanWong/p/16079803.html">设计模式学习笔记（九）桥接模式及其应用 - 归斯君 - 博客园 (cnblogs.com)</a></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>管道模式 - pipeline</title>
    <url>/2022/12/05/%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%A1%E9%81%93%E6%A8%A1%E5%BC%8F%20-%20pipeline/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>管道模式（Pipeline Pattern）是责任链模式（Chain of Command Pattern）的变体；区别在于责任链是将处理器按照链条组织起来，待处理的上下文按照链条找到能够处理自己的处理器，一般只有唯一的一个处理器；而管道模式是链条中的每一个处理器都需要对上下文进行处理</p>
<p><strong>目的</strong><br>降低业务逻辑流程的耦合性，将整个过程中所有的处理器隔离开，更方便扩展流程上新的业务逻辑</p>
<p><strong>现实世界类比</strong><br>工厂的生产流水线，车架 -&gt; 发送机 -&gt; 外壳 -&gt; 内饰 -&gt; 总装 -&gt; 质检，整辆车在传送带又一个环节运输至另一个环节，每个处理环节都对汽车处理自己的部分，最终产出成品</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>模拟一个场景，比如订单服务内查询接口把最终订单实体组装为一个 VO</p>
<p>除了原有的实体属性，比如内部数据需要对优惠金额进行计算，外部数据需要补充用户信息、商品信息等</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果将所有步骤抽为方法，则代码一般会实现为这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> OrderInfoVo <span class="title function_">buildVO</span><span class="params">(OrderBo bo)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">OrderInfoVo</span> <span class="variable">vo</span> <span class="operator">=</span> <span class="built_in">this</span>.wrapVo(bo);</span><br><span class="line">    <span class="built_in">this</span>.calMitigateSum(vo);</span><br><span class="line">    <span class="built_in">this</span>.buildUserInfo(vo);</span><br><span class="line">    <span class="built_in">this</span>.buildCommodityInfo(vo);</span><br><span class="line">    <span class="keyword">return</span> vo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面如果对 VO 的字段有了新的要求，比如增加物流信息；或者对生成 VO 的流程有了新的要求，比如根据查询条件进行缓存，就会有以下坏处：</p>
<ul>
<li>在 <code>buildVO</code> 中实现缓存逻辑，违反了方法的单一职责，维护在外面可能又需要维护一个统一的入口</li>
<li>将来每加入一个新的处理步骤或者删除某个步骤，都要修改 <code>buildVO</code> 方法</li>
</ul>
<p>这种情况下可以使用管道模式解决以上缺点</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>上下文维护着整个业务链条中间的结果和最终的结果数据</p>
<p><strong>管道上下文父类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传递到管道的上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理开始时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime startTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理结束时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime endTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体的业务数据上下文</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderVOContext</span> <span class="keyword">extends</span> <span class="title class_">PipelineContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单业务模型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> OrderBO bo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单 VO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> OrderVO vo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模型创建出错时的错误信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String errorMsg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他参数</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;build OrderVO&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p><strong>处理器父类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 管道中的上下文处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ContextHandler</span>&lt;T <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理输入的上下文数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 处理时的上下文数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 true 则表示由下一个 ContextHandler 继续处理，返回 false 则表示处理结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">(T context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>计算优惠金额</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@sl4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalMitigateSumHandler</span> <span class="keyword">implements</span> <span class="title class_">ContextHandler</span>&lt;OrderVOContext&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">(InstanceBuildContext context)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;--计算优惠金额--&quot;</span>);</span><br><span class="line">        <span class="comment">// 计算流程</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">mitigateSum</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        context.getVo().setMitigateSum(mitigateSum);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>构造用户信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@sl4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">buildUserInfoHandler</span> <span class="keyword">implements</span> <span class="title class_">ContextHandler</span>&lt;OrderVOContext&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">(InstanceBuildContext context)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;--构造用户信息--&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userClient.getUserById(context.getBo().getUserId());</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">            context.setErrorMsg(<span class="string">&quot;查询用户信息为空，id=&quot;</span> + context.getBo().getUserId());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        context.getVo().setUserName(user.getName());</span><br><span class="line">        context.getVo().setUserAge(user.getAge());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>构造商品信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@sl4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">buildGoodsInfoHandler</span> <span class="keyword">implements</span> <span class="title class_">ContextHandler</span>&lt;OrderVOContext&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">(InstanceBuildContext context)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;--构造商品信息--&quot;</span>);</span><br><span class="line">        <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> goodsClient.getGoodsBySku(context.getBo().getGoodsSku());</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(goods)) &#123;</span><br><span class="line">            context.setErrorMsg(<span class="string">&quot;查询商品信息为空，id=&quot;</span> + context.getBo().getGoodsSku());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        context.getVo().setGoodsSku(goods.getSku());</span><br><span class="line">        context.getVo().setGoodsName(goods.getName());</span><br><span class="line">		context.getVo().setGoodsPrice(goods.getPrice());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="组织处理器"><a href="#组织处理器" class="headerlink" title="组织处理器"></a>组织处理器</h3><p>现在业务 Context 和 Handler 都定义好了，那么使用什么方式将 Handler 组织起来呢？有如下几种：</p>
<ul>
<li>Handler 对象持有下一个 Handler 的信息，比如使用 <code>nextHandler</code> 属性来保存下一个处理器；缺点是无法直观了解整个业务链条都有哪些处理器，并且增删处理器需要修改其他处理器的属性</li>
<li>自定义注解将顺序信息和 Handler 的实现绑定；这样也无法直观了解到一段业务都有多少个处理器</li>
<li>维护一个路由表，基于 Spring 的自动注入来实现和管理路由表，使用一个执行器角色只有处理器集合作为入口</li>
</ul>
<p><strong>构造路由表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 管道路由的配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineRouteConfig</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据类型-&gt;管道中处理器类型列表 的路由</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span></span><br><span class="line">    Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;,</span><br><span class="line">        List&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">ContextHandler</span>&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;&gt;&gt;&gt; PIPELINE_ROUTE_MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在这里配置各种上下文类型对应的处理管道：键为上下文类型，值为处理器类型的列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        PIPELINE_ROUTE_MAP.put(OrderVOContext.class,</span><br><span class="line">                               Arrays.asList(</span><br><span class="line">                                       CalMitigateSumHandler.class,</span><br><span class="line">                                       buildUserInfoHandler.class,</span><br><span class="line">                                       buildGoodsInfoHandler.class</span><br><span class="line">                               ));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将来其他 Context 的管道配置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 Spring 启动时，根据路由表生成对应的管道映射关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;pipelineRouteMap&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;, List&lt;? <span class="keyword">extends</span> <span class="title class_">ContextHandler</span>&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;&gt;&gt; getHandlerPipelineMap() &#123;</span><br><span class="line">        <span class="keyword">return</span> PIPELINE_ROUTE_MAP.entrySet()</span><br><span class="line">                                 .stream()</span><br><span class="line">                                 .collect(Collectors.toMap(Map.Entry::getKey, <span class="built_in">this</span>::toPipeline));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据给定的管道中 ContextHandler 的类型的列表，构建管道</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;? <span class="keyword">extends</span> <span class="title class_">ContextHandler</span>&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;&gt; toPipeline(</span><br><span class="line">            Map.Entry&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;, List&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">ContextHandler</span>&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;&gt;&gt;&gt; entry) &#123;</span><br><span class="line">        <span class="keyword">return</span> entry.getValue()</span><br><span class="line">                    .stream()</span><br><span class="line">                    .map(appContext::getBean)</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext appContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        appContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>管道执行器</strong></p>
<p>管道执行器根据传入的上下文数据的类型，找到其对应的管道，然后将上下文数据放入管道中去进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 管道执行器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用 PipelineRouteConfig 中的 pipelineRouteMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;,</span><br><span class="line">                List&lt;? <span class="keyword">extends</span> <span class="title class_">ContextHandler</span>&lt;? <span class="built_in">super</span> PipelineContext&gt;&gt;&gt; pipelineRouteMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步处理输入的上下文数据</span></span><br><span class="line"><span class="comment">     * 如果处理时上下文数据流通到最后一个处理器且最后一个处理器返回 true，则返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 输入的上下文数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 处理过程中管道是否畅通，畅通返回 true，不畅通返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acceptSync</span><span class="params">(PipelineContext context)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(context, <span class="string">&quot;上下文数据不能为 null&quot;</span>);</span><br><span class="line">        <span class="comment">// 拿到数据类型</span></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt; dataType = context.getClass();</span><br><span class="line">        <span class="comment">// 获取数据处理管道</span></span><br><span class="line">        List&lt;? <span class="keyword">extends</span> <span class="title class_">ContextHandler</span>&lt;? <span class="built_in">super</span> PipelineContext&gt;&gt; pipeline = pipelineRouteMap.get(dataType);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(pipeline)) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;&#123;&#125; 的管道为空&quot;</span>, dataType.getSimpleName());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 管道是否畅通</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">lastSuccess</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ContextHandler&lt;? <span class="built_in">super</span> PipelineContext&gt; handler : pipeline) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 当前处理器处理数据，并返回是否继续向下处理</span></span><br><span class="line">                lastSuccess = handler.handle(context);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                lastSuccess = <span class="literal">false</span>;</span><br><span class="line">                logger.error(<span class="string">&quot;[&#123;&#125;] 处理异常，handler=&#123;&#125;&quot;</span>, context.getName(), handler.getClass().getSimpleName(), ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不再向下处理</span></span><br><span class="line">            <span class="keyword">if</span> (!lastSuccess) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lastSuccess;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用管道"><a href="#使用管道" class="headerlink" title="使用管道"></a>使用管道</h3><p>原来的 <code>buildVO</code> 可以引入管道来进行实现了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> OrderInfoVo <span class="title function_">buildVO</span><span class="params">(OrderBo bo)</span> &#123;</span><br><span class="line">    <span class="type">OrderVOContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.createContext(bo);</span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> pipelineExecutor.acceptSync(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流程成功</span></span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        <span class="keyword">return</span> CommonResponse.success(data.getInstanceId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logger.error(<span class="string">&quot;build vo 失败：&#123;&#125;&quot;</span>, data.getErrorMsg());</span><br><span class="line">    <span class="keyword">return</span> CommonResponse.failed(data.getErrorMsg());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="增加处理器"><a href="#增加处理器" class="headerlink" title="增加处理器"></a>增加处理器</h3><p>如果需要在流程中增加新业务</p>
<p><strong>创建新的处理器实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@sl4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">newTaskHandler</span> <span class="keyword">implements</span> <span class="title class_">ContextHandler</span>&lt;OrderVOContext&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">(InstanceBuildContext context)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;--执行新业务--&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修改手动维护的静态路由表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    PIPELINE_ROUTE_MAP.put(OrderVOContext.class,</span><br><span class="line">                           Arrays.asList(</span><br><span class="line">                               CalMitigateSumHandler.class,</span><br><span class="line">                               buildUserInfoHandler.class,</span><br><span class="line">                               newTaskHandler.class, <span class="comment">// 流程中增加了新逻辑</span></span><br><span class="line">                               buildGoodsInfoHandler.class</span><br><span class="line">                           ));</span><br></pre></td></tr></table></figure>



<h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>对于步骤繁多的任务，很多时候我们更需要的是异步处理，比如某些耗时长的定时任务，管道处理异步化非常的简单</p>
<p>在 PipelineExecutor 中引入异步的处理方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 管道线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> ThreadPoolTaskExecutor pipelineThreadPool; <span class="comment">// 处理异步的线程池</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步处理输入的上下文数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context  上下文数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callback 处理完成的回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acceptAsync</span><span class="params">(PipelineContext context, BiConsumer&lt;PipelineContext, Boolean&gt; callback)</span> &#123;</span><br><span class="line">    pipelineThreadPool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> acceptSync(context);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="literal">null</span>) &#123;</span><br><span class="line">            callback.accept(context, success);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过管道模式，可以大幅降低了系统的耦合度和提升了内聚程度与扩展性：</p>
<ul>
<li><p>优点</p>
<ul>
<li><code>buildVO</code> 所在的类只负责处理引导 BO 进入管道的业务流程，而不关注具体业务逻</li>
<li><code>PipelineExecutor </code> 抽象定义，不关心业务细节</li>
<li>每个 <code>ContextHandler </code> 只负责自己的业务，不需要知道链路结构，与其他处理器解耦</li>
<li>对于处理器新增、删除、调整顺序等操作，只需要修改路由表，和业务逻辑脱离</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>大的 Context 对象，让业务数据粒度很粗（上帝对象）</li>
<li>和策略一样，可能造成实现类膨胀</li>
<li>错误信息需要保存在 Context 对象中，走完所有处理器才会将错误返回</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/370363597">设计模式最佳套路2 —— 基于 Spring 实现管道模式的最佳实践 - 知乎 (zhihu.com)</a></p>
<p><a href="https://refactoringguru.cn/design-patterns/chain-of-responsibility">责任链设计模式（职责链模式） (refactoringguru.cn)</a></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>ES 折叠操作</title>
    <url>/2022/12/01/%E5%AD%A6%E4%B9%A0/ES/ES%20%E6%8A%98%E5%8F%A0%E5%92%8C%E8%81%9A%E5%90%88/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="折叠和聚合"><a href="#折叠和聚合" class="headerlink" title="折叠和聚合"></a>折叠和聚合</h2><p>日常会有很多场景希望将平面数据按照一定的条件组合起来，并按照一定规则进行计算</p>
<p>聚合将您的数据汇总为指标、统计或其他分析</p>
<p>可以帮助你回答类似如下问题：</p>
<ul>
<li>我的网页平均加载时间是多少？</li>
<li>根据交易量谁是我最有价值的客户？</li>
<li>在我的网站上大文件的衡量标准是多少？</li>
<li>每个产品类别有多少种产品？</li>
</ul>
<p>在关系型数据库中，聚合以 <code>GROUP BY</code> 关键字和聚合函数的方式进行实现</p>
<p>例如统计每个班级下男生的人数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `classId`,<span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> <span class="string">&#x27;number&#x27;</span> <span class="keyword">FROM</span> `student` <span class="keyword">WHERE</span> `gender` <span class="operator">=</span> &quot;male&quot; <span class="keyword">GROUP</span> <span class="keyword">BY</span> `classId`;</span><br></pre></td></tr></table></figure>

<p>按照班级即 <code>classId</code> 字段进行聚合，使用 <code>COUNT()</code> 聚合函数来统计数量</p>
<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>模拟一个场景来使用 ES 实现需求，设置这样一个索引</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /student-index/_mapping</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;class&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;float&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>模拟数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /student-index/_doc</span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">22</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;male&quot;</span><span class="punctuation">,</span><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">70</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;李四&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">19</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;male&quot;</span><span class="punctuation">,</span><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">72.5</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;王五&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">20</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;male&quot;</span><span class="punctuation">,</span><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span><span class="number">3</span><span class="punctuation">,</span><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">80</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;小明&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">21</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;male&quot;</span><span class="punctuation">,</span><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">75</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;小红&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">19</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;female&quot;</span><span class="punctuation">,</span><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">50</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;小兰&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">18</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;female&quot;</span><span class="punctuation">,</span><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span><span class="number">3</span><span class="punctuation">,</span><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">51</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;蛋蛋&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">20</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;male&quot;</span><span class="punctuation">,</span><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">90</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h1 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h1><p>在 ES 除了聚合 <code>aggregations</code> 外，有一种类似聚合的操作 <code>collapse</code> 折叠</p>
<blockquote>
<p>你可以使用 collapse 参数来基于字段值查询结果；每个折叠仅选择排序靠前的文档来完成折叠</p>
</blockquote>
<p>这里就可以看出折叠和聚合还是有使用上的区别的，聚合更关注的是聚合后的结果，而折叠是在原结果集基础上将字段去重，并且可以像分页一样对折叠结果进行分页</p>
<p>例如这样一组数据</p>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">class</th>
<th align="center">time</th>
</tr>
</thead>
<tbody><tr>
<td align="center">张三</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">李四</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">王五</td>
<td align="center">1</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p>根据 <code>time</code> 倒序，按照 <code>class</code> 进行折叠，<code>size</code> 为 1，返回的结果应该是 <code>class = 1</code> 的数据，因为命中了 <code>name = &quot;王五&quot;</code> 的文档</p>
<p>当 <code>from</code> 为 1 时，返回 <code>class = 2</code>，此时所有折叠后的数据都已经查询完成</p>
<p>折叠更像是对于查询的一种特殊操作，其参数使用也和 <code>query</code> 在同一层级，返回体中也是在 <code>hits</code> 中返回文档</p>
<h2 id="折叠查询"><a href="#折叠查询" class="headerlink" title="折叠查询"></a>折叠查询</h2><p>对于模拟的数据，对 <code>class</code> 字段折叠，班级的顺序按照男生的年龄排序，取第二名</p>
<p>即全校年龄第二大的男性学生所在的班级</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /student-index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;collapse&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;class&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">			<span class="punctuation">&#125;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="comment">// 不查询第一条</span></span><br><span class="line">	<span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>返回的结果，只取 hits 部分</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;student-index&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;k-mmzoQBCTaFCHoW7hai&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小明&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;class&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="number">75</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;class&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="number">2</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="number">21</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>可以看到，<code>_source</code> 结果选取了折叠所命中的第一个文档（折叠的依据）；<code>fields</code> 则是折叠的字段，说明年龄第二大的男生所在的班级是 2 班</p>
<h2 id="扩展结果"><a href="#扩展结果" class="headerlink" title="扩展结果"></a>扩展结果</h2><p>上面折叠的简单操作可以看到，返回的 hits 中包含了一个折叠依据的文档（排序条件的第一个文档）</p>
<p>如果需要返回折叠字段下的所有文档（我认为更像是分组操作），可以使用 <code>inner_hit</code> 参数实现</p>
<p>取全校年龄第二大的男性学生所在的班级下面的所有学生，且按照身高正序排列</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /student-index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;collapse&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;class&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;inner_hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;student_in_class&quot;</span><span class="punctuation">,</span> <span class="comment">// 自定的结果集名字</span></span><br><span class="line">			<span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span> <span class="comment">// inner_hits 内文档数量</span></span><br><span class="line">			<span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// 这个排序参数是 inner hit，内部文档的排序</span></span><br><span class="line">				<span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span></span><br><span class="line">				<span class="punctuation">&#125;</span></span><br><span class="line">			<span class="punctuation">]</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// 这个排序参数是查询条件的排序</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">			<span class="punctuation">&#125;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>返回结果前半部分和折叠查询一样，只取 <code>inner_hit</code> 字段下的结果集</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;inner_hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;student_in_class&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;relation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eq&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;max_score&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;student-index&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kemmzoQBCTaFCHoWyxaJ&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李四&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">19</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;class&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="number">72.5</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="number">72.5</span></span><br><span class="line">                    <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;student-index&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;k-mmzoQBCTaFCHoW7hai&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小明&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;class&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="number">75</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="number">75</span></span><br><span class="line">                    <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到 <code>inner_hits</code> 下是 <code>student_in_class</code> 自定的结果集名称，也就意味着一次 <code>inner_hits</code> 可以设置多个不同规则的结果集请求（<code>inner_hits</code> 参数是个数组）</p>
<p>返回的结果中包含了 2 班下的两名学生，并且根据 <code>height</code> 字段进行了排序</p>
<h2 id="search-after"><a href="#search-after" class="headerlink" title="search after"></a>search after</h2><p>折叠操作同样支持 search after 操作</p>
<p>因为本质上 ES 也是排序后根据文档顺序对折叠字段进行操作，当 search after 字段略过该值后，继续对未折叠字段值进行折叠操作</p>
<p>但是需要注意，<strong>只有当折叠字段和排序字段是同一字段时才能使用该方式，同时不允许二级排序</strong></p>
<p>语法和基本查询一致</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GET /search&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;collapse&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user.id&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;user.id&quot;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;search_after&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;dd5ce1ad&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="二级折叠"><a href="#二级折叠" class="headerlink" title="二级折叠"></a>二级折叠</h2><p>对某一个字段折叠后，<code>inner_hits</code> 内还可以对其他字段再进行一次折叠</p>
<p>但二次折叠无法使用 <code>inner_hits</code> 参数，即折叠只能支持到二级</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;collapse&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;class&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;inner_hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;student_in_class&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;collapse&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;height&quot;</span></span><br><span class="line">			<span class="punctuation">&#125;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">		<span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">			<span class="punctuation">&#125;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>根据 <code>class</code> 折叠后的内部文档，再根据 <code>height</code> 进行折叠操作</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>ES</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>ES 碎片</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象六大原则</title>
    <url>/2022/11/28/%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h1><table>
<thead>
<tr>
<th>设计原则</th>
<th>概述</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>开闭原则</td>
<td>对扩展开放，对修改关闭</td>
<td>易于维护</td>
</tr>
<tr>
<td>单一职责</td>
<td>一个类只干一件事，实现类要单一</td>
<td>提升可读性</td>
</tr>
<tr>
<td>里氏替换</td>
<td>不要重写父类的方法</td>
<td>健壮性、防止错误继承</td>
</tr>
<tr>
<td>迪米特法则</td>
<td>最少知道，对象之间少建立联系</td>
<td>低耦合</td>
</tr>
<tr>
<td>接口隔离</td>
<td>一个接口只干一件事，接口要精简单一</td>
<td>高内聚</td>
</tr>
<tr>
<td>依赖倒置</td>
<td>高层不应该依赖低层，要面向接口编程</td>
<td>利于结构升级</td>
</tr>
</tbody></table>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><blockquote>
<p><em>Software entities like classes,modules and functions should be open for extension but closed for modifications.</em></p>
<p><em>一个软件实体如类，模块和函数应该对扩展开放，对修改关闭</em></p>
</blockquote>
<p>随着业务发展需要增加新的方法，有几种方式：</p>
<ul>
<li><strong>在接口上添加新方法</strong><ul>
<li>导致每一个实现类都需要进行实现，改动量大</li>
<li>不一定所有的实现类都需要该方法</li>
</ul>
</li>
<li><strong>修改实现类旧方法</strong><ul>
<li>替代原有旧方法功能，如果同时需要使用旧方法则无法采用此方式 （<code>getPrice()</code> 获取的是原价格还是打折后价格？如果需要同时获取原价和打折后价格如何处理）</li>
</ul>
</li>
<li><strong>面向扩展，使用新接口或者新类继承父类</strong><ul>
<li>新接口方法接口，需要的类进行实现</li>
<li>新类继承父类，在父类基础上增加方法</li>
</ul>
</li>
</ul>
<p><strong>明显面向扩展更容易维护，这就是开闭原则的目的</strong></p>
<h2 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h2><blockquote>
<p><em>There should never be more than one reason for a class to change. —— Robert C. Martin</em></p>
<p><em>一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分</em></p>
</blockquote>
<p>控制业务实现的粒度问题；一个类可以具备任意数量的方法，但都属于同一个功能簇中</p>
<p><strong>严格控制类中方法的粒度，必要时进行分析与拆分</strong></p>
<h2 id="里氏替换"><a href="#里氏替换" class="headerlink" title="里氏替换"></a>里氏替换</h2><blockquote>
<p><em>Inheritance should ensure that any property proved about supertype objects also holds for subtype objects. —— Liskov</em></p>
<p><em>继承必须确保父类所拥有的性质在子类中仍然成立</em></p>
</blockquote>
<p>在里氏替换原则的指导方针下，可得出：仅仅依据两个类之间有没有 “is a” 的关系，来判断两个类能不能发生继承关系是不够的</p>
<p>应该遵守一个大原则：<strong>任何使用父类的地方，都能被透明的替换成子类，且替换成子类后，程序行为不会发生问题</strong></p>
<p>不应该滥用继承关系，鸵鸟是否是鸟的子类（不会飞），鲸鱼是否是鱼的子类（没有腮），继承具有侵入性，当需要使用继承关系时需要辨明是否是真正的继承，<strong>父类的每个方法都必须适用于子类</strong></p>
<ol>
<li>子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法</li>
<li>子类可以增加自己特有的方法</li>
<li>子类重载父类方法时，方法的形参要比父类方法更为宽松</li>
<li>子类实现父类抽象方法时，方法的返回值要比父类方法更为严格</li>
</ol>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><blockquote>
<p><em>talk only to your immediate friends. —— Ian Holland</em></p>
<p><em>只和直接的朋友交流</em></p>
</blockquote>
<p>迪米特法则也称为最少知道原则，最少知道包含两个目的：</p>
<ul>
<li><strong>只和直接的朋友交互</strong><ul>
<li>例如 MVC 架构，视图层和业务层交互，业务层和持久层交互，视图层不应该和持久层产生联系</li>
</ul>
</li>
<li><strong>较少对朋友的了解</strong><ul>
<li>类门面模式（门面指暴露重要工作的简单入口，而迪米特法则在于只暴露该暴露的入口，还是有所区别）思想，对外只暴露能够满足外部需要的内容</li>
</ul>
</li>
</ul>
<p><strong>目的在于降低类之间的耦合关系</strong></p>
<h2 id="接口隔离"><a href="#接口隔离" class="headerlink" title="接口隔离"></a>接口隔离</h2><blockquote>
<p><em>Interface Segregation Principle, ISP</em></p>
<p><em>低耦合、高内聚中的高内聚</em></p>
</blockquote>
<p>接口隔离原则中所说的接口并不是狭意的指 Java 中的 Interface，而是一切的提供方法定义的对象，例如 Java 中的接口、抽象类、实体类</p>
<p>接口隔离的原则：</p>
<ul>
<li>客户端不依赖不需要的接口</li>
<li>类间依赖关系建立在最小的接口上</li>
<li>接口应该细化，不应该具备臃肿的方法</li>
</ul>
<p>例如发送方式的实现类 <code>Send</code>，此时具备两种发送方式：邮件和短信，如果将方法都放在 <code>Send</code> 类中，则应该分别定义 <code>sendEmail()</code> 和 <code>sendNotice()</code> 两个方法，不利于后面的拓展；好的解决方法应该是定义接口，然后分别创建 <code>EmailSend</code> 和 <code>NoticeSend</code> 两个实现类，这就是接口隔离的目的</p>
<p>接口隔离和单一原则看似冲突，目标是达到二者的平衡</p>
<p><strong>避免接口污染</strong></p>
<h2 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h2><blockquote>
<p><em>Dependence Inversion Principle,DIP</em></p>
<p><em>不依赖于具体实现，而依赖于抽象</em></p>
</blockquote>
<p>不正确的依赖关系是上层调用下层，上层依赖下层</p>
<p>面向对象其实就是依赖倒置的一种体现，依赖倒置让下层依赖上层，比如接口，接口方法的扩展会影响所有实现类，但抽象层的变动远远少于实现层，所以依赖倒置可以很好地避免频繁的修改</p>
<p><strong>面向接口编程</strong></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="如何满足里氏替换原则"><a href="#如何满足里氏替换原则" class="headerlink" title="如何满足里氏替换原则"></a>如何满足里氏替换原则</h2><p>里氏替换的原则指：需要使用父类的地方可以替换为子类使用，因为父类的方法在子类上应该保持一致</p>
<p>在实际中遇到直接继承不能满足里氏替换的场景，就<strong>说明抽象不足，需要向上抽象</strong></p>
<p>如果一个 <code>Add</code> 类的 <code>compute(int n)</code> 操作为加法，减法也想要进行实现，则继承 <code>Add</code> 类后重写了 <code>compute(int n)</code> 方法，此时则违反了里氏替换原则，整个方法的实现被重写了</p>
<p>向上抽象出 <code>Compute</code> 接口，即可以实现里氏替换原则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Compute</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span> <span class="keyword">implements</span> <span class="title class_">Compute</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subtract</span> <span class="keyword">implements</span> <span class="title class_">Compute</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;减法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://refactoringguru.cn/design-patterns">常用设计模式有哪些？ (refactoringguru.cn)</a></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>规范</tag>
      </tags>
  </entry>
</search>
