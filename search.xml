<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LiteFlow - 执行器初始化</title>
      <link href="/2023/04/24/%E5%BC%80%E5%8F%91/LiteFlow/LiteFlow%20-%20%E6%89%A7%E8%A1%8C%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2023/04/24/%E5%BC%80%E5%8F%91/LiteFlow/LiteFlow%20-%20%E6%89%A7%E8%A1%8C%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h1><p>基于 SpringBoot 的实现方式自然使用到了 starter 机制，核心代码在 <code>liteflow-spring-boot-starter</code> 包下</p><p>首先来看 <code>spring.factories</code> 文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">  com.yomahub.liteflow.springboot.config.LiteflowPropertyAutoConfiguration,\</span></span><br><span class="line"><span class="string">  com.yomahub.liteflow.springboot.config.LiteflowMainAutoConfiguration</span></span><br></pre></td></tr></table></figure><p>可以看到一共有两个重要的自动装配的配置类：</p><ul><li><strong>LiteflowPropertyAutoConfiguration</strong>：配置属性的解析，封装为 <code>LiteflowConfig</code> 实例</li><li><strong>LiteflowMainAutoConfiguration</strong>：LiteFlow 的核心功能对象在该配置类下实例化<ul><li><strong>SpringAware</strong>：Spring ApplicationContext 的获取与封装，便于后续业务中获取 bean 的操作</li><li><strong>ComponentScanner</strong>：组件扫描器，用于扫描与封装 <code>NodeComponent</code> 节点的实现类</li><li><strong>FlowExecutor</strong>：规则执行器</li><li><strong>LiteflowExecutorInit</strong>：设置服务启动时初始化配置生效，用于启动时主动进行初始化操作</li><li><strong>MonitorBus</strong>：监控类元数据</li></ul></li></ul><h2 id="LiteflowPropertyAutoConfiguration"><a href="#LiteflowPropertyAutoConfiguration" class="headerlink" title="LiteflowPropertyAutoConfiguration"></a>LiteflowPropertyAutoConfiguration</h2><p>总的来说就是对配置属性的合并和封装，实例化 <code>LiteflowConfig</code>，便于后续业务的使用</p><p>合并了 <code>liteflow</code> 配置和 <code>liteflow.monitor</code> 配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;LiteflowProperty.class, LiteflowMonitorProperty.class&#125;)</span></span><br><span class="line"><span class="meta">@PropertySource(</span></span><br><span class="line"><span class="meta">        name = &quot;Liteflow Default Properties&quot;,</span></span><br><span class="line"><span class="meta">        value = &quot;classpath:/META-INF/liteflow-default.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiteflowPropertyAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LiteflowConfig <span class="title function_">liteflowConfig</span><span class="params">(LiteflowProperty property, LiteflowMonitorProperty liteflowMonitorProperty)</span>&#123;</span><br><span class="line">        <span class="type">LiteflowConfig</span> <span class="variable">liteflowConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiteflowConfig</span>();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        liteflowConfig.setPrintExecutionLog(property.isPrintExecutionLog());</span><br><span class="line">        liteflowConfig.setSubstituteCmpClass(property.getSubstituteCmpClass());</span><br><span class="line">        <span class="keyword">return</span> liteflowConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖前置 <code>LiteflowProperty</code> 和 <code>LiteflowMonitorProperty</code> bean，即流程配置参数和监控器的配置参数类</p><h2 id="LiteflowMainAutoConfiguration"><a href="#LiteflowMainAutoConfiguration" class="headerlink" title="LiteflowMainAutoConfiguration"></a>LiteflowMainAutoConfiguration</h2><p>配置核心的各种实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123;LiteflowPropertyAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(LiteflowConfig.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;liteflow&quot;, name = &quot;enable&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="meta">@Import(SpringAware.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiteflowMainAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化ComponentScanner</span></span><br><span class="line">    <span class="comment">//多加一个SpringAware的意义是，确保在执行这个的时候，SpringAware这个bean已经被初始化</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ComponentScanner <span class="title function_">componentScanner</span><span class="params">(LiteflowConfig liteflowConfig, SpringAware springAware)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ComponentScanner</span>(liteflowConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化FlowExecutor</span></span><br><span class="line">    <span class="comment">//多加一个SpringAware的意义是，确保在执行这个的时候，SpringAware这个bean已经被初始化</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FlowExecutor <span class="title function_">flowExecutor</span><span class="params">(LiteflowConfig liteflowConfig, SpringAware springAware)</span> &#123;</span><br><span class="line">        <span class="type">FlowExecutor</span> <span class="variable">flowExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlowExecutor</span>();</span><br><span class="line">        flowExecutor.setLiteflowConfig(liteflowConfig);</span><br><span class="line">        <span class="keyword">return</span> flowExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FlowExecutor的初始化工作，和实例化分开来</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;liteflow&quot;, name = &quot;parse-on-start&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> LiteflowExecutorInit <span class="title function_">liteflowExecutorInit</span><span class="params">(FlowExecutor flowExecutor)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LiteflowExecutorInit</span>(flowExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化MonitorBus</span></span><br><span class="line">    <span class="comment">//多加一个SpringAware的意义是，确保在执行这个的时候，SpringAware这个bean已经被初始化</span></span><br><span class="line">    <span class="meta">@Bean(&quot;monitorBus&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;liteflow&quot;, name = &quot;monitor.enable-log&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> MonitorBus <span class="title function_">monitorBus</span><span class="params">(LiteflowConfig liteflowConfig, SpringAware springAware)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MonitorBus</span>(liteflowConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 bean 的加载顺序：LiteflowPropertyAutoConfiguration -&gt; LiteflowConfig -&gt; ComponentScanner &amp; FlowExecutor &amp; MonitorBus -&gt; LiteflowExecutorInit</p><p>LiteflowExecutorInit 和 MonitorBus 依赖不同的配置条件，其中 <code>liteflow.parse-on-start</code> 默认是 true，<code>liteflow.monitor.enable-log</code> 默认是 false</p><h1 id="ComponentScanner"><a href="#ComponentScanner" class="headerlink" title="ComponentScanner"></a>ComponentScanner</h1><p><code>ComponentScanner</code> 在项目中也被缩写为 <code>cmp</code>，主要是依赖 Spring 的 <code>BeanPostProcessor</code> 来对 <code>NodeComponent</code> 的各种实现进行发现、保存、扩展等一系列操作</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>配置类中使用了其构造方法进行实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ComponentScanner</span><span class="params">(LiteflowConfig liteflowConfig)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.liteflowConfig = liteflowConfig;</span><br><span class="line">    <span class="keyword">if</span> (liteflowConfig.getPrintBanner()) &#123;</span><br><span class="line">        <span class="comment">// 打印liteflow的LOGO</span></span><br><span class="line">        LOGOPrinter.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法中主要进行了两个操作：</p><ol><li><p>填充属性 liteflowConfig</p></li><li><p>打印 LOGO（可以看出这个是启动的第一个 bean）；LOGOPrinter 就是一个打印 LOGO 的静态方法工具类</p></li></ol><h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>既然实现了 <code>BeanPostProcessor</code> 接口，那么重点就需要关注其对于 before 和 after 钩子方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentScanner</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>before 方法是一个空实现，重点关注 after 方法</p><h3 id="声明式组件"><a href="#声明式组件" class="headerlink" title="声明式组件"></a>声明式组件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是不是声明式组件</span></span><br><span class="line"><span class="comment">//如果是，就缓存到类属性的map中</span></span><br><span class="line"><span class="keyword">if</span> (LiteFlowProxyUtil.isDeclareCmp(bean.getClass())) &#123;</span><br><span class="line">    LOG.info(<span class="string">&quot;proxy component[&#123;&#125;] has been found&quot;</span>, beanName);</span><br><span class="line">    List&lt;NodeComponent&gt; nodeComponents = LiteFlowProxyUtil.proxy2NodeComponent(bean, beanName);</span><br><span class="line">    nodeComponents.forEach(</span><br><span class="line">            nodeComponent -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">nodeId</span> <span class="operator">=</span> nodeComponent.getNodeId();</span><br><span class="line">                nodeId = StrUtil.isEmpty(nodeId) ? beanName : nodeId;</span><br><span class="line">                nodeComponentMap.put(nodeId, nodeComponent);</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 只有注解支持单bean多Node,所以一个直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (nodeComponents.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nodeComponents.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何判断是否是一个声明式组件，实现方法是 <code>LiteFlowProxyUtil.isDeclareCmp</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断一个bean是否是声明式组件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isDeclareCmp</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">    <span class="comment">// 查看bean里的method是否有方法标记了@LiteflowMethod标注</span></span><br><span class="line">    <span class="comment">// 这里的bean有可能是cglib加强过的class，所以要先进行个判断</span></span><br><span class="line">    Class&lt;?&gt; targetClass = getUserClass(clazz);</span><br><span class="line">    <span class="comment">// 判断是否有方法标记了@LiteflowMethod标注，有则为声明式组件</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(targetClass.getMethods())</span><br><span class="line">        .anyMatch(method -&gt; method.getAnnotation(LiteflowMethod.class) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取真实的用户定义类</li><li>判断类中的方法是否标记了 <code>@LiteflowMethod</code></li></ol><h3 id="实现类组件"><a href="#实现类组件" class="headerlink" title="实现类组件"></a>实现类组件</h3><p>实现类组件有两种：</p><ul><li>继承自 <code>NodeComponent</code> 的逻辑组件</li><li>实现自 <code>ICmpAroundAspect</code> 的切面组件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件的扫描发现，扫到之后缓存到类属性map中</span></span><br><span class="line"><span class="keyword">if</span> (NodeComponent.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">    LOG.info(<span class="string">&quot;component[&#123;&#125;] has been found&quot;</span>, beanName);</span><br><span class="line">    <span class="type">NodeComponent</span> <span class="variable">nodeComponent</span> <span class="operator">=</span> (NodeComponent) bean;</span><br><span class="line">    nodeComponentMap.put(beanName, nodeComponent);</span><br><span class="line">    <span class="keyword">return</span> nodeComponent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件Aop的实现类加载</span></span><br><span class="line"><span class="keyword">if</span> (ICmpAroundAspect.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">    LOG.info(<span class="string">&quot;component aspect implement[&#123;&#125;] has been found&quot;</span>, beanName);</span><br><span class="line">    cmpAroundAspect = (ICmpAroundAspect) bean;</span><br><span class="line">    <span class="keyword">return</span> cmpAroundAspect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扫描组件的逻辑都是这类方式：</p><ol><li>判断是否是其实现</li><li>转型</li><li>保存到对应引用或对象</li></ol><p>可以看到对于逻辑组件，是一个 map 结构，存在多个组件；而对于切面组件，只能存在一个（事实上这段逻辑没有对实现进行判断，也就是说如果有多个实现的 bean 会进行覆盖，测试中也发现是这样）</p><h3 id="脚本组件"><a href="#脚本组件" class="headerlink" title="脚本组件"></a>脚本组件</h3><p>脚本组件也有两种：</p><ul><li><code>@ScriptBean</code> 修饰的脚本 bean</li><li><code>@ScriptMethod</code> 修饰的脚本方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描@ScriptBean修饰的类</span></span><br><span class="line"><span class="type">ScriptBean</span> <span class="variable">scriptBean</span> <span class="operator">=</span> AnnoUtil.getAnnotation(clazz, ScriptBean.class);</span><br><span class="line"><span class="keyword">if</span> (ObjectUtil.isNotNull(scriptBean)) &#123;</span><br><span class="line">    <span class="type">ScriptBeanProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptBeanProxy</span>(bean, clazz, scriptBean);</span><br><span class="line">    ScriptBeanManager.addScriptBean(scriptBean.value(), proxy.getProxyScriptBean());</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描@ScriptMethod修饰的类</span></span><br><span class="line">List&lt;Method&gt; scriptMethods = Arrays.stream(clazz.getMethods()).filter(method -&gt; &#123;</span><br><span class="line">    <span class="type">ScriptMethod</span> <span class="variable">scriptMethod</span> <span class="operator">=</span> AnnoUtil.getAnnotation(method, ScriptMethod.class);</span><br><span class="line">    <span class="keyword">return</span> ObjectUtil.isNotNull(scriptMethod) &amp;&amp; StrUtil.isNotEmpty(scriptMethod.value());</span><br><span class="line">&#125;).collect(Collectors.toList());</span><br><span class="line"><span class="keyword">if</span> (CollUtil.isNotEmpty(scriptMethods)) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Method&gt;&gt; scriptMethodsGroupByValue = CollStreamUtil.groupBy(scriptMethods, method -&gt; &#123;</span><br><span class="line">        <span class="type">ScriptMethod</span> <span class="variable">scriptMethod</span> <span class="operator">=</span> AnnoUtil.getAnnotation(method, ScriptMethod.class);</span><br><span class="line">        <span class="keyword">return</span> scriptMethod.value();</span><br><span class="line">    &#125;, Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;Method&gt;&gt; entry : scriptMethodsGroupByValue.entrySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        List&lt;Method&gt; methods = entry.getValue();</span><br><span class="line">        <span class="type">ScriptMethodProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptMethodProxy</span>(bean, clazz, methods);</span><br><span class="line"></span><br><span class="line">        ScriptBeanManager.addScriptBean(key, proxy.getProxyScriptMethod());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是将不同的脚本形式包装成代理类，转换成 bean 后放入 <code>ScriptBeanManager</code> 进行管理</p><p>转换的核心在 <code>getProxyScriptMethod</code> 方法，这个会在脚本相关源码中进一步分析</p><h1 id="FlowExecutor"><a href="#FlowExecutor" class="headerlink" title="FlowExecutor"></a>FlowExecutor</h1><p>流程规则主要执行器，也是一个规则表执行的主要入口</p><p>这里主要关注其构造流程，初始化在后面的 <code>LiteflowExecutorInit</code> 中讲解</p><h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FlowExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置FlowExecutor的Holder，虽然大部分地方都可以通过Spring上下文获取到，但放入Holder，还是为了某些地方能方便的取到</span></span><br><span class="line">    FlowExecutorHolder.setHolder(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 初始化DataBus</span></span><br><span class="line">    DataBus.init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FlowExecutor</span><span class="params">(LiteflowConfig liteflowConfig)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.liteflowConfig = liteflowConfig;</span><br><span class="line">    <span class="comment">// 把liteFlowConfig设到LiteFlowGetter中去</span></span><br><span class="line">    LiteflowConfigGetter.setLiteflowConfig(liteflowConfig);</span><br><span class="line">    <span class="comment">// 设置FlowExecutor的Holder，虽然大部分地方都可以通过Spring上下文获取到，但放入Holder，还是为了某些地方能方便的取到</span></span><br><span class="line">    FlowExecutorHolder.setHolder(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (BooleanUtil.isTrue(liteflowConfig.isParseOnStart())) &#123;</span><br><span class="line">        <span class="built_in">this</span>.init(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化DataBus</span></span><br><span class="line">    DataBus.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Spring 的启动方式，使用了无参构造，随后将 liteflowConfig 用 set 方法进行赋值，带有参数的构造方法应该是为了非 Spring 环境准备的，因为在 Spring 环境中 liteflowConfig 使用了 properties 的机制，而 FlowExecutor 通过 <code>@Bean</code> 进行实例化</p><p>可以看到无参构造中主要进行了 <code>DataBus.init()</code> 操作</p><h2 id="DataBus"><a href="#DataBus" class="headerlink" title="DataBus"></a>DataBus</h2><p>数据 BUS，主要用来管理 Slot，用以分配和回收</p><p>Slot 即整个规则流程调用时的管理者，保存了整个规则进行中的数据、组件步骤等信息，每一次调用会生成新的 Slot，并且互相隔离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;Integer, Slot&gt; SLOTS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentLinkedQueue&lt;Integer&gt; QUEUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 SLOTS 没有初始化</span></span><br><span class="line">    <span class="keyword">if</span> (MapUtil.isEmpty(SLOTS)) &#123;</span><br><span class="line">        <span class="comment">// 获取 liteflowConfig，在 Spring 环境中这里会使用已经注入的 SpringAware 从 ApplicationContext 中获取</span></span><br><span class="line">        <span class="type">LiteflowConfig</span> <span class="variable">liteflowConfig</span> <span class="operator">=</span> LiteflowConfigGetter.get();</span><br><span class="line">        <span class="comment">// 从配置中获取 slot size 参数</span></span><br><span class="line">        currentIndexMaxValue = liteflowConfig.getSlotSize();</span><br><span class="line">        <span class="comment">// 初始化 SLOTS</span></span><br><span class="line">        SLOTS = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化 QUEUE</span></span><br><span class="line">        QUEUE = IntStream.range(<span class="number">0</span>, currentIndexMaxValue)</span><br><span class="line">            .boxed()</span><br><span class="line">            .collect(Collectors.toCollection(ConcurrentLinkedQueue::<span class="keyword">new</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 SLOTS 用来保存分配的序号和 Slot 对象，QUEUE 则是用来保存 index</p><p>即在并发的情况下，能够分配的运行资格由 QUEUE 控制，QUEUE 会根据并发情况进行扩容，具体的资格由 0 ~ n 的 int 值来表示</p><h1 id="LiteflowExecutorInit"><a href="#LiteflowExecutorInit" class="headerlink" title="LiteflowExecutorInit"></a>LiteflowExecutorInit</h1><p>执行器初始化类，主要用于在启动时执行执行器的初始化方法，避免在运行执行器时第一次初始化而耗费时间</p><p>该类实例化的意义就是控制上面对象 FlowExecutor 的初始化操作，如果不在配置中设置启动初始化，则 FlowExecutor 的初始化工作会放在调用时进行 <code>@ConditionalOnProperty(prefix = &quot;liteflow&quot;, name = &quot;parse-on-start&quot;, havingValue = &quot;true&quot;)</code></p><h2 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiteflowExecutorInit</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FlowExecutor flowExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LiteflowExecutorInit</span><span class="params">(FlowExecutor flowExecutor)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.flowExecutor = flowExecutor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">flowExecutor.init(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类实现了 Spring 钩子 InitializingBean，afterPropertiesSet 进行 <code>FlowExecutor</code> 的初始化操作</p><h2 id="FlowExecutor-的-init"><a href="#FlowExecutor-的-init" class="headerlink" title="FlowExecutor 的 init"></a>FlowExecutor 的 init</h2><p><code>LiteflowExecutorInit</code> 的实例化是为了 init <code>FlowExecutor</code>，而 <code>FlowExecutor</code> 的初始化主要目的是 parse 规则文件</p><h3 id="ID-生成器"><a href="#ID-生成器" class="headerlink" title="ID 生成器"></a>ID 生成器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行id生成器的初始化</span></span><br><span class="line">IdGeneratorHolder.init();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 单例创建</span></span><br><span class="line">    INSTANCE = <span class="keyword">new</span> <span class="title class_">IdGeneratorHolder</span>();</span><br><span class="line">    <span class="type">LiteflowConfig</span> <span class="variable">liteflowConfig</span> <span class="operator">=</span> LiteflowConfigGetter.get();</span><br><span class="line">    <span class="comment">// 获取配置项中的生成器类路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">requestIdGeneratorClass</span> <span class="operator">=</span> liteflowConfig.getRequestIdGeneratorClass();</span><br><span class="line"></span><br><span class="line">    RequestIdGenerator requestIdGenerator;</span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(requestIdGeneratorClass)) &#123;</span><br><span class="line">      <span class="comment">// 默认为 DefaultRequestIdGenerator</span></span><br><span class="line">      requestIdGenerator = <span class="keyword">new</span> <span class="title class_">DefaultRequestIdGenerator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 实例化自定义生成器</span></span><br><span class="line">      Class&lt;RequestIdGenerator&gt; idGenerateClass = (Class&lt;RequestIdGenerator&gt;) Class</span><br><span class="line">        .forName(requestIdGeneratorClass);</span><br><span class="line">      <span class="comment">// 注册进 bean 容器</span></span><br><span class="line">      requestIdGenerator = ContextAwareHolder.loadContextAware().registerBean(idGenerateClass);</span><br><span class="line">    &#125;</span><br><span class="line">    INSTANCE.setRequestIdGenerator(requestIdGenerator);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RequestIdGeneratorException</span>(e.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IdGeneratorHolder</code> 用于保存实例化后的 ID 生成器 <code>RequestIdGenerator</code>，是一个单例</p><p>基本流程就是获取配置项上的生成器类路径，然后通过反射进行实例化，保存到 <code>IdGeneratorHolder</code> 这个角色中，如果没有进行配置则使用默认实现 <code>DefaultRequestIdGenerator</code></p><p><strong>默认实现 DefaultRequestIdGenerator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultRequestIdGenerator</span> <span class="keyword">implements</span> <span class="title class_">RequestIdGenerator</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">generate</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> IdUtil.fastSimpleUUID();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hutool 下的简单 UUID 生成</p><h3 id="规则文件源路径"><a href="#规则文件源路径" class="headerlink" title="规则文件源路径"></a>规则文件源路径</h3><p>在上面流程中加载了逻辑组件，接下来就是解析规则表</p><p><strong>规则路径为空</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">ruleSource</span> <span class="operator">=</span> liteflowConfig.getRuleSource();</span><br><span class="line"><span class="keyword">if</span> (StrUtil.isBlank(ruleSource)) &#123;</span><br><span class="line">   <span class="comment">// 查看有没有Parser的SPI实现</span></span><br><span class="line">   <span class="comment">// 所有的Parser的SPI实现都是以custom形式放入的，且只支持xml形式</span></span><br><span class="line">   ServiceLoader&lt;ParserClassNameSpi&gt; loader = ServiceLoader.load(ParserClassNameSpi.class);</span><br><span class="line">   Iterator&lt;ParserClassNameSpi&gt; it = loader.iterator();</span><br><span class="line">   <span class="keyword">if</span> (it.hasNext()) &#123;</span><br><span class="line">      <span class="type">ParserClassNameSpi</span> <span class="variable">parserClassNameSpi</span> <span class="operator">=</span> it.next();</span><br><span class="line">      ruleSource = <span class="string">&quot;el_xml:&quot;</span> + parserClassNameSpi.getSpiClassName();</span><br><span class="line">      liteflowConfig.setRuleSource(ruleSource);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ruleSource为空，而且没有spi形式的扩展，那么说明真的没有ruleSource</span></span><br><span class="line">      <span class="comment">// 这种情况有可能是基于代码动态构建的</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一块逻辑是在判断当配置文件的规则源路径为空的情况，此时会使用 SPI 工具 <code>ServiceLoader</code> 去加载自定义实现的规则加载器去放置新的规则路径</p><p><strong>项目文件和本地文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果有前缀的，则不需要再进行分割了，说明是一个整体</span></span><br><span class="line"><span class="comment">// 如果没有前缀，说明是本地文件，可能配置多个，所以需要分割</span></span><br><span class="line">List&lt;String&gt; sourceRulePathList;</span><br><span class="line"><span class="keyword">if</span> (ReUtil.contains(PREFIX_FORMAT_CONFIG_REGEX, ruleSource)) &#123;</span><br><span class="line">   sourceRulePathList = ListUtil.toList(ruleSource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">afterHandleRuleSource</span> <span class="operator">=</span> ruleSource.replace(StrUtil.SPACE, StrUtil.EMPTY);</span><br><span class="line">   sourceRulePathList = ListUtil.toList(afterHandleRuleSource.split(<span class="string">&quot;,|;&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LiteFlow 的特性可以支持从本地文件加载规则，所以在此处判断规则是来源于项目文件还是本地文件</p><p>根据规则前缀 <code>String PREFIX_FORMAT_CONFIG_REGEX = &quot;xml:|json:|yml:|el_xml:|el_json:|el_yml:&quot;</code> 的正则来匹配；如果是本地文件则根据 <code>,|;</code> 来进行分割</p><p>将规则文件的路径都放置在 <code>sourceRulePathList</code> 这个集合中</p><h3 id="规则文件解析"><a href="#规则文件解析" class="headerlink" title="规则文件解析"></a>规则文件解析</h3><p>获取规则源后要对规则文件进行解析</p><h4 id="复合规则配置"><a href="#复合规则配置" class="headerlink" title="复合规则配置"></a>复合规则配置</h4><p>这里应该是实现不同格式规则加载的特性，需要进行相关配置 <code>supportMultipleType</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FlowParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Set&lt;String&gt; parserNameSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; rulePathList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String path : sourceRulePathList) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 查找对应的解析器</span></span><br><span class="line">      parser = FlowParserProvider.lookup(path);</span><br><span class="line">      parserNameSet.add(parser.getClass().getName());</span><br><span class="line">      <span class="comment">// 替换掉前缀标识（如：xml:/json:），保留剩下的完整地址</span></span><br><span class="line">      path = ReUtil.replaceAll(path, PREFIX_FORMAT_CONFIG_REGEX, <span class="string">&quot;&quot;</span>);</span><br><span class="line">      rulePathList.add(path);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 支持多类型的配置文件，分别解析</span></span><br><span class="line">      <span class="keyword">if</span> (BooleanUtil.isTrue(liteflowConfig.isSupportMultipleType())) &#123;</span><br><span class="line">         <span class="comment">// 解析文件</span></span><br><span class="line">         parser.parseMain(ListUtil.toList(path));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (CyclicDependencyException e) &#123;</span><br><span class="line">      LOG.error(e.getMessage());</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> StrUtil.format(<span class="string">&quot;init flow executor cause error for path &#123;&#125;,reason:&#123;&#125;&quot;</span>, path,</span><br><span class="line">            e.getMessage());</span><br><span class="line">      LOG.error(e.getMessage(), e);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FlowExecutorNotInitException</span>(errorMsg);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程如下：</p><ol><li>遍历规则路径，查找对应的解析器</li><li>记录解析器类名（主要是用于后续非多类型解析器判断使用）</li><li>路径放入规则路径集合</li><li>如果支持多类型配置文件解析，则直接进行解析 <code>parser.parseMain(ListUtil.toList(path))</code></li><li>catch 异常，打印日志</li></ol><h4 id="单类型配置"><a href="#单类型配置" class="headerlink" title="单类型配置"></a>单类型配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单类型的配置文件，需要一起解析</span></span><br><span class="line"><span class="keyword">if</span> (BooleanUtil.isFalse(liteflowConfig.isSupportMultipleType())) &#123;</span><br><span class="line">   <span class="comment">// 检查Parser是否只有一个，因为多个不同的parser会造成子流程的混乱</span></span><br><span class="line">   <span class="keyword">if</span> (parserNameSet.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> <span class="string">&quot;cannot have multiple different parsers&quot;</span>;</span><br><span class="line">      LOG.error(errorMsg);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MultipleParsersException</span>(errorMsg);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 进行多个配置文件的一起解析</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (parser != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 解析文件</span></span><br><span class="line">         parser.parseMain(rulePathList);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigErrorException</span>(<span class="string">&quot;parse error, please check liteflow config property&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (CyclicDependencyException e) &#123;</span><br><span class="line">      LOG.error(e.getMessage(), e);</span><br><span class="line">      LOG.error(e.getMessage());</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ChainDuplicateException e) &#123;</span><br><span class="line">      LOG.error(e.getMessage(), e);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> StrUtil.format(<span class="string">&quot;init flow executor cause error for path &#123;&#125;,reason: &#123;&#125;&quot;</span>, rulePathList,</span><br><span class="line">            e.getMessage());</span><br><span class="line">      LOG.error(e.getMessage(), e);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FlowExecutorNotInitException</span>(errorMsg);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单类型的流程主要针对解析器数量进行了判断，也是使用 <code>parser.parseMain(ListUtil.toList(path))</code> 进入解析流程</p><h4 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h4><img src="/2023/04/24/%E5%BC%80%E5%8F%91/LiteFlow/LiteFlow%20-%20%E6%89%A7%E8%A1%8C%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/parser%20%E7%B1%BB%E5%9B%BE.jpg" class=""><p>这里主要先来看 <code>LocalXmlFlowELParser</code> 的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalXmlFlowELParser</span> <span class="keyword">extends</span> <span class="title class_">XmlFlowELParser</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseMain</span><span class="params">(List&lt;String&gt; pathList)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      List&lt;String&gt; contentList = PathContentParserHolder.loadContextAware().parseContent(pathList);</span><br><span class="line">      parse(contentList);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PathContentParserHolder.loadContextAware().parseContent(pathList)</code> 的操作用于获取文件中的内容，即规则的 EL 表达式等（就是读文件，不过会根据不同环境选择不同的实现）</p><p>最后执行 <code>BaseXmlFlowParser</code> 抽象类提供的 <code>parse</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(List&lt;String&gt; contentList)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="keyword">if</span> (CollectionUtil.isEmpty(contentList)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   List&lt;Document&gt; documentList = ListUtil.toList();</span><br><span class="line">   <span class="keyword">for</span> (String content : contentList) &#123;</span><br><span class="line">      <span class="comment">// 解析 XML org.dom4j.DocumentHelper，转换为 Document 对象</span></span><br><span class="line">      <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> DocumentHelper.parseText(content);</span><br><span class="line">      documentList.add(document);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 解析 node</span></span><br><span class="line">   ParserHelper.parseNodeDocument(documentList);</span><br><span class="line">   <span class="comment">// 解析 chain</span></span><br><span class="line">   ParserHelper.parseChainDocument(documentList, CHAIN_NAME_SET, <span class="built_in">this</span>::parseOneChain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ParserHelper"><a href="#ParserHelper" class="headerlink" title="ParserHelper"></a>ParserHelper</h4><p>以 <code>XML</code> 格式的规则表达为例</p><p><strong>解析 node</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * xml 形式的主要解析过程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> documentList documentList</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parseNodeDocument</span><span class="params">(List&lt;Document&gt; documentList)</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (Document document : documentList) &#123;</span><br><span class="line">      <span class="comment">// 获取 root 标签</span></span><br><span class="line">      <span class="type">Element</span> <span class="variable">rootElement</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">      <span class="comment">// 获取 nodes 标签</span></span><br><span class="line">      <span class="type">Element</span> <span class="variable">nodesElement</span> <span class="operator">=</span> rootElement.element(NODES);</span><br><span class="line">      <span class="comment">// 当存在&lt;nodes&gt;节点定义时，解析node节点</span></span><br><span class="line">      <span class="keyword">if</span> (ObjectUtil.isNotNull(nodesElement)) &#123;</span><br><span class="line">         List&lt;Element&gt; nodeList = nodesElement.elements(NODE);</span><br><span class="line">         String id, name, clazz, type, script, file, language;</span><br><span class="line">         <span class="keyword">for</span> (Element e : nodeList) &#123;</span><br><span class="line">            id = e.attributeValue(ID);</span><br><span class="line">            name = e.attributeValue(NAME);</span><br><span class="line">            clazz = e.attributeValue(_CLASS);</span><br><span class="line">            type = e.attributeValue(TYPE);</span><br><span class="line">            script = e.getText();</span><br><span class="line">            file = e.attributeValue(FILE);</span><br><span class="line">            language = e.attributeValue(LANGUAGE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建 node</span></span><br><span class="line">            <span class="type">NodePropBean</span> <span class="variable">nodePropBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodePropBean</span>().setId(id)</span><br><span class="line">               .setName(name)</span><br><span class="line">               .setClazz(clazz)</span><br><span class="line">               .setScript(script)</span><br><span class="line">               .setType(type)</span><br><span class="line">               .setFile(file)</span><br><span class="line">               .setLanguage(language);</span><br><span class="line"></span><br><span class="line">            ParserHelper.buildNode(nodePropBean);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从配置的 <code>XML</code> 规则中解析标签</li><li>找到 <code>nodes</code> 的标签；name 常量定义在 <code>ChainConstant.NODES</code></li><li>遍历 <code>nodes</code> 下面的每一个 <code>node</code> 标签，构建 <code>NodePropBean</code> node 对象</li><li><code>ParserHelper.buildNode(nodePropBean)</code> 开始解析节点，解析完成后会放置在 <code>FlowBus</code> 中（解析过程中还在分辨是普通节点还是脚本节点，这个放到脚本相关源码中再看）</li></ol><p><strong>解析 chain</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parseChainDocument</span><span class="params">(List&lt;Document&gt; documentList, Set&lt;String&gt; chainNameSet,</span></span><br><span class="line"><span class="params">      Consumer&lt;Element&gt; parseOneChainConsumer)</span> &#123;</span><br><span class="line">   <span class="comment">// 先在元数据里放上chain</span></span><br><span class="line">   <span class="comment">// 先放有一个好处，可以在parse的时候先映射到FlowBus的chainMap，然后再去解析</span></span><br><span class="line">   <span class="comment">// 这样就不用去像之前的版本那样回归调用</span></span><br><span class="line">   <span class="comment">// 同时也解决了不能循环依赖的问题</span></span><br><span class="line">   documentList.forEach(document -&gt; &#123;</span><br><span class="line">      <span class="comment">// 解析chain节点</span></span><br><span class="line">      List&lt;Element&gt; chainList = document.getRootElement().elements(CHAIN);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 先在元数据里放上chain</span></span><br><span class="line">      chainList.forEach(e -&gt; &#123;</span><br><span class="line">         <span class="comment">// 校验加载的 chainName 是否有重复的</span></span><br><span class="line">         <span class="comment">// TODO 这里是否有个问题，当混合格式加载的时候，2个同名的Chain在不同的文件里，就不行了</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">chainName</span> <span class="operator">=</span> Optional.ofNullable(e.attributeValue(ID)).orElse(e.attributeValue(NAME));</span><br><span class="line">         <span class="keyword">if</span> (!chainNameSet.add(chainName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ChainDuplicateException</span>(String.format(<span class="string">&quot;[chain name duplicate] chainName=%s&quot;</span>, chainName));</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         FlowBus.addChain(chainName);</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">// 清空</span></span><br><span class="line">   chainNameSet.clear();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析每一个chain</span></span><br><span class="line">   <span class="keyword">for</span> (Document document : documentList) &#123;</span><br><span class="line">      <span class="type">Element</span> <span class="variable">rootElement</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">      List&lt;Element&gt; chainList = rootElement.elements(CHAIN);</span><br><span class="line">      chainList.forEach(parseOneChainConsumer);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从 <code>XML</code> 规则中解析 <code>chain</code> 标签</li><li>遍历标签处理 chain 数据</li><li>获取 chainName，规则为如果没有配置独立的 id 就使用 name</li><li>加入 chainNameSet，如果 name 重复则抛出异常（这种方式无法处理多文件的重复问题，我理解带来的影响就是会导致解析的 chain 被覆盖）</li><li>先将 name 加入元数据管理类 <code>FlowBus</code>；这个流程是预装载，其元数据管理中的 map value 是占位对象</li><li>遍历 chain 标签，调用传入的 <code>Consumer</code> 方法开始解析；<code>Consumer</code> 方法为 <code>Parser</code> 实现的 <code>parseOneChain</code> 方法</li></ol><h4 id="EL-规则组装器"><a href="#EL-规则组装器" class="headerlink" title="EL 规则组装器"></a>EL 规则组装器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parseOneChainEl</span><span class="params">(JsonNode chainNode)</span> &#123;</span><br><span class="line">   <span class="comment">// 构建chainBuilder</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">chainId</span> <span class="operator">=</span> Optional.ofNullable(chainNode.get(ID)).orElse(chainNode.get(NAME)).textValue();</span><br><span class="line">   <span class="type">String</span> <span class="variable">el</span> <span class="operator">=</span> chainNode.get(VALUE).textValue();</span><br><span class="line">   <span class="type">LiteFlowChainELBuilder</span> <span class="variable">chainELBuilder</span> <span class="operator">=</span> LiteFlowChainELBuilder.createChain().setChainId(chainId);</span><br><span class="line">   chainELBuilder.setEL(el).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>parseOneChainEl</code> 后主要是获取 el 规则，创建 <code>LiteFlowChainELBuilder</code> 对象后在 <code>setEL</code> 的步骤中会进行 EL 规则的解析，最终返回 <code>List&lt;Condition&gt; conditionList</code></p><p>规则的解析使用了阿里开源的 QLExpress，后面会单独一篇来讲解</p><p>基本上到这里，相关的执行组件就已经初始化完毕了</p><p>后续具体的执行就是获取 <code>Chain</code> 对象的 <code>conditionList</code>，遍历 list 进行执行</p><h1 id="MonitorBus"><a href="#MonitorBus" class="headerlink" title="MonitorBus"></a>MonitorBus</h1><p>监控类元数据，打印执行器类</p><p>需要配置 condition 参数 <code>monitor.enable-log</code></p><h2 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ScheduledExecutorService</span> <span class="variable">printLogScheduler</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MonitorBus</span><span class="params">(LiteflowConfig liteflowConfig)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.liteflowConfig = liteflowConfig;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (BooleanUtil.isTrue(liteflowConfig.getEnableLog())) &#123;</span><br><span class="line">      <span class="built_in">this</span>.printLogScheduler.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">MonitorTimeTask</span>(<span class="built_in">this</span>), liteflowConfig.getDelay(),</span><br><span class="line">            liteflowConfig.getPeriod(), TimeUnit.MILLISECONDS);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向定时线程池设置任务，任务为 <code>new MonitorTimeTask(this)</code>，是一个 <code>TimerTask</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorTimeTask</span> <span class="keyword">extends</span> <span class="title class_">TimerTask</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MonitorBus monitorBus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MonitorTimeTask</span><span class="params">(MonitorBus monitorBus)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.monitorBus = monitorBus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">monitorBus.printStatistics();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>run</code> 方法为调用 <code>MonitorBus.printStatistics</code></p><h2 id="打印统计数据"><a href="#打印统计数据" class="headerlink" title="打印统计数据"></a>打印统计数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, BoundedPriorityBlockingQueue&lt;CompStatistics&gt;&gt; statisticsMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStatistics</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      Map&lt;String, BigDecimal&gt; compAverageTimeSpent = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, BigDecimal&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Entry&lt;String, BoundedPriorityBlockingQueue&lt;CompStatistics&gt;&gt; entry : statisticsMap.entrySet()) &#123;</span><br><span class="line">         <span class="type">long</span> <span class="variable">totalTimeSpent</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (CompStatistics statistics : entry.getValue()) &#123;</span><br><span class="line">            totalTimeSpent += statistics.getTimeSpent();</span><br><span class="line">         &#125;</span><br><span class="line">         compAverageTimeSpent.put(entry.getKey(), <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(totalTimeSpent)</span><br><span class="line">            .divide(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(entry.getValue().size()), <span class="number">2</span>, RoundingMode.HALF_UP));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      List&lt;Entry&lt;String, BigDecimal&gt;&gt; compAverageTimeSpentEntryList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">            compAverageTimeSpent.entrySet());</span><br><span class="line"></span><br><span class="line">      Collections.sort(compAverageTimeSpentEntryList, (o1, o2) -&gt; o2.getValue().compareTo(o1.getValue()));</span><br><span class="line"></span><br><span class="line">      <span class="type">StringBuilder</span> <span class="variable">logStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">      logStr.append(<span class="string">&quot;以下为LiteFlow中间件统计信息：\n&quot;</span>);</span><br><span class="line">      logStr.append(<span class="string">&quot;======================================================================================\n&quot;</span>);</span><br><span class="line">      logStr.append(<span class="string">&quot;===================================SLOT INFO==========================================\n&quot;</span>);</span><br><span class="line">      logStr.append(MessageFormat.format(<span class="string">&quot;SLOT TOTAL SIZE : &#123;0&#125;\n&quot;</span>, liteflowConfig.getSlotSize()));</span><br><span class="line">      logStr.append(MessageFormat.format(<span class="string">&quot;SLOT OCCUPY COUNT : &#123;0&#125;\n&quot;</span>, DataBus.OCCUPY_COUNT));</span><br><span class="line">      logStr.append(<span class="string">&quot;===============================TIME AVERAGE SPENT=====================================\n&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (Entry&lt;String, BigDecimal&gt; entry : compAverageTimeSpentEntryList) &#123;</span><br><span class="line">         logStr.append(MessageFormat.format(<span class="string">&quot;COMPONENT[&#123;0&#125;] AVERAGE TIME SPENT : &#123;1&#125;\n&quot;</span>, entry.getKey(),</span><br><span class="line">               entry.getValue()));</span><br><span class="line">      &#125;</span><br><span class="line">      logStr.append(<span class="string">&quot;======================================================================================\n&quot;</span>);</span><br><span class="line">      LOG.info(logStr.toString());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      LOG.error(<span class="string">&quot;print statistics cause error&quot;</span>, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>statisticsMap</code> 是用来保存组件执行时上报的数据，在 <code>printStatistics</code> 方法中对数据进行整理和打印</p><p>主要数据：</p><ul><li>slot 槽位现在的大小（用来衡量最大并发度）</li><li>slot 当前的占用数量（展示当前并发度）</li><li>各个组件的平均耗时</li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> LiteFlow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> LiteFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RECIPES - Maison Premiere’s Tom Collins</title>
      <link href="/2023/04/09/%E4%BA%BA%E7%94%9F/%E9%85%92/RECIPES%20-%20Maison%20Premiere%E2%80%99s%20Tom%20Collins/"/>
      <url>/2023/04/09/%E4%BA%BA%E7%94%9F/%E9%85%92/RECIPES%20-%20Maison%20Premiere%E2%80%99s%20Tom%20Collins/</url>
      
        <content type="html"><![CDATA[<p><img src="https://assets-prd.punchdrink.com/wp-content/uploads/2023/03/16224141/Article-Tom-Collins-Underrated-Classic-Cocktail-Recipe-500x688.jpg"></p><h1 id="Maison-Premiere-的汤姆柯林斯"><a href="#Maison-Premiere-的汤姆柯林斯" class="headerlink" title="Maison Premiere 的汤姆柯林斯"></a>Maison Premiere 的汤姆柯林斯</h1><p><a href="https://punchdrink.com/recipes/maison-premieres-tom-collins/">Maison Premiere’s Tom Collins Cocktail Recipe | PUNCH (punchdrink.com)</a></p><p>对于某些调酒师来说，“被低估” 并不一定意味着鲜为人知</p><p>Maison Premiere 的威廉·埃利奥特（William Elliott）认为，汤姆柯林斯是无处不在的经典，值得 ”好好对待“</p><p>关键在于找到一个轻度桶陈的老汤姆（他使用的是 Ransom Old Tom），并且，虽然常见的是在玻璃杯里进行调制，不过一个合适的汤姆柯林斯应该经过 shake 并过滤</p><p>在布鲁克林的酒吧里，埃利奥特对鸡尾酒的基底采用了类似吉姆雷特（Gimlet）的方式，需要柠檬汁和柠檬甜酒（lemon cordial）的鲜明组合，再加上少量的橙味苦精</p><h2 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h2><p><em>Serving: 1</em></p><ul><li>老汤姆金酒（最好是 Ransom）- 1.5 盎司（<a href="https://www.diffordsguide.com/beer-wine-spirits/2344/ransom-old-tom-gin">Ransom Old Tom Gin</a>）</li><li>柠檬甜酒 - 1 盎司（见注释）</li><li>海军力量金酒 - 0.5 盎司（最好是 Hayman’s Royal Dock <a href="https://www.diffordsguide.com/beer-wine-spirits/3066/haymans-royal-dock-of-deptford-gin">Hayman’s Royal Dock of Deptford Gin</a>）</li><li>柠檬汁 - 0.5 盎司</li><li>橙味苦精 - 3 dashes</li><li>苏打水 - 加满</li></ul><p><strong>装饰：</strong>安高天娜苦精、柠檬轮、糖霜、吸管</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>将前五种原料加入摇壶中，加冰进行 shake</li><li>滤入加冰的 12 盎司柯林斯玻璃杯中，将安高天娜苦精滴浮在表面</li><li>用柠檬轮和糖霜装饰，插入吸管</li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="柠檬甜酒（Lemon-Cordial）"><a href="#柠檬甜酒（Lemon-Cordial）" class="headerlink" title="柠檬甜酒（Lemon Cordial）"></a>柠檬甜酒（Lemon Cordial）</h3><p>将 10 个柠檬皮、32 盎司白糖和 1 盎司伏特加放在容器中混合，经过一夜或放置 12 小时</p><p>加入 32 盎司柠檬汁，搅拌至白糖溶解</p><p>过滤（fine-strain）</p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 酒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸡尾酒 </tag>
            
            <tag> recipes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoogleCode ConcurrentLinkedHashMap</title>
      <link href="/2023/04/09/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/GoogleCode%20ConcurrentLinkedHashMap/"/>
      <url>/2023/04/09/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/GoogleCode%20ConcurrentLinkedHashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><h2 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h2><p>ConcurrentLinkedHashMap 构造方法私有，只能通过其静态内部类 <code>Builder</code> 来进行实例化</p><blockquote><p>一个完全支持并发检索的哈希表，可调节更新预期并发度，以及限制其最大容量</p><p>该实现与 <code>ConcurrentHashMap</code> 的不同之处在于维护了一个页面替换算法（page replacement algorithm），用于在 map 超出容量时删除元素</p><p>这个 map 实现没有共有的构造器，它的实例是通过 <code>Builder</code> 创建的</p></blockquote><p><code>Builder</code> 支持链式赋值，使用如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ConcurrentLinkedHashMap&lt;Integer, String&gt; map =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedHashMap</span>.Builder&lt;Integer, String&gt;()</span><br><span class="line">            .maximumWeightedCapacity(<span class="number">2</span>)</span><br><span class="line">            .weigher(Weighers.singleton())</span><br><span class="line">            .listener((key, value) -&gt; System.out.println(<span class="string">&quot;元素被丢弃了 key=&quot;</span> + key + <span class="string">&quot; value=&quot;</span> + value))</span><br><span class="line">            .concurrencyLevel(<span class="number">32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>build()</code> 方法进行 <code>ConcurrentLinkedHashMap </code> 的实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConcurrentLinkedHashMap&lt;K, V&gt; <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">  checkState(capacity &gt;= <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedHashMap</span>&lt;K, V&gt;(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到如果 <code>capacity</code>，即 <code>maximumWeightedCapacity</code> 未进行赋值，则会抛出异常，其他参数均有默认值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 默认为 -1，结合上面的逻辑，不进行赋值实例化时会抛出异常</span></span><br><span class="line">  capacity = -<span class="number">1</span>;</span><br><span class="line">  weigher = Weighers.entrySingleton();</span><br><span class="line">  initialCapacity = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">  concurrencyLevel = DEFAULT_CONCURRENCY_LEVEL;</span><br><span class="line">  listener = (EvictionListener&lt;K, V&gt;) DiscardingListener.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="maximumWeightedCapacity"><a href="#maximumWeightedCapacity" class="headerlink" title="maximumWeightedCapacity"></a>maximumWeightedCapacity</h2><p>表示该 map 最大能够允许的最大重量，并且有可能暂时超过它（我理解可能驱逐元素是一个惰性过程）</p><p>在实例化 <code>ConcurrentLinkedHashMap</code> 时，使用原子类作为容量的记录器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ConcurrentLinkedHashMap</span><span class="params">(Builder&lt;K, V&gt; builder)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    capacity = <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(Math.min(builder.capacity, MAXIMUM_CAPACITY));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及 <code>capacity</code> 的方法：</p><ul><li>capacity：获取当前 capacity</li><li>setCapacity：设置 capacity</li><li>hasOverflowed：判断当前重量大小是否超过了 capacity</li></ul><h2 id="initialCapacity"><a href="#initialCapacity" class="headerlink" title="initialCapacity"></a>initialCapacity</h2><p>表示初始化底层存放元素的 map 容量，默认为 16</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ConcurrentLinkedHashMap</span><span class="params">(Builder&lt;K, V&gt; builder)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    data = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMapV8</span>&lt;K, Node&lt;K, V&gt;&gt;(builder.initialCapacity, <span class="number">0.75f</span>, concurrencyLevel);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentLinkedHashMap 底层实现存储的结构是 <code>ConcurrentHashMapV8</code>，看到其参数和 JUC 下面的 <code>ConcurrentHashMap</code> 一样大致就可以猜到该参数的作用，本质上也是在预估数据量来避免频繁 resize 操作</p><p>对于该参数是如何用于实例化 <code>ConcurrentHashMapV8</code> ，在后面的 <code>concurrencyLevel</code> 参数进行展示</p><p>该参数只用于实例化 <code>ConcurrentHashMapV8</code></p><h2 id="concurrencyLevel"><a href="#concurrencyLevel" class="headerlink" title="concurrencyLevel"></a>concurrencyLevel</h2><p>预估的并发线程数</p><p>和 <code>initialCapacity</code> 参数一样，都是为了实例化 <code>ConcurrentHashMapV8</code>，其参数的作用也和 <code>ConcurrentHashMap</code> 一样（作者都是 Doug Lea）</p><p><code>ConcurrentHashMap</code> 提高并发性能的思想就是 cell 化，按照底层 Entry 数组头元素作为并发粒度，那么 <code>concurrencyLevel</code> 和 <code>initialCapacity</code> 这两个参数必然同时影响底层数组的大小创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMapV8</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + initialCapacity / loadFactor);</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="weigher"><a href="#weigher" class="headerlink" title="weigher"></a>weigher</h2><p>重量器，用来衡量一个元素占用了多少重量，默认为 <code>SingletonWeigher</code></p><p>因为 ConcurrentLinkedHashMap 的核心功能是在限制 map 内元素的占用，那么衡量一个元素的权重就被抽象为了 <code>Weigher</code></p><p>其中除了 <code>Weigher</code> 还提供了 <code>EntryWeigher</code> 的抽象，用于对整个 KV 进行重量的衡量</p><p>对于 <code>Weigher</code> 实现，会被转换为 <code>EntryWeigher</code> 实现（统一入口）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Builder&lt;K, V&gt; <span class="title function_">weigher</span><span class="params">(Weigher&lt;? <span class="built_in">super</span> V&gt; weigher)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.weigher = (weigher == Weighers.singleton())</span><br><span class="line">      ? Weighers.&lt;K, V&gt;entrySingleton()</span><br><span class="line">      : <span class="keyword">new</span> <span class="title class_">BoundedEntryWeigher</span>&lt;K, V&gt;(Weighers.asEntryWeigher(weigher));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>EntryWeigherView</code> 就是用来将 <code>Weigher</code> 包装为 <code>EntryWeigher</code> 的实现</p><p>列举一些自带的实现</p><ul><li>Weigher<ul><li>SingletonWeigher：一个 value 的重量视为 1</li><li>CollectionWeigher：value 为集合类型，重量为集合的 size</li><li>ListWeigher：value 为 list 类型，重量为 list 的 size</li><li>MapWeigher：value 为 map 类型，重量为 map 的 size</li></ul></li><li>EntryWeigher<ul><li>BoundedEntryWeigher：内部为 <code>EntryWeigher</code> 实现，要求重量大于等于 1</li><li>SingletonEntryWeigher：一个 KV 的重量视为 1</li><li>EntryWeigherView：用于包装 <code>Weigher</code> 的实现</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ConcurrentLinkedHashMap</span><span class="params">(Builder&lt;K, V&gt; builder)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// The eviction support</span></span><br><span class="line">    weigher = builder.weigher;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该参数会在 put 元素以及一系列获取 ordered 视图操作中被使用</p><h2 id="listener"><a href="#listener" class="headerlink" title="listener"></a>listener</h2><p><code>EvictionListener</code> 的实现，用于驱逐元素时调用该实现的 <code>onEviction(K key, V value)</code> 方法进行通知</p><p>默认值为 <code>DiscardingListener.INSTANCE</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ConcurrentLinkedHashMap</span><span class="params">(Builder&lt;K, V&gt; builder)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="comment">// The notification queue and listener</span></span><br><span class="line">    listener = builder.listener;</span><br><span class="line">    pendingNotifications = (listener == DiscardingListener.INSTANCE)</span><br><span class="line">        ? (Queue&lt;Node&lt;K, V&gt;&gt;) DISCARDING_QUEUE</span><br><span class="line">        : <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;Node&lt;K, V&gt;&gt;();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看出，如果 listener 是一个默认值，则 <code>pendingNotifications</code> 也会使用默认队列，其实现就是空实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** A queue that discards all additions and is always empty. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DiscardingQueue</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;Object&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Object e)</span> &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object e)</span> &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Object <span class="title function_">poll</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Object <span class="title function_">peek</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Iterator&lt;Object&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123; <span class="keyword">return</span> emptyList().iterator(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>驱逐元素时不会进行通知，使用了<strong>空对象模式</strong></p><blockquote><p>在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查</p><p>Null 对象不是检查空值，而是反应一个不做任何动作的关系，这样的 Null 对象也可以在数据不可用的时候提供默认的行为</p></blockquote><h1 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h1><p><code>put</code> 和 <code>putIfAbsent</code> 最终都调用 <code>put(K key, V value, boolean onlyIfAbsent)</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> put(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> put(key, value, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">V <span class="title function_">put</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">  <span class="comment">// 入参校验</span></span><br><span class="line">  checkNotNull(key);</span><br><span class="line">  checkNotNull(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算权重</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> weigher.weightOf(key, value);</span><br><span class="line"><span class="comment">// 包装节点</span></span><br><span class="line">  <span class="keyword">final</span> WeightedValue&lt;V&gt; weightedValue = <span class="keyword">new</span> <span class="title class_">WeightedValue</span>&lt;V&gt;(value, weight);</span><br><span class="line">  <span class="keyword">final</span> Node&lt;K, V&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K, V&gt;(key, weightedValue);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// put 调用</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K, V&gt; prior = data.putIfAbsent(node.key, node);</span><br><span class="line">    <span class="comment">// 第一次写入 key，视为一次 Add</span></span><br><span class="line">    <span class="keyword">if</span> (prior == <span class="literal">null</span>) &#123;</span><br><span class="line">      afterWrite(<span class="keyword">new</span> <span class="title class_">AddTask</span>(node, weight));</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 存在 key 并且 onlyIfAbsent = true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent) &#123;</span><br><span class="line">      afterRead(prior);</span><br><span class="line">      <span class="keyword">return</span> prior.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 走到该 case，说明 key 存在并且 onlyIfAbsent = false</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">final</span> WeightedValue&lt;V&gt; oldWeightedValue = prior.get();</span><br><span class="line">     <span class="comment">// 并发错误下跳出，由 data.putIfAbsent(node.key, node) 继续取值</span></span><br><span class="line">      <span class="keyword">if</span> (!oldWeightedValue.isAlive()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 更新权重，视情况进行 Update 或者 read</span></span><br><span class="line">      <span class="keyword">if</span> (prior.compareAndSet(oldWeightedValue, weightedValue)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">weightedDifference</span> <span class="operator">=</span> weight - oldWeightedValue.weight;</span><br><span class="line">        <span class="keyword">if</span> (weightedDifference == <span class="number">0</span>) &#123;</span><br><span class="line">          afterRead(prior);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          afterWrite(<span class="keyword">new</span> <span class="title class_">UpdateTask</span>(prior, weightedDifference));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldWeightedValue.value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算权重"><a href="#计算权重" class="headerlink" title="计算权重"></a>计算权重</h2><p>经过参数校验后，首先要进行权重的计算和包装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算权重</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> weigher.weightOf(key, value);</span><br><span class="line"><span class="comment">// 包装节点</span></span><br><span class="line"><span class="keyword">final</span> WeightedValue&lt;V&gt; weightedValue = <span class="keyword">new</span> <span class="title class_">WeightedValue</span>&lt;V&gt;(value, weight);</span><br><span class="line"><span class="keyword">final</span> Node&lt;K, V&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K, V&gt;(key, weightedValue);</span><br></pre></td></tr></table></figure><p>权重的计算就是调用了 <code>EntryWeigher</code> 实现的 <code>weightOf()</code> 方法</p><p>随后将权重值和 value 包装进 <code>WeightedValue</code>，并包装为 <code>Node</code></p><p><code>Node</code> 即为链表的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">AtomicReference</span>&lt;WeightedValue&lt;V&gt;&gt; <span class="keyword">implements</span> <span class="title class_">Linked</span>&lt;Node&lt;K, V&gt;&gt;</span><br></pre></td></tr></table></figure><p>整个保存 KV 的核心结构（上面提到的 <code>ConcurrentHashMapV8</code>）保存的其实是 key 和 <code>Node</code> 的数据：<code>final ConcurrentMap&lt;K, Node&lt;K, V&gt;&gt; data;</code></p><h2 id="无冲突"><a href="#无冲突" class="headerlink" title="无冲突"></a>无冲突</h2><p>随后调用 <code>data</code> 的 <code>putIfAbsent</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K, V&gt; prior = data.putIfAbsent(node.key, node);</span><br></pre></td></tr></table></figure><p>根据返回的 prior 节点情况，判断后续流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次写入 key，视为一次 Add</span></span><br><span class="line">  <span class="keyword">if</span> (prior == <span class="literal">null</span>) &#123;</span><br><span class="line">    afterWrite(<span class="keyword">new</span> <span class="title class_">AddTask</span>(node, weight));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 存在 key 并且 onlyIfAbsent = true，视为一次 Read</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent) &#123;</span><br><span class="line">    afterRead(prior);</span><br><span class="line">    <span class="keyword">return</span> prior.getValue();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这两种情况均可以视为无冲突情况：</p><ul><li>不存在 prior</li><li>存在 prior 但是 onlyIfAbsent &#x3D; true</li></ul><p>随后执行相应的 Add 或者 Read 任务（后面解释任务的操作）</p><h2 id="需要更新"><a href="#需要更新" class="headerlink" title="需要更新"></a>需要更新</h2><p>当 key 已经存在，那么上述 put 方法其实并未完成，只是返回了 K 对应的 value 对象（节点）</p><p>可以猜测下面流程需要做的操作：</p><ul><li>替换 key 对应的 value；因为 value 和权重是绑定关系，也即替换了权重</li><li>进行 Task 流程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 走到该 case，说明 key 存在并且 onlyIfAbsent = false</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="keyword">final</span> WeightedValue&lt;V&gt; oldWeightedValue = prior.get();</span><br><span class="line">  <span class="comment">// 并发错误下跳出，由 data.putIfAbsent(node.key, node) 继续取值</span></span><br><span class="line">  <span class="keyword">if</span> (!oldWeightedValue.isAlive()) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新权重，视情况进行 Update 或 Read</span></span><br><span class="line">  <span class="keyword">if</span> (prior.compareAndSet(oldWeightedValue, weightedValue)) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">weightedDifference</span> <span class="operator">=</span> weight - oldWeightedValue.weight;</span><br><span class="line">    <span class="keyword">if</span> (weightedDifference == <span class="number">0</span>) &#123;</span><br><span class="line">      afterRead(prior);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      afterWrite(<span class="keyword">new</span> <span class="title class_">UpdateTask</span>(prior, weightedDifference));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldWeightedValue.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先获取 prior 节点的 <code>WeightedValue</code> 结构，当该结构 <code>isAlive()</code> 为 false 时，说明现在的 prior 节点在并发环境下已经成为过去式了，需要跳出循环，重新进行最开始的获取流程</li><li>当旧节点没问题，就会调用 CAS 方法来替换新的 weight 和 value，如果替换成功则会根据权重差值来进行 Read 或者 Update 任务</li><li>如果 CAS 失败，则会继续对节点进行判断，重复流程</li></ol><h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><h2 id="按-K-删除"><a href="#按-K-删除" class="headerlink" title="按 K 删除"></a>按 K 删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;K, V&gt; node = data.remove(key);</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  makeRetired(node);</span><br><span class="line">  afterWrite(<span class="keyword">new</span> <span class="title class_">RemovalTask</span>(node));</span><br><span class="line">  <span class="keyword">return</span> node.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先依赖 <code>data</code> 的 <code>remove(key)</code> 方法，拿到节点后进行判断，如果等于 null，说明该 key 没有对应的值，就不需要考虑后续流程了</li><li>如果节点不等 null，需要进行 <code>makeRetired()</code>，本质是修改节点 <code>WeightedValue</code> 的权重为负数（在添加流程中，依靠权重是否为负作为 value 被删除的标志）</li><li>随后进行 Removal 任务</li></ol><h2 id="按-KV-删除"><a href="#按-KV-删除" class="headerlink" title="按 KV 删除"></a>按 KV 删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;K, V&gt; node = data.get(key);</span><br><span class="line">  <span class="keyword">if</span> ((node == <span class="literal">null</span>) || (value == <span class="literal">null</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  WeightedValue&lt;V&gt; weightedValue = node.get();</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (weightedValue.contains(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tryToRetire(node, weightedValue)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.remove(key, node)) &#123;</span><br><span class="line">          afterWrite(<span class="keyword">new</span> <span class="title class_">RemovalTask</span>(node));</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        weightedValue = node.get();</span><br><span class="line">        <span class="keyword">if</span> (weightedValue.isAlive()) &#123;</span><br><span class="line">          <span class="comment">// retry as an intermediate update may have replaced the value with</span></span><br><span class="line">          <span class="comment">// an equal instance that has a different reference identity</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在删除的基础上多了对 value 的比较</p><p>当 key 存在时，这里用了多个嵌套判断来实现目的或保证并发：</p><ol><li>value 是否能对应上，对应不上直接返回删除失败</li><li>让 value 退休，调用 <code>tryToRetire(node, weightedValue)</code> 方法，如果失败就重新获取节点的 value，进行存活判断，如果依然存活则重复整个流程（从 1 开始）</li><li>调用 <code>data.remove(key, node)</code> 方法，如果成功则进行 Removal 任务，失败则重新整个流程</li></ol><h2 id="tryToRetire"><a href="#tryToRetire" class="headerlink" title="tryToRetire"></a>tryToRetire</h2><p>在上述删除流程中，都需要调用 <code>tryToRetire</code> 方法</p><p>本质上是将节点置为失效状态，失效状态根据节点 value 中的 <code>WeightedValue</code> 的 <code>weight</code> 来标示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">tryToRetire</span><span class="params">(Node&lt;K, V&gt; node, WeightedValue&lt;V&gt; expect)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (expect.isAlive()) &#123;</span><br><span class="line">    <span class="keyword">final</span> WeightedValue&lt;V&gt; retired = <span class="keyword">new</span> <span class="title class_">WeightedValue</span>&lt;V&gt;(expect.value, -expect.weight);</span><br><span class="line">    <span class="keyword">return</span> node.compareAndSet(expect, retired);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后置读写"><a href="#后置读写" class="headerlink" title="后置读写"></a>后置读写</h1><p>在上述流程中，各种操作都离不开调用 <code>afterRead</code> 和 <code>afterWrite</code> 方法</p><p>后置读写的操作本质上就是在调整链表结构来实现 LRU，对元素进行写入、驱逐和排序</p><h2 id="afterWrite"><a href="#afterWrite" class="headerlink" title="afterWrite"></a>afterWrite</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterWrite</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">    <span class="comment">// 写缓冲区添加任务</span></span><br><span class="line">    writeBuffer.add(task);</span><br><span class="line">    <span class="comment">// 设置 drain 状态为 REQUIRED</span></span><br><span class="line">    drainStatus.lazySet(REQUIRED);</span><br><span class="line">    <span class="comment">// 执行缓冲区的任务</span></span><br><span class="line">    tryToDrainBuffers();</span><br><span class="line">    <span class="comment">// 通知监听器</span></span><br><span class="line">    notifyListener();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 drainStatus 是一个被 <code>AtomicReference</code> 包装的 <code>DrainStatus</code>，代表当前缓冲操作的状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">DrainStatus</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** A drain is not taking place. */</span></span><br><span class="line">    IDLE &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="type">boolean</span> <span class="title function_">shouldDrainBuffers</span><span class="params">(<span class="type">boolean</span> delayable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !delayable;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** A drain is required due to a pending write modification. */</span></span><br><span class="line">    REQUIRED &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="type">boolean</span> <span class="title function_">shouldDrainBuffers</span><span class="params">(<span class="type">boolean</span> delayable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** A drain is in progress. */</span></span><br><span class="line">    PROCESSING &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="type">boolean</span> <span class="title function_">shouldDrainBuffers</span><span class="params">(<span class="type">boolean</span> delayable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Determines whether the buffers should be drained.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delayable if a drain should be delayed until required</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> if a drain should be attempted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">shouldDrainBuffers</span><span class="params">(<span class="type">boolean</span> delayable)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 drainStatus 被并发安全并 lazy 设置为 <code>REQUIRED</code> 后，<code>tryToDrainBuffers()</code> 方法来执行对缓冲区的操作</p><p><strong>tryToDrainBuffers</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">tryToDrainBuffers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (evictionLock.tryLock()) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            drainStatus.lazySet(PROCESSING);</span><br><span class="line">            drainBuffers();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            drainStatus.compareAndSet(PROCESSING, IDLE);</span><br><span class="line">            evictionLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取锁资格，evictionLock 是一个 <code>ReentrantLock</code>：<code>evictionLock = new ReentrantLock();</code></p><p>再将 drainStatus 状态设置为 <code>PROCESSING</code>；最后调用核心的 <code>drainBuffers</code> 方法</p><p>当执行结束后将 drainStatus CAS 修改为 <code>IDLE</code>，进行解锁</p><h2 id="afterRead"><a href="#afterRead" class="headerlink" title="afterRead"></a>afterRead</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterRead</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 buffer 的 index，这里为了避免对热 entries 的争抢</span></span><br><span class="line">    <span class="comment">// 个人理解类似针对缓冲区的 cell 机制</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">bufferIndex</span> <span class="operator">=</span> readBufferIndex();</span><br><span class="line">    <span class="comment">// 根据 bufferIndex 将 node 记录在 readBuffer 中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">writeCount</span> <span class="operator">=</span> recordRead(bufferIndex, node);</span><br><span class="line">    <span class="comment">// drain 操作</span></span><br><span class="line">    drainOnReadIfNeeded(bufferIndex, writeCount);</span><br><span class="line">    <span class="comment">// 通知监听器</span></span><br><span class="line">    notifyListener();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>recordRead</code> 的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">recordRead</span><span class="params">(<span class="type">int</span> bufferIndex, Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">    <span class="comment">// The location in the buffer is chosen in a racy fashion as the increment</span></span><br><span class="line">    <span class="comment">// is not atomic with the insertion. This means that concurrent reads can</span></span><br><span class="line">    <span class="comment">// overlap and overwrite one another, resulting in a lossy buffer.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">counter</span> <span class="operator">=</span> readBufferWriteCount[bufferIndex];</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">writeCount</span> <span class="operator">=</span> counter.get();</span><br><span class="line">    counter.lazySet(writeCount + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) (writeCount &amp; READ_BUFFER_INDEX_MASK);</span><br><span class="line">    readBuffers[bufferIndex][index].lazySet(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> writeCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取 readBufferWriteCount 的 counter 的 value 后 +1 写入</p><blockquote><p>这里注释中说明了这个操作不是原子的，意味着可以并发读取，并且会导致 buffer 的重叠和覆盖，还不清楚为什么这样处理</p><p>根据后续代码这里记录的 count 主要是用于控制读缓冲区的 drain 操作，可能不需要那么准确，猜测这样处理的原因是因为没必要为了并发安全牺牲性能</p></blockquote><p>随后将 node 记录在 readBuffers 中</p><p><strong>drainOnReadIfNeeded</strong></p><p>该方法就是用于 drain 读缓冲区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">drainOnReadIfNeeded</span><span class="params">(<span class="type">int</span> bufferIndex, <span class="type">long</span> writeCount)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 pending 数量，当前线程对应缓冲区在上一步操作的写数量 - 读缓冲区处理的数量（计算差值判断是否到了需要刷新的阈值）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">pending</span> <span class="operator">=</span> (writeCount - readBufferDrainAtWriteCount[bufferIndex].get());</span><br><span class="line">    <span class="comment">// READ_BUFFER_THRESHOLD = 32</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">delayable</span> <span class="operator">=</span> (pending &lt; READ_BUFFER_THRESHOLD);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">DrainStatus</span> <span class="variable">status</span> <span class="operator">=</span> drainStatus.get();</span><br><span class="line">    <span class="comment">// 判断是否需要 drain</span></span><br><span class="line">    <span class="keyword">if</span> (status.shouldDrainBuffers(delayable)) &#123;</span><br><span class="line">    tryToDrainBuffers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据读 count 计算 pending 数量，根据 pending 值来判断是否执行 drain 操作</p><p>其中对于操作的判断来自于 <code>DrainStatus</code>，即状态枚举实现的抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">DrainStatus</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** A drain is not taking place. */</span></span><br><span class="line">    IDLE &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="type">boolean</span> <span class="title function_">shouldDrainBuffers</span><span class="params">(<span class="type">boolean</span> delayable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !delayable;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** A drain is required due to a pending write modification. */</span></span><br><span class="line">    REQUIRED &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="type">boolean</span> <span class="title function_">shouldDrainBuffers</span><span class="params">(<span class="type">boolean</span> delayable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** A drain is in progress. */</span></span><br><span class="line">    PROCESSING &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="type">boolean</span> <span class="title function_">shouldDrainBuffers</span><span class="params">(<span class="type">boolean</span> delayable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Determines whether the buffers should be drained.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delayable if a drain should be delayed until required</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> if a drain should be attempted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">shouldDrainBuffers</span><span class="params">(<span class="type">boolean</span> delayable)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到：</p><ul><li>对于 <code>REQUIRED</code>，说明需要立即刷新缓冲区（这个状态最直接是来自于写操作）</li><li>对于 <code>PROCESSING</code>，说明当前其他线程正在处理，所以不需要该线程再进行操作了</li><li>对于 <code>IDLE</code>，则根据 pending 数量得到的 delayable 来判断</li></ul><p>最后也是调用 <code>tryToDrainBuffers</code> 方法来对缓冲区进行 drain 操作</p><h2 id="drainWriteBuffer"><a href="#drainWriteBuffer" class="headerlink" title="drainWriteBuffer"></a>drainWriteBuffer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">drainWriteBuffer</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; WRITE_BUFFER_DRAIN_THRESHOLD; i++) &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> writeBuffer.poll();</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    task.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取一定数量的 task，然后执行 task 的 run 方法</p><p>每一次 drain 操作都有一个阈值（WRITE_BUFFER_DRAIN_THRESHOLD &#x3D; 16），应该是为每个线程分摊工作量，在 read 中也是这样类似的设计</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/** Adds the node to the page replacement policy. */</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AddTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K, V&gt; node;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">    AddTask(Node&lt;K, V&gt; node, <span class="type">int</span> weight) &#123;</span><br><span class="line">      <span class="built_in">this</span>.weight = weight;</span><br><span class="line">      <span class="built_in">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;evictionLock&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      weightedSize.lazySet(weightedSize.get() + weight);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ignore out-of-order write operations</span></span><br><span class="line">      <span class="keyword">if</span> (node.get().isAlive()) &#123;</span><br><span class="line">        evictionDeque.add(node);</span><br><span class="line">        evict();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes a node from the page replacement policy. */</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RemovalTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K, V&gt; node;</span><br><span class="line"></span><br><span class="line">    RemovalTask(Node&lt;K, V&gt; node) &#123;</span><br><span class="line">      <span class="built_in">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;evictionLock&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// add may not have been processed yet</span></span><br><span class="line">      evictionDeque.remove(node);</span><br><span class="line">      makeDead(node);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Updates the weighted size and evicts an entry on overflow. */</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">UpdateTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> weightDifference;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K, V&gt; node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UpdateTask</span><span class="params">(Node&lt;K, V&gt; node, <span class="type">int</span> weightDifference)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.weightDifference = weightDifference;</span><br><span class="line">      <span class="built_in">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;evictionLock&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      weightedSize.lazySet(weightedSize.get() + weightDifference);</span><br><span class="line">      applyRead(node);</span><br><span class="line">      evict();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>对于 task 的实现，有 3 种：</p><ul><li><code>AddTask</code><ul><li>调整 weight</li><li><code>evictionDeque</code> 添加节点（尾插）</li><li>调用驱逐方法 <code>evict</code></li></ul></li><li><code>RemovalTask</code><ul><li><code>evictionDeque</code> 移除节点</li><li>设置节点 dead（包括调整 weight）</li></ul></li><li><code>UpdateTask</code><ul><li>调整 weight</li><li>调整 node 到尾部</li><li>调用驱逐方法 <code>evict</code></li></ul></li></ul><p><strong>为什么 <code>UpdateTask</code> 也需要驱逐元素？</strong>因为 weight 的计算方法是由实现类提供的，可能根据不同的情况计算 weight，更新操作也可能更新 weight，所以需要进行驱逐操作</p><p><strong>驱逐方法 evict</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">evict</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Attempts to evict entries from the map if it exceeds the maximum</span></span><br><span class="line">    <span class="comment">// capacity. If the eviction fails due to a concurrent removal of the</span></span><br><span class="line">    <span class="comment">// victim, that removal may cancel out the addition that triggered this</span></span><br><span class="line">    <span class="comment">// eviction. The victim is eagerly unlinked before the removal task so</span></span><br><span class="line">    <span class="comment">// that if an eviction is still required then a new victim will be chosen</span></span><br><span class="line">    <span class="comment">// for removal.</span></span><br><span class="line">    <span class="comment">// 判断是否超过 weight 阈值</span></span><br><span class="line">    <span class="keyword">while</span> (hasOverflowed()) &#123;</span><br><span class="line">      <span class="keyword">final</span> Node&lt;K, V&gt; node = evictionDeque.poll();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If weighted values are used, then the pending operations will adjust</span></span><br><span class="line">      <span class="comment">// the size to reflect the correct weight</span></span><br><span class="line">      <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Notify the listener only if the entry was evicted</span></span><br><span class="line">      <span class="keyword">if</span> (data.remove(node.key, node)) &#123;</span><br><span class="line">        <span class="comment">// 待通知队列</span></span><br><span class="line">        pendingNotifications.add(node);</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">// 标记删除</span></span><br><span class="line">      makeDead(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法就是为了实现 LRU，如果超出了 weight，则会从 <code>evictionDeque</code> 中 poll 出元素后，记录待通知队列，标记删除</p><p>标记删除删除的是 Map 结构中的元素（修改其 weight 标记删除），其中 node 也是 Map 中持有的引用</p><h2 id="drainReadBuffers"><a href="#drainReadBuffers" class="headerlink" title="drainReadBuffers"></a>drainReadBuffers</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">drainReadBuffers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> (<span class="type">int</span>) Thread.currentThread().getId();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start + NUMBER_OF_READ_BUFFERS;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">    drainReadBuffer(i &amp; READ_BUFFERS_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">drainReadBuffer</span><span class="params">(<span class="type">int</span> bufferIndex)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">writeCount</span> <span class="operator">=</span> readBufferWriteCount[bufferIndex].get();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; READ_BUFFER_DRAIN_THRESHOLD; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) (readBufferReadCount[bufferIndex] &amp; READ_BUFFER_INDEX_MASK);</span><br><span class="line">      <span class="keyword">final</span> AtomicReference&lt;Node&lt;K, V&gt;&gt; slot = readBuffers[bufferIndex][index];</span><br><span class="line">      <span class="keyword">final</span> Node&lt;K, V&gt; node = slot.get();</span><br><span class="line">      <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      slot.lazySet(<span class="literal">null</span>);</span><br><span class="line">      <span class="comment">// 本质上就是将 evictionDeque 中对应的 node 移动到队尾（LRU）</span></span><br><span class="line">      applyRead(node);</span><br><span class="line">      readBufferReadCount[bufferIndex]++;</span><br><span class="line">&#125;</span><br><span class="line">readBufferDrainAtWriteCount[bufferIndex].lazySet(writeCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述操作可以概括成几个要点：</p><ul><li>每一次 drain 操作分配了 buffer 操作的阈值</li><li>获取 node，释放 node</li><li>将 node 移动到队尾</li><li>记录 readBufferDrainAtWriteCount</li></ul><h1 id="驱逐监听器"><a href="#驱逐监听器" class="headerlink" title="驱逐监听器"></a>驱逐监听器</h1><p>最后就是 <code>notifyListener</code> 方法调用 <code>EvictionListener</code> 的实现来进行元素驱逐的通知功能</p><p>相关的方法在 <code>afterRead</code>、<code>afterWrite</code>、<code>setCapacity</code> 中被调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">notifyListener</span><span class="params">()</span> &#123;</span><br><span class="line">    Node&lt;K, V&gt; node;</span><br><span class="line">    <span class="keyword">while</span> ((node = pendingNotifications.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">  listener.onEviction(node.key, node.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历 pendingNotifications 中被驱逐的 node，调用 listener 的 <code>onEviction</code> 方法</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/ben-manes/concurrentlinkedhashmap">ben-manes&#x2F;concurrentlinkedhashmap: A ConcurrentLinkedHashMap for Java (github.com)</a></p><p><a href="https://code.google.com/p/concurrentlinkedhashmap/">https://code.google.com/p/concurrentlinkedhashmap/</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空对象模式 - Null Object</title>
      <link href="/2023/04/01/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F%20-%20Null%20Object/"/>
      <url>/2023/04/01/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F%20-%20Null%20Object/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>空对象模式（Null Object Pattern），使用空对象的行为（空实现、校验等）来代替对 Null 值的判断；空对象并不是在检查空值，而是通过对象的行为实现不进行任何动作或者校验的效果，以此对调用方隐藏更多的实现细节</p><p><strong>目的</strong><br>向上层隐藏更多的实现细节，加强系统的稳定性，减少判空判断</p><p><strong>现实世界类比</strong><br>在现实世界中也很难表达 ”空“ 这个概念，往往会使用 ”空盒子“、”空间“ 来进行表达，类比在代码中就是使用表现空概念的对象，而不是判空 <code>obj == null</code> 来实现对空的判断</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>模拟这样一个场景，对用户展示一些商品信息，其中要根据用户的属性对商品进行过滤</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>对于最终过滤后的商品，如果无法满足一定数量，例如商品数量 &lt; 3，就会从通用商品池中选择一定数量的商品进行补位</p><p>这样的需求在代码流程中如何设计，如果在过滤流程、VO 转换流程等阶段来实现，就会让逻辑看起来不太顺畅</p><p>这时就可以考虑使用空对象模式</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="全部商品信息"><a href="#全部商品信息" class="headerlink" title="全部商品信息"></a>全部商品信息</h3><p>先定义出一个商品信息集合，当然这些商品信息可以通过接口、数据库系统等来获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodsInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Pair&lt;Integer, Integer&gt; ageRange;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;GoodsInfo&gt; <span class="title function_">getAllGoodsInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">GoodsInfo</span>(<span class="string">&quot;洗衣机&quot;</span>, <span class="number">10</span>, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">20</span>, <span class="number">50</span>), BigDecimal.valueOf(<span class="number">2000.0</span>)),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">GoodsInfo</span>(<span class="string">&quot;笔记本电脑&quot;</span>, <span class="number">21</span>, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">15</span>, <span class="number">50</span>), BigDecimal.valueOf(<span class="number">4999.0</span>)),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">GoodsInfo</span>(<span class="string">&quot;扫地机器人&quot;</span>, <span class="number">5</span>, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">25</span>, <span class="number">55</span>), BigDecimal.valueOf(<span class="number">2500.0</span>)),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">GoodsInfo</span>(<span class="string">&quot;厨具&quot;</span>, <span class="number">30</span>, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">30</span>, <span class="number">60</span>), BigDecimal.valueOf(<span class="number">89.0</span>)),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">GoodsInfo</span>(<span class="string">&quot;文具&quot;</span>, <span class="number">100</span>, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">8</span>, <span class="number">30</span>), BigDecimal.valueOf(<span class="number">30.0</span>)),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">GoodsInfo</span>(<span class="string">&quot;空调&quot;</span>, <span class="number">6</span>, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">30</span>, <span class="number">60</span>), BigDecimal.valueOf(<span class="number">5100.0</span>)),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">GoodsInfo</span>(<span class="string">&quot;儿童玩具&quot;</span>, <span class="number">40</span>, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">10</span>, <span class="number">50</span>), BigDecimal.valueOf(<span class="number">100.0</span>))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户类"><a href="#用户类" class="headerlink" title="用户类"></a>用户类</h3><p>一个简单的用户信息，后续业务将会根据 <code>age</code> 和 <code>expectPrice</code> 属性对展示的商品进行过滤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Pair&lt;BigDecimal, BigDecimal&gt; expectPrice;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤规则接口及实现"><a href="#过滤规则接口及实现" class="headerlink" title="过滤规则接口及实现"></a>过滤规则接口及实现</h3><p>提供过滤规则接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GoodsFilterHandler</span> &#123;</span><br><span class="line">    List&lt;GoodsInfo&gt; <span class="title function_">filter</span><span class="params">(List&lt;GoodsInfo&gt; goodsInfos, User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>根据年龄进行过滤实现</strong></p><p>根据商品信息上的年龄和用户的年龄进行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgeFilter</span> <span class="keyword">implements</span> <span class="title class_">GoodsFilterHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;GoodsInfo&gt; <span class="title function_">filter</span><span class="params">(<span class="keyword">final</span> List&lt;GoodsInfo&gt; goodsInfos, <span class="keyword">final</span> User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> goodsInfos.stream().filter(</span><br><span class="line">            goodsInfo -&gt; goodsInfo.getAgeRange().getKey() &lt;= user.getAge() &amp;&amp; goodsInfo.getAgeRange().getValue() &gt;= user</span><br><span class="line">                .getAge()).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>根据期望价格区间进行过滤实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExpectPriceFilter</span> <span class="keyword">implements</span> <span class="title class_">GoodsFilterHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;GoodsInfo&gt; <span class="title function_">filter</span><span class="params">(<span class="keyword">final</span> List&lt;GoodsInfo&gt; goodsInfos, <span class="keyword">final</span> User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> goodsInfos.stream().filter(</span><br><span class="line">            goodsInfo -&gt; user.getExpectPrice().getKey().compareTo(goodsInfo.getPrice()) &lt;= <span class="number">0</span></span><br><span class="line">                &amp;&amp; user.getExpectPrice().getValue().compareTo(goodsInfo.getPrice()) &gt;= <span class="number">0</span>).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤流程模板方法及实现"><a href="#过滤流程模板方法及实现" class="headerlink" title="过滤流程模板方法及实现"></a>过滤流程模板方法及实现</h3><p>该抽象类主要进行两部分操作：</p><ul><li>实现类注册过滤器实现</li><li><code>filter</code> 方法根据注册的过滤器实现对结果集进行过滤，其中在最后通过工厂方法对结果集生成不同的 <code>Converter</code> 实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractGoodsFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;GoodsFilterHandler&gt; <span class="title function_">goodsFilterHandlers</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">filter</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        List&lt;GoodsFilterHandler&gt; goodsFilterHandlers = goodsFilterHandlers();</span><br><span class="line">        List&lt;GoodsInfo&gt; curGoods = GoodsInfo.getAllGoodsInfo();</span><br><span class="line">        <span class="keyword">for</span> (GoodsFilterHandler handler : goodsFilterHandlers) &#123;</span><br><span class="line">            curGoods = handler.filter(curGoods, user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成不同的 Converter 实现类</span></span><br><span class="line">        <span class="keyword">return</span> GoodsInfoConverterFactory.buildConverter(curGoods).buildVO();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Common 实现</strong></p><p>注册了过滤规则的两个实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonGoodsFilter</span> <span class="keyword">extends</span> <span class="title class_">AbstractGoodsFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;GoodsFilterHandler&gt; <span class="title function_">goodsFilterHandlers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">AgeFilter</span>(), <span class="keyword">new</span> <span class="title class_">ExpectPriceFilter</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换器工厂与实现"><a href="#转换器工厂与实现" class="headerlink" title="转换器工厂与实现"></a>转换器工厂与实现</h3><ul><li><code>buildConverter</code> 方法根据结果集生成不同的实现类</li><li><code>CommonConverter</code> 没有行为</li><li><code>LackConverter</code> 即空对象模式的实现，会在返回的结果集上补充模拟商品（好吧，感觉这个例子有点牵强）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodsInfoConverterFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_GOODS_INFO_LACK_SIZE</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GoodsInfoConverterFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GoodsInfoConverter <span class="title function_">buildConverter</span><span class="params">(List&lt;GoodsInfo&gt; goodsInfos)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtil.isEmpty(goodsInfos) || goodsInfos.size() &lt; DEFAULT_GOODS_INFO_LACK_SIZE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LackConverter</span>(goodsInfos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonConverter</span>(goodsInfos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GoodsInfoConverter</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> List&lt;GoodsInfo&gt; result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">buildVO</span><span class="params">()</span> &#123;</span><br><span class="line">            List&lt;GoodsInfo&gt; res = convert();</span><br><span class="line">            <span class="keyword">return</span> res.stream().map(GoodsInfo::getName).collect(Collectors.toList());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;GoodsInfo&gt; <span class="title function_">convert</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">GoodsInfoConverter</span><span class="params">(<span class="keyword">final</span> List&lt;GoodsInfo&gt; result)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.result = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CommonConverter</span> <span class="keyword">extends</span> <span class="title class_">GoodsInfoConverter</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">CommonConverter</span><span class="params">(<span class="keyword">final</span> List&lt;GoodsInfo&gt; result)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> List&lt;GoodsInfo&gt; <span class="title function_">convert</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LackConverter</span> <span class="keyword">extends</span> <span class="title class_">GoodsInfoConverter</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LackConverter</span><span class="params">(<span class="keyword">final</span> List&lt;GoodsInfo&gt; result)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> List&lt;GoodsInfo&gt; <span class="title function_">convert</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;GoodsInfo&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(result);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> result.size(); i &lt; DEFAULT_GOODS_INFO_LACK_SIZE; i++) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">GoodsInfo</span>(<span class="string">&quot;模拟商品&quot;</span>, <span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>任意构造一个用户，经过过滤器返回其展示的优先级高的商品</p><p>其中根据过滤规则，用户 1 无法满足 &gt;&#x3D; 3 的条件，所以使用了模拟商品进行补位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    user1.setAge(<span class="number">20</span>);</span><br><span class="line">    user1.setExpectPrice(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(BigDecimal.valueOf(<span class="number">10</span>), BigDecimal.valueOf(<span class="number">500</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user2.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    user2.setAge(<span class="number">50</span>);</span><br><span class="line">    user2.setExpectPrice(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(BigDecimal.valueOf(<span class="number">2000</span>), BigDecimal.valueOf(<span class="number">7000</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="type">CommonGoodsFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonGoodsFilter</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [文具, 儿童玩具, 模拟商品]</span></span><br><span class="line">    List&lt;String&gt; res1 = filter.filter(user1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [洗衣机, 笔记本电脑, 扫地机器人, 空调]</span></span><br><span class="line">    List&lt;String&gt; res2 = filter.filter(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调整规则</strong></p><p>可以看到最终空对象的业务逻辑（这里是判断 size 小于阈值，也可以理解为一种空行为）和整个过滤逻辑无关，业务逻辑中也不需要进行判空（工厂方法除外），对于上游 <code>AbstractGoodsFilter</code> 而言，它只是在执行过滤逻辑，而具体结果集并不关心，结果集的转换由空对象实现来实现</p><p>如果产品需求进行变动，当 size 小于 3 时直接抛出异常，则整个大的业务逻辑都不需要变动，只需要改变空对象的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LackConverter</span> <span class="keyword">extends</span> <span class="title class_">GoodsInfoConverter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LackConverter</span><span class="params">(<span class="keyword">final</span> List&lt;GoodsInfo&gt; result)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;GoodsInfo&gt; <span class="title function_">convert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;推荐商品属性 size &lt; &quot;</span> + DEFAULT_GOODS_INFO_LACK_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>上面的例子在使用空对象实现来进行特殊的业务流程，还可以使用空对象模式来对默认行为进行空实现，这样可以减少上游调用的判空代码</p><p>例如 Google 的 <code>ConcurrentLinkedHashMap</code></p><p>在实例化过程中（使用 <code>ConcurrentLinkedHashMap.Builder</code> 对象），<code>listener</code> 参数的默认值就是一个固定的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;</span><br><span class="line">      capacity = -<span class="number">1</span>;</span><br><span class="line">      weigher = Weighers.entrySingleton();</span><br><span class="line">      initialCapacity = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">      concurrencyLevel = DEFAULT_CONCURRENCY_LEVEL;</span><br><span class="line">      <span class="comment">// 默认实现 DiscardingListener.INSTANCE</span></span><br><span class="line">      listener = (EvictionListener&lt;K, V&gt;) DiscardingListener.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在通过 <code>Builder</code> 进行实例化中，真正创建的 <code>ConcurrentLinkedHashMap</code> 对象会根据默认值设置一个通知队列 <code>pendingNotifications</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ConcurrentLinkedHashMap</span><span class="params">(Builder&lt;K, V&gt; builder)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// The notification queue and listener</span></span><br><span class="line">    listener = builder.listener;</span><br><span class="line">    pendingNotifications = (listener == DiscardingListener.INSTANCE)</span><br><span class="line">        ? (Queue&lt;Node&lt;K, V&gt;&gt;) DISCARDING_QUEUE</span><br><span class="line">        : <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;Node&lt;K, V&gt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是默认值则会使用 <code>DISCARDING_QUEUE</code></p><p><code>DISCARDING_QUEUE</code> 就是一种空实现，会丢弃所有的通知（即不通知）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** A queue that discards all entries. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Queue&lt;?&gt; DISCARDING_QUEUE = <span class="keyword">new</span> <span class="title class_">DiscardingQueue</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** A queue that discards all additions and is always empty. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DiscardingQueue</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Object e)</span> &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object e)</span> &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> Object <span class="title function_">poll</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> Object <span class="title function_">peek</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> Iterator&lt;Object&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123; <span class="keyword">return</span> emptyList().iterator(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>空对象模式的优点：</p><ul><li>它可以加强系统的稳固性，能有有效地防止空指针报错对整个系统的影响，使系统更加稳定</li><li>它能够实现对空对象情况的定制化的控制，能够掌握处理空对象的主动权</li><li>它并不依靠 Client 来保证整个系统的稳定运行</li><li>它通过 <code>isNull</code> 对 <code>==null</code> 的替换，显得更加优雅，更加易懂</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://baike.baidu.com/item/%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/22932789?fr=aladdin">空对象模式_百度百科 (baidu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用信鸽解释 HTTPS</title>
      <link href="/2023/03/07/%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C/%E7%94%A8%E4%BF%A1%E9%B8%BD%E8%A7%A3%E9%87%8A%20HTTPS/"/>
      <url>/2023/03/07/%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C/%E7%94%A8%E4%BF%A1%E9%B8%BD%E8%A7%A3%E9%87%8A%20HTTPS/</url>
      
        <content type="html"><![CDATA[<p>密码学是一门深奥难懂的学科，它充满了数学证明；但除非是正在开发密码系统，否则不必了解太多深层次的知识</p><p>如果你打开这篇文章是希望创造下一代 HTTPS 协议，那么很抱歉，只有“鸽子”是远远不够的；如果你的目的不在于此，那么请欣赏这篇文章</p><h1 id="爱丽丝、鲍勃和-……-鸽子？"><a href="#爱丽丝、鲍勃和-……-鸽子？" class="headerlink" title="爱丽丝、鲍勃和 …… 鸽子？"></a>爱丽丝、鲍勃和 …… 鸽子？</h1><p>在互联网上的任何活动（阅读这篇文章、在 Amazon 平台购买商品、上传猫咪图片）归根结底是同服务器发送或者接收消息</p><p>可能听起来有点抽象，所以让我们想象一下这些信息是由<strong>信鸽</strong>（carrier pigeons）传递的，我知道这个比喻看起来很随意，但相信我，HTTPS 的工作方式是一样的，尽管要快得多</p><p>此外，后面会使用爱丽丝、鲍勃、马洛里来代替服务器、用户和黑客；如果这不是你第一次尝试理解密码概念，你会认出这些名字，因为它们在相关技术文献中被广泛使用</p><h1 id="第一次幼稚的交流"><a href="#第一次幼稚的交流" class="headerlink" title="第一次幼稚的交流"></a>第一次幼稚的交流</h1><p>如果爱丽丝想要发送一条消息给鲍勃，她将这条消息绑在信鸽的腿上让它飞向鲍勃；鲍勃收到了消息，看了看觉得非常好</p><p>但是如果马洛里拦截了爱丽丝正在飞行的信鸽随后替换了消息呢？鲍勃无法知道消息在运输的过程中被篡改了</p><p>这就是 <strong>HTTP</strong> 的工作原理，很可怕对吧，我不会通过 HTTP 发送我的银行凭证，你也不会</p><h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><p>如果爱丽丝和鲍勃很狡猾，他们互相定义了一套加密规则来书写消息，例如将字母表中的每一个字母都位移 3 位来表示</p><p>举个例子：D -&gt; A，E -&gt; B，F -&gt; C，原本的消息 “secret message” 将会被替换成 “pbzobq jbppxdb”</p><p>现在如果马洛里拦截了信鸽，她将无法将信息转换为有意义的内容，也无法理解它的意思，因为她不知道加密方式（secret code）；但是鲍勃可以轻易地将消息反向解码，根据 A -&gt; D，B -&gt; E，C -&gt; F 的规则，将 “pbzobq jbppxdb” 解码回 “secret message”</p><p>成功了！</p><p>这就被称为<strong>对称加密</strong>（symmetric key cryptography），因为如果知道了如何解码，就知道了如何加密</p><p>上面描述的密码通常被称为<strong>凯撒密码</strong>（Caesar cipher）；在现实生活中，我们通常使用更为复杂的方式，但主要思想是一样的</p><h1 id="我们如何确定密钥？"><a href="#我们如何确定密钥？" class="headerlink" title="我们如何确定密钥？"></a>我们如何确定密钥？</h1><p>如果除了发送者和接收者之外没有人知道使用了什么密钥，对称加密是非常安全的；在凯撒密码中，密钥是我们将每个字母移动多少个字母的偏移量；在上述示例中，使用了偏移量 3，也可以使用 4 或 12 等等</p><p>这个例子的问题是，如果爱丽丝和鲍勃在开始用鸽子发送消息之前没有见面，他们将无法安全地建立密钥；如果他们将密钥随消息一起发送，那么马洛里就会拦截并发现密钥，这将会导致马洛里在爱丽丝和鲍勃在给消息加密之后依然可以随意获取、篡改消息</p><p>这就是<strong>中间人攻击</strong>（Man in the Middle Attack）的典型示例，避免这种攻击的唯一方法是一起更改加密系统</p><h1 id="信鸽携带的盒子"><a href="#信鸽携带的盒子" class="headerlink" title="信鸽携带的盒子"></a>信鸽携带的盒子</h1><p>所以爱丽丝和鲍勃想出了一个更好的方案，当鲍勃想要向爱丽丝发送消息时，将遵循以下步骤：</p><ul><li>鲍勃给爱丽丝发送一只鸽子，身上不携带任何信息</li><li>爱丽丝让这只鸽子携带一个盒子，盒子有锁而且是打开状态，钥匙在爱丽丝这里，将鸽子返还给鲍勃</li><li>鲍勃将消息放入盒子，锁上锁，并再次将鸽子发给爱丽丝</li><li>爱丽丝获取到盒子，使用自己的钥匙打开盒子后阅读盒子内的消息</li></ul><p>这种方式马洛里在拦截到信鸽后也无法修改内容，因为他并没有盒子的钥匙；当爱丽丝希望给鲍勃发送消息时，遵循同样的流程</p><p>爱丽丝和鲍勃就是使用了通常称为<strong>非对称加密</strong>（asymmetric key cryptography）的技术，之所以称为<strong>不对称</strong>（asymmetric），是因为即使可以对消息进行加密（锁上盒子），也无法解密消息（打开盒子）</p><p>在技术术语中，盒子被称为<strong>公钥</strong>（public key），盒子外锁的钥匙称为<strong>私钥</strong>（private key）</p><h1 id="如何相信这个盒子？"><a href="#如何相信这个盒子？" class="headerlink" title="如何相信这个盒子？"></a>如何相信这个盒子？</h1><p>如果理解了上述内容，会发现依然存在一个问题；当鲍勃接收到盒子时，如何确定这个盒子发送于爱丽丝而不是马洛里拦截了鸽子，将盒子换成了她持有钥匙的盒子呢？</p><p>爱丽丝决定在盒子上签名，这样当鲍勃收到盒子时，他检查签名就可以知道这是不是爱丽丝发送的盒子</p><p>可能会有人这样想，鲍勃一开始是如何识别爱丽丝的签名的？爱丽丝和鲍勃面临同样的问题，所以他们决定，让泰德来代替爱丽丝来进行签名</p><p>谁是泰特？泰德是一个非常有名、知名且值得信赖的人，泰德给任何个人签名，每个人都相信他只会给合法的人签名</p><p>接下来，泰德只有在确定要求签名的人是爱丽丝的情况下才会在爱丽丝盒子上签名；因此马洛里让泰德在自己的盒子上签上爱丽丝的名字，所以会被鲍勃发现这是一个骗局</p><p>在技术术语中，泰德通常被称为<strong>认证机构</strong>（Certification Authority），您阅读本文时使用的浏览器附带了各种认证机构的签名</p><p>所以当我们第一次连接网络并且相信盒子，是因为我们相信泰德，并且泰德告诉我们这个盒子是合法的</p><h1 id="沉重的盒子"><a href="#沉重的盒子" class="headerlink" title="沉重的盒子"></a>沉重的盒子</h1><p>爱丽丝和鲍勃现在有了一个可靠的通信系统，但他们意识到携带盒子的鸽子比只携带信息的鸽子飞行的要慢，因为盒子有一定重量</p><p>所以他们决定，将使用盒子（非对称加密）来加密密钥，而使用对称密码对消息进行加密（还记得凯撒密码吗？）</p><p>这样就可以两全其美：<strong>兼顾非对称密码的可靠性和对称密码的效率</strong></p><p>在现实世界中，没有飞行缓慢的鸽子，但使用非对称加密消息比使用对称加密更慢，因此我们只使用非对称加密来交换加密密钥</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://baida.dev/articles/https-explained-with-carrier-pigeons">HTTPS explained with carrier pigeons</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰模式 - Decorator</title>
      <link href="/2023/02/19/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%20-%20Decorator/"/>
      <url>/2023/02/19/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%20-%20Decorator/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>装饰模式（Decorator Pattern）也叫装饰器模式，可以实现在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能；它是通过创建一个包装对象（装饰器），也就是装饰来包裹真实的对象（委托对象）</p><p><strong>目的</strong><br>更灵活地对对象方法进行扩展，也可以使多个装饰器共同作用，装饰器之间也可以任意组合</p><p><strong>现实世界类比</strong><br>嵌入式设备，摄像头通过接口连接计算机，安装合适的驱动和软件，整个硬件环境就可以具备摄影机的功能；而在具备摄影功能的基础上再连接新的设备遥控底盘，就变成了可以移动的摄像车</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>模拟一个场景，需要对对象进行序列化，实现一个序列化工具</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>假设要求序列化方式有多种实现，这个没问题，继承接口进行多实现</p><p>现在要对功能进行拓展，增加对于序列化结果的补充方法（PS.直接改变方法逻辑也是可以的，不过后面代码直接使用的 JSON 实现，不太好设置一个修改方法中间逻辑的例子，所以这样看起来有点像代理模式，后面会有我对于装饰模式和代理模式区别的看法），例如对于结果进行摘要或者输出到文件等操作</p><p>在这样的基础上，想要对原有实现方法进行增强、扩展，就需要创建新的实现类，或者再进行一层抽象来达到目的，那如果我需要即进行摘要又进行文件输出呢？</p><p>可以看出此时存在的问题：</p><ul><li>每次对于方法逻辑的修改可能会变动原有代码</li><li>扩展和扩展之间的乘积关系，需要定义更多的抽象</li><li>无法动态插拔实现</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="序列化器接口"><a href="#序列化器接口" class="headerlink" title="序列化器接口"></a>序列化器接口</h3><p>只定义一个序列化方法，传入对象输出序列化后的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">serialize</span><span class="params">(Object obj)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化器实现"><a href="#序列化器实现" class="headerlink" title="序列化器实现"></a>序列化器实现</h3><p>提供两种不同的实现，一种进行 JSON 序列化，一种调用 <code>toString</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSON 序列化器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonSerializer</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// toString 序列化器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToStringSerializer</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(<span class="keyword">final</span> Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化器装饰"><a href="#序列化器装饰" class="headerlink" title="序列化器装饰"></a>序列化器装饰</h3><p>序列化器装饰可以再抽出一个接口继承序列化器接口，这里因为都可以使用同一个 <code>serialize</code> 方法，就不再定义新的接口了</p><p>同时对于序列化器装饰基类，可以定义为抽象类，再使用模板方法来由后续实现类来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializerDecorator</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Serializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SerializerDecorator</span><span class="params">(<span class="keyword">final</span> Serializer serializer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(<span class="keyword">final</span> Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> serializer.serialize(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="摘要序列化器装饰"><a href="#摘要序列化器装饰" class="headerlink" title="摘要序列化器装饰"></a>摘要序列化器装饰</h3><p>重写 <code>serialize</code> 方法，再获取序列化结果后再进行摘要的计算并返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializerDigestDecorator</span> <span class="keyword">extends</span> <span class="title class_">SerializerDecorator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DigestAlgorithm digestAlgorithm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SerializerDigestDecorator</span><span class="params">(<span class="keyword">final</span> Serializer serializer, DigestAlgorithm digestAlgorithm)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(serializer);</span><br><span class="line">        <span class="built_in">this</span>.digestAlgorithm = digestAlgorithm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(<span class="keyword">final</span> Object obj)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="built_in">super</span>.serialize(obj);</span><br><span class="line">        <span class="comment">// 返回的是序列化后的摘要信息</span></span><br><span class="line">        <span class="keyword">return</span> DigestUtil.digester(digestAlgorithm).digestHex(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件输出序列化器装饰"><a href="#文件输出序列化器装饰" class="headerlink" title="文件输出序列化器装饰"></a>文件输出序列化器装饰</h3><p>重写 <code>serialize</code> 方法，在获取序列化结果后，输出至文件并返回序列化数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializerFileDecorator</span> <span class="keyword">extends</span> <span class="title class_">SerializerDecorator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FileWriter fileWriter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SerializerFileDecorator</span><span class="params">(<span class="keyword">final</span> Serializer serializer, String filePath)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(serializer);</span><br><span class="line">        <span class="built_in">this</span>.fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(filePath));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(<span class="keyword">final</span> Object obj)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="built_in">super</span>.serialize(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入文件</span></span><br><span class="line">        fileWriter.write(s);</span><br><span class="line">        fileWriter.flush();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>装饰器和装饰器之间可以任意、不限次数地嵌套，最终的结果会经过每个装饰器和委托对象的处理</p><p>暴露相关的方法还可以实现动态地更新装饰器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// obj</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JSON 序列化器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Serializer</span> <span class="variable">jsonSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonSerializer</span>();</span><br><span class="line">        System.out.println(jsonSerializer.serialize(student));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 包装 digest 装饰</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Serializer</span> <span class="variable">digestDecorator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SerializerDigestDecorator</span>(jsonSerializer, DigestAlgorithm.SHA1);</span><br><span class="line">        System.out.println(digestDecorator.serialize(student));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 包装 file 装饰</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Serializer</span> <span class="variable">fileDecorator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SerializerFileDecorator</span>(digestDecorator, <span class="string">&quot;./serialize.txt&quot;</span>);</span><br><span class="line">        System.out.println(fileDecorator.serialize(student));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// to string 序列化器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Serializer</span> <span class="variable">toStringSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToStringSerializer</span>();</span><br><span class="line">        System.out.println(toStringSerializer.serialize(student));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 包装 digest 装饰 和 file 装饰</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Serializer</span> <span class="variable">toStringFileDecorator</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SerializerFileDecorator</span>(<span class="keyword">new</span> <span class="title class_">SerializerDigestDecorator</span>(toStringSerializer, DigestAlgorithm.MD5),</span><br><span class="line">                <span class="string">&quot;./serialize2.txt&quot;</span>);</span><br><span class="line">        System.out.println(toStringFileDecorator.serialize(student));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="装饰-amp-代理"><a href="#装饰-amp-代理" class="headerlink" title="装饰 &amp; 代理"></a>装饰 &amp; 代理</h1><p>在这里需要讨论一个问题，装饰模式和代理模式都是对方法进行增强或者扩展，那么它们到底有什么区别？</p><p>网络上也有很多讨论，下面是一些观点和我的看法：</p><ul><li><p><strong>组合、聚合是装饰模式，继承是代理模式</strong><br>看起来有一定道理，感觉装饰模式要想实现嵌套的效果是需要使用组合来实现，但也会存在使用组合来实现的代理模式（静态代理）；是不是从一定角度来看的话，组合、聚合、继承这种结构的选择，和实现什么设计模式并无关系？</p><blockquote><p>The real difference is not ownership (composition versus aggregation), but rather type-information.</p><p><a href="https://stackoverflow.com/questions/18618779/differences-between-proxy-and-decorator-pattern">oop - Differences between Proxy and Decorator Pattern - Stack Overflow</a></p></blockquote></li><li><p><strong>装饰模式用于添加功能，代理模式用于增强功能</strong><br>我觉得不合理，设计模式不应该根据 “规范” 来进行分类，也不会根据模糊的描述来命名</p></li><li><p><strong>装饰模式在执行期间才会由客户端控制，使装饰器和委托对象建立联系，在此之前装饰器类只知道委托对象的接口；代理模式在编译期间就已经知道代理对象的具体信息（无论这个对象是通过代理类方法创建还是通过注入）</strong><br>我认为这个是相较而言最有标志性的区别了；装饰的行为发生在代码执行过程中，无论是创建新的装饰器增强委托类，还是取消委托对象的装饰器，都是动态的；而代理类从一开始就明确了自己的委托类</p><blockquote><p>But a <strong>Proxy</strong> <em>always</em> knows the (more) specific type of the delegatee. In other words, the <strong>Proxy</strong> and its delegatee will have the same base type, but the <strong>Proxy</strong> points to some derived type. A <strong>Decorator</strong> points to its own base type. Thus, the difference is in compile-time information about the type of the delegatee.</p></blockquote></li><li><p><strong>装饰模式的委托对象来自外部，代理模式的委托对象可以自已创建</strong><br>引申于上一个观点，对于 “具体信息” 的了解就决定了代理对象可以直接创建出委托对象</p></li></ul><p>事实上网络上对于装饰模式、代理模式的界定也一直在讨论中，感觉不一定需要关注到底什么是装饰什么是代理，还是能够使用合理的设计解决</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用装饰模式可以更灵活地对对象方法进行扩展</p><ul><li>优点<ul><li>无需创建新子类即可扩展对象的行为</li><li>可以在运行时添加或删除对象的功能</li><li>装饰器可以任意组合</li><li>可以将实现了许多不同行为的一个大类拆分为多个较小的类来满足单一职责原则</li></ul></li><li>缺点<ul><li>虽然可以支持运行时添加或删除对象的功能，但是实际实现起来比较困难（装饰栈）</li><li>装饰栈一定是有序的</li><li>初始化代码变得繁杂</li></ul></li></ul><p><strong>装饰模式的适用环境</strong></p><ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责</li><li>需要动态地给一个对象增加功能，这些功能也可以动态地被撤销</li><li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时<br>不能采用继承的情况主要有两种：第一种是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如 <code>final</code> 类）</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://refactoringguru.cn/design-patterns/decorator">装饰设计（装饰者模式 &#x2F; 装饰器模式） (refactoringguru.cn)</a></p><p><a href="https://stackoverflow.com/questions/18618779/differences-between-proxy-and-decorator-pattern">oop - Differences between Proxy and Decorator Pattern - Stack Overflow</a></p><p><a href="https://www.kancloud.cn/digest/xing-designpattern/143730">设计模式（九）装饰模式（Decorator） · 写最好的设计模式专栏 · 看云 (kancloud.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>啤酒花：你需要知道的知识</title>
      <link href="/2023/01/16/%E4%BA%BA%E7%94%9F/%E9%85%92/%E5%95%A4%E9%85%92%E8%8A%B1%EF%BC%9A%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/01/16/%E4%BA%BA%E7%94%9F/%E9%85%92/%E5%95%A4%E9%85%92%E8%8A%B1%EF%BC%9A%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<img src="/2023/01/16/%E4%BA%BA%E7%94%9F/%E9%85%92/%E5%95%A4%E9%85%92%E8%8A%B1%EF%BC%9A%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86/hops.jpg" class=""><p>记录显示第一个喝到啤酒的人距今有 9000 年之久，但奇怪的是，人们使用啤酒花为了防腐，或者为了添加风味和香气的历史并不久远</p><p>如今，啤酒中不添加啤酒花是不可思议的行为；它不仅可以保护啤酒的新鲜，也可以丰富啤酒的味道</p><p>本文将介绍你可能不知道的啤酒花知识，现在是时候了解关于家庭酿造的基本原料之一的新东西了</p><h1 id="认识啤酒花"><a href="#认识啤酒花" class="headerlink" title="认识啤酒花"></a>认识啤酒花</h1><h2 id="什么是啤酒花"><a href="#什么是啤酒花" class="headerlink" title="什么是啤酒花"></a>什么是啤酒花</h2><p>啤酒花来自啤酒花植物雌株，也被称为 Humulus Lupulus；它们的形状像一个倒置的绿色松果，啤酒花是这种特殊植物的花朵；奇怪的事实是：酒花不是葡萄藤，它是一个茎，这意味着植物不会用卷须而是用它的嫩枝来攀爬</p><p>酿酒师使用包含在这些花中的精油和树脂，你必须将其叶子剥开，才能得到黄色的蛇麻素腺，在这其中你可以找到添加到啤酒中的物质</p><p>在市场中可以看到啤酒花有很多种包装方式，最常见的是看到它的颗粒或是干花状态；一些人使用啤酒花精油，所以最近有人开发了一种叫做 hop hash 或 hop crack 的蛇麻粉（lupulin powder）来供使用</p><h2 id="为什么需要它们"><a href="#为什么需要它们" class="headerlink" title="为什么需要它们"></a>为什么需要它们</h2><p>一开始啤酒酿酒师在酿造过程中使用啤酒花是为了将啤酒保存更长时间，因为在那个时代，保存食物的方法很少，冰箱还没有发明，所以人们必须找到自然的方法来防止食物和饮料变质，他们尝试了了不同的草本植物和油等物质，但没有效果显著的方法</p><p>在法国一些记载记录了在 9 世纪啤酒酿造过程中开始有啤酒花的加入，德国人也有在 12 世纪开始使用它作为防腐剂的记录，并开始在欧洲和英国推广，在那个时代之前生产的不使用啤酒花的啤酒，现如今被人称为 Gruit 或 Grut</p><p>啤酒花也有助于赋予啤酒独特的香气和风味；它是苦的，有一些方法可以根据啤酒花来衡量啤酒的苦味；根据品种和种植地的不同，啤酒花具有不同的味道和香味，然后将其转移到啤酒中</p><p>啤酒花的苦味与麦芽的甜味形成对比，啤酒花种类和质量的不同会提供出各种各样的物质</p><h2 id="从哪里找到它们"><a href="#从哪里找到它们" class="headerlink" title="从哪里找到它们"></a>从哪里找到它们</h2><p>啤酒花生长需要特殊的环境，它们在纬度 35 到 55 度之间生长最事宜，南北半球维度范围都差不多</p><p>它们更喜欢平坦的地形，此外还会受到寒冷冬季和夏季日照时间长的显著影响，所以最好给它们找个避风的地方；这些情况并不常见，所以在某些国家更有可能发生</p><p>啤酒花最重要的产区位于德国、捷克共和国、美国和英国；美国和德国都是啤酒花的主要生产国，酿酒师倾向于将它们分别称为 “新世界酒花” 和 “旧世界酒花”</p><p>啤酒花们不需要照顾也能蓬勃生长，它们找到了在大自然中生存的方法；当然也有野生啤酒花分布在其他地方，比如澳大利亚，那里并没有专门种植啤酒花的农场</p><h2 id="如何用于啤酒"><a href="#如何用于啤酒" class="headerlink" title="如何用于啤酒"></a>如何用于啤酒</h2><p>在使用啤酒花时，必须将它们分为两个不同的类别</p><p>用于获得苦味的啤酒花 α 酸含量很高，这种特质使啤酒味道更加苦涩，但是它会在香气和风味方面不够精致；要获得啤酒花中的苦味物质并将其作用于啤酒，需要将啤酒花进行煮沸，苦味的程度往往取决于煮沸啤酒花的时间，时间越长苦味物质就会越多</p><p>另一类是香味啤酒花，它们的 α 酸含量较低更依赖精油，这一特质使它们的味道更加独特和美味；为了萃取出啤酒花的香味和风味，需要非常小心地处理，如果花很长时间进行煮沸，将失去它们独特的特性</p><p>也有一些种类的啤酒花具有类似的 α 酸和精油特性，使这两种特性互相平衡</p><p>你不能忘记啤酒花的主要用途，它是啤酒的防腐剂，它们的抗菌能力可以防止产品在没有任何冷藏手段的情况下过快变质；我们现在有更好的方法来保存啤酒，但这并不重要，啤酒花已经成为酿造过程中必不可少的基础；很难相信啤酒花并不是自啤酒酿造历史开始就被使用</p><img src="/2023/01/16/%E4%BA%BA%E7%94%9F/%E9%85%92/%E5%95%A4%E9%85%92%E8%8A%B1%EF%BC%9A%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86/Why-are-hops-added-to-beer.jpg" class=""><h2 id="有趣小知识"><a href="#有趣小知识" class="headerlink" title="有趣小知识"></a>有趣小知识</h2><ul><li>啤酒花植物雄株不产生为啤酒提供独特风味和香气所需的精油，这就是为什么啤酒花农场只使用雌株</li><li>啤酒花家族和大麻同属同一科：大麻科（Cannabaceae）；正因如此如果喝太多的话，啤酒会让你流口水是可以理解的（啤酒花的汉语被翻译为蛇麻，译者这么翻译的原因肯定是因为分类学；当然这里应该是作者的玩笑，表达的是对啤酒的喜爱，啤酒花里是没有四氢大麻酚的）</li><li>罗马人过去把啤酒花做成沙拉食用，就像现在人们吃芦笋的方式一样</li><li>你可以给鸡喂食啤酒花，啤酒花适合它们的消化系统，可以防止细菌进入肠道；但是啤酒花并不适合猫和狗，可能对其有毒，导致这些宠物高烧甚至死亡；因此，如果你家里有宠物，请确保啤酒花原料远离它们</li><li>啤酒（beer）和艾尔啤酒（ale）之间的区别一直存在着一场战争，当啤酒花开始成为酿造过程中的一种基本原料时，酿酒师开始将加了啤酒花的啤酒称为 beer，而 ale 称呼的就是不含啤酒花的产品；一些国家禁止在酿造过程中使用啤酒花，在亨利六世（Henry VI）的干预下，他喜欢喝加了啤酒花的啤酒，啤酒花才成为了酿造中必不可少的一环</li></ul><h1 id="啤酒和啤酒花的化学"><a href="#啤酒和啤酒花的化学" class="headerlink" title="啤酒和啤酒花的化学"></a>啤酒和啤酒花的化学</h1><h2 id="什么是-hop-harvest"><a href="#什么是-hop-harvest" class="headerlink" title="什么是 hop harvest"></a>什么是 hop harvest</h2><p>啤酒花必须在特定的时间内收获，一系列因素决定了什么是适合收获的季节，例如球果成熟度和水分含量、天气条件和啤酒花生长过程中的虫害压力等等；一年中收获啤酒花的最佳时间是秋季，即 8 月下旬和 9 月大部分时间</p><p>已有科学研究表明，采收日期对啤酒花品质有着重要影响，推迟收获可能被误认为会获得更好的收益，但事实证明啤酒花可能会失去部分特有的香气，也会缩短它们的存储寿命，氧化可能会加速最终导致啤酒花的挥发性香味消失</p><p>另一方面，过早收获会降低风味并会降低未来收获季节的产量；在有大量啤酒花农场的地区，他们计算出当球果达到 dry matter 的 23% 时是适合的收获时间；根据啤酒花的种类和环境条件的不同，啤酒花种植户每 4 到 7 天就会增加 1% 的 dry matter</p><p>啤酒花上的一些明显变化将提供线索说明是否准备好收割，例如花朵从绿色变为略带黄色的羊皮纸质地、蛇麻素腺也从浅黄色变为深黄色接近橙色；收货时，需要确保球果没有完全变为褐色</p><h2 id="什么让啤酒花味道如此不同"><a href="#什么让啤酒花味道如此不同" class="headerlink" title="什么让啤酒花味道如此不同"></a>什么让啤酒花味道如此不同</h2><p>如上所述，啤酒花的不同风味和香气主要取决于它们生长的地方，不同的天气条件、土壤和种植方式会以不同的形式最终影响啤酒花的特性</p><p>此外，收获的时间也可能会影响啤酒花的风味和香气</p><p>另一个关于味道的重要因素是每种啤酒花中的 α 酸和精油的含量；它们中的大多数在其含量上有所差异，但只有少数品种的啤酒花具有这些物质的平衡，这使它们变得苦涩，但充满独特的味道</p><p>α 酸所占的比重，通常在 2% 至 19% 之间；欧洲人对啤酒花更感兴趣，它们的啤酒花含有 5% 至 9% 的 α 酸；Dual-compound 啤酒花在欧洲更为常见；同时，美国啤酒花品种的 α 酸含量较高，在 8% 至 19% 之间，这会使得这些啤酒花更苦</p><h2 id="啤酒花的品种"><a href="#啤酒花的品种" class="headerlink" title="啤酒花的品种"></a>啤酒花的品种</h2><p>啤酒花有很多种，但它们都可以集中在三种类型：贵族啤酒花（Noble Hops）、美式啤酒花（American Hops）和英式啤酒花（English Hops）</p><p>贵族啤酒花来自德国和捷克共和国，被认为是最经典的啤酒花类型；其中包括 Saaz 和 Tettnanger 等品种，这些类型的啤酒花含有较少的 α 酸，并含有高水平的蛇麻烯精油</p><p>美式啤酒花往往更大胆，而且香味更加明显；它们含有大量的月桂烯精油，这使它们散发出松树和柑橘的香味，可以将 Cascade 和 Centennial 品种分类在这一类别</p><p>最后，英式啤酒花更加精致微妙；它们的月桂烯含量很低，这赋予了它们泥土、木质、草本等味道；与贵族啤酒花和美式啤酒花相比，英式啤酒花只使用在世界各地少量的啤酒品种，但它们对酿造英式啤酒至关重要</p><h2 id="添加的时机"><a href="#添加的时机" class="headerlink" title="添加的时机"></a>添加的时机</h2><p>通常酿酒师在糖化后加入啤酒花，这是谷物从麦芽变成麦芽汁后，需要开始进行煮沸的时候</p><p>当啤酒花和麦芽汁一起煮沸时，会启动一个叫做异构化（isomerisation）的过程；这个操作会将 α 酸转化为 异构的 α 酸（iso-alpha acids）；这一过程使最终产物产生苦味，啤酒花煮沸的时间越久，啤酒就会越苦，所以一般建议啤酒花的煮沸时间不超过 45 分钟</p><p>如果你想更专注于啤酒花风味，你必须减少其煮沸时间；稍后加入啤酒花，让它们沸腾的时间在 15 分钟到 30 分钟之间</p><p>如果啤酒花的香气更重要，那么最好在最后加入，煮沸时间不超过 5 分钟</p><p>一些酿酒师甚至在发酵过程中再加入啤酒花，这种做法被称为干投（dry hopping），包括在麦芽汁冷却后将啤酒花浸泡其中；这种方法可能需要几天甚至几周的时间，但并不是每个人都认为这种做法起到了实质性作用（个人认为，干投的问题在于成本和收益不成正比，只要成本大一定会有收益的）</p><p>对于苦味的测量，有 IBU（International Bitterness Unit） 这一国际统一单位，酿酒师在使用 α 酸时应熟悉这些测量方法</p><p>啤酒公司一般都有能够精确测量苦度值的机器，对于家酿者，可以使用一些公式对 IBU 进行计算（<a href="https://homebrewacademy.com/ibu-calculator/">IBU calculator</a>）</p><h1 id="啤酒花品种入门"><a href="#啤酒花品种入门" class="headerlink" title="啤酒花品种入门"></a>啤酒花品种入门</h1><h2 id="贵族酒花（Noble-x2F-Continental-Hops）"><a href="#贵族酒花（Noble-x2F-Continental-Hops）" class="headerlink" title="贵族酒花（Noble&#x2F;Continental Hops）"></a>贵族酒花（Noble&#x2F;Continental Hops）</h2><p>这种啤酒花品种的啤酒口感细腻、辛辣，具有花香和泥土味，起源于中欧，主要产地是捷克共和国和德国，它们的拉格（lagers）和皮尔森（pilsners）啤酒具有标志性的风味特征，要归功于这种啤酒花品种含有高比例的的蛇麻烯精油（essential oil humulene）</p><p>酿酒师将其描述为辛辣、药草、草本、花香、黑胡椒等味道；四种 α 酸含量低的贵族品种被认为是传统品种，包括：</p><ul><li>德国 - 斯派尔特（German Spalt）</li><li>德国 - 哈拉道（German Hallertau）</li><li>德国 - 泰特昂（German Tettnang）</li><li>德国 - 赫斯布鲁克（Czech Hersbrucker）</li><li>捷克 - 萨兹（Czech Saaz）</li></ul><p>酿酒师通常使用这些具有辛辣、平稳的苦味和花香的啤酒花来制作低 IBU 的啤酒，例如：</p><ul><li>Bohemian Pilsner Urquell</li><li>Samuel Adams Noble Pils</li><li>Trumer Pils</li><li>Czech Saaz characteristics</li></ul><h2 id="英式酒花（English-Hops）"><a href="#英式酒花（English-Hops）" class="headerlink" title="英式酒花（English Hops）"></a>英式酒花（English Hops）</h2><p>这种类型的啤酒花由 15 世纪的法兰德斯（Flanders）开始进口，因为具有优良的防腐特质可以帮助啤酒保持长久的新鲜</p><p>英式酒花类似于欧洲的品种，但具有更多的木质、辛辣、水果味和泥土味，以及较低的月桂烯含量</p><p>酿酒师将这些啤酒花描述为泥土、香草、花香、草本和水果，最常见的类型有：</p><ul><li>福格（Fuggle）</li><li>东肯特郡古丁（East Kent Golding）</li><li>朝圣者（Pilgrim）</li><li>十字燕雀（Bramling Cross）</li><li>塔吉特（Target）</li><li>挑战者（Challenger）</li></ul><p>酿酒师将选择这种啤酒花品种来酿造以下风格：</p><ul><li>Peter’s Best Bitter</li><li>Abbot Ale</li><li>Spitfire’s Amber Kentish Ale</li><li>Timothy Taylor Landlord</li></ul><h2 id="美式酒花（American-Hops）"><a href="#美式酒花（American-Hops）" class="headerlink" title="美式酒花（American Hops）"></a>美式酒花（American Hops）</h2><p>这种酒花品种体积大、更苦、特点鲜明，你可以在市场上找到超过 50 种不同的品种</p><p>大多数美国酿酒师都使用它们来酿造带有树脂、松脂和柑橘味的浅色啤酒</p><p>基本上这些非常芳香的植物是几乎所有美式 IPA （American IPA）的标志，赋予它们明显的香味和苦味；酿酒师通常对这种啤酒花品种的描述包括热带水果、柑橘、葡萄柚、辛辣、树脂和松脂，最受欢迎的美国啤酒花列表包括著名的四个 C：</p><ul><li>奇努克（Chinook）</li><li>卡斯卡特（Cascade）</li><li>哥伦布（Columbus）</li><li>世纪（Centennial）</li></ul><p>你也可以使用更偏向水果风味的品种：</p><ul><li>西楚（Citra）</li><li>西姆科（Simcoe）</li><li>亚麻黄（Amarillo）</li></ul><p>许多美国人喜欢四种 C 酿造的啤酒，特别是：</p><ul><li>Racer 5 IPA</li><li>Sierra Nevada Pale Ale</li><li>Amber IPA</li><li>American West Coast IPA</li><li>Ranger IPA</li></ul><h2 id="新世界酒花（New-World-Hops）"><a href="#新世界酒花（New-World-Hops）" class="headerlink" title="新世界酒花（New World Hops）"></a>新世界酒花（New World Hops）</h2><p>尽管这些啤酒花来自世界各地，但它们都具有相同的热带水果和柑橘风味，现在最流行的是：</p><ul><li>西楚（Citra）：来自美国，带有柑橘、柠檬、菠萝和芒果味道</li><li>埃尔德拉多（El Dorado）：来自美国，带有甜瓜、菠萝等味道</li><li>亚麻黄（Amarillo）：来自美国，带有柑橘和橙子味道</li><li>马赛克（Mosaic）：这种美国啤酒花带有百香果、浆果、柑橘、芒果等味道，还有独特的糖果感觉</li><li>银河（Galaxy）：来自澳大利亚，带有柑橘、热带水果等风味</li><li>莫图伊卡（Motueka）：来自新西兰，具备热带水果、柠檬等风味</li></ul><p>使用这些啤酒花的啤酒很流行，你应该试试：</p><ul><li>Hazy IPA</li><li>NEIPA</li><li>Feral Biggie Juice</li></ul><p>如今全球市场上可用的啤酒花类型几乎无穷无尽；一些数据估计，酿造产业种植了 120 种不同的啤酒花，甚至还有更多的实验品种或许很快就会进入市场</p><img src="/2023/01/16/%E4%BA%BA%E7%94%9F/%E9%85%92/%E5%95%A4%E9%85%92%E8%8A%B1%EF%BC%9A%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86/American-hops.jpg" class=""><h1 id="啤酒花的风味"><a href="#啤酒花的风味" class="headerlink" title="啤酒花的风味"></a>啤酒花的风味</h1><blockquote><p>When I read descriptions with flowery language, I find it not just useless—but sometimes misleading. </p></blockquote><p>首先，啤酒花的味道和香气极其复杂，即使是在一个品种中，不同品质的表达也可能是万花筒，也取决于啤酒花的使用方式以及与其他品种的组合；在早些年，识别出许多饮酒者熟悉的主力品种（Cascade - 卡斯卡特、Chinook - 奇努克）就足够了，但是如今已经无法满足现状，那么啤酒厂该如何传达啤酒的味道呢？</p><p>其次，如果直接陈列出味道和香气可能会过于抽象，但如果使用 “椰子” 来进行描述，是我们都可以理解的表达</p><p>为了达到这个目的，Barth-Hass 公司的 Georg Drexler 与一位香水制造商合作，提出了一个啤酒花风味的分类法，描述这项研究的学术论文尚未公开，但 Milk The Funk 发布了 Drexler 的分类方法</p><p>下面是他提出的几个类别，也附带了拥有这种风味、表达比较明显的啤酒花品种（括号内）</p><ul><li><strong>花香（<em>Ella</em>）</strong>：接骨木花、洋甘菊花、山谷百合、茉莉花、苹果花、玫瑰、天竺葵、康乃馨、丁香、薰衣草</li><li><strong>柑橘（<em>Mandarina Bavaria</em>）</strong>：葡萄柚、橙子、青柠、柠檬、佛手柑、柠檬草、姜、橘子</li><li><strong>甜水果（<em>Mosaic</em>）</strong>：香蕉、西瓜、蜜瓜、桃子、杏子、百香果、荔枝、干果、李子、菠萝、樱桃、猕猴桃、芒果、番石榴</li><li><strong>绿色水果（<em>Hallertau Blanc</em>）</strong>：梨、昆斯、苹果、鹅莓、白葡萄酒葡萄</li><li><strong>红浆果（<em>Monroe</em>）</strong>：黑加仑、红加仑、蓝莓、树莓、黑莓、草莓、野生草莓、蔓越莓</li><li><strong>焦糖（<em>Triskel</em>）</strong>：黄油、巧克力、酸奶、蜂蜜、奶油、焦糖、太妃糖、咖啡，香草、冬加豆（Tonka，零陵香豆，<a href="https://www.nosetime.com/xiangshui/116580.html">祖玛珑 馥郁典藏系列-末药与冬加豆</a>）</li><li><strong>木质（<em>Relax</em>）</strong>：烟草、干邑白兰地、橡木、皮革、半圆、香料、没药、树脂、泥土、雪松、松树</li><li><strong>薄荷（<em>Polaris</em>）</strong>：薄荷、柠檬油、樟脑、薄荷醇、葡萄酒酵母</li><li><strong>香草（<em>Columbus</em>）</strong>：爱夫芝、郁金香、罗勒、欧芹、龙蒿、莳萝、茴香、百里香、迷迭香、马郁兰、绿茶、红茶、伴侣茶、鼠尾草</li><li><strong>辛辣（<em>Saazer</em>）</strong>：胡椒、辣椒、咖喱、杜松子、茴香、肉豆蔻、甘草、丁香、生姜面包、茴香籽</li><li><strong>青草（<em>Herkules</em>）</strong>：新鲜切割的草、干草、番茄叶、青椒、荨麻</li><li><strong>植物（<em>Summit</em>）</strong>：芹菜汤、芹菜根、韭菜、洋葱、朝鲜蓟、大蒜、野生大蒜</li></ul><p><em>PS</em>：比较多，风味本身就是一门玄学，当然最标志的热带水果，甚至是核果等还是会体现的很明显</p><img src="/2023/01/16/%E4%BA%BA%E7%94%9F/%E9%85%92/%E5%95%A4%E9%85%92%E8%8A%B1%EF%BC%9A%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86/Hop-Flavor-Wheel-sgn.png" class=""><p>flavor wheel 下载地址</p><p><a href="https://peertobeer.net/category/beer-downloads/">Downloads Archives - Peer To Beer</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://homebrewacademy.com/beer-hops/">Beer Hops: All You Need to Know | Homebrew Academy</a></p><p><a href="https://www.beervanablog.com/beervana/2020/1/5/describing-the-flavor-of-hops">Describing the Flavors of Hops — Beervana (beervanablog.com)</a></p><p><a href="https://renegadebrewing.com/hops/">What Are Hops In Beer? (Why Add It?) (renegadebrewing.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 酒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 精酿啤酒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Guava RateLimiter</title>
      <link href="/2023/01/08/%E5%BC%80%E5%8F%91/%E5%B9%B6%E5%8F%91/Guava%20RateLimiter/"/>
      <url>/2023/01/08/%E5%BC%80%E5%8F%91/%E5%B9%B6%E5%8F%91/Guava%20RateLimiter/</url>
      
        <content type="html"><![CDATA[<h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><p>限流是保护高并发系统的三把利器之一（限流、缓存、降级）；其目的是通过对并发访问或请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务或进行流量整形</p><p>限流的类型可大致分为：</p><ul><li>限制总并发数 - 数据库连接池、线程池</li><li>限制瞬时并发数 - nginx 的 limitconn 模块、Java Semaphore 限制并发</li><li>限制时间窗口内的平均速率 - Guava 的 RateLimiter</li><li>其他 - 根据网络流量、CPU 占用率、内存占用率等作为标准来进行限流</li></ul><h1 id="桶漏-amp-令牌桶"><a href="#桶漏-amp-令牌桶" class="headerlink" title="桶漏 &amp; 令牌桶"></a>桶漏 &amp; 令牌桶</h1><p>桶漏和令牌桶指的是限流的两种模型，其目的都是限流以达到限制时间窗口内的平均速率的目的</p><p>桶漏是接收请求，并按照一定的速率通过请求</p><p>令牌桶是按照固定的速率生产令牌，请求需要获取对应的令牌才能通过</p><h1 id="RateLimiter"><a href="#RateLimiter" class="headerlink" title="RateLimiter"></a>RateLimiter</h1><p>Guava 是 Java 领域优秀的开源项目，它包含了 Google 在 Java 项目中使用一些核心库</p><p>其中就有限流相关的 <code>RateLimiter</code> 工具，底层基于令牌桶思想，提供了平滑突发限流（SmoothBursty）和平滑预热限流（SmoothWarmingUp）多种实现</p><p>类图属性如下：</p><img src="/2023/01/08/%E5%BC%80%E5%8F%91/%E5%B9%B6%E5%8F%91/Guava%20RateLimiter/RateLimiter%E7%B1%BB%E5%9B%BE.png" class=""><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>最终的实现类都是 <code>SmoothRateLimiter</code> 的内部类，但是创建方法放在了更上层的 <code>RateLimiter</code> 中（工厂）</p><p>调用 <code>RateLimiter.create()</code> 静态方法进行创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NO.1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RateLimiter <span class="title function_">create</span><span class="params">(<span class="type">double</span> permitsPerSecond)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> create(SleepingStopwatch.createFromSystemTimer(), permitsPerSecond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NO.2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RateLimiter <span class="title function_">create</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">long</span> warmupPeriod, TimeUnit unit)</span> &#123;</span><br><span class="line">    checkArgument(warmupPeriod &gt;= <span class="number">0</span>, <span class="string">&quot;warmupPeriod must not be negative: %s&quot;</span>, warmupPeriod);</span><br><span class="line">    <span class="keyword">return</span> create(</span><br><span class="line">        SleepingStopwatch.createFromSystemTimer(), permitsPerSecond, warmupPeriod, unit, <span class="number">3.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SmoothBursty</strong></p><p>先看参数列表为 <code>double permitsPerSecond</code> 的方法，<code>SleepingStopwatch.createFromSystemTimer()</code> 创建了一个 <code>SleepingStopwatch</code> 后调用了下一层创建方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> RateLimiter <span class="title function_">create</span><span class="params">(SleepingStopwatch stopwatch, <span class="type">double</span> permitsPerSecond)</span> &#123;</span><br><span class="line">    <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmoothBursty</span>(stopwatch, <span class="number">1.0</span> <span class="comment">/* maxBurstSeconds */</span>);</span><br><span class="line">    rateLimiter.setRate(permitsPerSecond);</span><br><span class="line">    <span class="keyword">return</span> rateLimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SleepingStopwatch</code> 的目的是记录创建时间和计算相对时间，整个 <code>RateLimiter</code> 的时间都是相对创建时间而言的，也就是时间的运算依赖 <code>SleepingStopwatch</code> 对象</p><p><code>new SmoothBursty(stopwatch, 1.0)</code> 的参数除了时间相关的对象，就是 <code>maxBurstSeconds = 1</code> 了，可以看出默认的 <code>SmoothBursty</code> 其应对突发流量的设置是多存储时间为 1s 的许可</p><p>而后调用了 <code>rateLimiter.setRate(permitsPerSecond)</code>，这个先放在后面</p><p><strong>SmoothWarmingUp</strong></p><p>参数列表为 <code>double permitsPerSecond, long warmupPeriod, TimeUnit unit</code> 的方法，先对参数进行了校验，随后也调用了下一层的创建方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> RateLimiter <span class="title function_">create</span><span class="params">(</span></span><br><span class="line"><span class="params">    SleepingStopwatch stopwatch,</span></span><br><span class="line"><span class="params">    <span class="type">double</span> permitsPerSecond,</span></span><br><span class="line"><span class="params">    <span class="type">long</span> warmupPeriod,</span></span><br><span class="line"><span class="params">    TimeUnit unit,</span></span><br><span class="line"><span class="params">    <span class="type">double</span> coldFactor)</span> &#123;</span><br><span class="line">    <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmoothWarmingUp</span>(stopwatch, warmupPeriod, unit, coldFactor);</span><br><span class="line">    rateLimiter.setRate(permitsPerSecond);</span><br><span class="line">    <span class="keyword">return</span> rateLimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程和 <code>SmoothBursty</code> 类似，多了 <code>warmupPeriod</code> 相关的参数，也是用来实现 WarmingUp 的关键参数</p><p>后面也调用了 <code>rateLimiter.setRate(permitsPerSecond)</code></p><h2 id="设置-rate"><a href="#设置-rate" class="headerlink" title="设置 rate"></a>设置 rate</h2><p>rate 的设置关键参数是 <code>permitsPerSecond</code>，这是使用者传入的参数，代表每秒希望生产的许可数量（不一定代表 QPS，因为每次请求许可不一定请求一个）</p><p>调用 <code>RateLimiter</code> 的 <code>setRate</code> 方法进行设置，在每次创建 <code>RateLimiter</code> 时，创建方法在实例化后也会调用一次该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setRate</span><span class="params">(<span class="type">double</span> permitsPerSecond)</span> &#123;</span><br><span class="line">    checkArgument(</span><br><span class="line">        permitsPerSecond &gt; <span class="number">0.0</span> &amp;&amp; !Double.isNaN(permitsPerSecond), <span class="string">&quot;rate must be positive&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex()) &#123; <span class="comment">// 获取锁</span></span><br><span class="line">        doSetRate(permitsPerSecond, stopwatch.readMicros());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先进行参数校验，随后获取锁调用 <code>doSetRate</code> 方法；这里可以进行一个猜想，设置 rate 和获取许可保证并发的锁一定是同一把，看起来统一封装到了 <code>mutex()</code> 方法里，而后调用了 <code>doSetRate</code></p><p><strong>SmoothRateLimiter 的 doSetRate</strong></p><p>在 <code>RateLimiter</code> 中，<code>doSetRate</code> 是一个抽象方法，<code>SmoothRateLimiter </code> 进行了实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doSetRate</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">long</span> nowMicros)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doSetRate</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">    resync(nowMicros);</span><br><span class="line">    <span class="type">double</span> <span class="variable">stableIntervalMicros</span> <span class="operator">=</span> SECONDS.toMicros(<span class="number">1L</span>) / permitsPerSecond;</span><br><span class="line">    <span class="built_in">this</span>.stableIntervalMicros = stableIntervalMicros;</span><br><span class="line">    doSetRate(permitsPerSecond, stableIntervalMicros);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先调用 <code>resync</code> 方法重新计算 <code>this.storedPermits</code> 和 <code>this.nextFreeTicketMicros</code> 这两个重要属性；这是一个常用的方法，在后续流程中会有多个操作都调用该方法，具体实现在后面进行分析</p><p>根据参数 <code>permitsPerSecond</code> 计算出一秒内许可生产的间隔，赋值给 <code>this.stableIntervalMicros</code></p><p>继续调用 <code>doSetRate</code></p><p><strong>SmoothBursty 的 doSetRate</strong></p><p><code>SmoothRateLimiter</code>  的 <code>doSetRate</code> 也是一个抽象方法，<code>SmoothBursty </code> 进行了实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doSetRate</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">double</span> stableIntervalMicros)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doSetRate</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">double</span> stableIntervalMicros)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">oldMaxPermits</span> <span class="operator">=</span> <span class="built_in">this</span>.maxPermits;</span><br><span class="line">    maxPermits = maxBurstSeconds * permitsPerSecond;</span><br><span class="line">    <span class="keyword">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class="line">        <span class="comment">// if we don&#x27;t special-case this, we would get storedPermits == NaN, below</span></span><br><span class="line">        storedPermits = maxPermits;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 等比缩放已经存储的许可数量</span></span><br><span class="line">        storedPermits =</span><br><span class="line">            (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">            ? <span class="number">0.0</span> <span class="comment">// initial state</span></span><br><span class="line">            : storedPermits * maxPermits / oldMaxPermits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要计算了新的 <code>maxPermits</code>，并根据旧的 <code>maxPermits</code>，即 <code>oldMaxPermits</code> 计算了 <code>storedPermits</code> 的值</p><p>相当于设置了新的 <code>permitsPerSecond</code>，需要计算新的 <code>maxPermits</code>，并等比缩放已经存储的许可数量</p><h2 id="获取许可（permits）"><a href="#获取许可（permits）" class="headerlink" title="获取许可（permits）"></a>获取许可（permits）</h2><p>创建 <code>RateLimiter</code> 对象后，使用 <code>acquire</code> 或者 <code>tryAcquire</code> 方法来获取许可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">10</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">sleepTime</span> <span class="operator">=</span> rateLimiter.acquire(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>最终的返回值是等待的时间，并且在返回之前该线程一直在等待</p><p>着重看下 <code>acquire</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> permits)</span> &#123; <span class="comment">// 参数 permits 代表一次需要获取的许可数量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">microsToWait</span> <span class="operator">=</span> reserve(permits); <span class="comment">// 调用 reserve 方法</span></span><br><span class="line">    stopwatch.sleepMicrosUninterruptibly(microsToWait); <span class="comment">// microsToWait &gt; 0 则 sleep</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * microsToWait / SECONDS.toMicros(<span class="number">1L</span>); <span class="comment">// 换算成 s 返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是通过 <code>reserve</code> 方法，返回的是一个需要等待的微秒值 <code>microsToWait</code>，如果大于 0 则进行 sleep 操作（使用的同样是 Guava 包下的 <code>Uninterruptibles</code>，先不关注）</p><p>最终将等待的微秒换算成单位秒返回</p><p><strong>reserve</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserve</span><span class="params">(<span class="type">int</span> permits)</span> &#123;</span><br><span class="line">    checkPermits(permits); <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mutex()) &#123; <span class="comment">// 上锁</span></span><br><span class="line">        <span class="keyword">return</span> reserveAndGetWaitLength(permits, stopwatch.readMicros());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法里主要做了两部分操作</p><ol><li>校验参数 <code>permits</code> 合法性，其实就是是否大于 0 <code>checkArgument(permits &gt; 0, &quot;Requested permits (%s) must be positive&quot;, permits);</code></li><li>使用 <code>synchronized</code> 关键字上锁（<code>mutex</code> 方法返回的是 <code>this.mutexDoNotUseDirectly</code> 一个 <code>Object</code> 对象），上锁后执行 <code>reserveAndGetWaitLength</code> 方法</li></ol><p><strong>reserveAndGetWaitLength</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserveAndGetWaitLength</span><span class="params">(<span class="type">int</span> permits, <span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">momentAvailable</span> <span class="operator">=</span> reserveEarliestAvailable(permits, nowMicros);</span><br><span class="line">    <span class="keyword">return</span> max(momentAvailable - nowMicros, <span class="number">0</span>); <span class="comment">// 计算一下是不是需要 wait</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过方法名 “获取等待长度”，可以知道这里主要是通过 <code>reserveEarliestAvailable</code> 获取一个时间（这个时间在后面的方法中可知是下一次获取许可的时间）后，在次方法最终确认需要等待的时间并返回 <code>max(momentAvailable - nowMicros, 0)</code>，如果不需要等待（<code>momentAvailable - nowMicros &lt; 0</code>），则返回 0</p><p><strong>arliestAvailable</strong></p><p><code>RateLimiter</code> 是一个抽象类，这个方法是一个抽象方法，由 <code>SmoothRateLimiter</code> 进行了实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="type">long</span> <span class="title function_">reserveEarliestAvailable</span><span class="params">(<span class="type">int</span> permits, <span class="type">long</span> nowMicros)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserveEarliestAvailable</span><span class="params">(<span class="type">int</span> requiredPermits, <span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">    resync(nowMicros); <span class="comment">// 重新计算 storedPermits 和 nextFreeTicketMicros</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">returnValue</span> <span class="operator">=</span> nextFreeTicketMicros; <span class="comment">// 保存 nextFreeTicketMicros，因为后面可能会被更新</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">storedPermitsToSpend</span> <span class="operator">=</span> min(requiredPermits, <span class="built_in">this</span>.storedPermits); <span class="comment">// 仓库能提供的许可</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">freshPermits</span> <span class="operator">=</span> requiredPermits - storedPermitsToSpend; <span class="comment">// 这次请求超出仓库能力的许可</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">waitMicros</span> <span class="operator">=</span> <span class="comment">// 等待时间</span></span><br><span class="line">        storedPermitsToWaitTime(<span class="built_in">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class="line">        + (<span class="type">long</span>) (freshPermits * stableIntervalMicros);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros); <span class="comment">// 根据等待时间延长下一次能够获取许可的时间</span></span><br><span class="line">    <span class="built_in">this</span>.storedPermits -= storedPermitsToSpend; <span class="comment">// 调整仓库许可数量；即 freshPermits &gt; 0，storedPermits 一定 = 0</span></span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行就调用了方法 <code>resync()</code>，该方法的目的是重新计算 <code>this.storedPermits</code> 和 <code>this.nextFreeTicketMicros</code> 这两个重要属性</p><p>接下来的几行操作可以概括为：如果需要获取的许可大于当前已经存储的许可，那么计算出超出的许可数量 <code>freshPermits</code>，调用 <code>storedPermitsToWaitTime</code> 方法返回值加上 <code>超出的许可数量 × 许可生产间隔</code> 即可算出需要额外等待的时长；这里对于 <code>SmoothBursty</code> 来说，返回固定是 0，也就是额外的等待时间就是 <code>超出的许可数量 × 许可生产间隔</code></p><p>最后更新这次操作后 <code>this.nextFreeTicketMicros</code> 和 <code>this.storedPermits</code> 的值，返回一开始保存的 <code>this.nextFreeTicketMicros</code></p><p><strong>这里需要思考一个问题</strong>：为什么返回的是 <code>resync</code> 后的 <code>nextFreeTicketMicros</code>？如果令牌数量不够，这个值不是被向后更新了吗？这里就体现出 <code>RateLimiter</code> 整体的一个思想，即每一个请求过来本质上都能拿到许可，无非是等待多长时间才能执行，对于超出部分来说，当前线程不用等待，将这部分时间全部交给下一个线程来进行等待了，我自己概括起来就是 <strong>惰性计算 + 以当前线程为主</strong></p><p><strong>resync</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resync</span><span class="params">(<span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">    <span class="comment">// if nextFreeTicket is in the past, resync to now</span></span><br><span class="line">    <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">newPermits</span> <span class="operator">=</span> (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();</span><br><span class="line">        storedPermits = min(maxPermits, storedPermits + newPermits);</span><br><span class="line">        nextFreeTicketMicros = nowMicros;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的目的是重新计算 <code>this.storedPermits</code> 和 <code>this.nextFreeTicketMicros</code> 这两个重要属性</p><p>如果当前时间超过了之前计算的下一次获取许可的时间，则开始更新：</p><ol><li>先计算新产生的许可数量（<code>coolDownIntervalMicros()</code> 返回的是许可生产的固定间隔）</li><li>更新 <code>this.storedPermits</code> 为合适的值（<code>SmoothBursty</code> 最多只能多存储 1s 的许可）</li><li>更新 <code>this.nextFreeTicketMicros</code> 为参数 <code>nowMicros</code></li></ol><h2 id="预热（WarmingUp）"><a href="#预热（WarmingUp）" class="headerlink" title="预热（WarmingUp）"></a>预热（WarmingUp）</h2><p>上面的分析主要是对 <code>SmoothBursty</code> 进行了分析，还提供了一种实现是 <code>SmoothWarmingUp</code></p><p><code>SmoothWarmingUp</code> 适用于资源需要预热的场景，相比 <code>SmoothBursty</code> 是对突发流量进行保证，通过 <code>maxBurstSeconds</code> 来计算额外存储的令牌数量，<code>SmoothWarmingUp</code> 使用 <code>warmupPeriod</code> 参数来设置预热的时长</p><p>由于预热机制的存在，其生产许可的速度是应该是动态的，如下图</p><img src="/2023/01/08/%E5%BC%80%E5%8F%91/%E5%B9%B6%E5%8F%91/Guava%20RateLimiter/%E8%AE%B8%E5%8F%AF%E9%A2%84%E7%83%AD.drawio.png" class="" title="许可预热.drawio"><p>其许可数量越多，说明还没到稳定时期，许可的生产间隔就要越长；许可少说明处于稳定期</p><p><strong>关键属性计算</strong></p><p>根据该图可以计算出一些数值，首先需要确定的是，从 <code>thresholdPermits</code> 到 0 的时间，是从 <code>maxPermits</code> 到 <code>thresholdPermits</code> 时间的一半，也就是梯形的面积是长方形面积的 2 倍，梯形的面积是 <code>warmupPeriod</code></p><p>因为在创建 <code>SmoothWarmingUp</code> 默认的 coldFactor 为 3 <code>SleepingStopwatch.createFromSystemTimer(), permitsPerSecond, warmupPeriod, unit, 3.0);</code> </p><p>梯形面积为 <code>warmupPeriod</code>，而长方形面积为 <code>stableInterval × thresholdPermits</code>，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warmupPeriod = <span class="number">2</span> * stableInterval * thresholdPermits</span><br></pre></td></tr></table></figure><p>由此，我们得出 <code>thresholdPermits</code> 的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thresholdPermits = <span class="number">0.5</span> * warmupPeriod / stableInterval</span><br></pre></td></tr></table></figure><p>然后我们根据梯形面积的计算公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warmupPeriod = <span class="number">0.5</span> * (stableInterval + coldInterval) * (maxPermits - thresholdPermits)</span><br></pre></td></tr></table></figure><p>得出 <code>maxPermits</code> 为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxPermits = thresholdPermits + <span class="number">2.0</span> * warmupPeriod / (stableInterval + coldInterval)</span><br></pre></td></tr></table></figure><p>这样，我们就得到了 <code>thresholdPermits</code> 和 <code>maxPermits</code> 的值</p><p>最后是冷却时间的间隔，对应到图中代表的是斜线的斜率，即由稳定到冷却中的速度；在代码中为：</p><p>该方法 <code>SmoothBursty</code> 的实现始终返回 0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">coolDownIntervalMicros</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> warmupPeriodMicros / maxPermits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>doSetRate</strong></p><p>上面分析了 <code>SmoothBursty</code> 的 <code>doSetRate</code> 实现，这里来看 <code>SmoothWarmingUp</code> 的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doSetRate</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">double</span> stableIntervalMicros)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">oldMaxPermits</span> <span class="operator">=</span> maxPermits;</span><br><span class="line">    <span class="type">double</span> <span class="variable">coldIntervalMicros</span> <span class="operator">=</span> stableIntervalMicros * coldFactor; <span class="comment">// coldFactor 是固定的 3</span></span><br><span class="line">    thresholdPermits = <span class="number">0.5</span> * warmupPeriodMicros / stableIntervalMicros;</span><br><span class="line">    maxPermits =</span><br><span class="line">        thresholdPermits + <span class="number">2.0</span> * warmupPeriodMicros / (stableIntervalMicros + coldIntervalMicros);</span><br><span class="line">    slope = (coldIntervalMicros - stableIntervalMicros) / (maxPermits - thresholdPermits); <span class="comment">// 计算斜率，对边 / 临边</span></span><br><span class="line">    <span class="keyword">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class="line">        <span class="comment">// if we don&#x27;t special-case this, we would get storedPermits == NaN, below</span></span><br><span class="line">        storedPermits = <span class="number">0.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        storedPermits =</span><br><span class="line">            (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">            ? maxPermits <span class="comment">// initial state is cold</span></span><br><span class="line">            : storedPermits * maxPermits / oldMaxPermits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是计算了相关的属性并赋值给成员变量，计算方法都和上图一致</p><p><strong>acquire 的 storedPermitsToWaitTime</strong></p><p><code>acquire</code> 流程和 <code>SmoothBursty</code> 基本一致，区别在于 <code>storedPermitsToWaitTime</code> 方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserveEarliestAvailable</span><span class="params">(<span class="type">int</span> requiredPermits, <span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">    resync(nowMicros);</span><br><span class="line">    <span class="type">long</span> <span class="variable">returnValue</span> <span class="operator">=</span> nextFreeTicketMicros;</span><br><span class="line">    <span class="type">double</span> <span class="variable">storedPermitsToSpend</span> <span class="operator">=</span> min(requiredPermits, <span class="built_in">this</span>.storedPermits);</span><br><span class="line">    <span class="type">double</span> <span class="variable">freshPermits</span> <span class="operator">=</span> requiredPermits - storedPermitsToSpend;</span><br><span class="line">    <span class="type">long</span> <span class="variable">waitMicros</span> <span class="operator">=</span></span><br><span class="line">        storedPermitsToWaitTime(<span class="built_in">this</span>.storedPermits, storedPermitsToSpend) <span class="comment">// 在于这里的方法</span></span><br><span class="line">        + (<span class="type">long</span>) (freshPermits * stableIntervalMicros);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);</span><br><span class="line">    <span class="built_in">this</span>.storedPermits -= storedPermitsToSpend;</span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>waitMicros</code> 由两部分组成，一部分是从 <code>storedPermits</code> 中获取花费的时间，一部分是等待 <code>freshPermits</code> 产生花费的时间；<code>SmoothBursty</code> 的该方法实现固定返回 0，即不存在从 <code>storedPermits</code> 获取许可的花费，而 <code>SmoothWarmingUp</code> 实现较为复杂</p><p>由于需要预热，所以从存储的许可中中取许可需要花费一定的时间，其实就是要计算下图中，阴影部分的面积</p><img src="/2023/01/08/%E5%BC%80%E5%8F%91/%E5%B9%B6%E5%8F%91/Guava%20RateLimiter/%E8%AE%B8%E5%8F%AF%E9%A2%84%E7%83%AD%E8%8E%B7%E5%8F%96%E8%AE%B8%E5%8F%AF.drawio.png" class="" title="许可预热获取许可.drawio"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">storedPermitsToWaitTime</span><span class="params">(<span class="type">double</span> storedPermits, <span class="type">double</span> permitsToTake)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">availablePermitsAboveThreshold</span> <span class="operator">=</span> storedPermits - thresholdPermits;</span><br><span class="line">    <span class="type">long</span> <span class="variable">micros</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// measuring the integral on the right part of the function (the climbing line)</span></span><br><span class="line">    <span class="comment">// 如果右边梯形部分有 permits，那么先从右边部分获取 permits，计算梯形部分的阴影部分的面积</span></span><br><span class="line">    <span class="keyword">if</span> (availablePermitsAboveThreshold &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="comment">// 从右边部分获取的 permits 数量</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">permitsAboveThresholdToTake</span> <span class="operator">=</span> min(availablePermitsAboveThreshold, permitsToTake);</span><br><span class="line">        <span class="comment">// TODO(cpovirk): Figure out a good name for this variable.</span></span><br><span class="line">        <span class="comment">// 梯形面积公式：(上底 + 下底) × 高 / 2</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">length</span> <span class="operator">=</span> permitsToTime(availablePermitsAboveThreshold)</span><br><span class="line">            + permitsToTime(availablePermitsAboveThreshold - permitsAboveThresholdToTake);</span><br><span class="line">        micros = (<span class="type">long</span>) (permitsAboveThresholdToTake * length / <span class="number">2.0</span>);</span><br><span class="line">        permitsToTake -= permitsAboveThresholdToTake;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// measuring the integral on the left part of the function (the horizontal line)</span></span><br><span class="line">    <span class="comment">// 加上长方形部分的阴影面积</span></span><br><span class="line">    micros += (stableIntervalMicros * permitsToTake);</span><br><span class="line">    <span class="keyword">return</span> micros;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于给定的 x 值，计算 y 值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> <span class="title function_">permitsToTime</span><span class="params">(<span class="type">double</span> permits)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> stableIntervalMicros + permits * slope;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终将这部分等待时间返回，达到预热等待的目的</p><h1 id="重点问题"><a href="#重点问题" class="headerlink" title="重点问题"></a>重点问题</h1><h2 id="许可从哪来"><a href="#许可从哪来" class="headerlink" title="许可从哪来"></a>许可从哪来</h2><p>经过上面的分析，可以得出，所谓的许可是惰性的运算，并不是表面理解的可能存在一个线程在生产许可，而是当请求进入时才会计算许可相关的数据（下一次许可时间、存储的许可数量、满足当前请求许可需要等待的时间等），然后对该请求行为进行处理</p><h2 id="并发安全是如何保证的"><a href="#并发安全是如何保证的" class="headerlink" title="并发安全是如何保证的"></a>并发安全是如何保证的</h2><p>并发主要出现在两个地方，<code>setRate</code> 设置速率方法和 <code>acquire</code> 获取许可方法内，并且这两个方法也互斥</p><p>关键的方法在 <code>reserve()</code> 内</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserve</span><span class="params">(<span class="type">int</span> permits)</span> &#123;</span><br><span class="line">    checkPermits(permits);</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex()) &#123;</span><br><span class="line">        <span class="keyword">return</span> reserveAndGetWaitLength(permits, stopwatch.readMicros());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么着重关注 <code>mutex()</code> 返回了什么对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Can&#x27;t be initialized in the constructor because mocks don&#x27;t call the constructor.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Object mutexDoNotUseDirectly;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">mutex</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">mutex</span> <span class="operator">=</span> mutexDoNotUseDirectly;</span><br><span class="line">    <span class="keyword">if</span> (mutex == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            mutex = mutexDoNotUseDirectly;</span><br><span class="line">            <span class="keyword">if</span> (mutex == <span class="literal">null</span>) &#123;</span><br><span class="line">                mutexDoNotUseDirectly = mutex = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mutex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会有几个疑问与答案：</p><ul><li><code>Object mutex = mutexDoNotUseDirectly</code> 为什么不直接操作 <code>this.mutexDoNotUseDirectly</code>，要使用一个临时变量</li><li><code>mutexDoNotUseDirectly</code> 锁对象的创建有必要使用懒汉式吗？<code>RateLimiter</code> 在实例化后直接执行了 <code>reserve</code> 方法，那么这个懒加载的单例意义是什么</li><li>为什么不使用 <code>synchronized (this)</code>，包装了一个方法 <code>mutex()</code> 来返回锁对象</li></ul><p><strong>第一个问题</strong>：减少 <code>volatile</code> 对内存的读请求；<code>mutexDoNotUseDirectly</code> 是可见的，每次读取都会访问内存，使用临时变量对于不需要可见性的场景能减少访问内存的次数</p><blockquote><p>It avoids an additional volatile read of the field once it’s determined to be non-null.<br>详见 issue：<a href="https://github.com/google/guava/issues/3381">https://github.com/google/guava/issues/3381</a></p></blockquote><p><strong>第二个问题</strong>：源代码注释中也已经解释了目的：<code>// Can&#39;t be initialized in the constructor because mocks don&#39;t call the constructor.</code></p><p>作者是考虑到使用 Mockito 框架时，用 mock 方法创建 <code>RateLimiter</code> 的 mock 对象不会执行其构造器，该锁对象不会被实例化；并且成员变量直接赋值也会被解释为构造器的一部分</p><blockquote><p>Inline field initialization is syntactic sugar for initializing from the constructor.<br>详见 issue：<a href="https://github.com/google/guava/issues/3066">https://github.com/google/guava/issues/3066</a></p></blockquote><p><strong>第三个问题</strong>：更方便控制锁粒度，并且避免使用 <code>this</code> 作为锁对象是一种规范，因为无法得知外部是否也是用 <code>this</code> 作为锁来使用</p><blockquote><p>可以参考该回答：<a href="https://stackoverflow.com/questions/12397427/what-is-different-between-method-synchronized-vs-object-synchronized">https://stackoverflow.com/questions/12397427/what-is-different-between-method-synchronized-vs-object-synchronized</a></p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/60979444">超详细的Guava RateLimiter限流原理解析 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/egg1996911/article/details/103928573">Guava限流器RateLimiter中mutexDoNotUseDirectly&#x2F;锁的使用_DengDengLei的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/shenchaohao12321/article/details/112143092">RateLimiter 源码分析(Guava 和 Sentinel 实现)_一直不懂的博客-CSDN博客_sentinel ratelimiter</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象创建与属性设置</title>
      <link href="/2023/01/07/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE/"/>
      <url>/2023/01/07/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在 Spring 框架和 MVC 三层模式下，对于创建一个对象并对属性进行赋值的操作不需要复杂的设计</p><p>代码中创建的对象往往是一个 “贫血模型”，只用来充当数据的传递者</p><p>应该根据不同的类及其功能选择合适的对象创建方式</p><h1 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h1><h2 id="set-方法"><a href="#set-方法" class="headerlink" title="set 方法"></a>set 方法</h2><p>最常见的方式；创建对象后，使用 set 方法来对属性进行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">student.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">student.setAge(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><h2 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h2><p>对需要赋值的属性设置为有参构造中的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String alias;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用上使用有参构造器来创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h2 id="链式赋值"><a href="#链式赋值" class="headerlink" title="链式赋值"></a>链式赋值</h2><p>将 set 方法改造，将 <code>this</code> 对象返回达成链式赋值的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String alias;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">name</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">alias</span><span class="params">(String alias)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.alias = alias;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">age</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建对象和赋值操作更流畅</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>().name(<span class="string">&quot;张三&quot;</span>).age(<span class="number">20</span>).alias(<span class="string">&quot;张三三&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>Lombok</strong></p><p>Lombok 的 <code>@Accessors(chain = true, fluent = true)</code> 注解可以生成类似的模板代码；该注解主要是对 Bean 方法（<code>@Getter</code> 和 <code>@Setter</code>）的生成进行进一步的配置</p><p><code>@Accessors</code> 的参数：</p><ul><li>fluent - 为 true 时生成的 set 方法名称不会带上 <code>set</code> 前缀，即以变量名作为方法名</li><li>chain - 为 true 时生成的 set 方法会以当前对象作为返回值，达到链式赋值的效果</li><li>prefix - 过滤固定前缀的变量，不对所配置前缀的变量生成 set 方法</li></ul><h2 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h2><p>可以称为生成器设计模式</p><p>创建出一个 <code>Builder</code> 生成器来对对象的创建进行管理</p><p><code>Builder</code> 可以对创建对象过程中的流程进行优化，减少选配参数，可以在创建前就对属性进行校验（优点就是生成器模式的优点）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String alias;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StudentBuilder <span class="title function_">builder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StudentBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String alias;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">name</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">alias</span><span class="params">(String alias)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.alias = alias;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">age</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Student <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="comment">// name 和 age 必须赋值</span></span><br><span class="line">          <span class="comment">// 如果 alias 设置了，则以设置的值为准；如果没有设置则使用 name</span></span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">            student.setName(Assert.notBlank(<span class="built_in">this</span>.name));</span><br><span class="line">            student.setAge(Assert.notNull(<span class="built_in">this</span>.age));</span><br><span class="line">            student.setAlias(Optional.ofNullable(<span class="built_in">this</span>.alias).orElse(<span class="built_in">this</span>.name));</span><br><span class="line">            <span class="keyword">return</span> student;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>builder()</code> 方法创建生成器，对生成器赋值后调用 <code>build()</code> 方法创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> Student.builder().name(<span class="string">&quot;张三&quot;</span>).age(<span class="number">20</span>).build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// build 方法调用之前其实是一个 Builder 对象</span></span><br><span class="line"><span class="type">StudentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Student.builder().name(<span class="string">&quot;张三&quot;</span>).age(<span class="number">20</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> builder.build();</span><br></pre></td></tr></table></figure><p><strong>Lombok</strong></p><p>Lombok 中使用 <code>@Builder</code> 注解可以自动生成模板代码</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>set 方法</td><td>简单直接</td><td>写法繁杂；无法从整体控制变量赋值情况</td></tr><tr><td>有参构造</td><td>对属性赋值进行有力约束</td><td>不灵活，如果最终对象种类多会出现多个不同参数的有参构造器，或者大而全参数的构造器</td></tr><tr><td>链式赋值</td><td>写法流畅</td><td>简单的优化，但是也只解决了写法繁杂的问题</td></tr><tr><td>Builder</td><td>功能强大可扩展</td><td>过程中会创建更多对象；实现复杂</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/weixin_45796051/article/details/121946894">https://blog.csdn.net/weixin_45796051/article/details/121946894</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RECIPES - Crimson Sour</title>
      <link href="/2023/01/02/%E4%BA%BA%E7%94%9F/%E9%85%92/RECIPES%20-%20Crimson%20Sour/"/>
      <url>/2023/01/02/%E4%BA%BA%E7%94%9F/%E9%85%92/RECIPES%20-%20Crimson%20Sour/</url>
      
        <content type="html"><![CDATA[<p><img src="https://assets-prd.punchdrink.com/wp-content/uploads/2022/09/14141915/Article-lactic-syrup-800x450.jpg" alt="Article-lactic-syrup-800x450.jpg (800×450) (punchdrink.com)"></p><h1 id="深红酸酒-Crimson-Sour"><a href="#深红酸酒-Crimson-Sour" class="headerlink" title="深红酸酒 Crimson Sour"></a>深红酸酒 Crimson Sour</h1><p><a href="https://punchdrink.com/recipes/crimson-sour/">Crimson Sour Vermouth Cocktail Recipe | PUNCH (punchdrink.com)</a></p><blockquote><p>Sour 作为名词直接有”酸味鸡尾酒“的意思</p><p>a drink made from strong alcohol, lemon, or lime juice, sugar, and ice</p><p>Whisky Sour 威士忌酸味鸡尾酒</p></blockquote><p>娜塔莎 · 大卫在她的书 <em>Drink Lightly</em> 中建议大家制作这杯鸡尾酒时使用大量应季的柑橘类水果</p><p>新鲜的血橙是这场秀的明星，“除了看起来光彩照人之外，它还拥有美丽的甜味，并且具有一种令人陶醉的、几乎熟透了的覆盆子味道”</p><h2 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h2><p><em>Serving: 1</em></p><ul><li>浓烈的甜味美思 - 1.5 盎司（<a href="https://www.diffordsguide.com/beer-wine-spirits/7232/lejon-sweet-vermouth">LeJon Sweet Vermouth</a>）</li><li>新鲜柠檬汁 - 0.75 盎司</li><li>新鲜血橙汁 - 0.75 盎司</li><li>可可豆碎金巴利 - 0.5 盎司（见注释）</li><li>香草乳酸糖浆 - 0.5 盎司（见注释）</li></ul><p><strong>装饰：</strong>血橙半圆切片（crescent）、柠檬轮</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>将所有原料和冰块混合，进行短暂的 shake</li><li>滤入装满碎冰的双层岩石杯（Double Rocks glass）；顶部补充更多的碎冰，像雪堆一样</li><li>使用血橙半圆切片和柠檬轮进行装饰，插上吸管</li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="可可豆碎金巴利（Cacao-Nib-Campari）"><a href="#可可豆碎金巴利（Cacao-Nib-Campari）" class="headerlink" title="可可豆碎金巴利（Cacao Nib Campari）"></a>可可豆碎金巴利（Cacao Nib Campari）</h3><ul><li>可可豆碎 - 25 克</li><li>金巴利 - 750 毫升</li></ul><p>将可可豆碎铺在烤盘，烘烤 3 到 4 分钟直到产生香味并变为深棕色</p><p>冷却后倒入一个可以密封的容器中与金巴利混合，盖上盖子静置 24 个小时，使用滤网（chinoise）过滤后装瓶冷藏</p><h3 id="香草乳酸糖浆（Vanilla-Lactic-Syrup）"><a href="#香草乳酸糖浆（Vanilla-Lactic-Syrup）" class="headerlink" title="香草乳酸糖浆（Vanilla Lactic Syrup）"></a>香草乳酸糖浆（Vanilla Lactic Syrup）</h3><ul><li>基础糖浆 - 500 克（糖水比 1:1）</li><li>Tahitian 香草提取物 - 4 克（<a href="https://www.amazon.com/-/zh/dp/B004QQ7YVM/ref=sr_1_1?__mk_zh_CN=%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%BD%91%E7%AB%99&crid=3JYYCZAUEANB5&keywords=Tahitian+vanilla+extract&qid=1672675608&sprefix=chinoise,aps,776&sr=8-1">Amazon.com: Cook’s Pure South Pacific Vanilla Extract 4 oz</a>）</li><li>乳酸粉 - 2 克</li><li>犹太盐（kosher salt） - 1 pinch</li></ul><blockquote><p>Kosher salt</p><p>Kosher salt 指的是完全不加碘盐，并且盐的晶体颗粒会比一般的盐要大一些</p><p>一般的食盐中都会加碘，这样会让盐带有碘的味道，也会影响到菜肴最终的味道，使用 Kosher salt 就不会有这些问题</p><p>另外，Kosher salt 由于晶体颗粒更大，能够更有效地从肉类中吸收水分，能够更好地帮助肉类进行符合犹太人教规处理（除去血液），这种处理后的食物称之为 Kosher food，这也是 Kosher salt 名字的由来</p></blockquote><blockquote><p>1 pinch</p><p>翻译为一撮</p><p>a pinch of salt 往往也表示 “不可尽信”</p><p>take … with a pinch of salt “对 … 不可尽信、持保留意见”</p></blockquote><p>在一个碗中混合糖浆、香草精、乳酸粉和盐</p><p>使用搅拌器搅拌，直到乳酸和盐溶解；倒入密封容器中冷藏 4 周</p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 酒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸡尾酒 </tag>
            
            <tag> recipes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES 的限制和疑难问题</title>
      <link href="/2022/12/31/%E5%BC%80%E5%8F%91/ES/ES%20%E7%9A%84%E9%99%90%E5%88%B6%E3%80%81%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98/"/>
      <url>/2022/12/31/%E5%BC%80%E5%8F%91/ES/ES%20%E7%9A%84%E9%99%90%E5%88%B6%E3%80%81%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p> <em><strong>Programmers know the benefits of everything and the tradeoffs of nothing.</strong></em></p><p><em>程序员知道任何事情的收益，却不去权衡利弊</em></p><p><a href="https://www.simplethread.com/relational-databases-arent-dinosaurs-theyre-sharks/">Relational Databases Aren’t Dinosaurs, They’re Sharks - Simple Thread</a></p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>使用关系型数据的思想去操作 ES，会发现很多功能的实现和想象中有出入</p><p>或者 ES 能够实现很多操作，但同时又有很多限制，在解决了一些问题基础上（天然分布式适合大数据量、top hit 这种方便的功能、模糊搜索分词器），是否也引入了一些新问题</p><p>记录下 ES 难以处理的问题以及当前的处理方法，是否可以有更好的处理方式，或者选型中避免处理此类问题</p><h1 id="深度分页"><a href="#深度分页" class="headerlink" title="深度分页"></a>深度分页</h1><p>ES 作为天然的分布式系统，数据分散至各个 shard 进行存储</p><p>带来的问题就是随着分页深度的增加，成本的增加也会更加明显</p><p>ES 假设一页有 100 条数据，需要查询第 100 页数据（即 from &#x3D; 9900，size &#x3D; 100），那么对于每一个节点都需要查询 10000 条数据，汇总给协调节点后，再有协调节点排序，最终选取真实命中的 100 条数据返回</p><p>所以对于深度分页 ES 进行了限制，默认的配置是 from + size &lt; 10000，大于限制的查询操作会被拒绝</p><p><strong>现在是怎么处理的</strong></p><p>没有好的办法，限制跳页的深度，如果需要查询更精准的数据就增加查询条件来缩小范围</p><p>业务绝大多数场景应该也没有查看这么多页数据的必要</p><p>可以使用 search after、scroll 避免深度分页限制，但是都有各自场景的限制</p><h1 id="索引刷新间隔"><a href="#索引刷新间隔" class="headerlink" title="索引刷新间隔"></a>索引刷新间隔</h1><p>索引下会有一个参数值 <code>refresh_interval</code>，表示 ES 刷新索引的间隔</p><p>刚进行索引的文档并不会立即对搜索可见，而是满足一定的要求后才会将 buffer 中的数据建立索引写入文件区，其中 <code>refresh_interval</code> 参数指定一定的时间间隔后将数据进行索引</p><p><code>refresh_interval</code>  的单位：</p><ul><li>ms</li><li>s</li><li>m</li></ul><p>单位缺省值为 ms，如果配置为 <code>-1</code> 则表示不刷新索引，当需要导出大量数据时，可以将 <code>refresh_interval</code> 设置为 <code>-1</code> 加快导入速度，导入完成后再设置刷新间隔或者手动刷新</p><p><strong>设置 refresh_interval</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT /<span class="punctuation">&#123;</span>index<span class="punctuation">&#125;</span>/_settings</span><br><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">  <span class="attr">&quot;refresh_interval&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1s&quot;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>强制刷新</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST <span class="punctuation">&#123;</span>index<span class="punctuation">&#125;</span>/_doc?refresh</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>现在是怎么处理的</strong></p><p>根据业务情况合理设置刷新间隔，需要兼顾 ES 压力和数据实时性要求，暂时配置的 500 ms</p><p>但是 scroll + update by doc id 的更新方式是否会因为 scroll 的快照特性和索引刷新时间问题而导致数据错误？这种情况怎么避免</p><p>不及时刷新也会导致 update by query 操作冲突</p><h1 id="根据条件更新-update-by-query"><a href="#根据条件更新-update-by-query" class="headerlink" title="根据条件更新 update by query"></a>根据条件更新 update by query</h1><p>update by query 操作看起来类似 SQL 中的 <code>UPDATE FROM ... SET ... WHERE ...</code>，但使用起来也有很多限制</p><p>更新内容使用 script 指定，例如，姓名为 <code>张三</code> 的数据 age + 1 </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST my-index/_update_by_query</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;script&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctx._source.age++&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lang&quot;</span><span class="punctuation">:</span> <span class="string">&quot;painless&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>因为 ES 的锁机制比较简单，对于冲突只能选择两种操作</p><blockquote><p><strong><code>conflicts</code></strong></p><p>(Optional, string) What to do if update by query hits version conflicts: <code>abort</code> or <code>proceed</code>. Defaults to <code>abort</code>.</p></blockquote><p>同时需要进行手动刷新，否则可能会频繁冲突</p><blockquote><p><strong><code>refresh</code></strong></p><p>(Optional, Boolean) If <code>true</code>, Elasticsearch refreshes affected shards to make the operation visible to search. Defaults to <code>false</code>.</p></blockquote><p>此外，ES 客户端和服务端是通过 REST 进行交互，连接时间是存在限制的，默认是 30 s</p><p>当脚本具有一定的处理逻辑，并且数据量较大，很有可能在限制时间内没有处理完成，就会抛出超时异常</p><p><strong>现在是怎么处理的</strong></p><p>配置连接时间，减少更新的文档数量，每次写入都进行更新</p><h1 id="list-字段增删元素"><a href="#list-字段增删元素" class="headerlink" title="list 字段增删元素"></a>list 字段增删元素</h1><p>ES mapping 中字段是不限制元素数量的（感觉和索引的实现方式有关）</p><p>例如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /my-index/_mapping</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;my-index&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;field_1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;field_2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>数据可以是</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;field_1&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;field_2&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>那么在更新 list 字段时就需要考虑更新方式，如果是刷新文档进行覆盖，会不会出现数据错误？</p><p>假设一个操作要给字段增加一个元素 1，而另一个操作要删除元素 2</p><table><thead><tr><th align="center">时间</th><th align="center">线程 1</th><th align="center">线程 2</th></tr></thead><tbody><tr><td align="center">T1</td><td align="center">查询文档数据 doc，得到 field &#x3D; [2,3]</td><td align="center">&#x2F;</td></tr><tr><td align="center">T2</td><td align="center">处理得知，需要写入的数据 field &#x3D; [1,2,3]</td><td align="center">查询文档数据 doc，得到 field &#x3D; [2,3]</td></tr><tr><td align="center">T3</td><td align="center">写入 ES，field &#x3D; [1,2,3]</td><td align="center">处理得知，需要写入的数据 field &#x3D; [3]</td></tr><tr><td align="center">T4</td><td align="center">&#x2F;</td><td align="center">写入 ES，field &#x3D; [3]</td></tr></tbody></table><p>最终导致数据错误（没有 DB 的锁机制那么方便）</p><p><strong>update by query</strong></p><p>当然可以使用 update by query 来使用脚本进行操作，相当于把一部分运算逻辑放在了 ES 来执行</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST my-index/_update_by_query</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;script&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;if(ctx._source.projectIds == null)&#123;ctx._source.projectIds = [];ctx._source.projectIds.add(params.id);&#125;else&#123;def index = ctx._source.projectIds.indexOf(params.id);if(index == -1)&#123;ctx._source.projectIds.add(params.id);&#125;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lang&quot;</span><span class="punctuation">:</span> <span class="string">&quot;painless&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>现在是怎么处理的</strong></p><p>使用 update by query 脚本进行增删，配置连接时间，限制更新的数据量（时间作为条件）</p><h1 id="折叠、聚合不支持滚动查询"><a href="#折叠、聚合不支持滚动查询" class="headerlink" title="折叠、聚合不支持滚动查询"></a>折叠、聚合不支持滚动查询</h1><p>scroll，search after 可以不受深度分页的限制，现在的客户端对于 scroll 操作包装的比较简单（没法指定数据集 size），并且一次性取出所有数据进入内存</p><p>所以使用 search after 来实现对更大量数据的查询（导出）</p><p>但折叠（Collapse）和聚合（Aggregations）操作无法支持 scroll 或者 search after 的查询方式</p><p><strong>现在是怎么处理的</strong></p><p>对于折叠或者聚合的数据使用分页进行查询，无法避免深度分页的限制</p><h1 id="聚合桶数量限制"><a href="#聚合桶数量限制" class="headerlink" title="聚合桶数量限制"></a>聚合桶数量限制</h1><p>ES 的聚合从功能上可以分为 3 类：</p><ul><li>桶聚合（Bucket）：对数据进行分组（分桶）；类似 <code>GROUP BY</code><ul><li>Date histogram 日期直方图</li><li>Range 范围</li><li>Terms 字段值</li><li>…</li></ul></li><li>指标聚合（Metric）：对桶内数据进行指标的计算；类似聚合函数<ul><li>Avg 平均数</li><li>Max 最大值</li><li>Sum 求和</li><li>…</li></ul></li><li>管道聚合（Pipeline）：以其他聚合作为元数据的聚合；相当于在其他聚合的基础上再次进行操作<ul><li>Bucket selector 桶选择器</li><li>Bucket sort 桶排序</li><li>Max bucket 最大的桶</li><li>…</li></ul></li></ul><p>桶聚合中最常见的场景就是根据字段值进行分桶（相当于 <code>GROUP BY</code> 多个字段）</p><p>但是 ES 中对于桶的数量是有限制的，当一次请求超过桶数量限制（默认为 <code>123</code>），则查询会返回错误  <code>trying to create too many buckets. must be less than or equal to: [100000] but was [100001]</code></p><p>这是 6.x 以后版本的特性， 目的是限制大批量聚合操作， 规避性能风险</p><p>当然可以进行配置，但也就意味着可能承担更多的性能风险</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /_cluster/settings</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;persistent&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;search.max_buckets&quot;</span><span class="punctuation">:</span> <span class="number">20000</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>桶聚合的 size</strong></p><p>同时，桶聚合需要指定 <code>size</code> 参数，也就是说 ES 并不会直接计算出所有的桶</p><p>假设 <code>size</code> 设置为 <code>1000</code>，此时数据中根据某个维度分桶有 <code>1500</code> 个，那么 ES 只会选择 top 1000 个桶进行返回</p><p><strong>现在是怎么处理的</strong></p><p>对于桶聚合的 <code>size</code>，给定一个较大的值，在短期内应该不会出现这么桶，如果超出限制则由查询逻辑手动进行桶的划分，同时业务是不是业务要思考，需不需要关注一个维度数据下所有值的结果（比如只关注 top 的数据）</p><p>对于桶数量显示，使用默认值，定时聚合中间结果（牺牲实时性，对查询有利），聚合过程中可以手动拆分聚合维度来减少桶的数量</p><h1 id="聚合后排序和分页"><a href="#聚合后排序和分页" class="headerlink" title="聚合后排序和分页"></a>聚合后排序和分页</h1><p>聚合后是无法按照文档内字段顺序来进行排序的（这点在关系型数据库中应该也是如此），但是 ES 的折叠操作可以按照文档顺序进行</p><p>聚合后的排序肯定只能通过聚合维度来进行排序（桶聚合的 key 或者指数聚合的结果），排序和分页的实现使用管道聚合中的 <code>Bucket sort</code> 实现</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">POST /sales/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;sales_per_month&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;date_histogram&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;calendar_interval&quot;</span><span class="punctuation">:</span> <span class="string">&quot;month&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;total_sales&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;sum&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;price&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sales_bucket_sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;bucket_sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="punctuation">&#123;</span> <span class="attr">&quot;total_sales&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span> </span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">3</span>                                </span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>上述操作：</p><ul><li>对日期按月进行桶聚合</li><li>对 <code>price</code> 字段进行 <code>sum</code> 的指数聚合</li><li>对桶聚合进行排序和分页，按照指数聚合 <code>total_sales</code> 结果倒序，取 3 条数据</li></ul><p>这里会出现一个问题，如果是嵌套的桶聚合，<code>bucket_sort</code> 是无法对上层桶，或者对全局的桶进行分页操作</p><blockquote><p>ES 文档原文 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.5/search-aggregations-pipeline-bucket-sort-aggregation.html">Bucket sort aggregation | Elasticsearch Guide [8.5] | Elastic</a></p><p>The <code>bucket_sort</code> aggregation, like all pipeline aggregations, is executed after all other non-pipeline aggregations. This means the sorting only applies to whatever buckets are already returned from the parent aggregation. For example, if the parent aggregation is <code>terms</code> and its <code>size</code> is set to <code>10</code>, the <code>bucket_sort</code> will only sort over those 10 returned term buckets.</p></blockquote><p>在关系型数据库中，假设对 A、B 字段进行聚合操作，然后在其基础上进行分页后有 5 条数据</p><p>A - 1、A - 2、B - 1、B - 2、B - 3</p><p>那么使用 <code>bucket_sort</code> 分页后，假设 <code>from = 0，size = 1</code></p><p>理想情况下是只返回 A - 1 这一条</p><p>但因为只对 <code>parent</code> 桶有效，实际的返回会是</p><p>A - 1 和 B - 1，因为 <code>size</code> 只限制了 B 字段分桶的桶数量</p><blockquote><p>摘自网络 <a href="https://blog.csdn.net/weixin_29715563/article/details/112106227">https://blog.csdn.net/weixin_29715563/article/details/112106227</a></p><p>张超大佬指出：分析系统里跑全量的 group by 我觉得是合理的需求， clickhouse 很擅长做这种事，es 如果不在这方面加强，分析场景很多会被 clickhouse 替掉</p><p>腾讯大佬指出：聚合这块比较看场景。因为我这边有一些业务是做聚合，也就是 olap 场景，多维分析，ES 并不是特别擅长，如果有丰富的多维分析场景，还有比较高的性能要求。我建议可以调研下 clickhouse。我们这边测评过开源和内部的大部分场景 clickhouse 几十亿的级别，基本也在秒级返回甚至毫秒级</p></blockquote><p><strong>Kibana 是怎样实现的</strong></p><p>在 Kibana 上配置图表，看起来能直接实现很类似的功能</p><img src="/2022/12/31/%E5%BC%80%E5%8F%91/ES/ES%20%E7%9A%84%E9%99%90%E5%88%B6%E3%80%81%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98/Kibana%E7%9A%84%E8%81%9A%E5%90%88%E5%9B%BE%E8%A1%A8.jpg" class=""><p>并且还支持跳页，不过看了其请求，在刷新时直接进行了一次大请求，返回了所有数据，最后应该是在内存中进行的分页操作</p><p>所以看起来 ES 的聚合本身就无法支持嵌套分页的操作</p><p><strong>现在是怎么处理的</strong></p><p>使用默认值，定时聚合中间结果（牺牲实时性，对查询有利），就可以根据中间结果进行分页了，业务也需要考虑是否有必要跳页，聚合后的结果是动态的、非直观的，跳页查询还有意义吗</p><p>同时对于嵌套聚合、折叠的场景，拼接一个用于聚合的 key 作为聚合字段（相当于业务数据手动拼接一个 key，使一层聚合实现嵌套聚合的效果，只能针对固定需求，丧失了灵活性）</p><h1 id="桶聚合准确性"><a href="#桶聚合准确性" class="headerlink" title="桶聚合准确性"></a>桶聚合准确性</h1><p>ES 的桶聚合会由各个分片聚合出结果后再交由协调节点汇总数据（也就是此时汇总数据是没有全局视野的），可能会导致桶的不准确</p><p>这个参数由桶聚合的 <code>shard_size</code> 进行控制，默认取值为 <code>size × 1.5 + 10</code></p><p>也就是每个节点只会聚合 <code>shard_size</code> 大小的结果返回给协调节点，再有协调节点合并结果，返回出 <code>size</code> 所需数量的桶（可以看出 <code>shard size</code> 不可能小于 <code>size</code>）</p><p>也就是最终结果的桶并不是绝对准确的，需要合理设置 <code>shard_size</code> 平衡准确性和性能</p><p><strong>现在是怎么处理的</strong></p><p>因为聚合桶数量限制，<code>size</code> 设置了一个短期来看足够大的值，所以 <code>shard_size</code> 同样很大</p><p>应该暂时不会存在桶不准确问题</p><h1 id="基数聚合准确性"><a href="#基数聚合准确性" class="headerlink" title="基数聚合准确性"></a>基数聚合准确性</h1><p>因为分页展示的要求，对于聚合或者折叠后，需要统计桶的数量</p><p>嵌套操作无法进行基数聚合，所以此处也使用了业务手动拼接的聚合 key，进行 <code>cardinality</code> 操作</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST /sales/_search?size=<span class="number">0</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;cardinality&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，基数聚合虽然可以统计出基数，但底层使用 HyperLogLog 进行实现，也就是带有一定的误差</p><p><img src="https://www.elastic.co/guide/en/elasticsearch/reference/8.5/images/cardinality_error.png" alt="cardinality_error.png (1000×400) (elastic.co)"></p><p>误差是比较小的，即使阈值低至 100，即使在百万 + 基数时，误差仍然很低（如上图所示，为1 - 6%）</p><p>允许误差存在会导致最终总页数不准确，或者每次查询都有所区别</p><p>不过 <code>cardinality</code> 支持精度参数 <code>precision_threshold</code>，如果基数数量在指定精度以内，那么就不存在误差</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST /sales/_search?size=<span class="number">0</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;cardinality&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;precision_threshold&quot;</span><span class="punctuation">:</span> <span class="number">100</span> </span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>现在是怎么处理的</strong></p><p>因为本身 ES 就有深度分页的限制（默认 10000），所以对于基数聚合也指定了 <code>precision_threshold = 10000</code></p><p>这样对于基数 10000 以内的数据会返回精确值，超过 10000 就不需要关注精确的值，只向前端返回 10000 限制跳页深度</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> ES </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua 基本语法</title>
      <link href="/2022/12/31/%E5%BC%80%E5%8F%91/Redis/Lua%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/12/31/%E5%BC%80%E5%8F%91/Redis/Lua%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p><strong>基本的操作</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">str = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br><span class="line"><span class="built_in">print</span>(str)</span><br></pre></td></tr></table></figure><p><strong>多重赋值语句</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a,b = <span class="number">1</span>,<span class="number">2</span>;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p><strong>值为 nil</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">--值为nil</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment">--值为nil</span></span><br></pre></td></tr></table></figure><p><strong>十六进制与科学计数法</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0x11</span></span><br><span class="line">b = <span class="number">2e10</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><h2 id="数字运算符"><a href="#数字运算符" class="headerlink" title="数字运算符"></a>数字运算符</h2><p><strong>Lua 支持加减乘除、幂等多种运算</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(a+b)</span><br><span class="line"><span class="built_in">print</span>(a-b)</span><br><span class="line"><span class="built_in">print</span>(a/b)</span><br><span class="line"><span class="built_in">print</span>(a*b)</span><br><span class="line"><span class="built_in">print</span>(b^a)</span><br><span class="line"><span class="built_in">print</span>(a^b)</span><br><span class="line"><span class="built_in">print</span>(a==b)</span><br><span class="line"><span class="built_in">print</span>(a~=b) <span class="comment">--lua的不等于符号为&quot;~=&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a&gt;=b)</span><br><span class="line"><span class="built_in">print</span>(a&lt;=b)</span><br></pre></td></tr></table></figure><h2 id="逻辑运算符与-true、false"><a href="#逻辑运算符与-true、false" class="headerlink" title="逻辑运算符与 true、false"></a>逻辑运算符与 true、false</h2><p><strong>注意：0 为 true，nil 为 false</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="literal">nil</span></span><br><span class="line">b = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">and</span> b)</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">or</span> b)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> b)</span><br></pre></td></tr></table></figure><p><strong>三元表达式</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(a &lt;=<span class="number">0</span> <span class="keyword">and</span> <span class="string">&quot;小于等于 0&quot;</span> <span class="keyword">or</span> <span class="string">&quot;大于 0&quot;</span>) <span class="comment">--输出&quot;小于等于 0&quot;</span></span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><strong>单引号双引号均可</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;hello world a&#x27;</span></span><br><span class="line">b = <span class="string">&quot;hello world b&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p><strong>转义字符</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;hello world\n换行&#x27;</span> <span class="comment">--\n换行</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p><strong>中括号保留原始值（忽略转义）</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">[[&#x27;hello world\n换行&#x27;]]</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p><strong>字符串使用 “..” 进行连接</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;hello &#x27;</span></span><br><span class="line">b = <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a..b)</span><br></pre></td></tr></table></figure><p><strong>tostring(param) 与 tonumber(param)</strong><br>如果tonumber()转换失败则值为nil</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">tostring</span>(<span class="number">1000</span>)</span><br><span class="line">b = <span class="string">&#x27;world&#x27;</span></span><br><span class="line">c = <span class="built_in">tonumber</span>(<span class="string">&quot;500&quot;</span>)</span><br><span class="line">d = <span class="built_in">tonumber</span>(<span class="string">&quot;str&quot;</span>) <span class="comment">--值为nil</span></span><br><span class="line"><span class="built_in">print</span>(a..b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure><p><strong>变量前加 ‘#’ 获取字符串长度</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(#a)</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>函数的基本形式</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(a,b)</span></span></span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>没有传参的参数值为 nil</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(a,b,c)</span></span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>可以 return 多个值，多个值可以配合多重赋值语句</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(a,b,c)</span></span></span><br><span class="line"><span class="keyword">return</span> a,b,c</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> aa,bb,cc = f(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(aa)</span><br><span class="line"><span class="built_in">print</span>(bb)</span><br><span class="line"><span class="built_in">print</span>(cc)</span><br></pre></td></tr></table></figure><h2 id="table-结构"><a href="#table-结构" class="headerlink" title="table 结构"></a>table 结构</h2><p><strong>table 类似数组，但是可以存数字、字符串、其他 table、函数在一个 table 中</strong><br><strong>table 下标从 1 开始</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tab = &#123;<span class="number">1</span>,<span class="string">&quot;hello world&quot;</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(tab[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><strong>下标越界的元素为 nil</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tab = &#123;<span class="number">1</span>,<span class="string">&quot;hello world&quot;</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(tab[<span class="number">10</span>])</span><br></pre></td></tr></table></figure><p><strong>指定位置插入元素</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tab = &#123;<span class="number">1</span>,<span class="string">&quot;hello world&quot;</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span>&#125;</span><br><span class="line">tab[<span class="number">10</span>] = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(tab[<span class="number">10</span>])</span><br></pre></td></tr></table></figure><p><strong>最后插入元素</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tab = &#123;<span class="number">1</span>,<span class="string">&quot;hello world&quot;</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span>&#125;</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(tab,<span class="string">&quot;no.n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tab[<span class="number">5</span>])</span><br></pre></td></tr></table></figure><p><strong>指定位置插入元素</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tab = &#123;<span class="number">1</span>,<span class="string">&quot;hello world&quot;</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span>&#125;</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(tab,<span class="number">3</span>,<span class="string">&quot;no.3&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tab[<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p><strong>删除元素</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tab = &#123;<span class="number">1</span>,<span class="string">&quot;hello world&quot;</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span>&#125;</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(tab,<span class="number">2</span>,<span class="string">&quot;no.2&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tab[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> del = <span class="built_in">table</span>.<span class="built_in">remove</span>(tab,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(tab[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(del)</span><br></pre></td></tr></table></figure><p><strong>字符串作为下标 key</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tab = &#123;</span><br><span class="line">a = <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">b = <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">c = <span class="number">100</span>,</span><br><span class="line">d = &#123;&#125;,</span><br><span class="line">e = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(tab.a)</span><br><span class="line"><span class="built_in">print</span>(tab.b)</span><br><span class="line"><span class="built_in">print</span>(tab.c)</span><br><span class="line"><span class="built_in">print</span>(tab.d)</span><br><span class="line"><span class="built_in">print</span>(tab.e)</span><br></pre></td></tr></table></figure><p><strong>特殊符号下标</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tab = &#123;</span><br><span class="line">a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tab[<span class="string">&quot;...&quot;</span>] = <span class="string">&quot;....&quot;</span></span><br><span class="line">tab[<span class="string">&quot;abc&quot;</span>] = <span class="string">&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(tab[<span class="string">&quot;...&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(tab[<span class="string">&quot;abc&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(tab.abc)</span><br></pre></td></tr></table></figure><p>字符串作为下标可以使用 <code>tab.abc</code>，特殊符号只能通过 <code>tab[&quot;...&quot;]</code> 形式指定下标</p><h2 id="分支判断"><a href="#分支判断" class="headerlink" title="分支判断"></a>分支判断</h2><p><strong>以 if 和 end 为代码块，支持 elseif</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line"><span class="keyword">if</span> a==<span class="number">10</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a==10&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a == <span class="number">9</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a==9&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a&gt;<span class="number">5</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&gt;5&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a&lt;=<span class="number">5</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&lt;=5&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>0 为 true，nil 为 false</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span></span><br><span class="line">b = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;0 is true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;0 is false&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> b <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nil is true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nil is false&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><strong>起始值为 0，到 10 结束</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">0</span>,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>起始值为 10，步长为 -1，到 0 结束</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">10</span>,<span class="number">0</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>循环中 i 的值不能更改（循环所用的值其实是变量 i 的值拷贝）</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">10</span>,<span class="number">0</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line">i = <span class="number">5</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>break 语句</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">10</span>,<span class="number">0</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">6</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>while 语句</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line"><span class="keyword">while</span> num &gt; <span class="number">5</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line">num = num - <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><strong>string.char() 支持十进制、十六进制等</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">string</span>.<span class="built_in">char</span>(<span class="number">104</span>,<span class="number">101</span>,<span class="number">108</span>,<span class="number">0x6C</span>,<span class="number">0x6f</span>) <span class="comment">--&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><p><strong>string.byte() 取出第 n 位字母的十进制</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">string</span>.<span class="built_in">char</span>(<span class="number">104</span>,<span class="number">101</span>,<span class="number">108</span>,<span class="number">0x6C</span>,<span class="number">0x6f</span>)</span><br><span class="line">n = <span class="built_in">string</span>.<span class="built_in">byte</span>(s,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure><p><strong>0x00 在 lua 字符串中不会影响字符串的结束，取值为 0</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">string</span>.<span class="built_in">char</span>(<span class="number">104</span>,<span class="number">101</span>,<span class="number">0x00</span>,<span class="number">108</span>,<span class="number">0x6C</span>,<span class="number">0x6f</span>)</span><br><span class="line">n = <span class="built_in">string</span>.<span class="built_in">byte</span>(s,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(n) <span class="comment">--&quot;0&quot;</span></span><br><span class="line"><span class="built_in">print</span>(#s) <span class="comment">--&quot;6&quot;</span></span><br></pre></td></tr></table></figure><h1 id="参考手册"><a href="#参考手册" class="headerlink" title="参考手册"></a>参考手册</h1><p><a href="https://www.runoob.com/manual/lua53doc/contents.html#contents">Lua 5.3 参考手册 - 目录 (runoob.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RECIPES - Añejo Highball</title>
      <link href="/2022/12/28/%E4%BA%BA%E7%94%9F/%E9%85%92/RECIPES%20-%20A%C3%B1ejo%20Highball/"/>
      <url>/2022/12/28/%E4%BA%BA%E7%94%9F/%E9%85%92/RECIPES%20-%20A%C3%B1ejo%20Highball/</url>
      
        <content type="html"><![CDATA[<p><img src="https://assets-prd.punchdrink.com/wp-content/uploads/2022/11/17163411/Article-Anejo-Highball-500x687.jpg" alt="Article-Anejo-Highball-500x687.jpg (500×687) (punchdrink.com)"></p><h1 id="有年代的嗨棒-Anejo-Highball"><a href="#有年代的嗨棒-Anejo-Highball" class="headerlink" title="有年代的嗨棒 Añejo Highball"></a>有年代的嗨棒 Añejo Highball</h1><p><a href="https://punchdrink.com/recipes/flatliner/"><a href="https://punchdrink.com/recipes/anejo-highball/">Añejo Highball Cocktail Recipe | PUNCH (punchdrink.com)</a></a></p><blockquote><p>añejo (plural añejos) - A tequila or rum which has been aged.</p><p>陈年的龙舌兰或者朗姆</p></blockquote><p>在 90 年代风靡一时的苹果和荔枝味 “tinis” 中，出现了一类更为柔和的鸡尾酒，对世界各地的调酒方法产生了深远的影响</p><p>Añejo Highball 就是其中之一，它以朗姆酒、库拉索酒、青柠汁和姜汁啤酒的简单组合，却呈现出精彩一课</p><h2 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h2><p><em>Serving: 1</em></p><ul><li>陈年朗姆 - 1.5 盎司</li><li>库拉索酒 - 0.5 盎司（<a href="https://www.diffordsguide.com/beer-wine-spirits/734/pierre-ferrand-dry-curacao">Pierre Ferrand Dry Curacao</a>）</li><li>青柠汁 - 0.25 盎司</li><li>安高天娜苦精 - 2 dashes（<a href="https://www.diffordsguide.com/beer-wine-spirits/3505/angostura-orange-bitters">Angostura Orange Bitters</a>）<em>没有指明 Angostura 哪种苦精，感觉橙味可能性更大</em></li><li>姜汁啤酒 - 2 盎司</li></ul><p><strong>装饰：</strong>青柠轮，橙子切片</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>在盛满冰块的海波杯（Highball glass）中，加入朗姆酒、库拉索酒、莱姆汁和安高天娜苦精</li><li>顶部倒入姜汁啤酒</li><li>使用青柠轮和橙子片进行装饰</li></ol>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 酒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸡尾酒 </tag>
            
            <tag> recipes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RECIPES - Flatliner</title>
      <link href="/2022/12/27/%E4%BA%BA%E7%94%9F/%E9%85%92/RECIPES%20-%20Flatliner/"/>
      <url>/2022/12/27/%E4%BA%BA%E7%94%9F/%E9%85%92/RECIPES%20-%20Flatliner/</url>
      
        <content type="html"><![CDATA[<p><img src="https://assets-prd.punchdrink.com/wp-content/uploads/2022/12/20113103/Article-Espresso-Martini-Telluride-Flatliner-Recipe-800x450.jpg"></p><h1 id="心脏停跳器-Flatliner"><a href="#心脏停跳器-Flatliner" class="headerlink" title="心脏停跳器 Flatliner"></a>心脏停跳器 Flatliner</h1><p><a href="https://punchdrink.com/recipes/flatliner/">Flatliner Espresso Martini Cocktail Recipe Riff | PUNCH (punchdrink.com)</a></p><p>丝般柔滑，泡沫四溢，科罗拉多州（Colorado）特莱瑞德（Telluride）的非正式酒单，和意式浓缩马天尼（Espresso Martini）和泥石流（Mudslide）相似，但对于滑雪小镇居民而言，它是当地的经典</p><p>尽管调酒师史蒂夫 · 福斯特（Steve Foster）起初是在 The Peaks Resort &amp; Spa 供应这一鸡尾酒，但配方已经传遍了整个城市</p><p>如今你会在 New Sheridan Chop House 看到福斯特正在 shaking Flatliner</p><h2 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h2><p><em>Serving: 1</em></p><ul><li>伏特加 - 1 盎司</li><li>甘露咖啡利口酒 - 1 盎司（<a href="https://www.diffordsguide.com/beer-wine-spirits/248/kahlua-coffee-liqueur">Kahlúa coffee liqueur</a>）</li><li>百利甜酒 - 1 盎司（<a href="https://www.diffordsguide.com/beer-wine-spirits/526/baileys-irish-cream-liqueur">Baileys Irish cream liqueur</a>）</li><li>意式浓缩咖啡 - 1 份 or 冷泡咖啡 - 1 盎司</li></ul><p><strong>装饰：</strong> 咖啡豆 - 3 粒</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>将所有原料加入装满冰块的摇壶，开始 shake</li><li>滤入蝶形杯（Coupe glass），然后用咖啡豆作为装饰</li></ol>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 酒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸡尾酒 </tag>
            
            <tag> recipes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精酿啤酒入门</title>
      <link href="/2022/12/25/%E4%BA%BA%E7%94%9F/%E9%85%92/%E7%B2%BE%E9%85%BF%E5%95%A4%E9%85%92/"/>
      <url>/2022/12/25/%E4%BA%BA%E7%94%9F/%E9%85%92/%E7%B2%BE%E9%85%BF%E5%95%A4%E9%85%92/</url>
      
        <content type="html"><![CDATA[<h1 id="精酿"><a href="#精酿" class="headerlink" title="精酿"></a>精酿</h1><blockquote><p>在公司的技术分享周会上进行分享的文档</p><p>只是进了简单的介绍，并且很多地方都是简略地描述了一下</p><p>对于不了解精酿的朋友可以借此了解一下 Craft Beer</p></blockquote><h2 id="什么是-Craft-Beer"><a href="#什么是-Craft-Beer" class="headerlink" title="什么是 Craft Beer"></a>什么是 Craft Beer</h2><p><strong>美国的精酿运动</strong></p><p>20 世纪开始，美国先后经历一战、禁酒令、二战，导致啤酒迅速退出市场</p><p>20 世纪 70 年代，关于家酿啤酒的书籍从英国流出，书中呼吁使用糖浆之类奇特的原料；弗雷德.埃克哈德（Fred Eckhardt）出版了一本题为《拉格啤酒论》的书，虽是薄薄一册，但技术上描述非常详细。可以毫不夸张的说，家酿方式为精酿啤酒运动提供了思想、激情和人物，是重要的源泉</p><p>1976 年，美国开始出现最早的精酿酒厂，生产瓶中发酵的波特、世涛和淡色艾尔供应给早已习惯淡味拉格的酒吧</p><p>1978 年 10 月 14 号，总统 Jimmy Carter 签署了 1337 号议案。这份议案将家庭酿造小量自产自用的啤酒或红酒合法化。从此，美国见证了酿酒文化的复兴和小型酒厂的蓬勃发展。到 1986 年 3 月，5 家自酿酒吧在美国营业</p><p>美国酒厂的总数从 1978 年的 42 家变成 2012 年的 2750 家，甚至超过了美国殖民地时代的大约数字；增长的其中绝大多数都是小型独立酒厂</p><p><strong>精酿的类官方定义</strong></p><p>精酿并不是啤酒的概念，而是啤酒厂的概念</p><p>美国啤酒酿造商协会（Brewers Association）出台的标准，对精酿酒厂的定义为：<strong>小型</strong>、<strong>独立</strong>、<strong>传统</strong></p><ul><li>小型：年产量在 600 万及 600 万桶以下</li><li>独立：其产权不能为其它非精酿酒厂的酒类企业购买，管理或控股超过 25%</li><li>传统：要使用传统或创新的原材料，遵循传统或创新的酿造方法来实现其酿造出啤酒的口味</li></ul><blockquote><p>鹅岛：<a href="https://item.jd.com/100008724119.html">京东链接</a></p><p>拳击猫：<a href="http://www.boxingcatbrewery.com/cn/">Boxing Cat Brewery</a></p></blockquote><p><strong>和工业啤酒的区别</strong></p><ul><li>更高的原料成本</li><li>更丰富的啤酒风格</li><li>更多创意</li><li>啤酒 Pub 门店，提供简餐</li><li>更艺术的美学设计</li><li>更贵</li></ul><p><strong>工厂店</strong></p><p>Craft Beer 的酒厂规模较小，为了突出精酿的理念往往会将生产工厂对外开放，可以预约参观</p><p>工厂店摒弃了分级批发商、分级代理等中间繁冗环节可以降低成本</p><p><a href="https://vitaminseabrewing.com/">VSB (vitaminseabrewing.com)</a></p><p><a href="https://treehousebrew.com/">Tree House Brewing Company</a></p><h2 id="啤酒风格"><a href="#啤酒风格" class="headerlink" title="啤酒风格"></a>啤酒风格</h2><p><strong>BJCP</strong></p><p>啤酒品酒师资格认证协会(BJCP，Beer Judge Certification Program) 于 1985 年创建于美国</p><p>宗旨是推广与传播啤酒相关的各类知识与文化，提升大众对啤酒的认知、品酒和评估水平；创造一个啤酒行业规范的评价程序，引导啤酒爱好者如何正确评价及饮用啤酒，便于对这些酒类进行排名和评比</p><p>BJCP 定期推出啤酒分类指南对啤酒加以科学分类，该指南也已成为世界啤酒市场的风向标，有助于啤友品鉴、自酿比赛筹办、酿友参赛、甚至新啤酒风格的创新</p><p><a href="D:\Relax\Beer\BJCP世界啤酒分类指南中文2015版.pdf">BJCP世界啤酒分类指南中文2015版</a></p><p><a href="https://www.bjcp.org/">Beer Judge Certification Program – Promoting beer literacy, recognizing beer tasting and evaluation skills. (bjcp.org)</a></p><p><strong>错误的分类方式</strong></p><p>啤酒经常会被按照颜色进行分类，比如黑啤、黄啤、白啤</p><p>但是这种分类方式是错误的，因为风格和颜色无关；一种风格往往有一定的色度范围，但并不决对，并且色度范围可能也很大，所以不可能通过颜色去区分啤酒的风格</p><p>啤酒的色度更多来源于酿造时所用的深色麦芽比重，想酿造黑色的 IPA、更浅的世涛也未尝不可</p><p><strong>工业啤酒也有风格</strong></p><p>常说的工业啤酒其实是属于拉格（Lager）这个大分类下</p><blockquote><p>拉格本身也是啤酒分类中的一种创新，本身拉格也是较难酿造的啤酒，因为它的难点在于低温。最早只有在德国北部一些偏冷地区将啤酒放在冰冷的山洞里窖藏才形成了这种风格（Lager 在德语里是窖藏的意思）</p></blockquote><p>那么拉格啤酒风靡世界的原因：</p><ul><li>口味清淡，更清爽</li><li>价格便宜</li><li>度数较低，社交属性</li><li>发酵难度小于艾尔啤酒</li><li>更容易工业生产</li><li>风格稳定</li><li>主流国家的推动，先入为主</li></ul><p><strong>艾尔和拉格</strong></p><p>艾尔（Ale）和拉格（Lager）最初指的是不同的酵母类型，而酵母类型能带来不同的风味</p><p><strong>艾尔</strong>酵母需要更高的温度（15℃~25℃），发酵过程中产生更多的代谢物质，其中包括给啤酒提供复杂香气的酯类、酚类、醛类等风味的物质，也包括不好的物质如双乙酰等；发酵时会产生更多的热量</p><p><strong>拉格</strong>酵母需要温度更低（4℃~12℃），发酵更加彻底，代谢产物较少，味道更加清冽，干净，爽口</p><p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252037761.jpg" alt="img"></p><p><strong>美式风格</strong></p><p>精酿运动发起于美国，所以如今的啤酒风格中经常能看到以 American 开头的风格名称</p><p>美式风格和传统风格（Pale Ale 和 American Pale Ale、Lager 和 American Lager）最大的区别在于使用<strong>美式酒花</strong>替代<strong>传统酒花</strong>，基于此啤酒风格也经常被分类为欧式和美式两大类（并不严谨）</p><p>美式酒花也被称为新世界酒花，传统的欧洲酒花更倾向于提供苦度、辛辣和草本风味，美式酒花更倾向于提供香味、柑橘类、瓜果、热带水果等味道</p><blockquote><p>卡斯卡特 1972 年商品化</p><p>西楚 2008 年商品化</p><p>金牌 1790 年商品化</p></blockquote><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/image-20220315235328107.png" alt="image-20220315235328107" style="zoom: 67%;" /><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252038370.png" alt="image-20220315235403042" style="zoom:67%;" /><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252038169.png" alt="image-20220315235344666" style="zoom: 67%;" /><p><strong>举一些有特点的风格</strong></p><p>（下面的风格名称并不严谨，更多的是商业化风格的叫法）</p><ul><li><strong>印度淡色艾尔（IPA）</strong>：更多的啤酒花带来更高的苦度以及更多的风味 <a href="https://item.jd.com/100011983501.html">北平机器百花深处IPA</a></li><li><strong>古斯（Gose）</strong>：乳酸、盐水、香料 <a href="https://item.jd.com/10030440794661.html">牛啤堂帝都海盐</a></li><li><strong>兰比克（Lambics）</strong>：野菌发酵，更酸，变体是水果兰比克和法柔 <a href="https://item.jd.com/7907410.html">林德曼</a></li><li><strong>牛奶世涛（Milk Stout）</strong>：加了乳糖的世涛，往往追求更高的糊精比重 <a href="https://item.jd.com/100012559742.html">打嗝海狸花生牛奶世涛</a></li><li><strong>小麦啤酒（Wheat）</strong>：小麦作为重要原料，有一定酸度<ul><li><strong>德式小麦</strong>：原料单一（1516 年《德国纯净啤酒法》） <a href="https://item.jd.com/100018726016.html">海底捞德式小麦</a></li><li><strong>比利时小麦</strong>：香料的加入，甜橙皮、芫荽籽 <a href="https://item.jd.com/100020388832.html">1664白啤</a></li></ul></li><li><strong>西打（Cider）</strong>：苹果酒（也可能是其他水果），更多的残糖 <a href="https://item.jd.com/53259108790.html">诱惑（TEMPT）7号</a></li><li><strong>修道院（Trappist &amp; Abbey）</strong>：比利时啤酒，由修道院（Trappist）或修道院授权（Abbey）酿造，收入用于慈善或社区服务，全球共有11家修道院酒厂；传统、高酒精度、厚重、焦糖，辅料大多数加入了比利时棕糖 <a href="https://item.jd.com/3306054.html">罗斯福（Rochefort）10号</a></li></ul><p><strong>更多创意</strong></p><p>精酿运动除了复刻历史上的传统啤酒风格（IPA - 18 世纪、古斯 - 16 世纪），也带来了更多风格创意的探索</p><ul><li><strong>香槟IPA（Brut IPA）</strong>：2017 年首创，使用葡萄糖淀粉酶，更低的苦味，更低的残糖意味着更干的口感</li><li><strong>酒花干投（Dry Hop）</strong>：一种酒花添加方式，适用于各种突出酒花风味类的风格，啤酒花不参与煮沸和旋沉阶段，而在冷却、发酵过程中加入啤酒花，目的是降低苦度增加香味</li><li><strong>燕麦世涛（Oatmeal Stout）</strong>：添加燕麦，追求更重的酒体</li><li><strong>酒花拉格（Hoppy Lager）</strong>：新时代风格，在传统拉格风格下加入大量新世界酒花，拉格的口感和更多的酒花香味和苦度</li><li><strong>水果啤酒（Fruit Beer）</strong>：酿造过程中加入水果甚至果泥（我觉得很难喝）</li></ul><h2 id="快点开喝"><a href="#快点开喝" class="headerlink" title="快点开喝"></a>快点开喝</h2><p><strong>啤酒的属性</strong></p><p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252038639.png" alt="img"></p><p>啤酒的酒标上标注了这瓶啤酒的基本信息</p><ul><li>酒厂（Brand）：Brew Dog</li><li>名称（Name）：Layer Cake</li><li>风格（Style）：Marshmallow &amp; Chocolate Stout 棉花糖 &amp; 巧克力世涛（酒厂自己定义的风格）</li><li>酒精度（ABV）：7%</li><li>容量（volume）：440 ml</li></ul><p>除此之外啤酒的信息</p><ul><li><p>苦度（IBU）：不同的风格苦度差异会很大，IPA（40 ~ 100）、英式苦啤（30 ~ 70）、捷克拉格（20 ~ 40）、西打酒（5 ~ 20）</p></li><li><p>啤酒色度（EBC）：啤酒色度，白 -&gt; 黄 -&gt; 棕 -&gt; 黑</p></li><li><p>终了比重（FG）：数值越大意味着越高的残糖，也可能有更厚重的酒体</p></li><li><p>二次发酵方式：瓶中二发，还是只有一发后打入二氧化碳装瓶</p></li><li><p>罐装杀菌方式：国产啤酒，生啤、纯生</p></li><li><p>其他操作：原浆、一番榨</p></li></ul><p><strong>一些名词</strong></p><ul><li>干 &amp; 甜：干指的是更少的残糖，甜则相反（干红、半干、甜红）</li><li>轻 &amp; 重：酒体中糊精、蛋白质的含量，更重的酒体意味着更厚的口感</li><li>泡沫：一方面来自二氧化碳的含量，一般而言越清爽的风格越追求更多的二氧化碳；另一方面更重的酒体更能产生更绵密的泡沫</li></ul><p><strong>适饮温度</strong></p><p>一定要冰镇</p><p>艾尔类可以比拉格类温度稍高，有助于风味的散发，但肯定要远远低于室温（没有暖气的冬天除外）</p><p><strong>配餐</strong></p><p>啤酒本身就是大众的酒种，喝啤酒的时候搭配高热量的简餐感觉就更爽了，这也是为什么啤酒吧往往都提供简餐；也可以搭配甜品</p><p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039603.png"></p><p><a href="https://www.brewdog.com/uk/bar_pages/bar/locator">Bar Locator (brewdog.com)</a></p><h1 id="酿造"><a href="#酿造" class="headerlink" title="酿造"></a>酿造</h1><h2 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h2><p>酿造啤酒的本质就是粉碎麦芽、糖化麦芽、煮沸麦汁、冷却麦汁、发酵麦汁</p><p><strong>粉碎麦芽</strong>需要用到<strong>粉碎机</strong>，一般使用对碾结构，因为最好的粉碎程度是挤出麦胚但保留麸皮，因为麸皮在后续流程中可以对麦汁进行过滤，减少蛋白质等物质，使酒体更清澈、更稳定</p><p><strong>糖化麦芽</strong>需要<strong>保温桶</strong>，因为需要一定的温度（65℃ 左右）让麦芽内的酶进行工作，分解淀粉为麦芽糖、糊精以及其他产物，麦芽糖就是酒精的来源</p><p><strong>煮沸麦汁</strong>需要<strong>煮沸桶</strong>，保持高温煮沸，让异味物质蒸发（二甲基硫醚），以及投放酒花、辅料通过煮沸来萃取风味，还有最重要的一点就是杀菌</p><p><strong>冷却麦汁</strong>需要用到<strong>冷却盘管</strong>，更高级的设备可以使用<strong>换热器</strong>以及<strong>冷水机</strong>，目的是让麦汁尽可能快速地冷却到适宜投放酵母的温度，减少氧化</p><p><strong>发酵麦汁</strong>需要用到<strong>发酵桶</strong>，密闭、能够安装<strong>单向阀</strong>（发酵过程中会产生大量的热和二氧化碳需要排出）</p><h2 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h2><p><strong>基本原料</strong></p><p>啤酒的四大原料：</p><ul><li>麦芽：大麦麦芽，某些风格可能会使用小麦麦芽</li><li>啤酒花：蛇麻科植物，最早是用来保鲜，现在用来赋予啤酒香味和苦味</li><li>酵母：各种酵母，但总体分为艾尔和拉格两类，酵母生产厂家会有针对此类酵母的详细参数<br><a href="http://wxtest.seastad.com/fermentation-solutions/you-create-beer/you-create-beer.html?id=1">酿啤酒的你 • Fermentis (seastad.com)</a></li><li>水：这个就不解释了</li></ul><p><strong>各种辅料</strong></p><p>除了最基本的原料，啤酒中往往还加入不同的辅料，有的可能是因为风格需要，也有的可能是酿造者的创意</p><p>比如：</p><ul><li>比利时小麦需要加入甜橙皮和芫荽籽</li><li>比利时修道院啤酒需要加入棕糖</li><li>牛奶世涛需要加入乳糖</li><li>燕麦世涛需要加入燕麦</li><li>烟熏啤酒需要加入烟熏木</li><li>蜂蜜酒需要加入蜂蜜</li><li>以及各种创意加入花椒（<a href="https://item.jd.com/10028156058690.html">啤休酿造花椒生姜风味</a>）、花茶（<a href="https://item.jd.com/69394013613.html">高大师</a>）、果汁、香草等等</li></ul><p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039419.png" alt="image-20220316014349585"></p><p><strong>麦芽的种类</strong></p><p>酿造用的麦芽通常称为基础麦芽和特种麦芽，基础麦芽是麦汁中麦芽糖的主体和基本特征，而特种麦芽主要带来更多的风味和色度</p><p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039668.png" alt="image-20220316014132216"></p><p>比如很多名称中带有 “巧克力” 的啤酒，可能并不是添加了巧克力，而是特种麦芽带来的巧克力风味</p><p><strong>啤酒花的种类</strong></p><p>啤酒花的香味来自于植物中所包含的 α—酸、β—酸和香精油，α—酸和β—酸经过高温后会成为啤酒中的苦味物质，但经过高温异构后才能更多溶于水，带来啤酒花的香味，所以啤酒花往往是苦味和香味并存</p><p>干投的方式可以避免啤酒花的苦味进入啤酒，但也减少了香味，所以干投往往需要更大量的啤酒花</p><p>啤酒花有不同的品种，在煮沸过程中不同的时间投入煮沸桶，来达到增加苦味和香味的目的</p><p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039251.png" alt="image-20220316015005883"></p><p><strong>单一酒花</strong></p><p>有的酒款会标注自己是<strong>单一酒花（Single-Hopped）</strong>，意思是所使用的原料里只包含一种品种的啤酒花</p><p>一般所使用的酒花是最新培育出的、风味更独特的新品种，能够更好的感知到这种酒花的风味</p><p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039769.png" alt="image-20220316015127042"></p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul><li><p>第一次发酵（2 周）</p><ul><li><p>粉碎麦芽</p></li><li><p>糖化</p></li><li><p>洗糟</p></li><li><p>煮沸</p></li><li><p>添加辅料、酒花</p></li><li><p>冷却</p></li><li><p>测糖（初始比重）</p></li><li><p>装发酵桶</p></li><li><p>投放酵母</p></li><li><p>液封</p></li></ul></li><li><p>第二次发酵（至少 2 周）</p><ul><li><p>测糖（终了比重）</p></li><li><p>配置二发用糖</p></li><li><p>装瓶</p></li><li><p>冷藏</p></li></ul></li></ul><p>从煮沸后的整个流程都需要对器材进行消毒，特别是发酵桶以及管道，如果这桶酒被杂菌污染，就该扔了</p><p><a href="https://www.youtube.com/watch?v=Wxo9PHc3jNw">How to Make Beer, the Animation. - YouTube</a></p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><strong>评分网站</strong></p><p><a href="https://untappd.com/">Untappd – Drink Socially – Free iOS and Android App</a></p><p><a href="https://www.jiuhuar.com/">精酿啤酒和啤酒世界-酒花儿 (jiuhuar.com)</a></p><p><strong>配方模拟</strong></p><p><a href="https://web.brewfather.app/tabs/tools">Brewfather</a></p><h2 id="还有"><a href="#还有" class="headerlink" title="还有"></a>还有</h2><p><strong>是否安全</strong></p><p>新闻经常报道喝假酒甲醇中毒的案例</p><p>家酿啤酒从工艺到设备肯定无法和酒厂相比，确实相对应的异味物质和不好的产物（甲醇等）会更多</p><p>但啤酒属于酿造酒，酿造酒所产生的酒精度就是比较低的，所以其他代谢产物会更少，甲醇中毒往往来自于蒸馏酒类，本身的甲醇浓度会在蒸馏后变得很高从而超过阈值；其次甲醛的主要来源是果胶，对于啤酒来说原料里果胶的来源非常少</p><p>所使用的酵母往往也是生物公司研制的产品，所带来的负面代谢产物会更少</p><p>食品检测也很方便，啤酒相关物质检测的价格在 200 元左右</p><p><strong>大师杯</strong></p><blockquote><p> 2012 年，中国第一批家酿爱好者和啤酒发烧友开始成立社团、协会，组织各种交流活动。2012 年 8 月，第一本中文啤酒家酿书《喝自己酿的啤酒》作者高岩，在南京创办了大师杯全国家酿啤酒大奖赛（以下简称大师杯），评选出优秀的家酿作品和酿造者，以颂扬酿造的艺术和科学</p><p>大师杯吸纳了诸多国内深耕于行业的先行者，形成大师杯全国家酿啤酒大奖赛组委会，制定并遵循组委会章程，秉承“公平、合理、科学”的价值观，不断提升大师杯的影响力和公信力。</p></blockquote><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039610.jpg" style="zoom: 50%;" /><p><a href="https://mp.weixin.qq.com/s/A2HxAoD_XUNVORqIWppcQA">2022 塔罗斯·大师杯 家酿赛，赛制说明&amp;分组规则</a></p><p><a href="https://mp.weixin.qq.com/s/vQdHVW-YuGWcpzzNXmcabA">2022 塔罗斯·大师杯 广州站报名开始</a></p><p><strong>我酿的啤酒</strong></p><p>曾经参过 2020 年大师杯，评分</p><p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039065.jpg" style="zoom:33%;" /><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039471.jpg" style="zoom:33%;" /></p><p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039794.jpg"></p><h1 id="艺术和文化"><a href="#艺术和文化" class="headerlink" title="艺术和文化"></a>艺术和文化</h1><h2 id="酒厂-amp-酒标"><a href="#酒厂-amp-酒标" class="headerlink" title="酒厂 &amp; 酒标"></a>酒厂 &amp; 酒标</h2><p><strong>打嗝海狸（Belching Beaver）</strong></p><p><a href="https://belchingbeaver.com/">Belching Beaver Brewery</a></p><p><strong>北酿（North Brewing）</strong></p><p><a href="https://shop.northbrewing.com/">North Brewing Co Online Shop</a></p><p><strong>岬角（Ballast Point）</strong></p><p><a href="https://ballastpoint.com/">Homepage - Ballast Point Brewing</a></p><p><strong>伟大理念（Great Notion）</strong></p><p><a href="https://greatnotion.com/">Great Notion | Home</a></p><p><strong>美奇乐（Mikkeller）</strong></p><p><a href="https://mikkeller.com/">Mikkeller</a></p><p><strong>联合艺术（Collective Arts）</strong></p><p><a href="https://collectiveartsbrewing.com/de/">Home - Collective Arts Germany (collectiveartsbrewing.com)</a></p><h2 id="衍生活动"><a href="#衍生活动" class="headerlink" title="衍生活动"></a>衍生活动</h2><p><strong>合酿</strong></p><p>合酿就是两个或多个不同的精酿厂牌在一起合作酿造一款酒，就有点儿像邻居之间的串门一样，今天我去你那儿，明天你来我这儿，大家坐一坐，聊一聊，吃个饭</p><p>除了联络感情，合酿还有一个重要意义就是能够将彼此的产品特点融合在一起，创造出更具特色的产品；合酿的过程其实也是个技术交流与分享的过程，取彼之长，补己之短</p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039709.png" alt="image-20220320171652123" style="zoom: 50%;" /><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039981.png" alt="image-20220320171714327" style="zoom:50%;" /><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039874.png" alt="image-20220320171722436" style="zoom: 50%;" /><p><strong>酒头接管</strong></p><p>啤酒吧引入一批某酒厂的啤酒而举办的带有广告性质、主题性质、促销性质的营销活动</p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039483.png" alt="image-20220320171908796" style="zoom:50%;" /><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039798.png" alt="image-20220320171914991" style="zoom:50%;" /><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039116.png" alt="image-20220320171926205" style="zoom:50%;" /><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252040917.png" alt="image-20220320173347954" style="zoom:50%;" /><p><strong>展览会 &amp; 啤酒节</strong></p><p><a href="https://www.jiuhuar.com/news/6225b9248ba5b044278b4569.html">「Design精酿」艺术展和春季啤酒畅饮大会来啦！ (jiuhuar.com)</a></p><p><a href="https://mp.weixin.qq.com/s/8zT6i8Alnaw2D7Tg7nwPYg">2021京A八乘八参节指南，这个周末等你来玩！ (qq.com)</a></p><p><a href="https://mp.weixin.qq.com/s/36PlJmIOa5tvlmFWGIVARQ">啤酒节来了！ | 第二届『跳啤拍档』广州精酿啤酒节，下周见！ (qq.com)</a></p><p><strong>啤酒跑</strong></p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252040418.png" alt="image-20220320172308492" style="zoom:50%;" /><p><a href="https://mp.weixin.qq.com/s/DCBIJeQYdWRUF_XcpCydlQ">我们赞助了一场快乐的【2020厦门啤酒跑∣RUN FOR BEER】 (qq.com)</a></p><p><strong>节日活动</strong></p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252040128.png" alt="image-20220320173409737" style="zoom: 67%;" /><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252040081.png" alt="image-20220320173420348" style="zoom:50%;" /><p><a href="https://mp.weixin.qq.com/s/woOyTmWUATl7-0p-K6EDkw">煎饼节后遗症｜京津大战全回顾 (qq.com)</a></p><p><strong>跨界</strong></p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252040229.png" alt="image-20220320173649555" style="zoom:50%;" /><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252040814.png" alt="image-20220320173657609" style="zoom:50%;" /><p><a href="https://mp.weixin.qq.com/s/qW5M9Eduzz0jn2H-o9bZHw">文末有福利｜道酿 X FIRST青年电影展 (qq.com)</a></p><h2 id="《都在酒里》"><a href="#《都在酒里》" class="headerlink" title="《都在酒里》"></a>《都在酒里》</h2><p>最后推荐一部机核的纪录片</p><p><a href="https://www.bilibili.com/video/BV1R5411s7ZY?spm_id_from=333.999.0.0">「4K重制版」坐在一起，为生活干杯：精酿啤酒纪录片《都在酒里》第三集《美式周末》_哔哩哔哩_bilibili</a></p><p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252042908.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 酒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 精酿啤酒 </tag>
            
            <tag> 吃喝玩乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥接模式 - Bridge</title>
      <link href="/2022/12/25/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%20-%20Bridge/"/>
      <url>/2022/12/25/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%20-%20Bridge/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>桥接（bridge）模式首先的场景是内部实现逻辑分为多个模块，每个模块又可能对应多种实现</p><p>在桥接内部，这些不同类型的模块按照组合或聚合的方式组织在一起，将逻辑模块抽象部分与实现部分相分离</p><p><strong>目的</strong><br>降低内部多种类型逻辑模块的耦合，扩展变成以各模块为单位，更为灵活</p><p><strong>现实世界类比</strong><br><a href="https://vans.com.cn/customs.html">Vans自由定制鞋_Vans(范斯)中国官方网站</a></p><p>球鞋定制，从选择款式开始，对不同的部位（鞋头、鞋腰、侧边条纹、鞋带等）选择不同的设计（颜色、图案、材质等），最终产出最终产品（桥接模式的最终成品可以认为是组合了多个模块逻辑的执行器）</p><p>针对不同部位选择不同的设计，而不是平铺出笛卡尔积式的配置表，就是桥接模式希望实现的解耦的目的</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>模拟一个场景，比如服务内希望实现一个消息通知功能</p><p>消息分为多种记录方式：缓存、数据库</p><p>通知的方式也分为多种方式：邮件、微信</p><p>服务内定义什么级别的消息通过什么方式进行通知</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果将所需要的发送方式进行实现，需要实现 4 种执行器（2 × 2），哪怕是服务中可以进行选择，也需要全部进行实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheEmailNotifier</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;缓存数据&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送电子邮件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheWeChatNotifier</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;缓存数据&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送微信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>如果后续有调整，增加了新的记录方式或者通知方式，那么需要需要创建的类就更多了，并且可能还存在相同的逻辑被实现了多份不便于维护</p><p>问题出现的原因是因为将记录方式和通知方式这两种互不关联的模块<strong>在实现中耦合在一起</strong></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="通知方式"><a href="#通知方式" class="headerlink" title="通知方式"></a>通知方式</h3><p><strong>定义接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String msg)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进行实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 电子邮件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailSender</span> <span class="keyword">implements</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="keyword">final</span> String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送电子邮件:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeChatSender</span> <span class="keyword">implements</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="keyword">final</span> String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送微信:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="记录方式"><a href="#记录方式" class="headerlink" title="记录方式"></a>记录方式</h3><p><strong>定义接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Recorder</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进行实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheRecorder</span> <span class="keyword">implements</span> <span class="title class_">Recorder</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(<span class="keyword">final</span> String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;记录到缓存:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DbRecorder</span> <span class="keyword">implements</span> <span class="title class_">Recorder</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(<span class="keyword">final</span> String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;记录到数据库:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组织者"><a href="#组织者" class="headerlink" title="组织者"></a>组织者</h3><p><strong>抽象组织者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractNotifier</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Recorder recorder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Sender sender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractNotifier</span><span class="params">(<span class="keyword">final</span> Recorder recorder, <span class="keyword">final</span> Sender sender)</span> &#123;</span><br><span class="line">        Assert.notNull(recorder);</span><br><span class="line">        Assert.notNull(sender);</span><br><span class="line">        <span class="built_in">this</span>.recorder = recorder;</span><br><span class="line">        <span class="built_in">this</span>.sender = sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        recorder.record(msg);</span><br><span class="line">        sender.send(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承构造模块的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomNotifier</span> <span class="keyword">extends</span> <span class="title class_">AbstractNotifier</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomNotifier</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">DbRecorder</span>(), <span class="keyword">new</span> <span class="title class_">EmailSender</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="业务扩展"><a href="#业务扩展" class="headerlink" title="业务扩展"></a>业务扩展</h3><p>需要增加新的发送方式，比如短信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShortMessageSender</span> <span class="keyword">implements</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="keyword">final</span> String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送短信:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要进行新的 notifier 的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlusNotifier</span> <span class="keyword">extends</span> <span class="title class_">AbstractNotifier</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PlusNotifier</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">CacheRecorder</span>(), <span class="keyword">new</span> <span class="title class_">ShortMessageSender</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>JDBC 驱动为所有的关系型数据库提供一个通用的标准，这就是一个桥接模式的典型应用</p><h3 id="进行连接"><a href="#进行连接" class="headerlink" title="进行连接"></a>进行连接</h3><p>先回顾一下 JDBC 的使用，使用 JDBC 连接 MySQL 数据库主要分为这样几步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.加载 MySQL 驱动注入到 DriverManager</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.提供 JDBC 连接的 URL、用户名和密码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test_db?&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建数据库的连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.创建 statement 实例</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.执行 SQL 语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">query</span> <span class="operator">=</span> <span class="string">&quot;select * from test&quot;</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(query);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.关闭连接对象</span></span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><h3 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h3><p><code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</code> 获取了 Driver 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注册驱动</span></span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 <code>DriverManager</code> 静态方法 <code>registerDriver()</code> 方法来将 MySQL 驱动注册到 <code>DriverManager</code></p><h3 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h3><p><code>registerDriver()</code> 方法具体如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">registerDriver</span><span class="params">(java.sql.Driver driver)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"><span class="comment">// 直接调用下面的同名静态方法</span></span><br><span class="line">    registerDriver(driver, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">registerDriver</span><span class="params">(java.sql.Driver driver,DriverAction da)</span><span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">// registeredDrivers 是一个 list,用 DriverInfo 实例封装 Driver</span></span><br><span class="line">    <span class="keyword">if</span>(driver != <span class="literal">null</span>) &#123;</span><br><span class="line">        registeredDrivers.addIfAbsent(<span class="keyword">new</span> <span class="title class_">DriverInfo</span>(driver, da));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This is for compatibility with the original DriverManager</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;registerDriver: &quot;</span> + driver);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>registeredDrivers</code> 静态变量是一个 list</p><p>泛型 <code>DriverInfo</code> 是驱动信息的包装类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DriverManager</span> &#123;</span><br><span class="line">    <span class="comment">// List of registered JDBC drivers</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DriverInfo"><a href="#DriverInfo" class="headerlink" title="DriverInfo"></a>DriverInfo</h3><p><code>DriverInfo</code> 类中封装了 <code>java.sql.Driver</code> 接口，类似 Driver 信息管理者的角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DriverInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Driver driver;</span><br><span class="line">    DriverAction da;</span><br><span class="line">    DriverInfo(Driver driver, DriverAction action) &#123;</span><br><span class="line">        <span class="built_in">this</span>.driver = driver;</span><br><span class="line">        da = action;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p>接下来进行连接的获取，<code>Connection connection = DriverManager.getConnection(url, username, password);</code></p><p><code>Connection</code> 接口是和特定数据库的连接会话，<strong>不同的数据库的连接会话都不相同</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Connection</span>  <span class="keyword">extends</span> <span class="title class_">Wrapper</span>, AutoCloseable &#123;</span><br><span class="line"></span><br><span class="line">    Statement <span class="title function_">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>DriverManager</code> 中的 <code>getConnection</code> 方法，从 <code>registeredDrivers</code> 进行选择对应数据库驱动下的连接实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">(String url,String user, String password)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    java.util.<span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Properties();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">        info.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="literal">null</span>) &#123;</span><br><span class="line">        info.put(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实际上调用的是下面的静态方法 getConnection</span></span><br><span class="line"><span class="comment">//  Worker method called by the public getConnection() methods.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">(</span></span><br><span class="line"><span class="params">    String url, java.util.Properties info, Class&lt;?&gt; caller)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * When callerCl is null, we should check the application&#x27;s</span></span><br><span class="line"><span class="comment">         * (which is invoking this class indirectly)</span></span><br><span class="line"><span class="comment">         * classloader, so that the JDBC driver class outside rt.jar</span></span><br><span class="line"><span class="comment">         * can be loaded from here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">callerCL</span> <span class="operator">=</span> caller != <span class="literal">null</span> ? caller.getClassLoader() : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(DriverManager.class) &#123;</span><br><span class="line">        <span class="comment">// synchronize loading of the correct classloader.</span></span><br><span class="line">        <span class="keyword">if</span> (callerCL == <span class="literal">null</span>) &#123;</span><br><span class="line">            callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(url == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;The url cannot be null&quot;</span>, <span class="string">&quot;08001&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;DriverManager.getConnection(\&quot;&quot;</span> + url + <span class="string">&quot;\&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Walk through the loaded registeredDrivers attempting to make a connection.</span></span><br><span class="line">    <span class="comment">// Remember the first exception that gets raised so we can reraise it.</span></span><br><span class="line">    <span class="type">SQLException</span> <span class="variable">reason</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">        <span class="comment">// If the caller does not have permission to load the driver then</span></span><br><span class="line">        <span class="comment">// skip it.</span></span><br><span class="line">        <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;    trying &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> aDriver.driver.connect(url, info);</span><br><span class="line">                <span class="keyword">if</span> (con != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Success!</span></span><br><span class="line">                    println(<span class="string">&quot;getConnection returning &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                    <span class="keyword">return</span> (con);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (reason == <span class="literal">null</span>) &#123;</span><br><span class="line">                    reason = ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;    skipping: &quot;</span> + aDriver.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we got here nobody could connect.</span></span><br><span class="line">    <span class="keyword">if</span> (reason != <span class="literal">null</span>)    &#123;</span><br><span class="line">        println(<span class="string">&quot;getConnection failed: &quot;</span> + reason);</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;getConnection: no suitable driver found for &quot;</span>+ url);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;No suitable driver found for &quot;</span>+ url, <span class="string">&quot;08001&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Connection-实现"><a href="#Connection-实现" class="headerlink" title="Connection 实现"></a>Connection 实现</h3><p>在 <code>Connection</code> 接口的具体实现部分，MySQL 的连接是通过两层实现完成抽象部分的实现</p><p>不同的数据库会进行不同的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionImpl</span> <span class="keyword">implements</span> <span class="title class_">JdbcConnection</span>, SessionEventListener, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">4009476458425101761L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SQLPermission</span> <span class="variable">SET_NETWORK_TIMEOUT_PERM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SQLPermission</span>(<span class="string">&quot;setNetworkTimeout&quot;</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JdbcConnection</span> <span class="keyword">extends</span> <span class="title class_">Connection</span>, MysqlConnection, TransactionEventHandler &#123;</span><br><span class="line">    JdbcPropertySet <span class="title function_">getPropertySet</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">changeUser</span><span class="params">(String var1, String var2)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>DriverManager</code> 作为组织者，组织了 <code>Driver</code>（由管理者 <code>DriverInfo</code> 进行管理）和 <code>Connection</code> 两类模块</p><p>根据使用的数据库不同灵活地进行连接的选择</p><p>对应的类图：</p><img src="/2022/12/25/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%20-%20Bridge/jdbc%E7%B1%BB%E5%9B%BE.drawio.png" class="" title="jdbc类图.drawio"><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>当存在一段逻辑中分为多类模块时，可以考虑将各模块分别实现再进行组织降低耦合</p><ul><li><p>优点</p><ul><li>可以将庞大的类拆分成更有层次的结构，层次之间不存在耦合</li><li>便于模块实现的扩展（开闭）</li><li>切换不同的实现更加方便</li><li>每个模块又可以定义出抽象部分和实现部分（单一职责）</li></ul></li><li><p>缺点</p><ul><li>在已存在的功能上进行改造工程量较大（不同于适配器模式）</li><li>高内聚的类进行桥接设计会使代码更加复杂</li></ul></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://refactoringguru.cn/design-patterns/bridge">桥接设计模式 (refactoringguru.cn)</a></p><p><a href="https://blog.csdn.net/MY9526/article/details/108738263">桥接模式的实际使用_最后一个NPE的博客-CSDN博客_桥接模式实战</a></p><p><a href="https://www.cnblogs.com/EthanWong/p/16079803.html">设计模式学习笔记（九）桥接模式及其应用 - 归斯君 - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布隆 &amp; 布谷鸟过滤器</title>
      <link href="/2022/12/11/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%83%E9%9A%86%20&amp;%20%E5%B8%83%E8%B0%B7%E9%B8%9F%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2022/12/11/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%83%E9%9A%86%20&amp;%20%E5%B8%83%E8%B0%B7%E9%B8%9F%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><strong>特征 or 全部</strong></p><p>在实际需求中，往往存在类似需求：</p><ul><li>黑白名单；例如手机号、网站等，需要过滤掉在黑名单中的数据，或者放行在白名单中的数据</li><li>推荐去重；首页新闻、视频等资源已经给用户推荐过的不进行重复推送</li><li>缓存穿透；保证缓存层能正常工作，不被特殊请求大量造成缓存穿透</li></ul><p>最容易想到的，就是通过一个集合例如 Map、List 等结构将数据存储起来，判断是否存在于集合中</p><p>这样相当于把所有的数据都进行了一遍存储，如果需要的只是过滤功能，而不需要将数据全部存储下来，只需要存储数据的特征值，就可以节省大量的空间</p><p>所以出现了布隆过滤器等概率型结构（probabilistic data structure），可以在使用很少空间的情况下对数据进行过滤操作，当然通过特征值进行存储可能会有以下问题：</p><ul><li>误判率</li><li>扩缩容依然需要数据全集（数据量不匹配会导致空间浪费或误判率上升）</li><li>删除操作难以实现</li></ul><p>需要在技术和业务两方面进行取舍</p><h1 id="布隆"><a href="#布隆" class="headerlink" title="布隆"></a>布隆</h1><p>布隆过滤器（bloom filter）由一串很长的二进制向量组成（位图 bitmap），可以将其看成一个二进制数组</p><p>当一个元素进入时，不是存储该元素本身，而是通过多个哈希算法，计算出该元素的多个下标，随后在位图中将对应的下标打上标记（bit 位置为 1），当需要判断是否存在某个元素时，也是进行哈希后，判断其需要的下标是否全为 1</p><p>可以看出，布隆过滤器带有一定的误判率，如果很多元素的下标正好复合了某一个元素的位置，那么该元素就会被误判存在：</p><ul><li>说存在但不一定存在</li><li>说不存在一定不存在</li></ul><p>图示模拟流程：<a href="https://www.jasondavies.com/bloomfilter/">https://www.jasondavies.com/bloomfilter/</a></p><p><strong>参数选择</strong></p><p>也可以看出布隆过滤器的误判率和以下参数相关：</p><ul><li>过滤器中位图的位数</li><li>哈希算法的数量和质量</li></ul><p><a href="https://hur.st/bloomfilter/?n=400000000&p=0.01&m=&k=">Bloom filter calculator (hur.st)</a> 可以进行布隆过滤器参数的预估</p><table><thead><tr><th align="center">参数值</th><th align="center">含义</th><th align="center">公式</th></tr></thead><tbody><tr><td align="center">n</td><td align="center">过滤器中的元素数量</td><td align="center"><code>n = ceil(m / (-k / log(1 - exp(log(p) / k))))</code></td></tr><tr><td align="center">p</td><td align="center">误判率</td><td align="center"><code>p = pow(1 - exp(-k / (m / n)), k)</code></td></tr><tr><td align="center">m</td><td align="center">过滤器使用的空间大小</td><td align="center"><code>m = ceil((n * log(p)) / log(1 / pow(2, log(2))));</code></td></tr><tr><td align="center">k</td><td align="center">哈希算法数量</td><td align="center"><code>k = round((m / n) * log(2));</code></td></tr></tbody></table><p><strong>无法删除</strong></p><p>布隆过滤器是无法删除元素的，因为一旦存储特征后，删除会导致连带其他元素的标记一起删除</p><p>为了能让布隆过滤器支持删除操作，衍生出了变体结构，计数布隆过滤器（counting bloom filter）</p><p><strong>实际应用</strong></p><p><a href="https://toutiao.io/posts/mtrvsx/preview">Now 直播发现页短视频瀑布流优化 - 开发者头条 (toutiao.io)</a></p><h1 id="计数布隆"><a href="#计数布隆" class="headerlink" title="计数布隆"></a>计数布隆</h1><p>使用一个 counter 数组来替代之前的位图，在进行标记时可以记录一共标记了多少次，显而易见空间占用会扩大不少</p><p>在进行判断时 <code>counter &gt; 0</code> 即表示了之前的 <code>index == 1</code> 操作</p><p>计数器也无法避免误删，只是能大幅度降低误删概率</p><h1 id="布谷鸟"><a href="#布谷鸟" class="headerlink" title="布谷鸟"></a>布谷鸟</h1><p>布谷鸟过滤器是布隆过滤器的升级，有如下优势：</p><ul><li>支持动态的新增和删除元素</li><li>提供了比传统布隆过滤器更高的查找性能，即使在接近满空间的情况下（访问内存次数低）</li><li>要求一定误判率下，空间占用一般更小</li></ul><p><strong>布谷鸟 hash</strong></p><blockquote><p>当发现鸟蛋占用了自己的位置时，就把它推走</p></blockquote><p>假设有两个 hash 表，记为 T1 和 T2</p><p>同时有两套 hash 算法，记为 H1 和 H2</p><p>添加元素流程如下：</p><ol><li>根据 H1 计算其在 T1 的位置下标</li><li>如果该位置没有标记则进行标记，如果标记了则继续</li><li>根据 H2 计算其在 T2 的位置下标</li><li>如果该位置没有标记则进行标记，如果标记了则说明所有位置都已经被占用，随机踢出 T1 或者 T2 上该下标的元素，将自己放入下标</li><li>被踢出的元素重复上述流程查找自己的位置</li><li>经过 <code>MaxLoop </code> 阈值后还存在元素没有合适的位置，则元素添加失败，说明需要进行扩容了</li></ol><p>图示模拟流程：<a href="http://www.lkozma.net/cuckoo_hashing_visualization/">http://www.lkozma.net/cuckoo_hashing_visualization/</a></p><p><strong>过滤器的 hash</strong></p><p>布谷鸟过滤器的 hash 是对布谷鸟 hash 的改进</p><p>布谷鸟 hash 中，哈希表存储的是元素的原始值 x，下标 p1 p2 的计算公式为</p><ul><li><code>p1 = hash1(x) % L</code></li><li><code>p2 = hash2(x) % L</code></li></ul><p>而布谷鸟过滤器对于下标的计算为：</p><ul><li><code>h1(x) = hash(x)</code></li><li><code>h2(x) = h1(x) ⊕ hash(x&#39;s fingerprint)</code></li></ul><p>我们可以看到，计算 h2（位置 2）时，对 x 的 fingerprint 进行了一个 hash 计算，公式中的异或操作获得了一个重要的特性：位置 h2 可以通过位置 h1 和 h1 中存储的 fingerprint 计算出来，即当元素被踢出时，根据当前位置和元素的指纹，就可以得到元素的下一个位置</p><p><strong>异或与对偶</strong></p><p>由 h2 的计算公式 <code>h2(x) = h1(x) ⊕ hash(x&#39;s fingerprint)</code>，两个位置具有对偶性</p><p>只要保证 <code>hash(x&#39;s fingerprint) !=0</code>，那么就可以确保 <code>h2 != h1</code>，也就可以确保，不会出现自己踢自己的死循环问题</p><p>为什么需要对指纹进行哈希运算呢？因为如果指纹的长度是 8 bit，那么异或操作只会改变当前位置  h1(x)  的低 8 位，高位不会改变，就算低 8 位完全不一样，最后计算出来的位置最远也只有 256 位，为了散列更充分，所以对指纹先进行一次哈希操作</p><p><strong>指纹</strong></p><p>指纹其实就是元数据的特征值，进行哈希后取的固定 n 个 bit 位</p><p><strong>空间利用率</strong></p><p>由于指纹是对数据进行哈希运算后固定的 bit 位，所以必然会出现误判的情况</p><p>在完美的情况下，也就是没有发生哈希冲突之前，它的空间利用率最高只有 50%</p><p>如果对数组进行展开，当一个位置可以存放多个数据时，空间利用率会提升；如果一个下标可以放 2、4、8 个元素的时候，空间利用率就会飙升到 84%、95%、98%</p><p><strong>删除的限制</strong></p><p>如果需要布谷鸟过滤器支持删除，它必须知道一个数据插入过多少次（否则也会误删）</p><p>并且不能让同一个数据插入 <code>kb+1</code> 次；个人认为如果插入超过了 <code>kb+1</code> 次，就会导致插入一定失败</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>布谷鸟的优缺点：</p><p><strong>优点：</strong></p><ul><li>访问内存次数低</li><li>Hash 函数计算简单</li><li>支持删除操作</li></ul><p><strong>缺点：</strong></p><ul><li>内存空间不联系，CPU 消耗大</li><li>容易出现装填循环问题，空间占用越多碰撞越多，插入效率越低</li><li>查询误判率</li><li>删除操作限制多，会影响插入性能和误删除</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf">https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf</a></p><p><a href="https://zhuanlan.zhihu.com/p/348865590">布隆，牛逼！布谷鸟，牛逼！ - 知乎 (zhihu.com)</a></p><p><a href="https://juejin.cn/post/6844903861749055502">布隆过滤器过时了，未来属于布谷鸟过滤器？ - 掘金 (juejin.cn)</a></p><p><a href="https://zhuanlan.zhihu.com/p/462815302">布隆过滤器与布谷鸟过滤器 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>管道模式 - Pipeline</title>
      <link href="/2022/12/05/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%A1%E9%81%93%E6%A8%A1%E5%BC%8F%20-%20Pipeline/"/>
      <url>/2022/12/05/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%A1%E9%81%93%E6%A8%A1%E5%BC%8F%20-%20Pipeline/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>管道模式（Pipeline Pattern）是责任链模式（Chain of Command Pattern）的变体；区别在于责任链是将处理器按照链条组织起来，待处理的上下文按照链条找到能够处理自己的处理器，一般只有唯一的一个处理器；而管道模式是链条中的每一个处理器都需要对上下文进行处理</p><p><strong>目的</strong><br>降低业务逻辑流程的耦合性，将整个过程中所有的处理器隔离开，更方便扩展流程上新的业务逻辑</p><p><strong>现实世界类比</strong><br>工厂的生产流水线，车架 -&gt; 发送机 -&gt; 外壳 -&gt; 内饰 -&gt; 总装 -&gt; 质检，整辆车在传送带又一个环节运输至另一个环节，每个处理环节都对汽车处理自己的部分，最终产出成品</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>模拟一个场景，比如订单服务内查询接口把最终订单实体组装为一个 VO</p><p>除了原有的实体属性，比如内部数据需要对优惠金额进行计算，外部数据需要补充用户信息、商品信息等</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果将所有步骤抽为方法，则代码一般会实现为这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> OrderInfoVo <span class="title function_">buildVO</span><span class="params">(OrderBo bo)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">OrderInfoVo</span> <span class="variable">vo</span> <span class="operator">=</span> <span class="built_in">this</span>.wrapVo(bo);</span><br><span class="line">    <span class="built_in">this</span>.calMitigateSum(vo);</span><br><span class="line">    <span class="built_in">this</span>.buildUserInfo(vo);</span><br><span class="line">    <span class="built_in">this</span>.buildCommodityInfo(vo);</span><br><span class="line">    <span class="keyword">return</span> vo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面如果对 VO 的字段有了新的要求，比如增加物流信息；或者对生成 VO 的流程有了新的要求，比如根据查询条件进行缓存，就会有以下坏处：</p><ul><li>在 <code>buildVO</code> 中实现缓存逻辑，违反了方法的单一职责，维护在外面可能又需要维护一个统一的入口</li><li>将来每加入一个新的处理步骤或者删除某个步骤，都要修改 <code>buildVO</code> 方法</li></ul><p>这种情况下可以使用管道模式解决以上缺点</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>上下文维护着整个业务链条中间的结果和最终的结果数据</p><p><strong>管道上下文父类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传递到管道的上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理开始时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime startTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理结束时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime endTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体的业务数据上下文</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderVOContext</span> <span class="keyword">extends</span> <span class="title class_">PipelineContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单业务模型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> OrderBO bo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单 VO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> OrderVO vo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模型创建出错时的错误信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String errorMsg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他参数</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;build OrderVO&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p><strong>处理器父类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 管道中的上下文处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ContextHandler</span>&lt;T <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理输入的上下文数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 处理时的上下文数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 true 则表示由下一个 ContextHandler 继续处理，返回 false 则表示处理结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">(T context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>计算优惠金额</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@sl4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalMitigateSumHandler</span> <span class="keyword">implements</span> <span class="title class_">ContextHandler</span>&lt;OrderVOContext&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">(InstanceBuildContext context)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;--计算优惠金额--&quot;</span>);</span><br><span class="line">        <span class="comment">// 计算流程</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">mitigateSum</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        context.getVo().setMitigateSum(mitigateSum);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造用户信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@sl4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">buildUserInfoHandler</span> <span class="keyword">implements</span> <span class="title class_">ContextHandler</span>&lt;OrderVOContext&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">(InstanceBuildContext context)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;--构造用户信息--&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userClient.getUserById(context.getBo().getUserId());</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">            context.setErrorMsg(<span class="string">&quot;查询用户信息为空，id=&quot;</span> + context.getBo().getUserId());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        context.getVo().setUserName(user.getName());</span><br><span class="line">        context.getVo().setUserAge(user.getAge());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造商品信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@sl4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">buildGoodsInfoHandler</span> <span class="keyword">implements</span> <span class="title class_">ContextHandler</span>&lt;OrderVOContext&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">(InstanceBuildContext context)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;--构造商品信息--&quot;</span>);</span><br><span class="line">        <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> goodsClient.getGoodsBySku(context.getBo().getGoodsSku());</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(goods)) &#123;</span><br><span class="line">            context.setErrorMsg(<span class="string">&quot;查询商品信息为空，id=&quot;</span> + context.getBo().getGoodsSku());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        context.getVo().setGoodsSku(goods.getSku());</span><br><span class="line">        context.getVo().setGoodsName(goods.getName());</span><br><span class="line">context.getVo().setGoodsPrice(goods.getPrice());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组织处理器"><a href="#组织处理器" class="headerlink" title="组织处理器"></a>组织处理器</h3><p>现在业务 Context 和 Handler 都定义好了，那么使用什么方式将 Handler 组织起来呢？有如下几种：</p><ul><li>Handler 对象持有下一个 Handler 的信息，比如使用 <code>nextHandler</code> 属性来保存下一个处理器；缺点是无法直观了解整个业务链条都有哪些处理器，并且增删处理器需要修改其他处理器的属性</li><li>自定义注解将顺序信息和 Handler 的实现绑定；这样也无法直观了解到一段业务都有多少个处理器</li><li>维护一个路由表，基于 Spring 的自动注入来实现和管理路由表，使用一个执行器角色只有处理器集合作为入口</li></ul><p><strong>构造路由表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 管道路由的配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineRouteConfig</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据类型-&gt;管道中处理器类型列表 的路由</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span></span><br><span class="line">    Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;,</span><br><span class="line">        List&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">ContextHandler</span>&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;&gt;&gt;&gt; PIPELINE_ROUTE_MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在这里配置各种上下文类型对应的处理管道：键为上下文类型，值为处理器类型的列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        PIPELINE_ROUTE_MAP.put(OrderVOContext.class,</span><br><span class="line">                               Arrays.asList(</span><br><span class="line">                                       CalMitigateSumHandler.class,</span><br><span class="line">                                       buildUserInfoHandler.class,</span><br><span class="line">                                       buildGoodsInfoHandler.class</span><br><span class="line">                               ));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将来其他 Context 的管道配置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 Spring 启动时，根据路由表生成对应的管道映射关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;pipelineRouteMap&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;, List&lt;? <span class="keyword">extends</span> <span class="title class_">ContextHandler</span>&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;&gt;&gt; getHandlerPipelineMap() &#123;</span><br><span class="line">        <span class="keyword">return</span> PIPELINE_ROUTE_MAP.entrySet()</span><br><span class="line">                                 .stream()</span><br><span class="line">                                 .collect(Collectors.toMap(Map.Entry::getKey, <span class="built_in">this</span>::toPipeline));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据给定的管道中 ContextHandler 的类型的列表，构建管道</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;? <span class="keyword">extends</span> <span class="title class_">ContextHandler</span>&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;&gt; toPipeline(</span><br><span class="line">            Map.Entry&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;, List&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">ContextHandler</span>&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;&gt;&gt;&gt; entry) &#123;</span><br><span class="line">        <span class="keyword">return</span> entry.getValue()</span><br><span class="line">                    .stream()</span><br><span class="line">                    .map(appContext::getBean)</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext appContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        appContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>管道执行器</strong></p><p>管道执行器根据传入的上下文数据的类型，找到其对应的管道，然后将上下文数据放入管道中去进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 管道执行器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用 PipelineRouteConfig 中的 pipelineRouteMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;,</span><br><span class="line">                List&lt;? <span class="keyword">extends</span> <span class="title class_">ContextHandler</span>&lt;? <span class="built_in">super</span> PipelineContext&gt;&gt;&gt; pipelineRouteMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步处理输入的上下文数据</span></span><br><span class="line"><span class="comment">     * 如果处理时上下文数据流通到最后一个处理器且最后一个处理器返回 true，则返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 输入的上下文数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 处理过程中管道是否畅通，畅通返回 true，不畅通返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acceptSync</span><span class="params">(PipelineContext context)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(context, <span class="string">&quot;上下文数据不能为 null&quot;</span>);</span><br><span class="line">        <span class="comment">// 拿到数据类型</span></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt; dataType = context.getClass();</span><br><span class="line">        <span class="comment">// 获取数据处理管道</span></span><br><span class="line">        List&lt;? <span class="keyword">extends</span> <span class="title class_">ContextHandler</span>&lt;? <span class="built_in">super</span> PipelineContext&gt;&gt; pipeline = pipelineRouteMap.get(dataType);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(pipeline)) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;&#123;&#125; 的管道为空&quot;</span>, dataType.getSimpleName());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 管道是否畅通</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">lastSuccess</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ContextHandler&lt;? <span class="built_in">super</span> PipelineContext&gt; handler : pipeline) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 当前处理器处理数据，并返回是否继续向下处理</span></span><br><span class="line">                lastSuccess = handler.handle(context);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                lastSuccess = <span class="literal">false</span>;</span><br><span class="line">                logger.error(<span class="string">&quot;[&#123;&#125;] 处理异常，handler=&#123;&#125;&quot;</span>, context.getName(), handler.getClass().getSimpleName(), ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不再向下处理</span></span><br><span class="line">            <span class="keyword">if</span> (!lastSuccess) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lastSuccess;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用管道"><a href="#使用管道" class="headerlink" title="使用管道"></a>使用管道</h3><p>原来的 <code>buildVO</code> 可以引入管道来进行实现了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> OrderInfoVo <span class="title function_">buildVO</span><span class="params">(OrderBo bo)</span> &#123;</span><br><span class="line">    <span class="type">OrderVOContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.createContext(bo);</span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> pipelineExecutor.acceptSync(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流程成功</span></span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        <span class="keyword">return</span> CommonResponse.success(data.getInstanceId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logger.error(<span class="string">&quot;build vo 失败：&#123;&#125;&quot;</span>, data.getErrorMsg());</span><br><span class="line">    <span class="keyword">return</span> CommonResponse.failed(data.getErrorMsg());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增加处理器"><a href="#增加处理器" class="headerlink" title="增加处理器"></a>增加处理器</h3><p>如果需要在流程中增加新业务</p><p><strong>创建新的处理器实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@sl4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">newTaskHandler</span> <span class="keyword">implements</span> <span class="title class_">ContextHandler</span>&lt;OrderVOContext&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">(InstanceBuildContext context)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;--执行新业务--&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改手动维护的静态路由表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    PIPELINE_ROUTE_MAP.put(OrderVOContext.class,</span><br><span class="line">                           Arrays.asList(</span><br><span class="line">                               CalMitigateSumHandler.class,</span><br><span class="line">                               buildUserInfoHandler.class,</span><br><span class="line">                               newTaskHandler.class, <span class="comment">// 流程中增加了新逻辑</span></span><br><span class="line">                               buildGoodsInfoHandler.class</span><br><span class="line">                           ));</span><br></pre></td></tr></table></figure><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>对于步骤繁多的任务，很多时候我们更需要的是异步处理，比如某些耗时长的定时任务，管道处理异步化非常的简单</p><p>在 PipelineExecutor 中引入异步的处理方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 管道线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> ThreadPoolTaskExecutor pipelineThreadPool; <span class="comment">// 处理异步的线程池</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步处理输入的上下文数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context  上下文数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callback 处理完成的回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acceptAsync</span><span class="params">(PipelineContext context, BiConsumer&lt;PipelineContext, Boolean&gt; callback)</span> &#123;</span><br><span class="line">    pipelineThreadPool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> acceptSync(context);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="literal">null</span>) &#123;</span><br><span class="line">            callback.accept(context, success);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过管道模式，可以大幅降低了系统的耦合度和提升了内聚程度与扩展性：</p><ul><li><p>优点</p><ul><li><code>buildVO</code> 所在的类只负责处理引导 BO 进入管道的业务流程，而不关注具体业务逻</li><li><code>PipelineExecutor </code> 抽象定义，不关心业务细节</li><li>每个 <code>ContextHandler </code> 只负责自己的业务，不需要知道链路结构，与其他处理器解耦</li><li>对于处理器新增、删除、调整顺序等操作，只需要修改路由表，和业务逻辑脱离</li></ul></li><li><p>缺点</p><ul><li>大的 Context 对象，让业务数据粒度很粗（上帝对象）</li><li>和策略一样，可能造成实现类膨胀</li><li>错误信息需要保存在 Context 对象中，走完所有处理器才会将错误返回</li></ul></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/370363597">设计模式最佳套路2 —— 基于 Spring 实现管道模式的最佳实践 - 知乎 (zhihu.com)</a></p><p><a href="https://refactoringguru.cn/design-patterns/chain-of-responsibility">责任链设计模式（职责链模式） (refactoringguru.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ 最佳实践</title>
      <link href="/2022/12/04/%E5%BC%80%E5%8F%91/MQ/RocketMQ%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2022/12/04/%E5%BC%80%E5%8F%91/MQ/RocketMQ%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="Topic-与-Tag"><a href="#Topic-与-Tag" class="headerlink" title="Topic 与 Tag"></a>Topic 与 Tag</h1><p>在 RocketMQ 中，Topic 和 Tag 都是业务上用来归类的标识，通过合理的使用 Topic 和 Tag 可以让业务结构清晰，更可以提高效率</p><p><strong>Topic</strong> 是消息主题，通过 Topic 对不同的业务消息进行分类<br><strong>Tag</strong>  是消息标签，用来进一步区分某个 Topic 下的消息分类，是消息生产时即由消息生产者设置的属性  </p><p>Topic 和 Tag 的选择，建议从以下几个方面判断：</p><ul><li><strong>消息类型是否一致：</strong>普通消息、事务消息、延迟消息、顺序消息；不同消息使用不同的 Topic，无法通过 Tag 进行区分</li><li><strong>业务是否相关联：</strong>没有关联的业务应该使用不同的 Topic</li><li><strong>消息优先级是否一致：</strong>同一个 Topic 内应该是同样优先级的消息</li><li><strong>量级是否相当：</strong>业务量小但实时性高的消息和业务量大的消息放在一个 Topic 内，可能会导致饥饿</li></ul><p>以电商系统为例，订单消息和支付消息属于不同的业务，设置 TOPIC_ORDER 和 TOPIC_PAY<br>其中订单消息根据商品种类再划分为不同的 tag，例如电器类、服装类、图书类等<br>支付消息根据不同的支付渠道划分，例如银行卡、支付宝、微信支付等</p><h1 id="消费幂等"><a href="#消费幂等" class="headerlink" title="消费幂等"></a>消费幂等</h1><p>为了防止消息重复消费导致业务处理异常，RocketMQ 消费者在接收消息后，有必要根据业务上的唯一 Key 对消息进行幂等处理</p><p>个人认为需要注意的是，这个业务上的唯一 Key，无论是在 Consumer 层做去重实现业务幂等（去重表），还是业务逻辑上做幂等（状态机、版本校验），都应该是使用业务意义上的唯一标识，而不是依赖 Message ID</p><p><strong>消息重复的场景</strong></p><ul><li><strong>Producer 端：</strong>发送消息时，Brocker 已经收到消息并持久化，但 ACK 由于网络原因未成功返回给生产者，为了保证消息不丢失，生产者会再一次发送消息；或者上游业务认为失败重新进行了调用，就可能会发送重复的消息，并且是不同的 Message ID</li><li><strong>Brocker 端：</strong>投递消息给消费者，消费者的 offset 因为网络等原因提交失败，为了保证消息至少一次，Brocker 会再次投递消息</li><li><strong>Consumer 端：</strong>服务扩缩容导致的 rebalance 操作，本质上也是消费者的 offset 没有及时提交</li></ul><p>因为不同的 Message ID 对应的消息内容可能相同，有可能出现冲突（重复）的情况，所以真正安全的幂等处理，不建议以 Message ID 作为处理依据</p><p>最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息 Key 设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(<span class="string">&quot;ons_test&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> message.getKey()</span><br><span class="line">        <span class="comment">// 根据业务唯一标识的 Key 做幂等处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="订阅关系"><a href="#订阅关系" class="headerlink" title="订阅关系"></a>订阅关系</h1><p>订阅关系需要保持一致，一致的定义是：<strong>同一个消费者组下所有 Consumer 实例所订阅的 Topic、Tag、Tag 的顺序必须完全一致</strong></p><p>如果订阅关系不一致，消息消费的逻辑就会混乱，甚至导致消息丢失</p><p><strong>为什么会丢失？</strong></p><p>当一个 Consumer 消费一个 Queue 时，会在 ConsumerQueue 中保存该消费者和消息的相关信息</p><p>ConsumerQueue 中保存了如下信息：</p><ul><li>前 8 个字节记录消息在 CommitLog 中的偏移量</li><li>中间 4 个字节记录消息大小</li><li>最后 8 个字节记录消息中 tag 的 hashcode</li></ul><p>假如一个 Consumer 订阅了 Topic1 中的 Tag1，那这个 Consumer 拉取消息时，首先从 Name Server 获取订阅关系，得到当前 Consumer 订阅的所有 tag 的 hashcode 集合 codeSet；每次从 ConsumerQueue 获取一条记录，就要判断最后 8 个字节 tag hashcode 是否在 codeSet 中，比如 Tag2 不在 codeSet 中，就会被过滤掉</p><p>所以不正确的订阅关系会导致该 ConsumerQueue 中的消息被错误丢弃了</p><h1 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h1><p>当客户端消费速度跟不上服务端消息发送的速度，便会出现消息堆积</p><p>消息堆积的主要影响：</p><ul><li>消费延迟</li><li>生产者无法成功发送消息（无法生产）</li></ul><p>以下场景需要着重关注消息堆积和延迟问题：</p><ul><li>业务系统上下游能力不匹配造成的持续堆积，且无法自行恢复</li><li>业务系统对消息的消费实时性要求较高，即使是短暂的堆积造成的消息延迟也无法接受</li></ul><p>客户端 Push 模式到消费消息有两个阶段：</p><ul><li><strong>获取消息：</strong>通过长轮询批量拉取的方式从 Brocker 拉取消息，这一阶段吞吐量较高，所以一般不会成为性能瓶颈</li><li><strong>消费 &amp; 提交：</strong>依赖业务的处理耗时和消费逻辑的并发度</li></ul><p>所以通过消息消费的两大步骤来看，消息堆积的主要问题出现在第二阶段，即<strong>消费耗时</strong>和<strong>消费并发度</strong>    </p><p><strong>消费耗时</strong></p><p>影响消费耗时的消费逻辑主要分为 CPU 内存计算和外部 IO 操作；由于大部分服务器场景都是 IO 密集型，业务代码在正常情况下不会涉及复杂的运算，内部耗时相比 IO 耗时来说可以忽略不记</p><p>IO 操作通常包含以下逻辑：</p><ul><li>读写外部数据库，例如 MySQL</li><li>读写外部缓存系统，例如 Redis</li><li>下游系统调用，例如 Dubbo 调用或者下游 HTTP 接口调用</li></ul><p><strong>消费并发度</strong></p><p>不同的消息类型对应不同的并发度配置策略</p><table><thead><tr><th>消息类型</th><th>并发度</th></tr></thead><tbody><tr><td>普通消息</td><td>单节点线程数 × 节点数量</td></tr><tr><td>定时和延时消息</td><td>单节点线程数 × 节点数量</td></tr><tr><td>事务消息</td><td>单节点线程数 × 节点数量</td></tr><tr><td>顺序消息</td><td>Min（单节点线程数 × 节点数量，分区数）</td></tr></tbody></table><p>此外单节点的并发度需要谨慎设置，不能盲目直接调大线程数，设置过大的线程数反而会带来大量的线程切换的开销</p><p>理想环境下单节点的最优线程数计算模型如下：</p><ul><li>单机 CPU 核数为 C</li><li>线程切换耗时忽略不计，IO 操作不消耗 CPU</li><li>线程有足够消息等待处理，且内存充足</li><li>逻辑中 CPU 计算耗时为 T1，外部 IO 操作为 T2</li></ul><p>则单个线程能达到的 TPS 为 <code>1 / (T1 + T2)</code>，如果CPU使用率达到理想状态 100%，那么单机达到最大能力时需要设置 <code>C × (T1 + T2) / T1</code> 个线程</p><h1 id="读写队列"><a href="#读写队列" class="headerlink" title="读写队列"></a>读写队列</h1><p>新建 Topic 需要配置相关的属性 <code>writeQueueNums</code> 和 <code>readQueueNums</code>，分别代表写队列的数量和读队列的数量</p><p>其中 <code>writeQueueNums</code> 和 <code>readQueueNums</code> 的参数可以自由配置，<strong>为什么可以自由配置呢而不是必须相等呢？</strong></p><blockquote><p><strong>备注</strong>：读写队列和读写分离不是同一个概念</p><p>读写分离指的是主节点和从节点关于读写请求分配的问题</p><p>读写队列在做路由信息时使用，在消息发送时，使用写队列个数返回路由信息，而消息消费时按照读队列个数返回路由信息，在物理文件层面，只有写队列才会创建文件</p></blockquote><p><strong>读写队列数量不匹配时会发生什么</strong></p><ul><li>写多读少：多出来的写队列无法被消费</li><li>读多写少：Consumer 对应的多出来的读队列没有消息，也就不会从该读队列消费任何消息</li></ul><p><strong>为什么要这么设计</strong></p><p>设置读写队列数的目的在于方便队列的缩容和扩容</p><p>一个 Topic 在每个 Brocker 上创建了 128 个队列，现在需要将队列缩容到 64 个，怎么做才能 100% 不会丢失消息，并且无需重启应用程序</p><p>解决办法：</p><ol><li>先将写队列缩容（128 调整为 64）；后续数据请求会进入 0 至 63 的写队列中，由之前的 Consumer 进行消费</li><li>等待 64 至 127 队列中的消息被消费完成</li><li>缩容读队列（128 调整为 64）；此时 Consumer 重新分配，对应 64 个写队列</li></ol><p><strong>同时缩容写队列和读队列可能会导致部分消息未被消费</strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://help.aliyun.com/document_detail/69109.html">最佳实践 (aliyun.com)</a></p><p><a href="https://www.cnblogs.com/liaowenhui/p/15717353.html">RocketMQ订阅关系不一致 - JustJavaIt - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/qian_348840260/article/details/108975241">rocketmq中的读写队列_八荒六合唯我独尊-CSDN博客_rocketmq读写队列</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> MQ </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES cardinality 和 HyperLogLog</title>
      <link href="/2022/12/03/%E5%BC%80%E5%8F%91/ES/ES%20cardinality%20%E5%92%8C%20HyperLogLog/"/>
      <url>/2022/12/03/%E5%BC%80%E5%8F%91/ES/ES%20cardinality%20%E5%92%8C%20HyperLogLog/</url>
      
        <content type="html"><![CDATA[<h1 id="基数聚合"><a href="#基数聚合" class="headerlink" title="基数聚合"></a>基数聚合</h1><p>基数聚合属于聚合中的度量聚合，计算不同值的<strong>近似计数</strong></p><p>需要注意，聚合出的结果是一个近似值，原因是底层结构使用的 HyperLogLog，具有一定误差</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>假定 index 存储的售卖数据，希望查询有多少种不同的商品类型</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST /sales/_search?size=<span class="number">0</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;cardinality&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以之前的学生 index 为例，查询有几个班级下有女学生</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;female&quot;</span> <span class="comment">// 结果集查询性别为女性</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="comment">// 不关注 hits 结果集</span></span><br><span class="line"><span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;class_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;cardinality&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;class&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>返回结果，选取 <code>hits</code> 和 <code>aggregations</code> 部分</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;relation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eq&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;max_score&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;aggregations&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;class_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>因为 <code>size</code> 为 0，所以 <code>hits</code> 中没有返回的文档</p><p><code>aggregations</code> 下自定义结果集名称 <code>class_count</code> 返回的值为 2，说明班级下有女学生的班级数量为 2</p><h2 id="近似值与精确阈值参数"><a href="#近似值与精确阈值参数" class="headerlink" title="近似值与精确阈值参数"></a>近似值与精确阈值参数</h2><p>由于返回结果是一个近似值，所以 <code>cardinality</code> 支持 <code>precision_threshold</code> 参数，用来设置精确阈值</p><p>阈值参数的本质是使用空间换取准确性，默认是 3000，最大支持 40000，超过 40000 的设置为按照 40000 来处理</p><p>低于阈值的计数更符合准确值，高于阈值的计数则会更加模糊</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;female&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;class_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;cardinality&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;class&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;precision_threshold&quot;</span><span class="punctuation">:</span> <span class="number">200000</span> <span class="comment">// 精度阈值，事实上内部将该参数视为 40000</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>计算精确的计数需要将值加载至哈希集合并返回大小，当基数特别大时，需要占用非常多资源</p><p>所以 ES 选择 HyperLogLog 算法来实现 <code>cardinality</code>，这种方式基于值的哈希计数，有一些特性：</p><ul><li>可配置的精度，可以选择用内存换取精度</li><li>低基数集合中是精准的</li><li>固定的内存使用率，无论唯一值有多少，只取决于设置的精度</li></ul><p>HyperLogLog + + 算法依赖于散列值的前导零，数据集中散列的精确分布会影响基数的准确性</p><p>ES 官方文档提供的数据显示，具体的准确性取决于数据集情况，但大部分场景的准确性都还是良好的，<strong>即使阈值设置为 100，在百万、千万基数下，误差范围也控制在了 1% ~ 6%；当阈值设置为 10000，误差基本在 1% 左右</strong></p><h2 id="脚本-runtime-field"><a href="#脚本-runtime-field" class="headerlink" title="脚本 runtime field"></a>脚本 runtime field</h2><p><code>cardinality</code> 像其他聚合操作一样，是可以使用脚本拼接字段的</p><p>如果希望对两个字段的组合进行操作，创建一个 runtime field 组合他们然后进行基数聚合</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;runtime_mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;gender_and_age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;script&quot;</span><span class="punctuation">:</span> <span class="string">&quot;emit(doc[&#x27;gender&#x27;].value + &#x27;&amp;&#x27; + doc[&#x27;age&#x27;].value)&quot;</span> <span class="comment">// 拼接 gender 和 age 字段</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type_promoted_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;cardinality&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gender_and_age&quot;</span> <span class="comment">// 根据 runtime field 进行基数操作</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>返回结果是 6，因为有两个文档的 runtime field <code>gender_and_age</code> 值都为 <code>male&amp;20</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;aggregations&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type_promoted_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">6</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><p>HyperLogLog 是一种基数计数的算法，旨在使用较少内存的情况下得到基数数量的近似精确值</p><h2 id="基数计数方式"><a href="#基数计数方式" class="headerlink" title="基数计数方式"></a>基数计数方式</h2><p>基数计数（cardinality counting）通常用来统计一个集合中不重复的元素个数，例如统计某个网站的 UV，或者用户搜索网站的关键词数量等</p><p>如何计算计数常见的有多种方式</p><ul><li>B 树<ul><li>利用树存储具体元素</li><li>优点：插入和查找效率高，统计数据时可以快速做到记录与去重，计算基数时只需要统计叶子节点个数即可</li><li>缺点：没有节省内存，需要存储数据全集</li></ul></li><li>bitmap<ul><li>使用 bit 位进行标记，即抛弃具体元素内容只存储特征值</li><li>优点：节约内存，结果可以进行方便的位运算操作（合并 - 与，差集 - 或）</li><li>缺点：空间占用仍然较大</li></ul></li><li>概率算法<ul><li>目前用于基数计数的概率算法有：LC、LLC、HLL 等</li><li>优点：LL、HLL 等能够在空间更小的情况下进行基数计算</li><li>缺点：有一定误差</li></ul></li></ul><h2 id="HLL"><a href="#HLL" class="headerlink" title="HLL"></a>HLL</h2><p>HLL 中实际存储的是一个长度为 m 的大数组 S，将待统计的数据集合划分成 m 组，每组根据算法记录一个统计值存入数组中</p><p>数组的大小 m 由算法实现方自己确定，Redis 中这个数组的大小是 16834，m 越大误差越小，但需要的内存空间也越大</p><p>HLL 的数学原理看不懂，大致就是 n 重伯努利原理</p><p>通过多次抛硬币，直到抛到正面为止，这是一次伯努利过程；当一直抛硬币，直到多次出现正面，将出现正面的投掷次数值记为 k1、k2、k3…kn，最大值记为 kmax，那么可以得到以下结论：</p><ul><li>n 次伯努利过程的投掷次数都不大于 kmax</li><li>n 次伯努利过程，至少有一次投掷次数等于 kmax</li></ul><p>最后经过一系列复杂的推论，最终的结果就是：<strong>进行了 n 次进行抛硬币实验，每次分别记录下第一次抛到正面的抛掷次数 k，那么可以用 n 次实验中最大的抛掷次数 kmax 来预估实验组数量 n</strong>；这就是 HLL 算法的数学理论基础</p><p>此外 HLL 为了提高准确性也做了其他优化</p><p><strong>分桶平均</strong></p><p>HLL 的基本思想是利用集合中数字的比特串第一个1出现位置的最大值来预估整体基数，但是这种预估方法存在较大误差，为了改善误差情况，HLL 中引入分桶平均的概念</p><p>为了避免一组实验中的运气影响，将统计数据划分多个桶，每个桶各自统计自己的 kmax 计算基数预估值，最终对各个桶的基数预估值进行合并，使用调和平均数的方式进一步降低误差</p><p><strong>偏差修正</strong></p><p>虽然调和平均数能够适当修正算法误差，但作者给出一种分阶段修正算法</p><p>当 HLL 算法开始统计数据时，统计数组中大部分位置都是空数据，并且需要一段时间才能填满数组，这种阶段引入一种小范围修正方法；当 HLL 算法中统计数组已满的时候，需要统计的数据基数很大，这时候 hash 空间会出现很多碰撞情况，这种阶段引入一种大范围修正方法</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.5/search-aggregations-metrics-cardinality-aggregation.html#search-aggregations-metrics-cardinality-aggregation">Cardinality aggregation | Elasticsearch Guide 8.5 </a></p><p><a href="https://juejin.cn/post/7067816471128342564">神奇的HyperLogLog算法【转载 #涉及到数学原理】 - 掘金 (juejin.cn)</a></p><p><a href="http://content.research.neustar.biz/blog/hll.html">Sketch of the Day: HyperLogLog — Cornerstone of a Big Data Infrastructure – AK Tech Blog (neustar.biz)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> ES </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
            <tag> ES 碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES 折叠操作</title>
      <link href="/2022/12/01/%E5%BC%80%E5%8F%91/ES/ES%20%E6%8A%98%E5%8F%A0%E5%92%8C%E8%81%9A%E5%90%88/"/>
      <url>/2022/12/01/%E5%BC%80%E5%8F%91/ES/ES%20%E6%8A%98%E5%8F%A0%E5%92%8C%E8%81%9A%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="折叠和聚合"><a href="#折叠和聚合" class="headerlink" title="折叠和聚合"></a>折叠和聚合</h2><p>日常会有很多场景希望将平面数据按照一定的条件组合起来，并按照一定规则进行计算</p><p>聚合将您的数据汇总为指标、统计或其他分析</p><p>可以帮助你回答类似如下问题：</p><ul><li>我的网页平均加载时间是多少？</li><li>根据交易量谁是我最有价值的客户？</li><li>在我的网站上大文件的衡量标准是多少？</li><li>每个产品类别有多少种产品？</li></ul><p>在关系型数据库中，聚合以 <code>GROUP BY</code> 关键字和聚合函数的方式进行实现</p><p>例如统计每个班级下男生的人数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `classId`,<span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> <span class="string">&#x27;number&#x27;</span> <span class="keyword">FROM</span> `student` <span class="keyword">WHERE</span> `gender` <span class="operator">=</span> &quot;male&quot; <span class="keyword">GROUP</span> <span class="keyword">BY</span> `classId`;</span><br></pre></td></tr></table></figure><p>按照班级即 <code>classId</code> 字段进行聚合，使用 <code>COUNT()</code> 聚合函数来统计数量</p><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>模拟一个场景来使用 ES 实现需求，设置这样一个索引</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PUT /student-index/_mapping</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;float&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>模拟数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /student-index/_doc</span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">22</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;male&quot;</span><span class="punctuation">,</span><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">70</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;李四&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">19</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;male&quot;</span><span class="punctuation">,</span><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">72.5</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;王五&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">20</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;male&quot;</span><span class="punctuation">,</span><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span><span class="number">3</span><span class="punctuation">,</span><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">80</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;小明&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">21</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;male&quot;</span><span class="punctuation">,</span><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">75</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;小红&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">19</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;female&quot;</span><span class="punctuation">,</span><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">50</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;小兰&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">18</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;female&quot;</span><span class="punctuation">,</span><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span><span class="number">3</span><span class="punctuation">,</span><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">51</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;蛋蛋&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">20</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;male&quot;</span><span class="punctuation">,</span><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">90</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h1><p>在 ES 除了聚合 <code>aggregations</code> 外，有一种类似聚合的操作 <code>collapse</code> 折叠</p><blockquote><p>你可以使用 collapse 参数来基于字段值查询结果；每个折叠仅选择排序靠前的文档来完成折叠</p></blockquote><p>这里就可以看出折叠和聚合还是有使用上的区别的，聚合更关注的是聚合后的结果，而折叠是在原结果集基础上将字段去重，并且可以像分页一样对折叠结果进行分页</p><p>例如这样一组数据</p><table><thead><tr><th align="center">name</th><th align="center">class</th><th align="center">time</th></tr></thead><tbody><tr><td align="center">张三</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">李四</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">王五</td><td align="center">1</td><td align="center">3</td></tr></tbody></table><p>根据 <code>time</code> 倒序，按照 <code>class</code> 进行折叠，<code>size</code> 为 1，返回的结果应该是 <code>class = 1</code> 的数据，因为命中了 <code>name = &quot;王五&quot;</code> 的文档</p><p>当 <code>from</code> 为 1 时，返回 <code>class = 2</code>，此时所有折叠后的数据都已经查询完成</p><p>折叠更像是对于查询的一种特殊操作，其参数使用也和 <code>query</code> 在同一层级，返回体中也是在 <code>hits</code> 中返回文档</p><h2 id="折叠查询"><a href="#折叠查询" class="headerlink" title="折叠查询"></a>折叠查询</h2><p>对于模拟的数据，对 <code>class</code> 字段折叠，班级的顺序按照男生的年龄排序，取第二名</p><p>即全校年龄第二大的男性学生所在的班级</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">POST /student-index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;collapse&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;class&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="comment">// 不查询第一条</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>返回的结果，只取 hits 部分</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;student-index&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;k-mmzoQBCTaFCHoW7hai&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小明&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;class&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="number">75</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;class&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="number">2</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="number">21</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>_source</code> 结果选取了折叠所命中的第一个文档（折叠的依据）；<code>fields</code> 则是折叠的字段，说明年龄第二大的男生所在的班级是 2 班</p><h2 id="扩展结果"><a href="#扩展结果" class="headerlink" title="扩展结果"></a>扩展结果</h2><p>上面折叠的简单操作可以看到，返回的 hits 中包含了一个折叠依据的文档（排序条件的第一个文档）</p><p>如果需要返回折叠字段下的所有文档（我认为更像是分组操作），可以使用 <code>inner_hit</code> 参数实现</p><p>取全校年龄第二大的男性学生所在的班级下面的所有学生，且按照身高正序排列</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">POST /student-index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;collapse&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;class&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;inner_hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;student_in_class&quot;</span><span class="punctuation">,</span> <span class="comment">// 自定的结果集名字</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span> <span class="comment">// inner_hits 内文档数量</span></span><br><span class="line"><span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// 这个排序参数是 inner hit，内部文档的排序</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// 这个排序参数是查询条件的排序</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>返回结果前半部分和折叠查询一样，只取 <code>inner_hit</code> 字段下的结果集</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;inner_hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;student_in_class&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;relation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eq&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;max_score&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;student-index&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kemmzoQBCTaFCHoWyxaJ&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李四&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">19</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;class&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="number">72.5</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="number">72.5</span></span><br><span class="line">                    <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;student-index&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;k-mmzoQBCTaFCHoW7hai&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小明&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;class&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="number">75</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="number">75</span></span><br><span class="line">                    <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到 <code>inner_hits</code> 下是 <code>student_in_class</code> 自定的结果集名称，也就意味着一次 <code>inner_hits</code> 可以设置多个不同规则的结果集请求（<code>inner_hits</code> 参数是个数组）</p><p>返回的结果中包含了 2 班下的两名学生，并且根据 <code>height</code> 字段进行了排序</p><h2 id="search-after"><a href="#search-after" class="headerlink" title="search after"></a>search after</h2><p>折叠操作同样支持 search after 操作</p><p>因为本质上 ES 也是排序后根据文档顺序对折叠字段进行操作，当 search after 字段略过该值后，继续对未折叠字段值进行折叠操作</p><p>但是需要注意，<strong>只有当折叠字段和排序字段是同一字段时才能使用该方式，同时不允许二级排序</strong></p><p>语法和基本查询一致</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GET /search&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;collapse&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user.id&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;user.id&quot;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;search_after&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;dd5ce1ad&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="二级折叠"><a href="#二级折叠" class="headerlink" title="二级折叠"></a>二级折叠</h2><p>对某一个字段折叠后，<code>inner_hits</code> 内还可以对其他字段再进行一次折叠</p><p>但二次折叠无法使用 <code>inner_hits</code> 参数，即折叠只能支持到二级</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;collapse&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;class&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;inner_hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;student_in_class&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;collapse&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;height&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>根据 <code>class</code> 折叠后的内部文档，再根据 <code>height</code> 进行折叠操作</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> ES </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
            <tag> ES 碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES 的 from size 和 scroll 和 search after</title>
      <link href="/2022/11/29/%E5%BC%80%E5%8F%91/ES/ES%20%E7%9A%84%20from%20size%20%E5%92%8C%20scroll%20%E5%92%8C%20search%20after/"/>
      <url>/2022/11/29/%E5%BC%80%E5%8F%91/ES/ES%20%E7%9A%84%20from%20size%20%E5%92%8C%20scroll%20%E5%92%8C%20search%20after/</url>
      
        <content type="html"><![CDATA[<h1 id="from-size"><a href="#from-size" class="headerlink" title="from size"></a>from size</h1><p>from size 是最常见的分页方式，类比 MySQL 的 offset limit</p><p>由于 ES 是天然分布式的，数据分散在各个 shards 上，所以需要查询 <code>from + size</code> 的条数时，coordinate node 就向该 index 的其余的  shards 发送同样的请求，等汇总到 <code>(shards × (from + size))</code> 条数时在 coordinate node 再进行一次排序，最终抽取出真正 from 后的 size 条结果</p><p>显而易见，当 shards 较多、分页深度很大时，这种方式存在很大的性能问题，这也是 ES 默认深度为 <code>from + size &lt;= 10000</code> 的原因</p><h2 id="Routing-机制"><a href="#Routing-机制" class="headerlink" title="Routing 机制"></a>Routing 机制</h2><p>写入文档时指定存储的分片</p><p>官方提供的公式如下：<code>shard_num = hash(_routing) % num_primary_shards</code></p><ul><li><code>_routing</code> 代表提供路由的字段。默认情况下为文档的 ID</li><li><code>num_primary_shards</code> 代表的为 primary shard 的个数，这个在每个索引类型创建之前就被设置了，可以手动设置也可以让 ES 默认设置。因为 ES 版本不同，设置的默认值也不同。该值在第一次创建索引类型被设置完成之后无法无法修改（修改路由机制就代表需要迁移数据）</li><li><code>shard_num</code> 代表数据落在的 shard 编号</li></ul><p>基本流程是 ES 根据路由字段计算其哈希值，再与主分片数量取余，计算得出数据落在的分片编号</p><p>此外如果只根据 <code>_routing</code> 会出现数据倾斜，可以采取折中方案，使用 <code>routing_partition_size</code> 参数，来使同一类 <code>_routing</code> 路由到主分片的一个子集中</p><p><code>shard_num = (hash(_routing) + hash(_id) % routing_partition_size) % num_primary_shards</code></p><h2 id="restful"><a href="#restful" class="headerlink" title="restful"></a>restful</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST /hero-index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;must_not&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// searchRequest</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hero-index&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询条件</span></span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">    <span class="comment">// 分页条件</span></span><br><span class="line">    searchSourceBuilder.from(<span class="number">0</span>);</span><br><span class="line">    searchSourceBuilder.size(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// term name = &quot;&quot;</span></span><br><span class="line">    <span class="type">TermQueryBuilder</span> <span class="variable">termQueryBuilder</span> <span class="operator">=</span> QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// bool 类型为 must not</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery().mustNot(termQueryBuilder);</span><br><span class="line">    <span class="comment">// 查询条件组装进 searchSourceBuilder</span></span><br><span class="line">    searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line">    searchSourceBuilder.timeout(<span class="keyword">new</span> <span class="title class_">TimeValue</span>(<span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">search</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;totalHits:&quot;</span> + search.getHits().getTotalHits().value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="search-after"><a href="#search-after" class="headerlink" title="search after"></a>search after</h1><p>ES 5 引入的新机制</p><p>简单概括 search after 如何使用：</p><ul><li>必须先指定排序规则（需要获取排序坐标）</li><li>比如从第一页开始（从中间开始也无法知道中间的具体位置）</li><li>从第一页开始以后每次都带上<code>search_after=lastEmittedDocFieldValue</code><br><code>lastEmittedDocFieldValue</code> 就是下一页开始的 keyset 坐标（也就是这个参数把深度分页变成了常数级分页）</li></ul><p><strong>和 from size 相比，无论去到第几页，coordinate node 向其它 node 发送的请求始终就是请求 size 个 docs；即无论分页深度是多少，都是常量级的开销</strong></p><p>其实现原理和关系型数据库常使用的 keyset 分页思想一致，业务妥协（只能按顺序分页而不能跳转页数）来实现性能的提升</p><p>但需要注意，看似 search after 是一个 O(1) 级别的操作，但随着分页深度的增加，其内部逻辑扫描的 doc 数量也在不断增加，依然会影响查询性能，只是相比 from size 方式有一定提升（MySQL 单表查询的分页也是如此）</p><p>此外，如果字段区分度不高，则会忽略某些数据；例如根据 age 作为排序条件，此时如果每页数据取 1000 条，而某个 age 数据 count &gt; 1000，则会忽略后续数据；<strong>解决方法是排序字段唯一，或者组合后的多个排序条件唯一</strong></p><h2 id="restful-1"><a href="#restful-1" class="headerlink" title="restful"></a>restful</h2><p>第一次查询和普通查询一致</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">POST /hero-index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;must_not&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>随后的查询增加 <code>search_after</code> 查询条件，值为最后一条数据排序字段的值</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">POST /hero-index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;must_not&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;search_after&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="number">35</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;i-mnlIQBCTaFCHoWJhbM&quot;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h2><p>同 from size 一致</p><p>第二次查询及之后需要 <code>searchSourceBuilder.searchAfter(new Object[1]);</code> 来设置 <code>search_after</code> 参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">searchAfter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// searchRequest</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hero-index&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询条件</span></span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">    <span class="comment">// 分页条件</span></span><br><span class="line">    searchSourceBuilder.from(<span class="number">0</span>);</span><br><span class="line">    searchSourceBuilder.size(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// term name = &quot;&quot;</span></span><br><span class="line">    <span class="type">TermQueryBuilder</span> <span class="variable">termQueryBuilder</span> <span class="operator">=</span> QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// bool 类型为 must not</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery().mustNot(termQueryBuilder);</span><br><span class="line">    <span class="comment">// 查询条件组装进 searchSourceBuilder</span></span><br><span class="line">    searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line">    searchSourceBuilder.timeout(<span class="keyword">new</span> <span class="title class_">TimeValue</span>(<span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上批数据最后一条的排序字段值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastHitOrderFieldValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// set 进 searchAfter 属性中</span></span><br><span class="line">    searchSourceBuilder.searchAfter(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;lastHitOrderFieldValue&#125;);</span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">search</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;totalHits:&quot;</span> + search.getHits().getTotalHits().value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h1><p>如果一开始就明确地查询全量的数据，无论使用 from size 还是 search after 都不是一个好的选择，要么依然存在深度分页的问题，要么需要多次请求，所以引入了 scroll 方式</p><p>scroll 就是把一次的查询结果缓存一定的时间，如 <code>scroll = 1m</code> 则把查询结果在下一次请求上来时暂存 1 分钟</p><p>response 比传统的返回多了一个 <code>scroll_id</code>，下次带上这个 <code>scroll_id</code> 即可找回这个缓存的结果</p><p>本质上是让各个 shard 将结果缓存，此外也有很多优化（单 shard 减少请求数量、剪枝等）来提高性能</p><h2 id="restful-2"><a href="#restful-2" class="headerlink" title="restful"></a>restful</h2><p>第一次请求</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">POST /hero-index/_search?scroll=<span class="number">1</span>m</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;must_not&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>随后</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /_search/scroll</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;scroll&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1m&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;scroll_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;FGluY2x1ZGVfY29udGV4dF91dWlkDXF1ZXJ5QW5kRmV0Y2gBFlN0TlRCWW5pUktHLWxvMEdDN3Zya2cAAAAAAAAA_hZkVXh5THJ1SFR1dVVPQlJJX3JDZWRR&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scrollSearch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// searchRequest</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hero-index&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询条件</span></span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">    <span class="comment">// 分页条件</span></span><br><span class="line">    searchSourceBuilder.from(<span class="number">0</span>);</span><br><span class="line">    searchSourceBuilder.size(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// term name = &quot;&quot;</span></span><br><span class="line">    <span class="type">TermQueryBuilder</span> <span class="variable">termQueryBuilder</span> <span class="operator">=</span> QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// bool 类型为 must not</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery().mustNot(termQueryBuilder);</span><br><span class="line">    <span class="comment">// 查询条件组装进 searchSourceBuilder</span></span><br><span class="line">    searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line">    searchSourceBuilder.timeout(<span class="keyword">new</span> <span class="title class_">TimeValue</span>(<span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 scroll</span></span><br><span class="line">    <span class="type">Scroll</span> <span class="variable">scroll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scroll</span>(TimeValue.timeValueMinutes(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    searchRequest.scroll(scroll);</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">search</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;totalHits:&quot;</span> + search.getHits().getTotalHits().value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后应该循环查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scrollAfterSearch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义 scroll</span></span><br><span class="line">    <span class="type">Scroll</span> <span class="variable">scroll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scroll</span>(TimeValue.timeValueMinutes(<span class="number">1</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">scrollId</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">SearchScrollRequest</span> <span class="variable">searchScrollRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchScrollRequest</span>(scrollId);</span><br><span class="line">    searchScrollRequest.scroll(scroll);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    searchScrollRequest.scroll(scroll);</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">search</span> <span class="operator">=</span> client.scroll(searchScrollRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;totalHits:&quot;</span> + search.getHits().getTotalHits().value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>文章 <strong>《业界难题 - ”跨库分页” 的四种方案》</strong></p><h2 id="需求产生"><a href="#需求产生" class="headerlink" title="需求产生"></a>需求产生</h2><p><strong>分页需求</strong></p><p>对于数据的查询，很多业务都有分页拉取数据的需求，例如：分页拉取聊天记录、商品信息、图片数据等</p><p>除了对数据集拆分，往往还需要业务字段进行排序</p><p>比如取第 3 页的订单数据，每页 100 条，根据创建时间倒序；可以根据创建时间建立索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">order</span>` <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span> LIMIT <span class="number">200</span>,<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><strong>分库分表</strong></p><p>随着业务的发展，为了应对数据量大、请求量大等问题，对数据库进行了横向扩展</p><p>引入分库分表后，数据根据 patition key 路由规则写入不同的库表中</p><p>同时为了让读写压力尽可能均匀分布在各个库中，往往会设置合适的 patition key</p><p>当分库分表后需要进行示例的分页需求时，就无法通过简单的请求一个库实现目的了（假设分表键不是使用的创建时间，事实上使用创建时间范围作为分表键也没任何意义）</p><p>排序的依据是时间，分表的依据是其他字段，因此数据库丧失了创建时间排序的全局视野</p><p>本文就在讨论如何满足 跨越多个水平拆分数据库的分页查询问题</p><h2 id="全局视野"><a href="#全局视野" class="headerlink" title="全局视野"></a>全局视野</h2><p>当数据分布在两个库中，无论哪个分库的第三页，都不一定会是全局排序的第三页数据</p><p>情况如下：</p><ul><li>一般情况：两个库各占第三页数据的一部分</li><li>极端情况：两个库各占一半</li><li>极端情况：第三页数据完全来自于一个库</li></ul><p>由于查询前并不清楚数据到底是如何分布在各个分库上的，所以每个库都返回 3 页数据，所得到的 6 页数据再进行排序，此时获得了根据创建时间排序的全局视野，再从 6 页数据中抽取需要的第 3 页数据</p><p><strong>优点：</strong></p><ul><li>业务无损，精准返回</li></ul><p><strong>缺点：</strong></p><ul><li><p>每次需要向各分库查询的数据量和 shard 数量倍数级相关，和页码（深度）指数级相关</p></li><li><p>需要二次排序</p></li><li><p>需要更多 IO 资源</p></li></ul><h2 id="禁止跳页"><a href="#禁止跳页" class="headerlink" title="禁止跳页"></a>禁止跳页</h2><p>由业务进行妥协，不允许进行页数的随意跳转，只允许依次进行 下一页 操作，就能减少深度分页带来的性能影响</p><p>被称为 keyset 分页、search after 等</p><p>首先这种方式需要先进行排序，比如使用创建时间作为排序字段，第一页时各分库执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">order</span>` <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span> LIMIT <span class="number">0</span>,<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>当点击下一页时，根据第一页数据的最后一条，即第一页中最小创建时间的数据（假设是 1669820860000），各分库执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">order</span>` <span class="keyword">WHERE</span> `createdTime` <span class="operator">&gt;</span> <span class="number">1669820860000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span> LIMIT <span class="number">0</span>,<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>可以发现，除第一次查询时，后面每次查询都需要带上排序条件下，上一次查询最后数据的排序值，这也是无法进行跳页的原因，因为不通过查询无法知道所需页数据的 search after 条件是多少</p><p>禁止跳页后每个分库一次都只查询一页数据，查询数据量只和分库数量倍数级相关</p><p><strong>优点：</strong></p><ul><li>性能相对较好，不受全局视野中深度分页指数级影响</li></ul><p><strong>缺点：</strong></p><ul><li>业务进行不能跳页的妥协</li><li>排序字段需要具有区分度</li></ul><h2 id="允许精度损失"><a href="#允许精度损失" class="headerlink" title="允许精度损失"></a>允许精度损失</h2><p>正常情况下，patition key 规则都尽可能使数据均匀分布在各分库中</p><p>所以可以理想认为，每个分库都完整包含了数据的一部分</p><p>假设需要取第 100 页数据，有 2 个分库，可以各取每个分库的半页数据再得到数据的并集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">order</span>` <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span> LIMIT <span class="number">9450</span>,<span class="number">50</span>;</span><br></pre></td></tr></table></figure><p>这种方式最终结果只能是近似结果，并不精准</p><p><strong>优点：</strong></p><ul><li>性能相对较好，不受全局视野中深度分页指数级影响</li></ul><p><strong>缺点：</strong></p><ul><li>业务进行精度损失的妥协</li></ul><h2 id="二次查询"><a href="#二次查询" class="headerlink" title="二次查询"></a>二次查询</h2><p>这种方式既能做到精准数据，也能减少查询量</p><p>基本的思想是通过多次查询来获得全局视野，再根据全局视野在结果集中抽取需要的数据</p><p>假设一页查询 5 条数据，查询第 201 页，有三个分库；单表查询如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">order</span>` <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span> LIMIT <span class="number">1000</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure><p><strong>第一步：</strong></p><p>改写查询，各分库按理想情况下数据分布进行查询，即</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">order</span>` <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span> LIMIT <span class="number">333</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>返回结果</p><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">C</th></tr></thead><tbody><tr><td align="center">523</td><td align="center">423</td><td align="center">500</td></tr><tr><td align="center">423</td><td align="center">421</td><td align="center">400</td></tr><tr><td align="center">323</td><td align="center">400</td><td align="center">300</td></tr><tr><td align="center">223</td><td align="center">320</td><td align="center">200</td></tr><tr><td align="center">123</td><td align="center">320</td><td align="center">100</td></tr></tbody></table><p><strong>第二步：</strong></p><p>结果集排序后，找到排序字段第一位的值，<code>createdTime DESC</code>，即创建时间的最大值</p><p>可以得到是分库 A 返回的 523</p><p><strong>第三步：</strong></p><p>扩大查询范围，查询条件使用 <code>between</code> 语句，最大值为全局最大值（523），最小值为该分库返回结果集的最大值（B-423，C-500）</p><p>因为最大值在分库 A 结果集中，所以 A 是不需要二次请求的（523 和 123 数据中必然还是上一次的结果集）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `order_B` <span class="keyword">WHERE</span> `createdTime` <span class="keyword">BETWEEN</span> <span class="number">523</span> <span class="keyword">AND</span> <span class="number">423</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `order_C` <span class="keyword">WHERE</span> `createdTime` <span class="keyword">BETWEEN</span> <span class="number">523</span> <span class="keyword">AND</span> <span class="number">500</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>B、C 可能会返回更多的数据，结果集更新为</p><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">C</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center">520</td></tr><tr><td align="center"></td><td align="center">499</td><td align="center">510</td></tr><tr><td align="center">523</td><td align="center">423</td><td align="center">500</td></tr><tr><td align="center">423</td><td align="center">421</td><td align="center">400</td></tr><tr><td align="center">323</td><td align="center">400</td><td align="center">300</td></tr><tr><td align="center">223</td><td align="center">320</td><td align="center">200</td></tr><tr><td align="center">123</td><td align="center">320</td><td align="center">100</td></tr></tbody></table><p><strong>第四步：</strong></p><p>推断全局视野</p><p>在分库 A 中，523 是第 333 条数据</p><p>在分库 B 中，加上新返回的 1 条数据，523 是第 333 - 1 - 1 &#x3D; 331 条数据</p><p>在分库 C 中，加上新返回的 2 条数据，523 是第 333 - 2 -1 &#x3D; 330 条数据</p><p>此时得到整个结果集中的最大值 523 在全局的 offset 应该是 333 + 331 + 330 &#x3D; 994</p><p><strong>第五步：</strong></p><p>已经有了 523 这个数据的全局视野，offset 994</p><p>又有了结果集 18 条数据</p><p>那么排序后就可以在结果集中找到 offset 1000 limit 5 的数据集了</p><p><strong>优点：</strong></p><ul><li>既能精准获取结果，又能避免深度分页</li></ul><p><strong>缺点：</strong></p><ul><li><p>逻辑复杂</p></li><li><p>需要多次查询</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th align="center">方式</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">全局视野</td><td align="center">精确</td><td align="center">性能问题</td></tr><tr><td align="center">禁止跳页</td><td align="center">避免深度分页</td><td align="center">业务妥协</td></tr><tr><td align="center">允许精度损失</td><td align="center">避免深度分页</td><td align="center">业务妥协</td></tr><tr><td align="center">二次查询</td><td align="center">精确 + 避免深度分页</td><td align="center">多次查询</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/91d03b16af77">Elasticsearch 5.x 源码分析（3）from size, scroll 和 search after - 简书 (jianshu.com)</a></p><p><a href="https://developer.aliyun.com/article/713865">业界难题-“跨库分页”的四种方案-阿里云开发者社区 (aliyun.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> ES </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
            <tag> ES 碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象六大原则</title>
      <link href="/2022/11/28/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2022/11/28/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h1><table><thead><tr><th>设计原则</th><th>概述</th><th>目的</th></tr></thead><tbody><tr><td>开闭原则</td><td>对扩展开放，对修改关闭</td><td>易于维护</td></tr><tr><td>单一职责</td><td>一个类只干一件事，实现类要单一</td><td>提升可读性</td></tr><tr><td>里氏替换</td><td>不要重写父类的方法</td><td>健壮性、防止错误继承</td></tr><tr><td>迪米特法则</td><td>最少知道，对象之间少建立联系</td><td>低耦合</td></tr><tr><td>接口隔离</td><td>一个接口只干一件事，接口要精简单一</td><td>高内聚</td></tr><tr><td>依赖倒置</td><td>高层不应该依赖低层，要面向接口编程</td><td>利于结构升级</td></tr></tbody></table><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><blockquote><p><em>Software entities like classes,modules and functions should be open for extension but closed for modifications.</em></p><p><em>一个软件实体如类，模块和函数应该对扩展开放，对修改关闭</em></p></blockquote><p>随着业务发展需要增加新的方法，有几种方式：</p><ul><li><strong>在接口上添加新方法</strong><ul><li>导致每一个实现类都需要进行实现，改动量大</li><li>不一定所有的实现类都需要该方法</li></ul></li><li><strong>修改实现类旧方法</strong><ul><li>替代原有旧方法功能，如果同时需要使用旧方法则无法采用此方式 （<code>getPrice()</code> 获取的是原价格还是打折后价格？如果需要同时获取原价和打折后价格如何处理）</li></ul></li><li><strong>面向扩展，使用新接口或者新类继承父类</strong><ul><li>新接口方法接口，需要的类进行实现</li><li>新类继承父类，在父类基础上增加方法</li></ul></li></ul><p><strong>明显面向扩展更容易维护，这就是开闭原则的目的</strong></p><h2 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h2><blockquote><p><em>There should never be more than one reason for a class to change. —— Robert C. Martin</em></p><p><em>一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分</em></p></blockquote><p>控制业务实现的粒度问题；一个类可以具备任意数量的方法，但都属于同一个功能簇中</p><p><strong>严格控制类中方法的粒度，必要时进行分析与拆分</strong></p><h2 id="里氏替换"><a href="#里氏替换" class="headerlink" title="里氏替换"></a>里氏替换</h2><blockquote><p><em>Inheritance should ensure that any property proved about supertype objects also holds for subtype objects. —— Liskov</em></p><p><em>继承必须确保父类所拥有的性质在子类中仍然成立</em></p></blockquote><p>在里氏替换原则的指导方针下，可得出：仅仅依据两个类之间有没有 “is a” 的关系，来判断两个类能不能发生继承关系是不够的</p><p>应该遵守一个大原则：<strong>任何使用父类的地方，都能被透明的替换成子类，且替换成子类后，程序行为不会发生问题</strong></p><p>不应该滥用继承关系，鸵鸟是否是鸟的子类（不会飞），鲸鱼是否是鱼的子类（没有腮），继承具有侵入性，当需要使用继承关系时需要辨明是否是真正的继承，<strong>父类的每个方法都必须适用于子类</strong></p><ol><li>子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法</li><li>子类可以增加自己特有的方法</li><li>子类重载父类方法时，方法的形参要比父类方法更为宽松</li><li>子类实现父类抽象方法时，方法的返回值要比父类方法更为严格</li></ol><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><blockquote><p><em>talk only to your immediate friends. —— Ian Holland</em></p><p><em>只和直接的朋友交流</em></p></blockquote><p>迪米特法则也称为最少知道原则，最少知道包含两个目的：</p><ul><li><strong>只和直接的朋友交互</strong><ul><li>例如 MVC 架构，视图层和业务层交互，业务层和持久层交互，视图层不应该和持久层产生联系</li></ul></li><li><strong>较少对朋友的了解</strong><ul><li>类门面模式（门面指暴露重要工作的简单入口，而迪米特法则在于只暴露该暴露的入口，还是有所区别）思想，对外只暴露能够满足外部需要的内容</li></ul></li></ul><p><strong>目的在于降低类之间的耦合关系</strong></p><h2 id="接口隔离"><a href="#接口隔离" class="headerlink" title="接口隔离"></a>接口隔离</h2><blockquote><p><em>Interface Segregation Principle, ISP</em></p><p><em>低耦合、高内聚中的高内聚</em></p></blockquote><p>接口隔离原则中所说的接口并不是狭意的指 Java 中的 Interface，而是一切的提供方法定义的对象，例如 Java 中的接口、抽象类、实体类</p><p>接口隔离的原则：</p><ul><li>客户端不依赖不需要的接口</li><li>类间依赖关系建立在最小的接口上</li><li>接口应该细化，不应该具备臃肿的方法</li></ul><p>例如发送方式的实现类 <code>Send</code>，此时具备两种发送方式：邮件和短信，如果将方法都放在 <code>Send</code> 类中，则应该分别定义 <code>sendEmail()</code> 和 <code>sendNotice()</code> 两个方法，不利于后面的拓展；好的解决方法应该是定义接口，然后分别创建 <code>EmailSend</code> 和 <code>NoticeSend</code> 两个实现类，这就是接口隔离的目的</p><p>接口隔离和单一原则看似冲突，目标是达到二者的平衡</p><p><strong>避免接口污染</strong></p><h2 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h2><blockquote><p><em>Dependence Inversion Principle,DIP</em></p><p><em>不依赖于具体实现，而依赖于抽象</em></p></blockquote><p>不正确的依赖关系是上层调用下层，上层依赖下层</p><p>面向对象其实就是依赖倒置的一种体现，依赖倒置让下层依赖上层，比如接口，接口方法的扩展会影响所有实现类，但抽象层的变动远远少于实现层，所以依赖倒置可以很好地避免频繁的修改</p><p><strong>面向接口编程</strong></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="如何满足里氏替换原则"><a href="#如何满足里氏替换原则" class="headerlink" title="如何满足里氏替换原则"></a>如何满足里氏替换原则</h2><p>里氏替换的原则指：需要使用父类的地方可以替换为子类使用，因为父类的方法在子类上应该保持一致</p><p>在实际中遇到直接继承不能满足里氏替换的场景，就<strong>说明抽象不足，需要向上抽象</strong></p><p>如果一个 <code>Add</code> 类的 <code>compute(int n)</code> 操作为加法，减法也想要进行实现，则继承 <code>Add</code> 类后重写了 <code>compute(int n)</code> 方法，此时则违反了里氏替换原则，整个方法的实现被重写了</p><p>向上抽象出 <code>Compute</code> 接口，即可以实现里氏替换原则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Compute</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span> <span class="keyword">implements</span> <span class="title class_">Compute</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subtract</span> <span class="keyword">implements</span> <span class="title class_">Compute</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;减法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://refactoringguru.cn/design-patterns">常用设计模式有哪些？ (refactoringguru.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
