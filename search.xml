<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL 5.7 官方文档 - InnoDB 引擎.md</title>
      <link href="/%E5%BC%80%E5%8F%91/MySQL/MySQL%205.7%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%20-%20InnoDB%20%E5%BC%95%E6%93%8E.html"/>
      <url>/%E5%BC%80%E5%8F%91/MySQL/MySQL%205.7%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%20-%20InnoDB%20%E5%BC%95%E6%93%8E.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>摘自 MySQL 5.7 官方文档 14 章 <em>The InnoDB Storage Engine</em> 下的 <em>InnoDB Locking and Transaction Model</em></p><p>主要内容为 InnoDB 引擎下的锁机制和事务模型</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-transaction-model.html">MySQL :: MySQL 5.7 Reference Manual :: 14.7 InnoDB Locking and Transaction Model</a></p><h1 id="InnoDB-的锁机制和事务模型"><a href="#InnoDB-的锁机制和事务模型" class="headerlink" title="InnoDB 的锁机制和事务模型"></a>InnoDB 的锁机制和事务模型</h1><p>要实现大规模（large-scale）、繁忙或高可用（highly reliable）的数据库应用程序、从不同的数据库系统移植大量代码，或调整 MySQL 性能，了解 InnoDB 锁定和 InnoDB 事务模型是很重要的。</p><p>本节讨论了与 InnoDB 锁机制和您应该熟悉的 InnoDB 事务模型相关的几个主题</p><ul><li>14.7.1 - InnoDB 的锁机制</li><li>14.7.2 - InnoDB 的事务模型</li><li>14.7.3 - InnoDB 中不同 SQL 语句设置的锁</li><li>14.7.4 - 幻影行</li><li>14.7.5 - InnoDB 中的死锁</li></ul><h2 id="InnoDB-的锁机制"><a href="#InnoDB-的锁机制" class="headerlink" title="InnoDB 的锁机制"></a>InnoDB 的锁机制</h2><h3 id="共享锁-amp-排它锁"><a href="#共享锁-amp-排它锁" class="headerlink" title="共享锁 &amp; 排它锁"></a>共享锁 &amp; 排它锁</h3><p>InnoDB 实现了标准的行级锁，有两种类型：<strong>共享锁 S</strong>（shared locks）和<strong>排他锁 X</strong>（exclusive locks）</p><ul><li>共享锁：允许事务读取一行</li><li>排他锁：允许事务更新或删除一行</li></ul><p>如果事务 T1 对数据行 r 持有 S 锁，则如下处理来自某个不同事务 T2 的对数据行 r 的锁的请求：</p><ul><li>立即对 T2 签发 S 锁；此时 T1 和 T2 都持有对 r 的 S 锁</li><li>不会立即对 T2 签发 X 锁</li></ul><p>如果 T1 持有的是 X 锁，那么 T2 对任意类型的锁都不会被立即签发，相反 T2 只能等待 T1 释放它针对 r 的锁</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>InnoDB 支持多粒度锁（multiple granularity locking），允许行锁和表锁共存；举一个例子，SQL <code>LOCK TABLE ... WRITE</code> 会获取一个排他锁（X 锁）对于该指定的表；为了使多粒度级别的锁定变得实用，InnoDB 使用了意向锁，意向锁是表级锁，用于指示事务稍后需要表中某行使用哪种类型的锁（共享或排他），意向锁有两种类型：</p><ul><li>意向共享锁（IS）表示事务意图针对表中的数据行设置共享锁</li><li>意向排他锁（IX）表示事务意图针对表中的数据行设置排他锁</li></ul><p>例如，<code>SELECT ... LOCK IN SHARE MODE</code> 设置 IS 锁，而 <code>SELECT ... FOR UPDATE</code> 设置排他锁</p><p>意向锁定协议如下：</p><ul><li>在事务可以获取表中某行的共享锁之前，它必须首先获取表上的 IS 锁或更强的锁</li><li>在事务可以获取表中某行的排他锁之前，它必须首先获取表上的 IX 锁</li></ul><p>表级锁类型兼容性总结如下表所示</p><table><thead><tr><th align="center"></th><th align="center">X</th><th align="center">IX</th><th align="center">S</th><th align="center">IS</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">Conflict</td><td align="center">Conflict</td><td align="center">Conflict</td><td align="center">Conflict</td></tr><tr><td align="center">IX</td><td align="center">Conflict</td><td align="center">Compatible</td><td align="center">Conflict</td><td align="center">Compatible</td></tr><tr><td align="center">S</td><td align="center">Conflict</td><td align="center">Conflict</td><td align="center">Compatible</td><td align="center">Compatible</td></tr><tr><td align="center">IS</td><td align="center">Conflict</td><td align="center">Compatible</td><td align="center">Compatible</td><td align="center">Compatible</td></tr></tbody></table><p>如果请求事务与现有锁兼容，则会将锁授予该事务，但如果它与现有锁冲突，则不会授予该事务；事务将会等待直到导致冲突的锁被释放；如果锁请求与现有锁冲突，并且由于会导致死锁而无法授予，则会发生错误</p><p>意向锁不会阻塞除全表请求之外的任何内容（例如，<code>LOCK TABLES…WRITE</code>），意向锁的主要目的是显示有人正在锁定一行，或者要锁定表中的一行（即表达意图）</p><p>在 <code>SHOW ENGINE INNODB STATUS</code> 和 InnoDB monitor 输出中，意向锁的事务数据与以下内容类似：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TABLE</span> LOCK <span class="keyword">table</span> `test`.`t` trx id <span class="number">10080</span> lock mode IX</span><br></pre></td></tr></table></figure><h3 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h3><p>记录锁用于锁住一条索引记录，举一个例子 <code>SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;</code> 获取的锁将防止任何其他的事务对 <code>t.c1 = 10</code> 的行记录进行插入、更新、删除</p><p>记录锁总是锁定索引记录，即使是没有索引的表，InnoDB 会创建隐式的聚集索引（hidden clustered index）然后使用该索引来进行记录上锁</p><p>在 <code>SHOW ENGINE INNODB STATUS</code> 和 InnoDB monitor 输出中，记录锁的事务数据与以下内容类似：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id <span class="number">58</span> page <span class="keyword">no</span> <span class="number">3</span> n bits <span class="number">72</span> index `<span class="keyword">PRIMARY</span>` <span class="keyword">of</span> <span class="keyword">table</span> `test`.`t`</span><br><span class="line">trx id <span class="number">10078</span> lock_mode X locks rec but <span class="keyword">not</span> gap</span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">2</span> PHYSICAL RECORD: n_fields <span class="number">3</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">4</span>; hex <span class="number">8000000</span>a; <span class="keyword">asc</span>     ;;</span><br><span class="line"> <span class="number">1</span>: len <span class="number">6</span>; hex <span class="number">00000000274</span>f; <span class="keyword">asc</span>     <span class="string">&#x27;O;;</span></span><br><span class="line"><span class="string"> 2: len 7; hex b60000019d0110; asc        ;;</span></span><br></pre></td></tr></table></figure><h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>一个间隙锁锁住的是索引记录之间的范围，或者锁定第一个索引记录之前或者最后一个索引记录之后的范围</p><p>举个例子，<code>SELECT c1 FROM t1 WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code>，将会防止其他事务将 value 为 15 的数据插入 t.c1，无论这一列是否已经存在该值，因为该范围中的所有值都被锁定了</p><p>间隙可能跨越单个索引值、多个索引值，甚至为空</p><p>间隙锁是性能和并发之间权衡的一部分，用于某些事务隔离级别中</p><p><strong>间隙锁与唯一索引</strong></p><p>间隙锁在对于使用唯一索引查询一行数据的情况下不会加锁（不包括组合唯一索引，只在查询条件中覆盖了部分字段的情况）</p><p>举个例子，如果字段 <code>id</code> 是一个唯一索引，以下语句仅对 <code>id</code> 为 100 的行使用索引记录锁，并且其他会话是否在 id &#x3D; 100 前面的间隙中插入行并不重要：<code>SELECT * FROM child WHERE id = 100;</code></p><p>如果 <code>id</code> 没有索引或者不是唯一索引，则该语句会锁住前面的间隙</p><p><strong>间隙锁不互斥</strong></p><p>这里同时需要注意，<strong>不同的事务可能同时持有互相冲突的间隙锁</strong></p><p>举个例子，事务 A 可以持有一个共享间隙锁（gap S-lock），而事务 B 持有一个相同范围的排他间隙锁（gap X-lock），允许间隙锁冲突的原因是如果从索引中清除记录，则必须合并不同事务在记录上持有的间隙锁</p><p>InnoDB 中的间隙锁的功能是 “纯粹禁止”（purely inhibitive），这意味着它们的唯一目的是防止其他事务插入到锁定的范围中，所以间隙锁可以共存；一个事务获取的间隙锁定不会阻止另一个事务对同一间隙获取间隙锁定；共享和排他间隙锁之间没有区别，它们彼此不冲突，并且执行相同的功能</p><p><strong>禁用间隙锁</strong></p><p>间隙锁定可以明确禁用，如果将事务隔离级别更改为 READ COMMITTED 或启用 <code>innodb_locks_unsaf_for_binlog</code> 系统变量（现已废弃）即可；在这种情况下，间隙锁对于查询和索引扫描是禁用的，仅用于外键约束检查和唯一键检查</p><p>使用 READ COMMITTED 隔离级别或启用 <code>innodb_locks_unsaf_for_binlog</code> 也会产生其他影响</p><ul><li>MySQL 评估 WHERE 条件后，将释放不匹配行的记录锁</li><li>对于 UPDATE 语句，InnoDB 会进行 semi-consistent 读取，从而将最新提交的版本返回给 MySQL，以便MySQL 可以确定该行是否符合 UPDATE 的 WHERE 条件</li></ul><h3 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h3><p>临键锁是当前索引记录的<strong>记录锁</strong>和该记录之前范围的<strong>间隙锁</strong>的组合</p><p>InnoDB 的行级锁实现当进行查询或者对索引进行扫描，是这样来进行加锁操作：首先对于扫描的索引行设置共享或者排他锁，因此行级锁实际上是索引记录锁；一个锁住索引行的临键锁同样会<strong>影响索引记录之前的区间</strong></p><p>如果一个会话对索引中的记录 R 具有共享或排他锁定，则另一个会话将无法在索引顺序中 R 之前的间隙中插入新的索引记录</p><p>假设一个索引包含值 10、11、13 和 20，此索引可能的下一个键锁定涵盖以下区间，其中圆括号表示排除区间端点，方括号表示包含端点（开区间闭区间）：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative <span class="literal">infinity</span>, <span class="number">10</span>]</span><br><span class="line">(<span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line">(<span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line">(<span class="number">13</span>, <span class="number">20</span>]</span><br><span class="line">(<span class="number">20</span>, positive <span class="literal">infinity</span>)</span><br></pre></td></tr></table></figure><p>对于最后一个间隔，临键锁锁定索引中最大值上方的间隙，以及值高于索引中实际任何值的 “上确界” 伪记录（“supremum” pseudo-record），上确界并不是真实的索引记录，所以实际上，临键锁只锁定了最大索引值后面的间隙</p><p>InnoDB 默认的隔离级别为 REPEATABLE READ，在这种情况下 InnoDB 会在查询或者扫描索引时使用临键锁来防止出现幻影行</p><p>临键锁锁的事务数据在 <code>SHOW ENGINE INNODB STATUS</code> 和 InnoDB monitor 输出中显示如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id <span class="number">58</span> page <span class="keyword">no</span> <span class="number">3</span> n bits <span class="number">72</span> index `<span class="keyword">PRIMARY</span>` <span class="keyword">of</span> <span class="keyword">table</span> `test`.`t`</span><br><span class="line">trx id <span class="number">10080</span> lock_mode X</span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">1</span> PHYSICAL RECORD: n_fields <span class="number">1</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">8</span>; hex <span class="number">73757072656</span>d756d; <span class="keyword">asc</span> supremum;;</span><br><span class="line"></span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">2</span> PHYSICAL RECORD: n_fields <span class="number">3</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">4</span>; hex <span class="number">8000000</span>a; <span class="keyword">asc</span>     ;;</span><br><span class="line"> <span class="number">1</span>: len <span class="number">6</span>; hex <span class="number">00000000274</span>f; <span class="keyword">asc</span>     <span class="string">&#x27;O;;</span></span><br><span class="line"><span class="string"> 2: len 7; hex b60000019d0110; asc        ;;</span></span><br></pre></td></tr></table></figure><h3 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h3><p>插入意向锁是在插入行之前由 INSERT 操作设置的一种间隙锁</p><p>该锁以这样一种方式发出插入意图的信号，即如果插入到同一索引间隙的多个事务不在间隙内的同一位置插入，则不需要等待彼此；举个例子，存在索引行 value 为 4 和 7，独立的事务打算查询 value 5 和 6，每个事务都会在获得插入行上的排他锁定之前用插入意向锁定来锁定 4 和 7 之间的间隙，但是并不会互相阻塞，因为插入的行是不冲突的</p><p>下面的示例演示了一个事务，该事务在获得插入记录的独占锁之前使用插入意向锁，该示例涉及两个客户端，A 和 B</p><ol><li><p>客户端 A 创建一个包含两个索引记录（90 和 102）的表，然后启动一个事务，对 ID 大于 100 的索引记录进行排他锁定，排他性锁定包括记录 102 之前的间隙锁定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> child (id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, <span class="keyword">PRIMARY</span> KEY(id)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> child (id) <span class="keyword">values</span> (<span class="number">90</span>),(<span class="number">102</span>);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> child <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+</span></span><br><span class="line"><span class="operator">|</span> id  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">102</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+</span></span><br></pre></td></tr></table></figure></li><li><p>客户端 B 开启一个事务，将一条记录插入到间隙中，事务在等待获得排他锁的同时获得插入意向锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> child (id) <span class="keyword">VALUES</span> (<span class="number">101</span>);</span><br></pre></td></tr></table></figure></li></ol><p>插入意向锁的事务数据在 <code>SHOW ENGINE INNODB STATUS</code> 和 InnoDB monitor 输出中显示如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id <span class="number">31</span> page <span class="keyword">no</span> <span class="number">3</span> n bits <span class="number">72</span> index `<span class="keyword">PRIMARY</span>` <span class="keyword">of</span> <span class="keyword">table</span> `test`.`child`</span><br><span class="line">trx id <span class="number">8731</span> lock_mode X locks gap before rec <span class="keyword">insert</span> intention waiting</span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">3</span> PHYSICAL RECORD: n_fields <span class="number">3</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">4</span>; hex <span class="number">80000066</span>; <span class="keyword">asc</span>    f;;</span><br><span class="line"> <span class="number">1</span>: len <span class="number">6</span>; hex <span class="number">000000002215</span>; <span class="keyword">asc</span>     &quot; ;;</span><br><span class="line"> 2: len 7; hex 9000000172011c; asc     r  ;;...</span><br></pre></td></tr></table></figure><h3 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h3><p>自增锁是特殊的表级锁，当事务在表中插入 <code>AUTO_INCREMENT</code> 列时将会获取</p><p>在最简单的情况下，如果一个事务正在向表中插入值，那么任何其他事务都必须等待自己向该表中插入，以便第一个事务插入的行接收连续的主键值</p><p><code>innodb_autoinc_lock_mode</code> 变量控制用于自动增量锁定的算法，它允许您选择如何在可预测的自动增量值序列和插入操作的最大并发性之间进行权衡</p><h3 id="空间索引的谓词锁"><a href="#空间索引的谓词锁" class="headerlink" title="空间索引的谓词锁"></a>空间索引的谓词锁</h3><p>InnoDB 支持以空间数据（spatial data）为列的 <code>SPATIAL</code> 索引</p><p>为了处理涉及 SPATIAL 索引的操作的锁定，临键锁不能很好地支持 REPEATABLE READ 或 SERIALIZABLE 事务隔离级别，因为多维数据中没有绝对的排序概念，因此不清楚哪个是 “下一个” 键</p><p>为了支持具有 <code>SPATIAL</code> 索引的表的隔离级别，InnoDB 使用了谓词锁（predicate locks）；<code>SPATIAL</code> 索引包含最小边界矩形（MBR）值，因此 InnoDB 通过在用于查询的 MBR 值上设置谓词锁来强制对索引进行一致读取，此时其他事务处理无法插入或修改与查询条件匹配的行</p><h2 id="InnoDB-的事务模型"><a href="#InnoDB-的事务模型" class="headerlink" title="InnoDB 的事务模型"></a>InnoDB 的事务模型</h2><p>InnoDB 的事务模型旨在将多版本特性（multi-versioning）和传统的两阶段锁定相结合</p><p>InnoDB 在行级别执行锁定，并以 Oracle 的风格默认作为非锁定一致读（nonlocking consistent reads）来运行查询</p><p>InnoDB 中的锁信息被有效地存储在空间中，因此不需要升级锁，通常允许几个用户锁定 InnoDB 表中的每一行，或行的任何随机子集，并不会导致 InnoDB 内存耗尽</p><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>隔离级别是数据库处理的基础，</p><p>InnoDB 提供了 <em>SQL:1992 标准</em> 所描述的四种隔离级别：</p><ul><li>READ UNCOMMITTED</li><li>READ COMMITTED</li><li>REPEATABLE READ (DEFAULT)</li><li>SERIALIZABLE</li></ul><p>用户可以使用 <code>SET TRANSACTION</code> 语句来更改单个会话或所有后续连接的隔离级别，在命令行或配置文件使用 <code>--trsaction</code> 配置可以设置服务器的隔离级别</p><p>InnoDB 支持不同的隔离事务级别使用不同的锁策略，可以使用默认的 RR 级别强调高度一致性，用于进行对于 ACID 要求较高的关键数据操作；在批量情况下，也可以使用 RC 或者 RU 级别来放宽一致性原则，在这种情况下精确的一致性和重复结果不如最小化上锁开销那么重要；S 级别会比 RR 更加严格，它经常被用于特殊的场景，例如 XA 事务或者解决并发和死锁问题</p><p><strong>REAPEATABLE READ</strong></p><p>这是 InnoDB 的默认隔离级别；同一事务中都读取由第一次读取建立的快照版本，这意味着如果在同一事务中发出多个非锁定的 SELECT 语句，那么这些 SELECT 操作查询到的数据集彼此是一致的；这被称为 “一致的非锁定读取”（Consistent Nonlocking Reads）</p><p>对于锁定读取（SELECT … FOR UPDATE 或者 LOCK IN SHARE MODE）、UPDATE、DELETE 语句，会根据索引类型和查询范围进行上锁：</p><ul><li>对于具有唯一搜索条件的唯一索引，InnoDB 只锁定找到的索引记录，而不锁定之前的间隙</li><li>对于其他搜索条件，InnoDB 会锁定扫描的索引范围，使用间隙锁或临键锁来阻止其他会话插入到范围所覆盖的间隙中</li></ul><p><strong>READ COMMITTED</strong></p><p>即使在同一事务中，每次一致读取都会设置新的快照</p><p>对于锁定读取（SELECT … FOR UPDATE 或者 LOCK IN SHARE MODE）、UPDATE、DELETE 语句，InnoDB 只锁定索引记录，而不锁定它们的间隙，因此允许在锁定记录附近插入新记录；间隙锁定仅用于外键约束检查和重复 key 检查</p><p>由于不锁定间隙（间隙锁被禁用），所以可能会出现幻读问题，因为其他会话可以将新行插入间隙中</p><p>RC 隔离级别仅支持基于行的二进制日志记录；如果将 RC 与 binlog_format&#x3D;MIXED 一起使用，则服务器会自动使用基于行的日志记录</p><p>使用 RC 隔离级别可能存在的影响：</p><ul><li>对于 UPDATE 或 DELETE 语句，InnoDB 只为更新或删除的行保留锁记录，MySQL 会在评估 WHERE 条件后释放不匹配行的记录锁，这大大降低了死锁的概率，但死锁仍然可能发生</li><li>对于 UPDATE 语句，如果一行已经被锁定，InnoDB 会执行 “半一致”（semi-consistent） 读取，将最新提交的版本返回给 MySQL，以便 MySQL 可以确定该行是否符合 UPDATE 的 WHERE 条件，如果行匹配（必须更新）MySQL 将再次读取该行，这一次 InnoDB 要么将其锁定，要么等待锁定</li></ul><p><strong>READ UNCOMMITTED</strong></p><p>SELECT 操作会以无锁方式执行，但是可以使用行的可能的早期版本，所以使用这种隔离级别可能导致读取是不一致的，被称为脏读</p><p><strong>SERIALIZABLE</strong></p><p>该级别类似 RR，但是如果禁用了自动提交 InnoDB 隐式地将 SELECT 转换为了 SELECT … LOCK IN SHARE MODE；如果自动提交是启用状态，SELECT 是它自己的事务</p><p>因此已知它是只读的，一致（非锁定）读取执行串行化不会阻塞其他的事务（若要在其他事务已修改所选行的情况下进行锁定读取，需要禁用自动提交）</p><h3 id="自动提交、提交和回滚"><a href="#自动提交、提交和回滚" class="headerlink" title="自动提交、提交和回滚"></a>自动提交、提交和回滚</h3><p>InnoDB 中所有的用户操作都发生在事务中</p><p>如果启用了自动提交模式，则每条 SQL 语句都会自己形成一个事务，默认情况下 MySQL 会为每个新连接的 Session 开启自动提交，因此 MySQL 会在每个执行成功的 SQL 语句后自动提交事务；如果执行发生了错误，那么提交或者回滚取决于错误类型</p><p>启用了自动提交的会话也可以执行多语句事务，方法是以显式 START transaction 或 BEGIN 语句开始，然后以 COMMIT 或 ROLLBACK 语句结束</p><p>如果在 <code>SET autocommit=0</code> 的会话中禁用了自动提交模式，则该会话始终打开一个事务；COMMIT 或 ROLLBACK 语句会结束当前事务，并启动新事务</p><p>如果事务禁用了自动提交，并且结束时也没有针对该事务明确的 COMMIT 操作，那么 MySQL 会回滚该事务</p><h3 id="一致非锁定读"><a href="#一致非锁定读" class="headerlink" title="一致非锁定读"></a>一致非锁定读</h3><p>一致读取意味着 InnoDB 使用多版本控制在某个时间点（timepoint）向查询显示数据库的快照，查询会看到在此时间点之前提交的事务所做的修改，而不会看到以后或未提交的事务进行的修改</p><p>您可以通过提交事务，然后使用一致快照执行另一个 SELECT 或开启一个新事务来推进时间点</p><p>不同隔离级别的快照策略：</p><ul><li>REPEATABLE READ：第一次读取设置快照；提交事务后的读取则会使用最新数据</li><li>READ COMMITTED：事务中的每个一致读取都会设置并读取自己的新快照</li></ul><p><strong>举一个例子说明一致性读</strong></p><p>事务 A 只有在 B 提交了事务，并且 A 也提交了事务时才看到由 B 插入的行</p><table><thead><tr><th>事务 A</th><th>事务 B</th></tr></thead><tbody><tr><td>开启事务</td><td>开启事务</td></tr><tr><td>SELECT * FROM t;（empty set）</td><td></td></tr><tr><td></td><td>INSERT INTO tVALUES (1, 2);</td></tr><tr><td>SELECT * FROM t;（empty set）</td><td></td></tr><tr><td></td><td>COMMIT;</td></tr><tr><td>SELECT * FROM t;（empty set）</td><td></td></tr><tr><td>COMMIT;</td><td></td></tr><tr><td>SELECT * FROM t;（1,2）</td><td></td></tr></tbody></table><p>如果您想查看数据库的“最新”状态，请使用 READ COMMITTED 隔离级别或使用锁定读</p><p><strong>需要注意 DML 对数据可见的影响</strong></p><p>数据库状态的快照应用于事务中的 SELECT 语句，而不一定应用于 DML 语句</p><p>如果插入或修改某些行，然后提交该事务，则从另一个并发的 REPEATABLE READ 事务发出的 DELETE 或 UPDATE 语句可能会影响那些刚刚提交的行，即使会话无法查询到这些数据（因为快照）</p><p>如果事务确实更新或删除了由其他事务提交的行，则这些更改对当前事务可见</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(c1) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 <span class="operator">=</span> <span class="string">&#x27;xyz&#x27;</span>;</span><br><span class="line"><span class="comment">-- 0 行</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 <span class="operator">=</span> <span class="string">&#x27;xyz&#x27;</span>;</span><br><span class="line"><span class="comment">-- 可能会删除最近由其他事务提交的匹配到的行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(c2) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c2 <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="comment">-- 0 行</span></span><br><span class="line"><span class="keyword">UPDATE</span> t1 <span class="keyword">SET</span> c2 <span class="operator">=</span> <span class="string">&#x27;cba&#x27;</span> <span class="keyword">WHERE</span> c2 <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="comment">-- 如果另一个事务刚刚提交了 abc 值的 10 行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(c2) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c2 <span class="operator">=</span> <span class="string">&#x27;cba&#x27;</span>;</span><br><span class="line"><span class="comment">-- 10 行；这个事务现在可以看到它刚刚更新的行</span></span><br></pre></td></tr></table></figure><h3 id="锁定读"><a href="#锁定读" class="headerlink" title="锁定读"></a>锁定读</h3><p>如果查询数据后希望在同一事务中插入或更新相关数据，则常规 SELECT 语句无法提供足够的保护，其他事务可以更新或删除您刚才查询的同一行</p><p>InnoDB 引擎提供了两种锁定读的方式来提供额外的安全保证：</p><ul><li><code>SELECT ... LOCK IN SHARE MODE</code><br>在读取到的所有行上设置共享锁（shared mode lock）其他事务可以进行读取，但是在事务提交之前都不能进行修改，如果查询过程中这些行中的任意行被另一个尚未提交的事务修改，则查询将等待该事务结束，然后使用更新后的值</li><li><code>SELECT ... FOR UPDATE</code><br>对于查询到的索引记录，锁定行和任何关联的索引条目，就像为这些行进行 UPDATE 语句一样<br>对其他事务被阻止更新这些行、进行查询、在共享模式下锁定或读取特定事务隔离级别的数据<br>一致读（快照读）将忽略在读取视图中存在的记录上设置的任何锁（记录的旧版本无法锁定，因为它们是通过在记录的内存副本上应用 undo log 来重建的）</li></ul><p>这些子句在处理树结构或图结构数据时非常有用，无论是在单个表中还是在多个表中拆分；可以从一个位置遍历边或树枝到另一个位置，同时保留返回并更改任何这些“指针”值的权利</p><p>当事务被提交或回滚时，由 LOCK IN SHARE MODE 和 FOR UPDATE 查询设置的所有锁都会被释放</p><p><strong>FOR UPDATE 不会传递</strong></p><p>外部语句中的锁定读取子句不会锁定嵌套子查询中表的行，除非在子查询中也指定了锁定读取子句</p><p>例如，以下语句不会锁定表 t2 中的行</p><p><code>SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2) FOR UPDATE;</code></p><p>要锁定表 t2 中的行，请向子查询添加一个锁定读取子句</p><p><code>SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2 FOR UPDATE) FOR UPDATE;</code></p><blockquote><p>locking read</p><p>A <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html"><code>SELECT</code></a> statement that also performs a <strong>locking</strong> operation on an <code>InnoDB</code> table. Either <code>SELECT ... FOR UPDATE</code> or <code>SELECT ... LOCK IN SHARE MODE</code>. It has the potential to produce a <strong>deadlock</strong>, depending on the <strong>isolation level</strong> of the transaction. The opposite of a <strong>non-locking read</strong>*. Not allowed for global tables in a <strong>read-only transaction</strong>.</p><p><code>SELECT ... FOR SHARE</code> replaces <code>SELECT ... LOCK IN SHARE MODE</code> in MySQL 8.0.1, but <code>LOCK IN SHARE MODE</code> remains available for backward compatibility.</p><p>See <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html">Section 14.7.2.4, “Locking Reads”</a>.</p><p>See Also <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_deadlock">deadlock</a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_isolation_level">isolation level</a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_locking">locking</a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_non_locking_read">non-locking read</a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_read_only_transaction">read-only transaction</a>.</p></blockquote><h2 id="InnoDB-中不同语句设置的锁"><a href="#InnoDB-中不同语句设置的锁" class="headerlink" title="InnoDB 中不同语句设置的锁"></a>InnoDB 中不同语句设置的锁</h2><p>如果在查询中使用了二级索引，并且要设置的索引记录锁（record locks）是排他的，那么 InnoDB 还会检索相应的聚集索引记录并对其设置锁</p><p>如果你的语句没有合适的索引，MySQL 必须扫描整个表，该表的每一行都会被锁住，将会阻止其他用户对该表的所有插入，所以创建良好的索引非常重要，这样查询操作就不会扫描超出需求范围的记录行</p><p>InnoDB 设置特定类型的锁，如下所示：</p><ul><li><p><code>SELECT ... FROM</code><br>一致性读，读取数据库的快照不会上锁，除非隔离级别为 SERIALIZABLE；对于 SERIALIZABLE 级别，该查询将会在遇到的索引记录上设置共享的临键锁；但是对于使用唯一索引锁定行来查询唯一行的语句，只需要索引记录锁</p></li><li><p><code>SELECT ... FOR UPDATE</code> 或 <code>SELECT ... LOCK IN SHARE MODE</code><br>为扫描的行获取锁，并可能为不符合结果集中包含条件的行释放锁（例如，如果它们不符合 WHERE 子句中给定的条件<br>但是在某些情况下可能不会立即解锁，因为结果行与其原始源之间的关系在查询执行过程中丢失，例如在 UNION 中，在评估表中扫描（和锁定）的行是否符合结果集之前，可能会将这些行插入到临时表中；在这种情况下，临时表中的行与原始表中的列之间的关系将丢失，而后的行直到查询执行结束才被解锁</p></li><li><p><code>SELECT ... LOCK IN SHARE MODE</code><br>在查询遇到的所有索引记录上设置共享的临键锁，但是对于使用唯一索引锁定行来查询唯一行的语句，只需要索引记录锁</p></li><li><p><code>SELECT ... FOR UPDATE</code><br>在查询遇到的所有索引记录上设置排他的临键锁，但是对于使用唯一索引锁定行来查询唯一行的语句，只需要索引记录锁</p></li><li><p><code>UPDATE ... WHERE ...</code><br>在遇到的每一行索引记录上设置排他的临键锁；但是对于使用唯一索引锁定行来查询唯一行的语句，只需要索引记录锁</p></li><li><p><code>UPDATE</code><br>修改聚集索引记录时，会对受影响的辅助索引记录使用隐式锁，在查询新的辅助索引记录之前执行重复检测时、或者在插入新的辅助索引记录时，更新操作还会对受影响的辅助索引记录获取共享锁</p></li><li><p><code>DELETE FROM ... WHERE ...</code><br>对遇到的索引记录设置排他临键锁；但是对于使用唯一索引锁定行来查询唯一行的语句，只需要索引记录锁</p></li><li><p><code>INSERT</code><br>对插入的行设置排他记录锁，而不是临键锁（即没有间隙锁），并且不会阻止其他会话插入插入行之前的间隙中</p><p>在插入行之前，设置类型为间隙锁的插入意向锁；该锁相当于发出插入意向的信号，即如果插入到同一索引间隙中的多个事务并不在间隙内的同一位置插入，则它们不需要彼此等待；假设存在值为 4 和 7 的索引记录，当尝试插入值为 5 和 6 的单独事务，在获得排他记录锁之前，每个事务都使用插入意向锁来锁定 4 和 7 之间的间隙，但不会互相阻止，因为插入行不冲突</p><p>如果出现重复键错误，则会对重复索引记录设置共享锁，如果有多个会话试图插入同一行，而另一个会话已经具有排他锁，则这种共享锁的使用可能会导致死锁，如果另一个会话删除该行，则可能会发生如下情况；假设一个 InnoDB 表 t1 具有以下结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (i <span class="type">INT</span>, <span class="keyword">PRIMARY</span> KEY (i)) ENGINE <span class="operator">=</span> InnoDB;</span><br></pre></td></tr></table></figure><p>现在假设三个事务按顺序执行以下操作：</p><ol><li><p>事务 1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>事务 2</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>事务 3</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>事务 1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure></li></ol><p><strong>流程分析</strong>：事务 1 的第一个操作会获取 <code>1</code> 记录行的排他锁，而后事务 2 和 事务 3 也会插入 <code>1</code> 导致重复键错误，各自获取针对 <code>1</code> 的共享锁，事务 1 进行回滚，此时事务 2 和事务 3 出现死锁：由于另一方持有共享锁，因此两方都无法获取该行的排他锁</p><p>如果表中已经包含键值为 <code>1</code> 的行，并且三个事务按顺序执行以下操作，则会出现类似的情况：</p><ol><li><p>事务 1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> i <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>事务 2</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>事务 3</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>事务 1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li></ol><p><strong>流程分析</strong>：事务 1 的第一个操作会获取 <code>1</code> 记录行的排他锁，而后事务 2 和 事务 3 也会插入 <code>1</code> 导致重复键错误，各自获取针对 <code>1</code> 的共享锁，当事务 1 提交时，它会释放其在行上的排他锁，并授予事务 2 和 3 的排队共享锁请求；此事务 2和事务 3 出现死锁：由于另一方持有共享锁，因此两方都无法获取该行的独占锁</p></li><li><p><code>INSERT ... ON DUPLICATE KEY UPDATE</code><br>不同于简单的 INSERT 操作，当发生重复键错误时，会在需要更新的行上设置排他锁，而不是共享锁；对重复的主键值使用排他记录锁，对于重复的唯一索引值，将使用排他临键锁</p></li><li><p><code>REPLACE</code><br>如果唯一键没有冲突则和一个 INSERT 操作一致，否则会在需要 replace 的行上加排他临键锁</p></li><li><p><code>INSERT INTO T SELECT ... FROM S WHERE ...</code></p></li></ul><h2 id="幻影行"><a href="#幻影行" class="headerlink" title="幻影行"></a>幻影行</h2><p>之所以称呼为 “幻影读问题” 是因为一个事务在<strong>不同的时间</strong>进行<strong>相同的查询请求</strong>返回的结果集不同；举个例子，如果一个 <code>SELECT</code> 操作执行了两次，但是第一次查询返回了 1 行数据，第二次查询没有返回数据，那么这行数据就被称为 “幻影行”（phantom row）</p><p>假设子表的 id 列上有一个索引，并且希望读取并锁定表中标识符值大于 100 的所有行，以便稍后更新所选行中的某些列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> child <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>该查询会从 id 大于 100 的第一条记录开始扫描索引；假设这个表存在一些数据，id 的值为 90 和 102，如果在扫描范围内的索引记录上设置的锁不锁定在间隙（在这种情况下是 90 和 102 之间的间隙）中进行的插入，那么另一个事务就可以查询一个新行例如 id 为 101；如果随后同一个事务内执行了相同的 <code>SELECT</code> 操作，将会看到新插入的数据 101（幻影）也在返回结果中，这样其实违反了事务的隔离原则</p><p>为了防止幻影，InnoDB 使用了一种被称为 next-key locking 的算法，即结合了记录锁和间隙锁的临键锁；当查询进行扫描索引时，InnoDB 提供了这样的行级锁，将会对需要的行设置共享或者排他锁</p><p>因此行级锁实际上是索引记录锁，此外索引记录上的下一个键锁定也会影响索引记录之前的间隔，也就是说，下一个键锁是索引记录锁加上索引记录之前间隙上的间隙，如果一个会话对索引中的记录 R 持有共享或独占锁，则另一个会话无法在索引顺序中 R 之前的间隙中插入新的索引记录</p><p>当 InnoDB 扫描索引时，它还可以锁定索引中最后一条记录之后的间隙。正如前面的例子所发生的那样：为了防止在 id 大于 100 的表中插入任何内容，InnoDB 设置的锁包括 id 值 102 后面的间隙上的锁</p><p>可以使用临键锁在应用程序中实现唯一性检查：如果在共享模式下读取数据，但没有看到要插入的行的重复项，那么您可以安全地插入行，并知道在读取期间在行的后续行上设置的临键锁可以防止其他事务同时插入重复项，临键锁可以锁住表中不存在的数据</p><p>间隙锁可以被禁用，但这可能会导致幻读问题的出现</p><h2 id="InnoDB-中的死锁"><a href="#InnoDB-中的死锁" class="headerlink" title="InnoDB 中的死锁"></a>InnoDB 中的死锁</h2><h3 id="死锁示例"><a href="#死锁示例" class="headerlink" title="死锁示例"></a>死锁示例</h3><p>以下示例说明了当锁定请求导致死锁时，错误是如何发生的，该示例涉及两个客户端，A 和 B</p><ol><li><p>首先，客户端 A 创建一个包含一行的表，然后开始一个事务，在事务中 A 通过在共享模式下选择行来获得该行的 S 锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t (i <span class="type">INT</span>) ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">1.07</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t (i) <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.09</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> i <span class="operator">=</span> <span class="number">1</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> i    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br></pre></td></tr></table></figure></li><li><p>下一步，客户端 B 开启事务，尝试从表中删除该行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> i <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除操作需要 X 锁，现状是无法授予该锁，因为它与客户端 A 持有的 S 锁互斥，因此该请求会出现在行和客户端 B 块的锁请求队列中</p></li><li><p>最后客户端 A 也试图删除该行数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> i <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ol><p>死锁之所以会出现是因为客户端 A 需要 X 锁来删除该行，不过该锁不会被签发因为客户端 B 的一个请求已经已经获取了 X 锁并且在等待客户端 A 释放它的 S 锁，也无法将 A 持有的 S 锁升级为 X 锁，因为此时 B 已经持有了 X 锁，所以 InnoDB 为其中一个客户端返回错误并释放其锁</p><p>客户端返回此错误：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR <span class="number">1213</span> (<span class="number">40001</span>): Deadlock found <span class="keyword">when</span> trying <span class="keyword">to</span> <span class="keyword">get</span> lock;</span><br><span class="line">try restarting transaction</span><br></pre></td></tr></table></figure><p>此时就可以将锁签发给另一个客户端，让它从表中删除该行</p><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>当启用死锁检测（默认启用）时，InnoDB 会自动检测事务死锁，并回滚一个或多个事务以打破死锁；InnoDB 试图选择要回滚的小事务，其中事务的大小由插入、更新或删除的行数决定</p><p>如果 <code>InnoDB_table_locks=1</code>（默认值）和 <code>autocommit=0</code>，则 InnoDB 可以感知表锁，并且引擎上层的 MySQL 层可以感知行级锁；否则当涉及 MySQL lock TABLES 语句设置的表锁或 InnoDB 以外的存储引擎设置的锁时，InnoDB 无法检测到死锁；通过设置 <code>innodb_lock_wait_timeout</code> 系统变量的值来解决这些情况</p><p>在高并发系统上，当多个线程等待同一个锁时，死锁检测可能会导致速度减慢；有时当死锁发生时，禁用死锁检测并依靠 <code>innodb_lock_wait_timeout</code> 设置进行事务回滚可能会更有效；可以使用 <code>innodb_Deadlock_detect</code> 变量禁用死锁检测</p><h3 id="如何减少和解决死锁"><a href="#如何减少和解决死锁" class="headerlink" title="如何减少和解决死锁"></a>如何减少和解决死锁</h3><p>死锁是事务数据库中的一个经典问题，但除非它们非常频繁以至于根本无法成功执行某些事务，否则它们并不危险</p><p>通常必须编写逻辑用于在事务因死锁而回滚时，可以重新执行事务</p><p>InnoDB 使用自动行级锁定（automatic row-level locking），所以即使在只插入或删除一行的事务的情况下，也可能出现死锁；这是因为这些操作并不是真正的“原子”操作；它们会自动对插入或删除的行的（可能有几个）索引记录设置锁</p><p>可以使用以下技术来处理死锁并降低其发生的可能性：</p><ul><li><p>随时使用 <code>SHOW ENGINE INNODB STATUS</code> 指令以确定最近死锁的原因；这可以帮助调整应用程序以避免死锁</p></li><li><p>如果频繁的死锁警告引起问题，请通过启用 <code>innodb_print_all_deadlocks</code> 变量来收集更广泛的调试信息；MySQL 错误日志中记录了每个死锁的信息，而不仅仅是最新的死锁；调试完成后禁用此选项</p></li><li><p>如果事务由于死锁而失败，请始终做好重新执行事务的准备；死锁并不危险，只需要再试一次</p></li><li><p>保持事务的规模小且持续时间短，以减少它们发生冲突的可能性；即避免大事务</p></li><li><p>在进行一组相关更改后立即提交事务，以减少它们发生冲突的可能性；特别是，不要让交互式 MySQL 会话与未提交的事务长时间开启</p></li><li><p>如果使用锁定读（<code>SELECT…FOR UPDATE</code> 或 <code>SELECT…LOCK IN SHARE MODE</code>），请尝试使用较低的隔离级别，例如 READ COMMITTED</p></li><li><p>当修改事务中的多个表或同一表中的不同行集时，每次都要以一致的顺序执行这些操作，可以让事务的执行形成定义良好的队列，从而避免死锁；即应用中的按照表顺序、字段值顺序排序</p></li><li><p>精心设置索引，避免过多索引导致的死锁；使用 <code>EXPLAIN SELECT</code> 来确定 MySQL 服务器认为哪些索引最适合查询</p></li><li><p>不使用锁；如果业务可以允许查询从旧快照返回数据，不要使用 <code>FOR UPDATE</code> 或 <code>LOCK IN SHARE MODE</code> 子句，并且推荐使用 READ COMMITTED 隔离级别，因为同一事务中的每个一致读都从自己的新快照中读取</p></li><li><p>如果上述建议没有帮助，可以使用表级锁序列化事务，将 <code>LOCK TABLES</code> 与事务性表（如 InnoDB 表）一起使用的正确方法是以 <code>SET autocommit=0</code>（而不是 <code>START transaction</code>）开头，后跟 <code>LOCK TABLES</code>，然后在显式提交事务之前不调用 <code>UNLOCK TABLES</code><br>例如，如果您需要写入表 t1 并从表 t2 读取，则可以执行以下操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">LOCK TABLES t1 WRITE, t2 READ, ...;</span><br><span class="line">... do something <span class="keyword">with</span> tables t1 <span class="keyword">and</span> t2 here ...</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure><p>表级锁防止对表进行并发更新，从而避免死锁，而代价是并发响应能力较低</p></li><li><p>序列化事务的另一种方法是创建一个只包含一行的辅助“信号量”（semaphore）表；在访问其他表之前首先让每个事务更新该行；这样所有事务都以串行方式发生；需要注意 InnoDB 死锁检测算法也适用于这种情况，因为序列化锁是行级锁，对于 MySQL 表级锁则必须使用 timeout 方法来解决死锁</p></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-transaction-model.html">MySQL :: MySQL 5.7 Reference Manual :: 14.7 InnoDB Locking and Transaction Model</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DB </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 小心 FOR UPDATE 的 Record 锁</title>
      <link href="/%E5%BC%80%E5%8F%91/MySQL/MySQL%20%E5%B0%8F%E5%BF%83%20FOR%20UPDATE%20%E7%9A%84%20Record%20%E9%94%81.html"/>
      <url>/%E5%BC%80%E5%8F%91/MySQL/MySQL%20%E5%B0%8F%E5%BF%83%20FOR%20UPDATE%20%E7%9A%84%20Record%20%E9%94%81.html</url>
      
        <content type="html"><![CDATA[<h1 id="FOR-UPDATE"><a href="#FOR-UPDATE" class="headerlink" title="FOR UPDATE"></a>FOR UPDATE</h1><p><code>FOR UPDATE</code> 是 SELECT 语句的可选参数</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/select.html">MySQL :: MySQL 5.7 Reference Manual :: 13.2.9 SELECT Statement</a></p><ul><li><p>如果将 <code>FOR UPDATE</code> 和支持页锁或行锁的数据库引擎一起使用（比如 InnoDB），被查询的行将被写锁定，直到当前事务结束<br>使用 <code>LOCK IN SHARE MODE</code> 将设置共享锁，允许其他事务读取检查的行，但不更新或删除它们</p></li><li><p>当使用类似的语句 <code>CREATE TABLE new_table SELECT ... FROM old_table </code> 不能在 <code>SELECT</code> 中使用 <code>FOR UPDATE</code></p><p>如果您尝试执行此操作，则该语句将被拒绝，并显示 <code>Can&#39;t update table &#39;old_table&#39; while &#39;new_table&#39; is being created.</code></p></li></ul><h1 id="锁定读"><a href="#锁定读" class="headerlink" title="锁定读"></a>锁定读</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html">MySQL :: MySQL 5.7 Reference Manual :: 14.7.2.4 Locking Reads</a></p><p>如果查询数据后希望在同一事务中插入或更新相关数据，则常规 SELECT 语句无法提供足够的保护，其他事务可以更新或删除您刚才查询的同一行</p><p>InnoDB 引擎提供了两种锁定读的方式来提供额外的安全保证：</p><ul><li><code>SELECT ... LOCK IN SHARE MODE</code><br>在读取到的所有行上设置共享锁（shared mode lock）其他事务可以进行读取，但是在事务提交之前都不能进行修改，如果查询过程中这些行中的任意行被另一个尚未提交的事务修改，则查询将等待该事务结束，然后使用更新后的值</li><li><code>SELECT ... FOR UPDATE</code><br>对于查询到的索引记录，锁定行和任何关联的索引条目，就像为这些行进行 UPDATE 语句一样<br>对其他事务被阻止更新这些行、进行查询、在共享模式下锁定或读取特定事务隔离级别的数据<br>一致读（快照读）将忽略在读取视图中存在的记录上设置的任何锁（记录的旧版本无法锁定，因为它们是通过在记录的内存副本上应用 undo log 来重建的）</li></ul><p>这些子句在处理树结构或图结构数据时非常有用，无论是在单个表中还是在多个表中拆分；可以从一个位置遍历边或树枝到另一个位置，同时保留返回并更改任何这些“指针”值的权利</p><p>当事务被提交或回滚时，由 LOCK IN SHARE MODE 和 FOR UPDATE 查询设置的所有锁都会被释放</p><br><p><strong>FOR UPDATE 不会传递</strong></p><p>外部语句中的锁定读取子句不会锁定嵌套子查询中表的行，除非在子查询中也指定了锁定读取子句</p><p>例如，以下语句不会锁定表 t2 中的行</p><p><code>SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2) FOR UPDATE;</code></p><p>要锁定表 t2 中的行，请向子查询添加一个锁定读取子句</p><p><code>SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2 FOR UPDATE) FOR UPDATE;</code></p><blockquote><p>locking read</p><p>A <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html"><code>SELECT</code></a> statement that also performs a <strong>locking</strong> operation on an <code>InnoDB</code> table. Either <code>SELECT ... FOR UPDATE</code> or <code>SELECT ... LOCK IN SHARE MODE</code>. It has the potential to produce a <strong>deadlock</strong>, depending on the <strong>isolation level</strong> of the transaction. The opposite of a <strong>non-locking read</strong>*. Not allowed for global tables in a <strong>read-only transaction</strong>.</p><p><code>SELECT ... FOR SHARE</code> replaces <code>SELECT ... LOCK IN SHARE MODE</code> in MySQL 8.0.1, but <code>LOCK IN SHARE MODE</code> remains available for backward compatibility.</p><p>See <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html">Section 14.7.2.4, “Locking Reads”</a>.</p><p>See Also <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_deadlock">deadlock</a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_isolation_level">isolation level</a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_locking">locking</a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_non_locking_read">non-locking read</a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_read_only_transaction">read-only transaction</a>.</p></blockquote><h1 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h1><p>上面介绍锁定读中，有一句解释</p><blockquote><p>Consistent reads ignore any locks set on the records that exist in the read view.</p><p>一致读将忽略在读取视图中存在的记录上设置的任何锁</p></blockquote><p>这里的一致读指的就是一致性非锁定读（Consistent Nonlocking Reads）</p><p>一致读取意味着 InnoDB 使用多版本控制在某个时间点（timepoint）向查询显示数据库的快照，查询会看到在此时间点之前提交的事务所做的修改，而不会看到以后或未提交的事务进行的修改</p><p>您可以通过提交事务，然后使用一致快照执行另一个 SELECT 或开启一个新事务来推进时间点</p><p>不同隔离级别的快照策略：</p><ul><li>REPEATABLE READ：第一次读取设置快照；提交事务后的读取则会使用最新数据</li><li>READ COMMITTED：事务中的每个一致读取都会设置并读取自己的新快照</li></ul><br><p><strong>举一个例子说明一致性读</strong></p><p>事务 A 只有在 B 提交了事务，并且 A 也提交了事务时才看到由 B 插入的行</p><table><thead><tr><th>事务 A</th><th>事务 B</th></tr></thead><tbody><tr><td>开启事务</td><td>开启事务</td></tr><tr><td>SELECT * FROM t;（empty set）</td><td></td></tr><tr><td></td><td>INSERT INTO tVALUES (1, 2);</td></tr><tr><td>SELECT * FROM t;（empty set）</td><td></td></tr><tr><td></td><td>COMMIT;</td></tr><tr><td>SELECT * FROM t;（empty set）</td><td></td></tr><tr><td>COMMIT;</td><td></td></tr><tr><td>SELECT * FROM t;（1,2）</td><td></td></tr></tbody></table><p>如果您想查看数据库的“最新”状态，请使用 READ COMMITTED 隔离级别或使用锁定读</p><br><p><strong>需要注意 DML 对数据可见的影响</strong></p><p>数据库状态的快照应用于事务中的 SELECT 语句，而不一定应用于 DML 语句</p><p>如果插入或修改某些行，然后提交该事务，则从另一个并发的 REPEATABLE READ 事务发出的 DELETE 或 UPDATE 语句可能会影响那些刚刚提交的行，即使会话无法查询到这些数据（因为快照）</p><p>如果事务确实更新或删除了由其他事务提交的行，则这些更改对当前事务可见</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(c1) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 <span class="operator">=</span> <span class="string">&#x27;xyz&#x27;</span>;</span><br><span class="line"><span class="comment">-- 0 行</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 <span class="operator">=</span> <span class="string">&#x27;xyz&#x27;</span>;</span><br><span class="line"><span class="comment">-- 可能会删除最近由其他事务提交的匹配到的行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(c2) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c2 <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="comment">-- 0 行</span></span><br><span class="line"><span class="keyword">UPDATE</span> t1 <span class="keyword">SET</span> c2 <span class="operator">=</span> <span class="string">&#x27;cba&#x27;</span> <span class="keyword">WHERE</span> c2 <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="comment">-- 如果另一个事务刚刚提交了 abc 值的 10 行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(c2) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c2 <span class="operator">=</span> <span class="string">&#x27;cba&#x27;</span>;</span><br><span class="line"><span class="comment">-- 10 行；这个事务现在可以看到它刚刚更新的行</span></span><br></pre></td></tr></table></figure><h1 id="合理使用-FOR-UPDATE"><a href="#合理使用-FOR-UPDATE" class="headerlink" title="合理使用 FOR UPDATE"></a>合理使用 FOR UPDATE</h1><p>业务中有时需要查询数据，对数据进行 check 之后再更新，就需要使用锁机制</p><p>往往简单的实现方式是在并发不高的场景下开启事务直接使用 <code>FOR UPDATE</code> 进行查询后进行修改</p><p>不过需要注意查询数据是否存在，如果数据不存在可能会严重影响性能，具体原因将会在下面进行分析，当然一句话概括也很简单：<code>FOR UPDATE</code> 会上 record 锁，如果数据不存在 record 锁会变为 gap 锁</p><h2 id="真实背景"><a href="#真实背景" class="headerlink" title="真实背景"></a>真实背景</h2><p>压测中发现涉及积分表写入的响应特别慢，甚至还存在死锁</p><p>逻辑流程：</p><ol><li>写锁定读对应行（因为需要 check 余额）</li><li>检查余额，计算更新参数</li><li>插入或者更新（使用 <code>INSERT IGNORE ... ON DUPLICATE KEY UPDATE</code> 实现）</li></ol><p>这是使用锁定读容易忽略的一个点，即<strong>有可能不存在对应行数据，导致锁的范围变大</strong></p><h2 id="记录锁和间隙锁"><a href="#记录锁和间隙锁" class="headerlink" title="记录锁和间隙锁"></a>记录锁和间隙锁</h2><p><strong>记录锁 Record Locks</strong></p><p>记录锁是索引记录上的锁</p><p>例如 <code>SELECT c1 FROM t WHERE c1=10 For UPDATE；</code>；将会阻止任何其他事务插入、更新或删除 <code>t.c1</code> 值为 <code>10</code> 的行</p><p>记录锁总是锁定索引记录，即使定义的表没有索引；这种情况 InnoDB 会创建一个隐藏的聚集索引，并将该索引用于记录锁定</p><p>记录锁的事务数据在 SHOW ENGINE INNODB STATUS 和 InnoDB 监视器输出中显示如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id <span class="number">58</span> page <span class="keyword">no</span> <span class="number">3</span> n bits <span class="number">72</span> index `<span class="keyword">PRIMARY</span>` <span class="keyword">of</span> <span class="keyword">table</span> `test`.`t`</span><br><span class="line">trx id <span class="number">10078</span> lock_mode X locks rec but <span class="keyword">not</span> gap</span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">2</span> PHYSICAL RECORD: n_fields <span class="number">3</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">4</span>; hex <span class="number">8000000</span>a; <span class="keyword">asc</span>     ;;</span><br><span class="line"> <span class="number">1</span>: len <span class="number">6</span>; hex <span class="number">00000000274</span>f; <span class="keyword">asc</span>     <span class="string">&#x27;O;;</span></span><br><span class="line"><span class="string"> 2: len 7; hex b60000019d0110; asc        ;;</span></span><br></pre></td></tr></table></figure><br><p><strong>间隙锁 Gap Locks</strong></p><p>间隙锁定是对索引记录之间间隙的锁定，或对第一个索引记录之前（上确界）或最后一个索引记录之后（下确界）间隙的锁定</p><p>例如 <code>SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code>；将会防止其他事务将值 <code>15</code> 插入到 <code>t.c1</code> 列中，无论该列中是否已经存在任何此类值，因为该范围中所有现有值之间的间隙都被锁定</p><p>间隙可能跨越单个索引值、多个索引值，甚至为空</p><p>间隙锁只存在于部分隔离级别中</p><p>对于唯一索引并且只查询唯一行的语句，不会设置间隙锁</p><p>例如 <code>SELECT * FROM child WHERE id = 100;</code>；但是如果 id 没有索引或具有非唯一索引，则该语句会锁定前面的间隙（这里就是背景问题的根源）</p><p><strong>间隙锁的冲突性</strong></p><p>需要注意不同的事务可以在间隙上持有冲突的间隙锁（只有间隙锁和间隙锁之前不冲突）</p><p>例如，事务 A 可以在间隙上保持共享间隙锁（gap S-lock），而事务 B 在相同间隙上保持独占间隙锁（gap X-lock）；允许冲突的间隙锁的原因是，如果从索引中删除记录，必须合并不同事务在记录上保留的间隙锁</p><p>InnoDB 中的间隙锁是“纯抑制性的（purely inhibitive）”，这意味着它们的唯一目的是防止其他事务插入到间隙中，所以间隙锁可以共存</p><p>一个事务占用的间隙锁不会阻止另一个事务对同一间隙占用间隙锁，共享和独占间隙锁之间没有区别，它们彼此不冲突，并且具备相同的功能</p><h2 id="验证-普通索引"><a href="#验证-普通索引" class="headerlink" title="验证 - 普通索引"></a>验证 - 普通索引</h2><p>创建 DB 和插入基本数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test_key` (</span><br><span class="line">  `id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `key` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_key` (`key`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test_key`(`key`) <span class="keyword">VALUES</span>(<span class="number">10</span>),(<span class="number">20</span>),(<span class="number">30</span>),(<span class="number">40</span>),(<span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>查询 <code>performance_schema.data_locks</code> 可以获取当前持有锁的事务及锁相关信息（我使用的 MySQL 版本为 8.0，需要注意不同版本的区别）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `performance_schema.data_locks`;</span><br></pre></td></tr></table></figure><p>隔离级别为 RR</p><p><strong>查询命中索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test_key` <span class="keyword">WHERE</span> `key` <span class="operator">=</span> <span class="number">30</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>表中存在 key &#x3D; 30 的数据，持有的锁：</p><ul><li>表级别的<strong>插入意向锁</strong>（<code>FOR UPDATE</code> 带来）</li><li>idx_key 30 索引上的<strong>临键锁</strong></li><li>PRIMARY 3 索引上的<strong>记录锁</strong></li><li>RECORD 40 索引上的<strong>间隙锁</strong></li></ul><table><thead><tr><th>INDEX_NAME</th><th>LOCK_TYPE</th><th>LOCK_MODE</th><th>LOCK_DATA</th></tr></thead><tbody><tr><td>&#x2F;</td><td>TABLE</td><td>IX</td><td>&#x2F;</td></tr><tr><td>idx_key</td><td>RECORD</td><td>X</td><td>30, 3</td></tr><tr><td>PRIMARY</td><td>RECORD</td><td>X,REC_NOT_GAP</td><td>3</td></tr><tr><td>idx_key</td><td>RECORD</td><td>X,GAP</td><td>40, 4</td></tr></tbody></table><p><strong>查询未命中索引，但有更大的索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test_key` <span class="keyword">WHERE</span> `key` <span class="operator">=</span> <span class="number">35</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>表中不存在 key &#x3D; 30 的数据，但存在 key &#x3D; 40 的数据，持有的锁：</p><ul><li>表级别的<strong>插入意向锁</strong></li><li>idx_key 40 索引上的<strong>间隙锁</strong></li></ul><table><thead><tr><th>INDEX_NAME</th><th>LOCK_TYPE</th><th>LOCK_MODE</th><th>LOCK_DATA</th></tr></thead><tbody><tr><td>&#x2F;</td><td>TABLE</td><td>IX</td><td>&#x2F;</td></tr><tr><td>idx_key</td><td>RECORD</td><td>X,GAP</td><td>40, 4</td></tr></tbody></table><p><strong>查询未命中索引，没有更大的索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test_key` <span class="keyword">WHERE</span> `key` <span class="operator">=</span> <span class="number">60</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>表中不存在 key &#x3D; 60 的数据，且没有比 60 更大的索引，持有的锁：</p><ul><li>表级别的<strong>插入意向锁</strong></li><li>上确界伪记录<strong>临键锁</strong></li></ul><table><thead><tr><th>INDEX_NAME</th><th>LOCK_TYPE</th><th>LOCK_MODE</th><th>LOCK_DATA</th></tr></thead><tbody><tr><td>&#x2F;</td><td>TABLE</td><td>IX</td><td>&#x2F;</td></tr><tr><td>idx_key</td><td>RECORD</td><td>X</td><td>supremum pseudo-record</td></tr></tbody></table><h2 id="验证-唯一约束"><a href="#验证-唯一约束" class="headerlink" title="验证 - 唯一约束"></a>验证 - 唯一约束</h2><p>同理</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test_uni_key` (</span><br><span class="line">  `id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `key` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uni_key` (`key`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test_uni_key`(`key`) <span class="keyword">VALUES</span>(<span class="number">10</span>),(<span class="number">20</span>),(<span class="number">30</span>),(<span class="number">40</span>),(<span class="number">50</span>);</span><br></pre></td></tr></table></figure><p><strong>查询命中索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test_uni_key` <span class="keyword">WHERE</span> `key` <span class="operator">=</span> <span class="number">30</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>表中存在 key &#x3D; 30 的数据，持有的锁：</p><ul><li>表级别的<strong>插入意向锁</strong></li><li>uni_key 30 索引上的<strong>记录锁</strong></li><li>PRIMARY 3 索引上的<strong>记录锁</strong></li></ul><table><thead><tr><th>INDEX_NAME</th><th>LOCK_TYPE</th><th>LOCK_MODE</th><th>LOCK_DATA</th></tr></thead><tbody><tr><td>&#x2F;</td><td>TABLE</td><td>IX</td><td>&#x2F;</td></tr><tr><td>idx_key</td><td>RECORD</td><td>X,REC_NOT_GAP</td><td>30, 3</td></tr><tr><td>PRIMARY</td><td>RECORD</td><td>X,REC_NOT_GAP</td><td>3</td></tr></tbody></table><p><strong>查询未命中索引，但有更大的索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test_uni_key` <span class="keyword">WHERE</span> `key` <span class="operator">=</span> <span class="number">35</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>表中不存在 key &#x3D; 30 的数据，但存在 key &#x3D; 40 的数据，持有的锁：</p><ul><li>表级别的<strong>插入意向锁</strong></li><li>uni_key 40 索引上的<strong>间隙锁</strong></li></ul><table><thead><tr><th>INDEX_NAME</th><th>LOCK_TYPE</th><th>LOCK_MODE</th><th>LOCK_DATA</th></tr></thead><tbody><tr><td>&#x2F;</td><td>TABLE</td><td>IX</td><td>&#x2F;</td></tr><tr><td>uni_key</td><td>RECORD</td><td>X,GAP</td><td>40, 4</td></tr></tbody></table><p><strong>查询未命中索引，没有更大的索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test_uni_key` <span class="keyword">WHERE</span> `key` <span class="operator">=</span> <span class="number">60</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>表中不存在 key &#x3D; 60 的数据，且没有比 60 更大的索引，持有的锁：</p><ul><li>表级别的<strong>插入意向锁</strong></li><li>上确界伪记录<strong>临键锁</strong></li></ul><table><thead><tr><th>INDEX_NAME</th><th>LOCK_TYPE</th><th>LOCK_MODE</th><th>LOCK_DATA</th></tr></thead><tbody><tr><td>&#x2F;</td><td>TABLE</td><td>IX</td><td>&#x2F;</td></tr><tr><td>uni_key</td><td>RECORD</td><td>X</td><td>supremum pseudo-record</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从验证中可以看出，普通索引和唯一约束索引的区别在于对于存在的数据，普通索引多了<strong>索引记录的临键锁</strong>和<strong>索引记录下个范围的间隙锁</strong>；这是因为没有了唯一约束，同值数据可能存在多行，例如 <code>key = 30</code> 的数据可能在其他事务中被插入最终造成幻读，所以需要更多的锁来保证</p><p>此外可以看出导致不规范使用 <code>FOR UPDATE</code> 严重影响效率的核心原因，<code>supremum pseudo-record</code> 的<strong>临键锁</strong>或下一个索引范围的<strong>间隙锁</strong>，可能会锁住表中大片区域导致并发下降、线程等待</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ul><li>业务中是否可以提前写入数据，避免 <code>FOR UPDATE</code> 操作找不到索引而升级为间隙锁甚至锁住上确界</li><li>必要时可以使用其他效率更高、更轻量的锁实现代替，例如使用 Redis 锁</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/select.html">MySQL :: MySQL 5.7 Reference Manual :: 13.2.9 SELECT Statement</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html">MySQL :: MySQL 5.7 Reference Manual :: 14.7.2.4 Locking Reads</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-record-locks">MySQL :: MySQL 5.7 Reference Manual :: 14.7.1 InnoDB Locking</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DB </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RECIPES - Mulled Wine</title>
      <link href="/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/RECIPES%20-%20Mulled%20Wine.html"/>
      <url>/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/RECIPES%20-%20Mulled%20Wine.html</url>
      
        <content type="html"><![CDATA[<img src="/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/RECIPES%20-%20Mulled%20Wine/Mulled%20Wine%20Recipe-1.jpg" class="" title="Mulled Wine Recipe-1"><blockquote><p> <em>This traditional homemade mulled wine recipe is incredibly easy to make and always SO cozy and delicious.</em></p><p>这种传统的自制热葡萄酒配方非常容易制作，而且非常舒适美味</p></blockquote><p>圣诞节来喝热红酒吧~</p><h1 id="Mulled-Wine-热葡萄酒"><a href="#Mulled-Wine-热葡萄酒" class="headerlink" title="Mulled Wine 热葡萄酒"></a>Mulled Wine 热葡萄酒</h1><p>也被称为 glühwein、vino-caliente、glögg、vin brulé、bisschopswijn、vin chaud、candola、vinho quente… 或者其他上百个名字，这取决于你在世界上的位置</p><p>不用说似乎世界上几乎每个人都喜欢热葡萄酒，很明显，我可以保证你们也一样</p><h2 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h2><p>首先来准备原料，对于这个热葡萄酒配方，需要</p><ul><li><strong>红酒（Wine）</strong>：无需挥霍一瓶昂贵的葡萄酒，只需要一瓶中等价位的干红或白葡萄酒就可以了（如果你需要制作一大批，这是一个使用盒装葡萄酒的完美场景~）；最好的选择是果味浓郁、酒体饱满的葡萄酒，这样它才能经得起高温的考验，且不会被香料的香气完全淹没</li><li><strong>白兰地（Brandy）</strong>：与桑格利亚汽酒（Sangria）类似，在热葡萄酒中多加一点利口酒也是一种传统做法；白兰地是传统的选择，但君度酒（Cointreau 或其他橙味利口酒）或茶色波特酒（Tawny Port）也是美味的替代品</li><li><strong>新鲜的橙子（Fresh oranges）</strong>：使用切片在葡萄酒中慢煮，如果愿意可以切片并用作装饰（为了尽量减少苦味，建议在将橙子放入葡萄酒中慢煮之前将其去皮）</li><li><strong>肉桂（Cinnamon）</strong>：如果你手头有肉桂的话，你可以加入一些肉桂粉</li><li><strong>香料（Mulling spices）</strong>：因国家而异，例如整瓣丁香和八角茴香，也许还有一些豆蔻荚</li><li><strong>甜味剂（Sweetener）</strong>：随意添加喜欢的甜味剂，糖是最经典的，也可以使用枫糖浆或蜂蜜来自然增甜</li></ul><h2 id="制作步骤"><a href="#制作步骤" class="headerlink" title="制作步骤"></a>制作步骤</h2><p>接下来开始制作热葡萄酒，只需</p><ol><li><strong>将原料混合</strong>：将所有的材料放在煮锅中搅拌均匀</li><li><strong>慢煮</strong>：用中高火加热，直到葡萄酒几乎达到文火慢煮的程度（避免起泡；酒精在 172°F &#x2F; 77.8°C 时开始蒸发，所以要小心确保葡萄酒不会蒸发）将火调至小火，完全盖上盖子，让葡萄酒慢煮至少 15 分钟最多 3 小时</li><li><strong>过滤和调味</strong>：用细网滤去并丢弃橙子片、丁香、肉桂棒、八角茴香和生姜等材料；品尝一下热葡萄酒，如果需要可以加入想要的额外甜味剂</li><li><strong>完成</strong>：装在热的杯子里，上面放上喜欢的装饰</li></ol><img src="/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/RECIPES%20-%20Mulled%20Wine/Mulled%20Wine%20Recipe-2.jpg" class="" title="Mulled Wine Recipe-2"><h2 id="定制变化"><a href="#定制变化" class="headerlink" title="定制变化"></a>定制变化</h2><p>想定制一下这款热葡萄酒吗？请随意</p><ul><li><strong>白葡萄酒</strong>：用干白葡萄酒制作的热葡萄也非常美味</li><li><strong>印度茶包（Chai Tea Bag）</strong>：用于代替丁香和八角，可以随意将 1 到 2 个印度茶包浸泡在热葡萄酒中（如果晚上来喝，最好使用不含咖啡因的）</li><li><strong>不同的香料</strong>：随意添加任何听起来有趣的香料，比如新鲜的姜片、豆蔻荚、肉豆蔻、百香果或柠檬皮是其他一些不错的香料</li><li><strong>装饰</strong>：可以营造节日气氛，可以在出锅前几分钟撒上一些新鲜的蔓越莓</li><li><strong>慢煮锅（Crock Pot）</strong>：也可以尝试使用慢煮锅设置低温来制作热葡萄酒，不过需要明确地提醒大家，当涉及到厂家认为的“低”温度时，慢煮锅的配置可以覆盖所有温度范围（意思就是低温根本不低呗）；因此如果使用慢煮锅，一定要密切关注它的状态，确保葡萄酒不会遭遇高温</li></ul><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p><a href="https://www.gimmesomeoven.com/mulled-wine-recipe/">Mulled Wine Recipe | Gimme Some Oven</a></p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 宿醉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recipes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLM 信息提取结构化输出</title>
      <link href="/%E5%BC%80%E5%8F%91/LangChain/LLM%20%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%E7%BB%93%E6%9E%84%E5%8C%96%E8%BE%93%E5%87%BA.html"/>
      <url>/%E5%BC%80%E5%8F%91/LangChain/LLM%20%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%E7%BB%93%E6%9E%84%E5%8C%96%E8%BE%93%E5%87%BA.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>看了新一期的阮一峰周刊，引用了一篇博客 <em>Information Extraction with Large Language Models - Parsing Unstructured Data with GPT-3</em></p><p><a href="https://marcotm.com/articles/information-extraction-with-large-language-models-parsing-unstructured-data-with-gpt/">Information Extraction with Large Language Models - Parsing Unstructured Data with GPT-3 (marcotm.com)</a></p><blockquote><p>In the past months, ChatGPT has been dominating the news headlines, and people are both excited and scared by its quite sophisticated ability to generate texts. Besides short- and long-form text generation, there are quite a few other use cases which provide a lot of practical value. With the current generation of these large language models (LLMs), many of the classic tasks in Natural Language Processing (NLP) such as text classification, sentiment analysis, or named entity recognition, are almost trivial to solve.</p><p>在过去的几个月里，ChatGPT 一直占据着新闻头条，人们对它相当复杂的文本生成能力既兴奋又害怕，除了生成短格式和长格式文本外，还有许多其他用例提供了很大的实用价值</p><p>随着这些大型语言模型（LLM）的出现，自然语言处理（NLP）中的许多经典任务，如文本分类、情感分析或命名实体识别，几乎都很难解决</p><p>In this article, I have documented some experimentation with how to use GPT-3 (<em>update: and 3.5</em>) to extract structured information from unstructured texts and I hope the article can serve as a tutorial for how to approach such a task with an LLM.</p><p>在这篇文章中，我记录了一些关于如何使用 GPT-3（更新：和 3.5）从非结构化文本中提取结构化信息的实验，我希望这篇文章可以作为如何使用 LLM 处理此类任务的教程</p></blockquote><p>作者维护了一个招聘网站，但是招聘信息是以非结构化文本形式进行投递，作者希望将其重要信息提取出来，维护数据后用户可以通过相关性进行查询</p><blockquote><p>With about 500 job posts per month, some of them advertising multiple roles, we end up with over 1000 jobs per month. As you can see on the <a href="https://www.hacker-jobs.com/">site</a>, there are several filters such as “remote”, “part-time”, etc. which allow you to narrow down the choices based on some general characteristics.</p><p>每月约有 500 个招聘信息，其中一些信息包含多个职位的内容，即我们最终每月有 1000 多个职位</p><p>正如你在网站上看到的，有几个过滤器，如“远程”、“兼职”等，允许你根据一些一般特征缩小选择范围</p><p>However, a job board usually also offers to select a certain job category (e.g., “iOS developer”). Since the “Who is hiring” threads are not limited to certain types of jobs and often there are interesting roles that might not fit into the usual categories, I tried a different approach for how to sort the jobs according to one’s interests: For each job, a text embedding for the job description (including the company description) is created, which then can be used to sort by similarity to a selected job.</p><p>然而，招聘委员会通常也会提供选择特定的工作类别（例如，“iOS开发者”）</p><p>由于“谁在招聘”主题并不局限于某些类型的工作，而且通常有一些有趣的角色可能不属于通常的类别，我尝试了一种不同的方法来根据个人的兴趣对工作进行排序：对于每个工作，都会创建一个 embedding  工作描述（包括公司描述）的文本，其然后可以用于根据与所选作业的相似性进行排序</p></blockquote><p>这里就来体验下作者对于 LLM（GPT-3.5）解析文本输出结构化信息的 prompt，以及尝试使用 LangChain 进行实现</p><h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>以下是作者制作出这一 Prompt 的主要想法和观察结果：</p><ul><li>提示首先描述基本任务 <code>turn unstructured job posting [..] into a JSON</code></li><li>提醒一则招聘信息可以包括多个角色或职位</li><li>详细描述了所需的输出格式；对于每个字段，指定字段名称和字段类型</li><li>对于某些字段给出了额外的提示，这些提示大多来自观察到的错误案例或不良行为；例如，角色有时以单数形式书写，有时以复数形式书写，原始提示逐字复制，但希望 LLM 可以将其标准化</li><li>让 LLM 清楚如果没有明确信息，可以将字段设置为 <code>null</code></li><li>在以前的版本中，在某些情况下职位会被列出两次，没有任何差异；原因是该招聘信息内容为该公司正在寻找两名开发，因此添加了指令，只包含了一次完全解决问题的需求</li><li>在说明之后，添加原始的招聘信息</li><li>然后声明输出使用 JSON 格式</li><li>在看到的一个技巧是用 &#96;&#96;&#96;&#96;json&#96;，这是一些标记语言在文档中包含代码和类似文本的典型方式</li><li>最后还编写了应该完成的实际 JSON 的第一部分</li></ul><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>作者认为对于这种任务，不希望模型变得有创造性</p><p>因此使用了以下参数：</p><ul><li>Temperature：0</li><li>Maximum：4000 - <length_of_the_prompt></li><li>Stop sequences：&#96;&#96;&#96;</li><li>Top P：0.1</li><li>Frequency penalty：0</li><li>Presence penalty：0</li></ul><h1 id="Prompt"><a href="#Prompt" class="headerlink" title="Prompt"></a>Prompt</h1><p>文章中作者说明了 GPT-3.5 是基于聊天的模型，所以对 Prompt 进行了一些微调</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Your task is to parse an unstructured job posting and turn it into a JSON containing the most important information. The job posting can describe one or more jobs at the same company. The JSON should consist of the following information:</span><br><span class="line"> - The company name (field name: &quot;companyName&quot;, field type: string)</span><br><span class="line"> - the location of the company (field name: &quot;companyLocation&quot;, field type: string); if not explictily stated, you can try to infer the company&#x27;s actual location from other clues, e.g., something like &quot;Remote (US)&quot; usually means that the company is located in the US; if the location cannot be inferred, set it to null</span><br><span class="line"> - a short description of what the company is doing or building (field name: &quot;companyDescription&quot;, field type: string); try to keep it short (max length: ca. 300 characters)</span><br><span class="line"> - a list of advertised jobs (field name: &quot;jobs&quot;, field type: array).</span><br><span class="line">Each element of the &quot;jobs&quot; array should contain the following fields:</span><br><span class="line"> - The job title (field name: &quot;jobTitle&quot;, field type: string); the job title should be given in the singular form (i.e., Frontend Developer instead of Frontend Developers)</span><br><span class="line"> - the salary range (field name: &quot;salary&quot;, field type: string); only include explictly stated salary amounts, otherwise set to null</span><br><span class="line"> - whether equity is part of the compensation (field name: &quot;equity&quot;, field type: boolean)</span><br><span class="line"> - the benefits (field name: &quot;benefits&quot;, field type: string); include things like 401k, insurance, equipment, child care, etc. if stated, otherwise set to null</span><br><span class="line"> - the location of the job (field name: &quot;location&quot;, field type: string)</span><br><span class="line"> - whether this is a job for senior/experienced candidates (field name: &quot;senior&quot;, field type: boolean); typically senior, staff, lead, principal, vp, cto, etc. positions are all regarded as senior level</span><br><span class="line"> - whether it is a remote opportunity (field name: &quot;remote&quot;, field type: boolean)</span><br><span class="line"> - whether it can be done onsite from an office (field name: &quot;onsite&quot;, field type: boolean)</span><br><span class="line"> - whether it can be done part-time (field name: &quot;partTime&quot;, field type: boolean)</span><br><span class="line"> - whether it can be done full-time (field name: &quot;fullTime&quot;, field type: boolean)</span><br><span class="line"> - the URL to the specific job description (field name: &quot;jobUrl&quot;, field type: string)</span><br><span class="line"> - and any specific requirements/skills that might be stated (field name: &quot;requirements&quot;, field type: string).</span><br><span class="line">In general, if certain information is not stated, set the respective field to null. If the company seeks more than one person for the same role, include the role only once. Please output only the pure JSON representation. Do not include any explanations, comments, thoughts, etc. The output has to be a valid JSON object which can be parsed as is.</span><br><span class="line"></span><br><span class="line">This is the job posting:</span><br><span class="line"></span><br><span class="line">%s</span><br></pre></td></tr></table></figure><p>因为感觉 Azure 对于中文的支持比较好，这里我调整成了中文，并且使用 LangChain 工具进行 Prompt 的组装</p><p><strong>Prompt 组装</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">template = <span class="string">&quot;&quot;&quot;您的任务是解析一个非结构化的招聘信息，并将其转换为包含最重要信息的 JSON</span></span><br><span class="line"><span class="string">职位发布可以描述同一公司的一个或多个职位；JSON 应包含以下信息</span></span><br><span class="line"><span class="string">- 公司名称（字段名称：companyName，字段类型：字符串）</span></span><br><span class="line"><span class="string">- 公司的位置（字段名称：companyLocation，字段类型：字符串）；如果没有明确说明，你可以尝试从其他线索推断公司的实际位置，例如，像“远程（美国）”这样的词通常意味着公司位于美国；如果无法推断位置，请将其设置为 null</span></span><br><span class="line"><span class="string">- 公司正在做什么或正在建设什么的简短描述（字段名：companyDescription，字段类型：字符串）；尽量保持短（最大长度：约 300 个字符）</span></span><br><span class="line"><span class="string">- 招聘广告的职位清单（字段名：jobs，字段类型：数组）</span></span><br><span class="line"><span class="string">jobs 数组的每个元素都应包含以下字段：</span></span><br><span class="line"><span class="string">- 职务（字段名称：jobTitle，字段类型：字符串）；职位名称应以单数形式给出（即，前端开发人员而非前端开发人员）</span></span><br><span class="line"><span class="string">- 薪资范围（字段名称：salary，字段类型：字符串）；仅包括明确说明的工资金额，否则设置为 null</span></span><br><span class="line"><span class="string">- 股权是否是补偿的一部分（字段名称：equity，字段类型：布尔值）</span></span><br><span class="line"><span class="string">- 公司福利（字段名称：benefits，字段类型：字符串）；包括养老金、保险、设备、儿童保育、年假等，如果没有说明则设置为 null</span></span><br><span class="line"><span class="string">- 工作地点（字段名：location，字段类型：字符串）</span></span><br><span class="line"><span class="string">- 这是否是一份适合资深/有经验的候选人的工作（字段名称：senior，字段类型：布尔值）；通常，高级、职员、领导、校长、副总裁、首席技术官等职位都被视为高级职位</span></span><br><span class="line"><span class="string">- 是否为远程办公（字段名称：remote，字段类型：布尔值）</span></span><br><span class="line"><span class="string">- 是否可以兼职（字段名：partTime，字段类型：布尔值）</span></span><br><span class="line"><span class="string">- 特定作业描述的URL（字段名：jobUrl，字段类型：字符串）</span></span><br><span class="line"><span class="string">- 以及可能说明的任何特定要求/技能（字段名称：requirements，字段类型：字符串）</span></span><br><span class="line"><span class="string">通常，如果没有说明某些信息，请将相应的字段设置为 null</span></span><br><span class="line"><span class="string">如果公司为同一职位寻找多个人，则只包括该职位一次</span></span><br><span class="line"><span class="string">请仅输出纯 JSON 表示</span></span><br><span class="line"><span class="string">不包括任何解释、评论、想法等</span></span><br><span class="line"><span class="string">输出必须是一个有效的 JSON 对象，可以按原样解析</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">system_message_prompt = SystemMessagePromptTemplate.from_template(template)</span><br><span class="line">human_template = <span class="string">&quot;这是招聘信息：\n&#123;text&#125;&quot;</span></span><br><span class="line">human_message_prompt = HumanMessagePromptTemplate.from_template(human_template)</span><br></pre></td></tr></table></figure><p><strong>招聘信息存储在 txt 文件</strong></p><p>这里直接使用了阮一峰博客“谁在招人”广告中的招聘信息；具体内容可以查看</p><p><a href="https://github.com/ruanyf/weekly/issues/3684">谁在招人？（2023年12月） · Issue #3684 · ruanyf&#x2F;weekly (github.com)</a></p><p>这里随便选取一个</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【杭州】网易云音乐</span><br><span class="line">有意向的同学可联系 semanwmj@gmail.com</span><br><span class="line"></span><br><span class="line">资深前端开发工程师</span><br><span class="line">职位描述</span><br><span class="line">负责云音乐社交直播的前端开发工作。</span><br><span class="line">参与各类型项目（Web&amp;Webview、中后台系统、混合应用、小程序、创意活动及游戏）的前端开发工作，完成系统设计、技术选型、模块开发工作。</span><br><span class="line">以不断提升质量、效率、体验为目的，封装组件、沉淀文档、生产工具、搭建系统, 享受工程师的日常。</span><br><span class="line">分享自己日常的所见所想，引导同事共同成长，营造积极健康的技术氛围。</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 组装 chain</span></span><br><span class="line">chain = LLMChain(</span><br><span class="line">    llm=chat_model,</span><br><span class="line">    prompt=chat_prompt</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文件</span></span><br><span class="line">file_path = <span class="string">&quot;../content.txt&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    content = file.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">result = chain.run(content)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><p>LLM 输出的 JSON 格式的结果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;companyName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;网易云音乐&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;companyLocation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;杭州&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;companyDescription&quot;</span><span class="punctuation">:</span> <span class="string">&quot;网易云音乐是一家位于杭州的音乐公司，专注于社交直播和音乐领域的前端开发工作。&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;jobs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;jobTitle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;资深前端开发工程师&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;salary&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;equity&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;benefits&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="string">&quot;杭州&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;senior&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;remote&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;partTime&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;jobUrl&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;requirements&quot;</span><span class="punctuation">:</span> <span class="string">&quot;精通各种 Web 前端技术和标准(Javascript、HTML、CSS)，熟悉页面布局常用解决方案，对表现与数据分离、Web语义化等有深刻理解。熟练掌握一个数据驱动视图的框架（ React、Sevlte、Solid、Vue）。熟练掌握常用的前端构建工具（Webpack、Vite 等），并具有成熟的模块化开发思维。熟悉常用前端数据管理的解决方案（如 Redux、Zustand、Jotai 等），并清楚它们的优劣和应用场景。熟悉 HTTP 协议，并掌握相关网络调试工具，有服务端开发的背景常识。对重复性或不规范的工作容忍度低，能自发通 过沟通或技术手段解决。&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="LangChain-Pydantic-解析器"><a href="#LangChain-Pydantic-解析器" class="headerlink" title="LangChain Pydantic 解析器"></a>LangChain Pydantic 解析器</h1><p>上面已经使用 LangChain 管理了 LLM、Prompt，不如直接应用 Pydantic 解析器来直接解析成结构化的数据</p><p>好处是定义好结构后，LangChain 默认可以生成一套对于结构化输出的提示，即 <code>get_format_instructions</code> 方法</p><p><strong>结构定义</strong></p><p>这里使用 Pydantic 定义结构，对应上面的 Prompt</p><ul><li>字段名、数据类型进行对应，其中 <code>jobs</code> 的类型为新定义的 <code>Job</code> 结构</li><li>描述中拆分出 title 和 description；对于无法定义出区别的字段，就使用同样的值（例如 <code>股权是否是补偿的一部分</code>）</li><li>为了省事，所有的字段都声明了允许为 None；其实这个可以结合实际需求进行强校验，不通过往往说明招聘信息内容确实（例如换公司名称、公司位置等应该是必填项）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Job</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    jobTitle: <span class="built_in">str</span> = Field(<span class="literal">None</span>, title=<span class="string">&quot;职务&quot;</span>, description=<span class="string">&quot;职位名称应以单数形式给出（即，前端开发人员而非前端开发人员）&quot;</span>)</span><br><span class="line">    salary: <span class="built_in">str</span> = Field(<span class="literal">None</span>, title=<span class="string">&quot;薪资范围&quot;</span>, description=<span class="string">&quot;仅包括明确说明的工资金额，否则设置为 null&quot;</span>)</span><br><span class="line">    equity: <span class="built_in">bool</span> = Field(<span class="literal">None</span>, title=<span class="string">&quot;股权是否是补偿的一部分&quot;</span>, description=<span class="string">&quot;股权是否是补偿的一部分&quot;</span>)</span><br><span class="line">    benefits: <span class="built_in">str</span> = Field(<span class="literal">None</span>, title=<span class="string">&quot;公司福利&quot;</span>, description=<span class="string">&quot;包括养老金、保险、设备、儿童保育、年假等，如果没有说明则设置为 null&quot;</span>)</span><br><span class="line">    location: <span class="built_in">str</span> = Field(<span class="literal">None</span>, title=<span class="string">&quot;工作地点&quot;</span>, description=<span class="string">&quot;工作地点&quot;</span>, )</span><br><span class="line">    senior: <span class="built_in">bool</span> = Field(<span class="literal">None</span>, title=<span class="string">&quot;这是否是一份适合资深/有经验的候选人的工作&quot;</span>, description=<span class="string">&quot;这是否是一份适合资深/有经验的候选人的工作&quot;</span>)</span><br><span class="line">    remote: <span class="built_in">bool</span> = Field(<span class="literal">None</span>, title=<span class="string">&quot;是否为远程办公&quot;</span>, description=<span class="string">&quot;是否为远程办公&quot;</span>)</span><br><span class="line">    partTime: <span class="built_in">bool</span> = Field(<span class="literal">None</span>, title=<span class="string">&quot;是否可以兼职&quot;</span>, description=<span class="string">&quot;是否可以兼职&quot;</span>)</span><br><span class="line">    jobUrl: <span class="built_in">str</span> = Field(<span class="literal">None</span>, title=<span class="string">&quot;特定作业描述的URL&quot;</span>, description=<span class="string">&quot;特定作业描述的URL&quot;</span>, )</span><br><span class="line">    requirements: <span class="built_in">str</span> = Field(<span class="literal">None</span>, title=<span class="string">&quot;特定要求&quot;</span>, description=<span class="string">&quot;特定要求&quot;</span>, )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    companyName: <span class="built_in">str</span> = Field(<span class="literal">None</span>, title=<span class="string">&quot;公司名称&quot;</span>, description=<span class="string">&quot;公司名称&quot;</span>)</span><br><span class="line">    companyLocation: <span class="built_in">str</span> = Field(<span class="literal">None</span>, title=<span class="string">&quot;公司位置&quot;</span>, description=<span class="string">&quot;如果没有明确说明，你可以尝试从其他线索推断公司的实际位置，例如，像“远程（美国）”这样的词通常意味着公司位于美国；如果无法推断位置，请将其设置为 null&quot;</span>)</span><br><span class="line">    companyDescription: <span class="built_in">str</span> = Field(<span class="literal">None</span>, title=<span class="string">&quot;公司描述&quot;</span>, description=<span class="string">&quot;公司正在做什么或正在建设什么的简短描述，尽量保持短&quot;</span>)</span><br><span class="line">    jobs: <span class="type">List</span>[Job] = Field(<span class="literal">None</span>, title=<span class="string">&quot;职位清单&quot;</span>, description=<span class="string">&quot;招聘广告的职位清单&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>创建解析器和 Prompt</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pydantic 解析器</span></span><br><span class="line">pydantic_parser = PydanticOutputParser(pydantic_object=Info)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get_format_instructions 用于获取生成的提示</span></span><br><span class="line">format_instructions = pydantic_parser.get_format_instructions()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将额外说明放在 Prompt 中</span></span><br><span class="line">prompt = PromptTemplate(</span><br><span class="line">    template=<span class="string">&quot;尽可能的将招聘信息解析为 JSON 格式\n通常，如果没有说明某些信息，请将相应的字段设置为 null；如果公司为同一职位寻找多个人，则只包括该职位一次\n请仅输出纯 JSON 表示。不包括任何解释、评论、想法等。输出必须是一个有效的 JSON 对象，可以按原样解析\n&#123;format_instructions&#125;\n&#123;text&#125;&quot;</span>,</span><br><span class="line">    input_variables=[<span class="string">&quot;text&quot;</span>],</span><br><span class="line">    partial_variables=&#123;<span class="string">&quot;format_instructions&quot;</span>: format_instructions&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>执行</strong></p><p>执行同上，但是在 chain 中入参结果解析器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># output_parser 参数指定结果解析器</span></span><br><span class="line">chain = LLMChain(</span><br><span class="line">    llm=chat_model,</span><br><span class="line">    prompt=prompt,</span><br><span class="line">    output_parser=pydantic_parser</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;D:/WorkSpace_learn/langchain-test/text.txt&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    content = file.read()</span><br><span class="line"></span><br><span class="line">result = chain.run(content)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">companyName=<span class="string">&#x27;Apifox&#x27;</span> companyLocation=<span class="string">&#x27;天河 CBD&#x27;</span> companyDescription=<span class="string">&#x27;Apifox 是 API 文档、API 调试、API Mock、API 自动化测试一体化协作平台&#x27;</span> jobs=[Job(jobTitle=<span class="string">&#x27;初中级前端开发工程师&#x27;</span>, salary=<span class="string">&#x27;12~25K&#x27;</span>, equity=<span class="literal">None</span>, benefits=<span class="literal">None</span>, location=<span class="literal">None</span>, senior=<span class="literal">False</span>, remote=<span class="literal">False</span>, partTime=<span class="literal">False</span>, jobUrl=<span class="literal">None</span>, requirements=<span class="string">&#x27;本科及以上学历，至少 1 年以上 web 前端开发工作经验； 精通使用各种 web 前端技术，包括 HTML5/CSS/Javascript/TypeScript 等 ； 熟悉一种或多种常用前端框架，如（ React 、Vue 、Angular 等）； 熟悉使用 webpack 等模块化、工程化工具； 拥 有开发流程中的代码规范意识、配置管理规范意识、文档撰写规范意识；&#x27;</span>), Job(jobTitle=<span class="string">&#x27;高级前端开发工程师&#x27;</span>, salary=<span class="string">&#x27;20~40K&#x27;</span>, equity=<span class="literal">None</span>, benefits=<span class="literal">None</span>, location=<span class="literal">None</span>, senior=<span class="literal">True</span>, remote=<span class="literal">False</span>, partTime=<span class="literal">False</span>, jobUrl=<span class="literal">None</span>, requirements=<span class="string">&#x27;本科及以上学历，至少 1 年以上 web 前端开发工作经验； 精通使用各种 web 前端技术，包括 HTML5/CSS/Javascript/TypeScript 等； 熟悉一种或多种常用前端框架，如（ React 、Vue 、Angular 等）； 熟悉使用 webpack 等模块化、工程化工具； 拥有开发流程中的代码规范意识、配置管理规范意识、文档撰写规范意识；&#x27;</span>), Job(jobTitle=<span class="string">&#x27;专家前端开发工程师&#x27;</span>, salary=<span class="string">&#x27;35~60K&#x27;</span>, equity=<span class="literal">None</span>, benefits=<span class="literal">None</span>, location=<span class="literal">None</span>, senior=<span class="literal">True</span>, remote=<span class="literal">False</span>, partTime=<span class="literal">False</span>, jobUrl=<span class="literal">None</span>, requirements=<span class="string">&#x27;本科及以上学历，至少 1 年以上 web 前端开发工作经验； 精通使用各 种 web 前端技术，包括 HTML5/CSS/Javascript/TypeScript 等； 熟悉一种或多种常用前端框架，如（ React 、Vue 、Angular 等）； 熟悉使用 webpack 等模块化、工程化工具； 拥有开发流程中的代码规范意识、配置管理规范意识、文档撰 写规范意识；&#x27;</span>)]</span><br></pre></td></tr></table></figure><img src="/%E5%BC%80%E5%8F%91/LangChain/LLM%20%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%E7%BB%93%E6%9E%84%E5%8C%96%E8%BE%93%E5%87%BA/%E7%BB%93%E6%9E%84%E5%8C%96%E8%BE%93%E5%87%BA.png" class="" title="结构化输出"><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>将文本解析为结构化数据带来的好处：</p><ul><li><strong>效率和成本</strong>：减少人工处理的工作量，提高数据处理的效率，降低数据处理的成本</li><li><strong>正确性</strong>：（也许？）避免了人为错误的可能性</li><li><strong>增强数据可用性</strong>：将文本转化为结构化数据后，数据变得更易于管理和分析</li><li><strong>支持决策制定：</strong> 结构化数据使得信息更容易理解和比较，为决策制定提供更多支持</li></ul><p>文中的需求一大特点就是用于增强数据的可用性</p><p>其次我认为是不是可以用来作为自然语言和 AI 沟通的桥梁；比如一个 SQL 需求， “查询学生姓名和年龄，按照成绩排序”</p><p>第一步先使用结构引导 LLM 对需求进行拆解，假设使用 JSON 结构</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;学生&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;filed&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;姓名&quot;</span><span class="punctuation">,</span><span class="string">&quot;年龄&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;成绩&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>第二步再以结构化数据驱动 LLM 转换为 SQL 结构，是不是可以更好地引导 LLM 对需求进行理解（我胡乱想的）</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> LangChain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Prompt </tag>
            
            <tag> AI </tag>
            
            <tag> LangChain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>升级 MacOS 14 导致 embedded-redis 不兼容</title>
      <link href="/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/%E5%8D%87%E7%BA%A7%20MacOS%2014%20%E5%AF%BC%E8%87%B4%20embedded-redis%20%E4%B8%8D%E5%85%BC%E5%AE%B9.html"/>
      <url>/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/%E5%8D%87%E7%BA%A7%20MacOS%2014%20%E5%AF%BC%E8%87%B4%20embedded-redis%20%E4%B8%8D%E5%85%BC%E5%AE%B9.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>一直都没更新操作系统的版本，心血来潮更新了 MacOS 的 14（Sonoma）</p><p><a href="https://www.apple.com.cn/macos/sonoma/?ivk_sa=1024320u">macOS Sonoma - Apple (中国大陆)</a></p><p>然后发现单测竟然跑不通了，但是 push 上去的代码 CI 依然可以通过，所以当时基本就确定是版本升级带来的兼容性问题了</p><p>看了下日志，是嵌入的 Redis 运行不起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: Can<span class="string">&#x27;t start redis server. Check logs for details. Redis process log: </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">at redis.embedded.AbstractRedisInstance.awaitRedisServerReady(AbstractRedisInstance.java:70)</span></span><br><span class="line"><span class="string">at redis.embedded.AbstractRedisInstance.start(AbstractRedisInstance.java:42)</span></span><br><span class="line"><span class="string">at redis.embedded.RedisServer.start(RedisServer.java:9)</span></span><br></pre></td></tr></table></figure><p>这里嵌入的 Redis 是用来 mock 单测内的 Redis 服务端的</p><p>使用的开源 <a href="https://github.com/kstyrc/embedded-redis">kstyrc&#x2F;embedded-redis: Redis embedded server for Java integration testing (github.com)</a></p><h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><h2 id="检查端口占用"><a href="#检查端口占用" class="headerlink" title="检查端口占用"></a>检查端口占用</h2><p>当然第一时间检查端口占用，这种代码内嵌的服务经常会出现关闭失败的情况，导致主线程已经结束了实际服务还在运行，导致端口占用；当然从异常栈信息来看并不是端口占用导致的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :&lt;端口号&gt;</span><br></pre></td></tr></table></figure><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>异常信息上表示 <code>Check logs for details</code></p><p>事实上也没有日志可以查看，只能 debug 进行查看了</p><p>具体位置在 <code>org.apache.commons.io.IOUtils.AbstractRedisInstance.start()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> EmbeddedRedisException &#123;</span><br><span class="line">    <span class="keyword">if</span> (active) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmbeddedRedisException</span>(<span class="string">&quot;This redis server instance is already running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redisProcess = createRedisProcessBuilder().start();</span><br><span class="line">        logErrors();</span><br><span class="line">      <span class="comment">// 这里在等待服务端返回的数据</span></span><br><span class="line">        awaitRedisServerReady();</span><br><span class="line">        active = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmbeddedRedisException</span>(<span class="string">&quot;Failed to start Redis instance&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">awaitRedisServerReady</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(redisProcess.getInputStream()));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String outputLine;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            outputLine = reader.readLine();</span><br><span class="line">          <span class="comment">// 这里为 null 所以抛出了异常</span></span><br><span class="line">            <span class="keyword">if</span> (outputLine == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//Something goes wrong. Stream is ended before server was activated.</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t start redis server. Check logs for details.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!outputLine.matches(redisReadyPattern()));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IOUtils.closeQuietly(reader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是 debug 也没发现哪里有日志</p><p>事实上还找到了一个 issue 来询问这个问题</p><p><a href="https://github.com/kstyrc/embedded-redis/issues/51">“Can’t start redis server. Check logs for details” - which logs???? · Issue #51 · kstyrc&#x2F;embedded-redis (github.com)</a></p><p>看下方的评论很多人都是因为 Windows 的不兼容导致</p><h2 id="对应的-issue"><a href="#对应的-issue" class="headerlink" title="对应的 issue"></a>对应的 issue</h2><p>只能继续找 issue，看看有没有解决方案，还真找到了一样的问题</p><p><a href="https://github.com/kstyrc/embedded-redis/issues/135">Unable to run on macOS Sonoma · Issue #135 · kstyrc&#x2F;embedded-redis (github.com)</a></p><p>有老哥 fork 后解决了不兼容问题</p><p><a href="https://github.com/codemonstur/embedded-redis">codemonstur&#x2F;embedded-redis: Redis embedded server (github.com)</a></p><img src="/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/%E5%8D%87%E7%BA%A7%20MacOS%2014%20%E5%AF%BC%E8%87%B4%20embedded-redis%20%E4%B8%8D%E5%85%BC%E5%AE%B9/%E6%88%AA%E5%9B%BE.png" class="" title="issue 截图"><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>因为是本地单测环境问题，所以引用开源的风险也不大</p><p>其次因为之前的这个依赖在 parent 包内管理，很难快速进行版本升级</p><p>所以决定 fork 代码后修改坐标，在本地打一个相同坐标的包进行覆盖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.kstyrc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>embedded-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>真 · 跑起来就不要再动了</p><p>不要轻易更新版本 : (</p><img src="/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/%E5%8D%87%E7%BA%A7%20MacOS%2014%20%E5%AF%BC%E8%87%B4%20embedded-redis%20%E4%B8%8D%E5%85%BC%E5%AE%B9/%E5%8F%88%E4%B8%8D%E6%98%AF%E4%B8%8D%E8%83%BD%E7%94%A8.jpg" class="" title="又不是不能用">]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 疑难杂症 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 从弱引用看常量池</title>
      <link href="/%E5%BC%80%E5%8F%91/Java/Java%20%E4%BB%8E%E5%BC%B1%E5%BC%95%E7%94%A8%E7%9C%8B%E5%B8%B8%E9%87%8F%E6%B1%A0.html"/>
      <url>/%E5%BC%80%E5%8F%91/Java/Java%20%E4%BB%8E%E5%BC%B1%E5%BC%95%E7%94%A8%E7%9C%8B%E5%B8%B8%E9%87%8F%E6%B1%A0.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在看阿里开源的 TransmittableThreadLocal Agent 时发现了在对类进行增强的流程中使用了 <code>WeakHashMap</code></p><p>com.alibaba.ttl3.agent.TtlExtensionTransformletManager</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> use WeakHashMap as a Set collection, value is always null.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> WeakHashMap&lt;ClassLoader, ?&gt; collectedClassLoaderHistory = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;(<span class="number">512</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map: ExtensionTransformlet ClassLoader -&gt; ExtensionTransformlet ClassName -&gt; ExtensionTransformlet instance(not include from parent classloader)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> WeakHashMap&lt;ClassLoader, Map&lt;String, TtlTransformlet&gt;&gt; classLoader2ExtensionTransformlets =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;(<span class="number">512</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map: ExtensionTransformlet ClassLoader -&gt; ExtensionTransformlet ClassName -&gt; ExtensionTransformlet instance(include from parent classloader)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> WeakHashMap&lt;ClassLoader, Map&lt;String, TtlTransformlet&gt;&gt; classLoader2ExtensionTransformletsIncludeParentCL =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;(<span class="number">512</span>);</span><br></pre></td></tr></table></figure><p>这里使用了弱引用元素的 HashMap，应该是只用于 JVM 启动的类加载阶段，所以使用了特殊的引用类型</p><p>之前没怎么关注过引用类型，所以看了一下 API 使用了一下，感觉引用类型可以用来验证常量池等现象，加深对引用的理解</p><p>虽然更像是八股文的内容，不过还是想记录下来</p><h1 id="强软弱虚"><a href="#强软弱虚" class="headerlink" title="强软弱虚"></a>强软弱虚</h1><p><strong>在这里重复一下 Java 中四种引用类型的概念</strong></p><p>在 Java 中，有四种类型的引用：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）；它们在垃圾回收方面具有不同的特性，适用于不同的场景</p><ul><li>强引用（Strong Reference）<ul><li>强引用是最常见的引用类型，它会阻止被引用对象被垃圾回收</li><li>当一个对象有强引用与之关联时，垃圾回收器不会回收该对象，即使内存空间不足</li></ul></li><li>软引用（Soft Reference）<ul><li>软引用是一种相对强引用较弱的引用类型</li><li>当内存空间足够时，软引用不会被垃圾回收，但当内存空间不足时，垃圾回收器会尝试回收软引用对象</li></ul></li><li>弱引用（Weak Reference）<ul><li>弱引用比软引用更弱，它的生命周期更短</li><li>当垃圾回收器执行垃圾回收时，无论内存是否足够，弱引用都会被回收</li></ul></li><li>虚引用（Phantom Reference）<ul><li>虚引用是最弱的引用类型，几乎没有实际的引用作用</li><li>虚引用的主要作用是跟踪垃圾回收器的回收过程，通过与引用队列（Reference Queue）联合使用</li></ul></li></ul><br><p><strong>常见的应用场景</strong></p><table><thead><tr><th align="center">类型</th><th align="center">场景</th></tr></thead><tbody><tr><td align="center">强引用</td><td align="center">适用于需要确保对象一直存在的场景，例如全局变量、静态变量等</td></tr><tr><td align="center">软引用</td><td align="center">适用于对内存敏感的缓存场景，可以在内存不足时释放一些缓存对象</td></tr><tr><td align="center">弱引用</td><td align="center">适用于临时对象的缓存、对象关联性的辅助引用等场景，可以快速释放不再被引用的对象</td></tr><tr><td align="center">虚引用</td><td align="center">适用于需要在对象被回收时执行特定操作的场景，例如对象销毁的清理操作</td></tr></tbody></table><h1 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h1><blockquote><p>当 WeakHashMap 中的某个 entry 的 key 不再被日常使用时，该 entry 将自动被删除</p><p>更准确地说，给定 key 的映射的存在不会阻止该键被垃圾收集器丢弃，即使其可最终化、最终确定，然后回收</p><p>当一个 key 被丢弃时，它的 entry 实际上会从映射中删除，因此此类的行为与其他 Map 实现有些不同</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待 GC</span></span><br><span class="line">    System.gc();</span><br><span class="line">  TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(map.size()); <span class="comment">// 0</span></span><br><span class="line">    System.out.println(map.keySet()); <span class="comment">// []</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意 <code>System.gc()</code> 不一定会确保执行了 GC 操作，并且 GC 是异步的，所以后续又进行了 1s 的 sleep，不过从结果上来看是进行了 GC 操作</p><h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><p><code>WeakHashMap</code> 实现弱引用元素的关键在于内部类 <code>Entry</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The entries in this hash table extend WeakReference, using its main ref</span></span><br><span class="line"><span class="comment"> * field as the key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;Object&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates new entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(Object key, V value,</span><br><span class="line">          ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">          <span class="type">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">      <span class="comment">// key 和 queue</span></span><br><span class="line">        <span class="built_in">super</span>(key, queue);</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.hash  = hash;</span><br><span class="line">        <span class="built_in">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>Entry</code> 继承了 <code>WeakReference</code>，并且在构造器中调用了父类构造器，将 key 包装为了弱引用，并且提供了一个队列用于存放被驱逐的 <code>Entry</code> 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reference queue for cleared WeakEntries</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="驱逐元素"><a href="#驱逐元素" class="headerlink" title="驱逐元素"></a>驱逐元素</h2><p>在调用 <code>size</code>、<code>get</code> 等方法时，<code>WeakHashMap</code> 通过 <code>expungeStaleEntries</code> 方法来驱逐元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清理表中的过期（无用）条目。</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expungeStaleEntries</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历队列中的每个对象，直到队列为空</span></span><br><span class="line">    <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="literal">null</span>; ) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;  <span class="comment">// 使用 synchronized 来确保线程安全</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将从队列中获取的对象强转为 Entry&lt;K,V&gt; 类型</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取该条目在表数组中的索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, table.length);</span><br><span class="line"></span><br><span class="line">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">            Entry&lt;K,V&gt; p = prev;</span><br><span class="line">            <span class="comment">// 遍历在 table[i] 中的链表节点</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                <span class="comment">// 判断当前节点是否等于过期（被回收）的节点</span></span><br><span class="line">                <span class="keyword">if</span> (p == e) &#123;</span><br><span class="line">                    <span class="comment">// 从链表中移除过期（被回收）节点</span></span><br><span class="line">                    <span class="keyword">if</span> (prev == e)</span><br><span class="line">                        table[i] = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        prev.next = next;</span><br><span class="line">                    <span class="comment">// 将 value 设置为 null，使该条目能被垃圾回收器回收</span></span><br><span class="line">                    e.value = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// 减少哈希表的大小</span></span><br><span class="line">                    size--;  </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>概括流程如下：</p><ol><li>遍历 <code>ReferenceQueue</code> 内的对象</li><li>找到哈希表中的位置遍历链表上的元素</li><li>从链表中移除过期（被回收）节点</li><li>将 value 设置为 null，使该条目能被垃圾回收器回收</li><li>减少哈希表 size</li></ol><p>有两点需要注意</p><ul><li>清理逻辑中不能清空 <code>e.next</code>，因为过时的 entry 可能正在被 <code>HashIterator</code> 迭代器使用</li><li>在清理对象时使用 synchronized 上锁，lock 对象为 <code>ReferenceQueue</code> 实例</li></ul><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>上面在注意中提到，迭代器可能使用过时的 entry</p><p>那说明迭代器逻辑中并没有使用 <code>expungeStaleEntries</code> 相关逻辑，那么迭代器是如何驱逐过期对象呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HashIterator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;                   <span class="comment">// 当前遍历的索引位置</span></span><br><span class="line">    <span class="keyword">private</span> Entry&lt;K,V&gt; entry;            <span class="comment">// 当前遍历到的 Entry</span></span><br><span class="line">    <span class="keyword">private</span> Entry&lt;K,V&gt; lastReturned;     <span class="comment">// 最后返回的 Entry</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;  <span class="comment">// 预期修改计数，用于检查并发修改</span></span><br><span class="line">    <span class="keyword">private</span> Object nextKey;              <span class="comment">// 下一个键，需要强引用以防止在 hasNext 和 next 之间的键消失</span></span><br><span class="line">    <span class="keyword">private</span> Object currentKey;           <span class="comment">// 当前键，需要强引用以防止在 nextEntry 和任何使用 entry 之间的键消失</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        index = isEmpty() ? <span class="number">0</span> : table.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否存在下一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        Entry&lt;K,V&gt;[] t = table;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当下一个键为空时进行循环</span></span><br><span class="line">        <span class="keyword">while</span> (nextKey == <span class="literal">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = entry;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;</span><br><span class="line">            <span class="comment">// 当entry为null并且index大于0时，从table的index-1位置开始依次向前查找，直到找到非null的entry</span></span><br><span class="line">            <span class="keyword">while</span> (e == <span class="literal">null</span> &amp;&amp; i &gt; <span class="number">0</span>)</span><br><span class="line">                e = t[--i];</span><br><span class="line">            entry = e;</span><br><span class="line">            index = i;</span><br><span class="line">            <span class="comment">// 如果entry为null，说明没有找到下一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                currentKey = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 采用强引用保持键，防止键在此期间被回收</span></span><br><span class="line">            nextKey = e.get(); </span><br><span class="line">            <span class="comment">// 如果键为null，说明该Entry已经被回收，此时跳到下一个Entry</span></span><br><span class="line">            <span class="keyword">if</span> (nextKey == <span class="literal">null</span>)</span><br><span class="line">                entry = entry.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>字符串常量池是 Java 中的一个特殊区域，用于存储字符串常量的唯一实例；它是在堆内存中的一部分，与堆中的其他对象分开存储</p><p><strong>特点与使用：</strong></p><ul><li>字符串不可变</li><li>常量池中相同字面量字符串唯一，编译器会自动优化</li><li>使用双引号括起来的字符串字面量（如  <code>String s = &quot;Hello World&quot;</code>）在编译时会自动放入字符串常量池</li><li><code>String</code> 类的 <code>intern()</code> 方法手动将字符串添加到常量池中</li><li>如果使用 <code>String</code> 构造器则会创建一个新对象，该对象和字符串常量池中是不同对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line">System.out.println(s2 == s3); <span class="comment">// true</span></span><br><span class="line">System.out.println(s2 == s4); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p><code>WeakHashMap</code> 的弱引用是指 key，将 key 分别设置为上述 String 的三种创建方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Object, Object&gt; map1 = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;();</span><br><span class="line">map1.put(<span class="string">&quot;Hello World&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map1.put(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World&quot;</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Map&lt;Object, Object&gt; map2 = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;();</span><br><span class="line">map2.put(<span class="string">&quot;Hello World&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map2.put(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World&quot;</span>).intern(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line">System.out.println(map1.entrySet()); <span class="comment">// [Hello World=2]</span></span><br><span class="line">System.out.println(map2.entrySet()); <span class="comment">// [Hello World=3]</span></span><br></pre></td></tr></table></figure><p>结果可以看出 <code>new String(&quot;&quot;)</code> 创建出的对象已经被移除了</p><h1 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h1><h2 id="Integer-的-valueOf-和缓存"><a href="#Integer-的-valueOf-和缓存" class="headerlink" title="Integer 的 valueOf 和缓存"></a>Integer 的 valueOf 和缓存</h2><p>在我们声明一个 Integer 时，其实字节码调用的是其 <code>valueOf</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i5</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i6</span> <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>对应的字节码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> <span class="number">1</span> istore_1</span><br><span class="line"> <span class="number">2</span> iconst_2</span><br><span class="line"> <span class="number">3</span> istore_2</span><br><span class="line"> <span class="number">4</span> bipush <span class="number">6</span></span><br><span class="line"> <span class="number">6</span> istore_3</span><br><span class="line"> <span class="number">7</span> iconst_1</span><br><span class="line"> <span class="number">8</span> invokestatic #<span class="number">2</span> &lt;java/lang/Integer.valueOf&gt;</span><br><span class="line"><span class="number">11</span> astore <span class="number">4</span></span><br><span class="line"><span class="number">13</span> iconst_2</span><br><span class="line"><span class="number">14</span> invokestatic #<span class="number">2</span> &lt;java/lang/Integer.valueOf&gt;</span><br><span class="line"><span class="number">17</span> astore <span class="number">5</span></span><br><span class="line"><span class="number">19</span> bipush <span class="number">6</span></span><br><span class="line"><span class="number">21</span> invokestatic #<span class="number">2</span> &lt;java/lang/Integer.valueOf&gt;</span><br><span class="line"><span class="number">24</span> astore <span class="number">6</span></span><br><span class="line"><span class="number">26</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>可以分为两类来看：</p><ul><li>int 基础类型<ul><li>当字面量为 -1 ~ 5 时，使用的操作符为 <code>iconst_&lt;i&gt;</code>，其实等效于 <code>bipush &lt;i&gt;</code><br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.iconst_i">Chapter 6. The Java Virtual Machine Instruction Set (oracle.com)</a></li><li>其他字面量则使用 <code>bipush</code>，当然随着字面量扩大还会使用到 <code>sipush</code> 等</li></ul></li><li>Integer 包装类<ul><li>调用 <code>Integer.valueOf</code> 方法</li></ul></li></ul><p>所以对于 <code>Integer</code> 而言，实际上的直接赋值被字节码转换为了方法的调用</p><p>而 <code>valueOf</code> 就带有了为人熟知的缓存值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是八股文中常说的 -128 ~ 127</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line">System.out.println(i1 == i2); <span class="comment">// true</span></span><br><span class="line">System.out.println(i2 == i3); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i5</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">128</span>);</span><br><span class="line">System.out.println(i4 == i5); <span class="comment">// false</span></span><br><span class="line">System.out.println(i5 == i6); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="number">127</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="number">128</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line">System.out.println(map.entrySet()); <span class="comment">// [127=1]</span></span><br></pre></td></tr></table></figure><p>因为 128 在调用 <code>valueOf</code> 时并不在缓存中，最后返回 <code>new Integer(i)</code> 导致该对象没有强引用存在，被回收了</p><h1 id="Map-作为-Set-使用"><a href="#Map-作为-Set-使用" class="headerlink" title="Map 作为 Set 使用"></a>Map 作为 Set 使用</h1><p>在 TransmittableThreadLocal 中其实是将 <code>WeekHashMap</code> 当作 Set 来使用，value 恒为 null，在其注释也有说明</p><blockquote><p> NOTE: use WeakHashMap as a Set collection, value is always null.</p></blockquote><p>这种场景比较常见，Spring 中就有将 <code>ConcurrentHashMap</code> 作为 Set 使用的例子，这样就可以简单地实现一个具有和某个 Map 同样功能的 Set 了</p><p>此外从 Java 6 开始 <code>java.util.Collections</code> 类提供了一个 <code>newSetFromMap</code> 方法，该方法能够基于指定的 Map 对象创建一个新的 Set 对象 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; set = Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;());</span><br><span class="line">set.add(<span class="number">127</span>);</span><br><span class="line">set.add(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line">System.out.println(set); <span class="comment">// [127]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RECIPES - 序号5</title>
      <link href="/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/RECIPES%20-%20%E8%AD%A6%E5%8F%B75.html"/>
      <url>/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/RECIPES%20-%20%E8%AD%A6%E5%8F%B75.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://assets-prd.punchdrink.com/wp-content/uploads/2023/11/03143721/Vertical__5-500x688.jpg"></p><h1 id="5"><a href="#5" class="headerlink" title="#5"></a>#5</h1><p><a href="https://punchdrink.com/recipes/number-5/">#5 Bourbon Cocktail Recipe | PUNCH (punchdrink.com)</a></p><p>作为 2015 年 1 月发布 Trick Dog 的唐人街菜单的爆款，这款“辛辣波本柑橘香肠”（正如店主 Josh Harris 所描述的）正处于潮流之中，在菜单发布的 6 个月里，这家酒吧的销量超过了 11000 个 #5</p><p>这种饮料通常用一串添加了香菜风味的芒果块装饰，但也可以使用风干橙片和姜糖来获得类似的泥土味和酸味</p><h2 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h2><ul><li>波本（最好是 Old Grand-Dad Bonded） - 1.5 盎司（<a href="https://www.diffordsguide.com/beer-wine-spirits/7471/old-grand-dad-bonded-100-proof">Old Grand-Dad Bonded)</a>）</li><li>芒果糖浆（见注释） - 0.75 盎司</li><li>柠檬汁 - 0.75 盎司</li><li>Ancho Reyes chile 利口酒 - 0.5 盎司</li><li>安高天娜苦精 - 4 dashes（<a href="https://www.diffordsguide.com/beer-wine-spirits/3505/angostura-orange-bitters">Angostura Orange Bitters</a>）</li></ul><p><strong>装饰：</strong>串有香菜风味的芒果块或风干橙片和姜糖</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>将所有原料加入加有冰块的摇壶中，摇至冷却</li><li>滤入一个加冰的双层老式玻璃杯中</li><li>放上装饰</li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="芒果糖浆（Mango-Syrup）"><a href="#芒果糖浆（Mango-Syrup）" class="headerlink" title="芒果糖浆（Mango Syrup）"></a>芒果糖浆（Mango Syrup）</h3><ul><li>白砂糖 - 1.5 千克</li><li>纯净水 - 1 升</li><li>芒果泥 - 850 克</li><li>墨西哥可乐 - 2 瓶 355 毫升</li><li>姜片 - 100 克</li><li>犹太盐（kosher salt） - 1.5 勺</li></ul><p>将所有材料加入锅中，用小火慢煮加热</p><p>从火上取下，倒入保温桶静置 4 到 6 个小时，用滤网滤出冷藏</p><h3 id="芒果方块（Mango-Cubes）"><a href="#芒果方块（Mango-Cubes）" class="headerlink" title="芒果方块（Mango Cubes）"></a>芒果方块（<strong>Mango Cubes</strong>）</h3><p>剥几个刚成熟的芒果（应该有点软，但不要过熟导致糊状）切一个漂亮的长方体，然后切 0.5 厘米的方块</p><p>然后在密封袋中加入香菜糖浆（见注释）密封，冷藏 2 到 3 天</p><h3 id="香菜糖浆（Cilantro-Syrup）"><a href="#香菜糖浆（Cilantro-Syrup）" class="headerlink" title="香菜糖浆（Cilantro Syrup）"></a>香菜糖浆（Cilantro Syrup）</h3><ul><li>白砂糖 - 1 千克</li><li>纯净水 - 1 升</li><li>焯水香菜 - 30 克</li><li>盐 - 1 勺</li></ul><p>将所有材料加入锅中，用小火慢煮加热</p><p>从火上取下，倒入保温桶静置 4 到 6 个小时，用滤网滤出冷藏</p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 宿醉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸡尾酒 </tag>
            
            <tag> recipes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LangChain 文档学习 No.4 - 输出解析器</title>
      <link href="/%E5%BC%80%E5%8F%91/LangChain/LangChain%20%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%20No.4%20-%20%E8%BE%93%E5%87%BA%E8%A7%A3%E6%9E%90%E5%99%A8.html"/>
      <url>/%E5%BC%80%E5%8F%91/LangChain/LangChain%20%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%20No.4%20-%20%E8%BE%93%E5%87%BA%E8%A7%A3%E6%9E%90%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="列表解析器"><a href="#列表解析器" class="headerlink" title="列表解析器"></a>列表解析器</h1><p>返回逗号分隔的项目列表时，可以使用此输出解析器</p><p><strong>解析器和 prompt</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表解析器</span></span><br><span class="line">output_parser = CommaSeparatedListOutputParser()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表解析器自带格式说明</span></span><br><span class="line">format_instructions = output_parser.get_format_instructions()</span><br><span class="line"><span class="comment"># prompt template</span></span><br><span class="line">prompt_template = PromptTemplate(</span><br><span class="line">    template=<span class="string">&quot;列举出五个&#123;subject&#125;.\n&#123;format_instructions&#125;&quot;</span>,</span><br><span class="line">    input_variables=[<span class="string">&quot;subject&quot;</span>],</span><br><span class="line">    partial_variables=&#123;<span class="string">&quot;format_instructions&quot;</span>: format_instructions&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AI 模型</span></span><br><span class="line">model = Azure.chat_model</span><br><span class="line">output = model.predict(prompt_template.<span class="built_in">format</span>(subject=<span class="string">&quot;棒棒糖口味&quot;</span>))</span><br><span class="line"><span class="comment"># 解析</span></span><br><span class="line"><span class="built_in">print</span>(output_parser.parse(output))</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt; [&#x27;草莓味&#x27;, &#x27;葡萄味&#x27;, &#x27;橙子味&#x27;, &#x27;苹果味&#x27;, &#x27;蓝莓味&#x27;]</span></span><br></pre></td></tr></table></figure><h1 id="日期解析器"><a href="#日期解析器" class="headerlink" title="日期解析器"></a>日期解析器</h1><p>输出解析为日期时间格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 日期解析器</span></span><br><span class="line">output_parser = DatetimeOutputParser()</span><br><span class="line">template = <span class="string">&quot;&quot;&quot;Answer the users question:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;question&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;format_instructions&#125;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># prompt template</span></span><br><span class="line">prompt_template = PromptTemplate.from_template(</span><br><span class="line">    template,</span><br><span class="line">    partial_variables=&#123;<span class="string">&quot;format_instructions&quot;</span>: output_parser.get_format_instructions()&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AI 模型</span></span><br><span class="line">model = Azure.chat_model</span><br><span class="line">chain = LLMChain(prompt=prompt, llm=model)</span><br><span class="line">output = chain.run(<span class="string">&quot;around when was bitcoin founded?&quot;</span>)</span><br><span class="line"><span class="comment"># 解析</span></span><br><span class="line"><span class="built_in">print</span>(output_parser.parse(output))</span><br></pre></td></tr></table></figure><p>这里可能是因为使用了 AzureOpenAI，没法按照限制的格式输出，不太稳定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: time data <span class="string">&#x27;Bitcoin was founded on January 3, 2009. The corresponding datetime string would be &quot;2009-01-03T00:00:00.000000Z&quot;.&#x27;</span> does not match format <span class="string">&#x27;%Y-%m-%dT%H:%M:%S.%fZ&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="枚举解析器"><a href="#枚举解析器" class="headerlink" title="枚举解析器"></a>枚举解析器</h1><p>枚举解析器用来解析枚举</p><p><strong>定义枚举</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Colors</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    WHITE = <span class="string">&quot;白色&quot;</span></span><br><span class="line">    RED = <span class="string">&quot;红色&quot;</span></span><br><span class="line">    GREEN = <span class="string">&quot;绿色&quot;</span></span><br><span class="line">    BLUE = <span class="string">&quot;蓝色&quot;</span></span><br><span class="line">    YELLOW = <span class="string">&quot;黄色&quot;</span></span><br></pre></td></tr></table></figure><p><strong>解析器和 prompt</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parser = EnumOutputParser(enum=Colors)</span><br><span class="line">prompt_template = PromptTemplate.from_template(<span class="string">&quot;选择一个你最喜欢的颜色\n&#123;format_instructions&#125;&quot;</span>)</span><br><span class="line">prompt = prompt_template.<span class="built_in">format</span>(format_instructions=parser.get_format_instructions())</span><br><span class="line"><span class="built_in">print</span>(prompt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt; 选择一个你最喜欢的颜色\nSelect one of the following options: 白色, 红色, 绿色, 蓝色, 黄色</span></span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model = Azure.chat_model</span><br><span class="line">result = model.predict(prompt)</span><br><span class="line"><span class="built_in">print</span>(parser.parse(result))</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt; Colors.BLUE</span></span><br></pre></td></tr></table></figure><h1 id="结构化解析器"><a href="#结构化解析器" class="headerlink" title="结构化解析器"></a>结构化解析器</h1><p>当需要返回多个字段时，可以使用这种输出解析器，Pydantic \ JSON 解析器相比之下更强大</p><p><strong>定义我们想要接收的响应结构</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 结构定义</span></span><br><span class="line">response_schemas = [</span><br><span class="line">    ResponseSchema(name=<span class="string">&quot;answer&quot;</span>, description=<span class="string">&quot;回答用户的问题&quot;</span>),</span><br><span class="line">    ResponseSchema(name=<span class="string">&quot;source&quot;</span>, description=<span class="string">&quot;用于回答用户问题的来源，应该是一个网站&quot;</span>),</span><br><span class="line">    ResponseSchema(name=<span class="string">&quot;score&quot;</span>, description=<span class="string">&quot;给自己的回答打分，满分 100&quot;</span>, <span class="built_in">type</span>=<span class="string">&quot;num&quot;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建解析器</span></span><br><span class="line">output_parser = StructuredOutputParser.from_response_schemas(response_schemas)</span><br></pre></td></tr></table></figure><p><strong>提示模板</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成的格式说明</span></span><br><span class="line">format_instructions = output_parser.get_format_instructions()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示模板</span></span><br><span class="line">prompt_template = PromptTemplate(</span><br><span class="line">    template=<span class="string">&quot;尽可能回答用户的问题.\n&#123;format_instructions&#125;\n&#123;question&#125;&quot;</span>,</span><br><span class="line">    input_variables=[<span class="string">&quot;question&quot;</span>],</span><br><span class="line">    partial_variables=&#123;<span class="string">&quot;format_instructions&quot;</span>: format_instructions&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">model = Azure.chat_model</span><br><span class="line">prompt = prompt.<span class="built_in">format</span>(question=<span class="string">&quot;中国的首都是哪个城市？&quot;</span>)</span><br><span class="line">output = model.predict(prompt)</span><br><span class="line">result = output_parser.parse(output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(result))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(result[<span class="string">&quot;answer&quot;</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(result[<span class="string">&quot;source&quot;</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(result[<span class="string">&quot;score&quot;</span>]))</span><br><span class="line"><span class="comment"># &gt;&gt; &lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"><span class="comment"># &gt;&gt; &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="comment"># &gt;&gt; &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="comment"># &gt;&gt; &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 答案</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># &gt;&gt; &#123;&#x27;answer&#x27;: &#x27;中国的首都是北京。&#x27;, &#x27;source&#x27;: &#x27;https://zh.wikipedia.org/wiki/%E5%8C%97%E4%BA%AC&#x27;, &#x27;score&#x27;: 100&#125;</span></span><br></pre></td></tr></table></figure><h1 id="Pydantic-JSON-解析器"><a href="#Pydantic-JSON-解析器" class="headerlink" title="Pydantic \ JSON 解析器"></a>Pydantic \ JSON 解析器</h1><p>该输出解析器允许用户指定任意的 JSON 模式，并查询符合该模式的 JSON 输出</p><blockquote><p>需要注意</p><p>大型语言模型是有漏洞的，必须使用具有足够容量的 LLM 来生成格式正确的 JSON<br>在 OpenAI 家族中，DaVinci 的能力可靠，但 Curie 的能力不足</p></blockquote><p>使用 Pydantic 来声明数据模型；Pydantic 的。BaseModel 类似于 Python 的数据类，但具有真正的类型检查和强制转换功能</p><p><strong>定义结构</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define your desired data structure.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Joke</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    setup: <span class="built_in">str</span> = Field(description=<span class="string">&quot;question to set up a joke&quot;</span>)</span><br><span class="line">    punchline: <span class="built_in">str</span> = Field(description=<span class="string">&quot;answer to resolve the joke&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 您可以使用 Pydantic 轻松添加自定义验证逻辑</span></span><br><span class="line"><span class="meta">    @validator(<span class="params"><span class="string">&quot;setup&quot;</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">question_ends_with_question_mark</span>(<span class="params">cls, field</span>):</span><br><span class="line">        <span class="keyword">if</span> field[-<span class="number">1</span>] != <span class="string">&quot;?&quot;</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Badly formed question!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> field</span><br><span class="line">      </span><br><span class="line"><span class="comment"># PydanticOutputParser 解析器</span></span><br><span class="line">parser = PydanticOutputParser(pydantic_object=Joke)</span><br></pre></td></tr></table></figure><p><strong>定义模板</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># And a query intented to prompt a language model to populate the data structure.</span></span><br><span class="line">joke_query = <span class="string">&quot;Tell me a joke.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># prompt template</span></span><br><span class="line">prompt_template = PromptTemplate(</span><br><span class="line">    template=<span class="string">&quot;Answer the user query.\n&#123;format_instructions&#125;\n&#123;query&#125;\n&quot;</span>,</span><br><span class="line">    input_variables=[<span class="string">&quot;query&quot;</span>],</span><br><span class="line">    partial_variables=&#123;<span class="string">&quot;format_instructions&quot;</span>: parser.get_format_instructions()&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt = prompt_template.format_prompt(query=joke_query)</span><br><span class="line">output = model(_<span class="built_in">input</span>.to_string())</span><br><span class="line"><span class="built_in">print</span>(parser.parse(prompt))</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt; Joke(setup=&#x27;Why did the chicken cross the road?&#x27;, punchline=&#x27;To get to the other side!&#x27;)</span></span><br></pre></td></tr></table></figure><p>复合类型字段的示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Here&#x27;s another example, but with a compound typed field.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Actor</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    name: <span class="built_in">str</span> = Field(description=<span class="string">&quot;name of an actor&quot;</span>)</span><br><span class="line">    film_names: <span class="type">List</span>[<span class="built_in">str</span>] = Field(description=<span class="string">&quot;list of names of films they starred in&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="自动修复解析器"><a href="#自动修复解析器" class="headerlink" title="自动修复解析器"></a>自动修复解析器</h1><p>自动修复解析器包装另一个输出解析器，如果第一个解析器失败，它会调用另一个 LLM 来修复错误</p><p>但除了抛出错误，我们还可以做其他事情，例如我们可以将格式错误的输出和格式化的指令一起传递给模型，并要求它进行修复</p><p><strong>定义结构</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Actor</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    name: <span class="built_in">str</span> = Field(description=<span class="string">&quot;name of an actor&quot;</span>)</span><br><span class="line">    film_names: <span class="type">List</span>[<span class="built_in">str</span>] = Field(description=<span class="string">&quot;list of names of films they starred in&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Pydantic 解析器</span></span><br><span class="line">parser = PydanticOutputParser(pydantic_object=Actor)</span><br></pre></td></tr></table></figure><p><strong>错误语句解析</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mis_formatted = <span class="string">&quot;&#123;&#x27;name&#x27;: &#x27;汤姆汉克斯&#x27;, &#x27;film_names&#x27;: [&#x27;阿甘正传&#x27;]&#125;&quot;</span></span><br><span class="line">parser.parse(mis_formatted)</span><br></pre></td></tr></table></figure><p>上面的 JSON 格式是错误的（单引号），所以抛出异常</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">langchain.schema.output_parser.OutputParserException: Failed to parse Actor from completion &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;汤姆汉克斯&#x27;</span>, <span class="string">&#x27;film_names&#x27;</span>: [<span class="string">&#x27;阿甘正传&#x27;</span>]&#125;. Got: Expecting property name enclosed <span class="keyword">in</span> double quotes: line 1 column 2 (char 1)</span><br></pre></td></tr></table></figure><p><strong>使用自动修复解析器包装解析器和 LLM</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new_parser = OutputFixingParser.from_llm(parser=parser, llm=Azure.chat_model, max_retries=<span class="number">2</span>)</span><br><span class="line">result = new_parser.parse(mis_formatted)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt; name=&#x27;Tom Hanks&#x27; film_names=[&#x27;Forrest Gump&#x27;]</span></span><br><span class="line"><span class="comment"># 呃，这里被 AI 修复成了英文</span></span><br></pre></td></tr></table></figure><p>实现原理就是进行重试，将解析器的格式说明和错误内容交给 AI 重新进行处理</p><h1 id="重试解析器"><a href="#重试解析器" class="headerlink" title="重试解析器"></a>重试解析器</h1><p>某些情况下查看输出就可以修复解析错误</p><p>但是例如输出不仅格式不正确，而且不完整则完全无法解析</p><p><strong>假设定义结构和错误返回</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Action</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    action: <span class="built_in">str</span> = Field(description=<span class="string">&quot;action to take&quot;</span>)</span><br><span class="line">    action_input: <span class="built_in">str</span> = Field(description=<span class="string">&quot;input to the action&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 错误返回并没有 action_input 的信息</span></span><br><span class="line">bad_response = <span class="string">&#x27;&#123;&quot;action&quot;: &quot;search&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>如果我们使用 <code>OutputFixingParser</code> 也无法完整修复，因为 AI 并不清楚数据是什么（感觉可以理解为修复的更多是格式错误，无法修复内容的不完整）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fix_parser = OutputFixingParser.from_llm(parser=parser, llm=Azure.chat_model)</span><br><span class="line"><span class="built_in">print</span>(fix_parser.parse(bad_response))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复结果依然是不完整的</span></span><br><span class="line"><span class="comment"># &gt;&gt; Action(action=&#x27;search&#x27;, action_input=&#x27;&#x27;)</span></span><br></pre></td></tr></table></figure><p>此时就需要重试进行解决</p><p><strong>使用 RetryOutputParser</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 RetryWithErrorOutputParser</span></span><br><span class="line">retry_parser = RetryWithErrorOutputParser.from_llm(</span><br><span class="line">    parser=parser, llm=Azure.chat_model</span><br><span class="line">)</span><br><span class="line">retry_parser.parse_with_prompt(bad_response, prompt_value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt; Action(action=&#x27;search&#x27;, action_input=&#x27;who is leo di caprios gf?&#x27;)</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://python.langchain.com.cn/docs/modules/model_io/output_parsers/">输出解析器 (Output Parsers) | 🦜️🔗 Langchain</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> LangChain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> LangChain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LangChain 文档学习 No.3 - 示例选择器</title>
      <link href="/%E5%BC%80%E5%8F%91/LangChain/LangChain%20%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%20No.3%20-%20%E7%A4%BA%E4%BE%8B%E9%80%89%E6%8B%A9%E5%99%A8.html"/>
      <url>/%E5%BC%80%E5%8F%91/LangChain/LangChain%20%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%20No.3%20-%20%E7%A4%BA%E4%BE%8B%E9%80%89%E6%8B%A9%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="MMR"><a href="#MMR" class="headerlink" title="MMR"></a>MMR</h1><p>MMR 为最大边际相关性，<code>MaxMarginalRelevanceExampleSelector</code> 根据示例与输入之间的相似度以及多样性来选择示例</p><p>通过寻找与输入具有最大余弦相似度的嵌入的示例，并在迭代中进行添加；同时对与已选择示例的相似度进行惩罚来进行实现</p><p><strong>import</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.prompts.example_selector <span class="keyword">import</span> (</span><br><span class="line">    MaxMarginalRelevanceExampleSelector,</span><br><span class="line">    SemanticSimilarityExampleSelector,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> langchain.vectorstores <span class="keyword">import</span> FAISS</span><br><span class="line"><span class="keyword">from</span> langchain.embeddings <span class="keyword">import</span> OpenAIEmbeddings</span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> FewShotPromptTemplate, PromptTemplate</span><br></pre></td></tr></table></figure><p><strong>构造提示模板和示例集合</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">example_prompt = PromptTemplate(</span><br><span class="line">    input_variables=[<span class="string">&quot;input&quot;</span>, <span class="string">&quot;output&quot;</span>],</span><br><span class="line">    template=<span class="string">&quot;Input: &#123;input&#125;\nOutput: &#123;output&#125;&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反义词示例集</span></span><br><span class="line">examples = [</span><br><span class="line">    &#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;happy&quot;</span>, <span class="string">&quot;output&quot;</span>: <span class="string">&quot;sad&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;tall&quot;</span>, <span class="string">&quot;output&quot;</span>: <span class="string">&quot;short&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;energetic&quot;</span>, <span class="string">&quot;output&quot;</span>: <span class="string">&quot;lethargic&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;sunny&quot;</span>, <span class="string">&quot;output&quot;</span>: <span class="string">&quot;gloomy&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;windy&quot;</span>, <span class="string">&quot;output&quot;</span>: <span class="string">&quot;calm&quot;</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>创建 MaxMarginalRelevanceExampleSelector</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">example_selector = MaxMarginalRelevanceExampleSelector.from_examples(</span><br><span class="line">    <span class="comment"># 可供选择的示例列表</span></span><br><span class="line">    examples,</span><br><span class="line">    <span class="comment"># 用于生成用于测量语义相似性的嵌入的嵌入类（LangChain 对接了很多三方 Embedding API）</span></span><br><span class="line">    OpenAIEmbeddings(),</span><br><span class="line">    <span class="comment"># 这是 VectorStore 类，用于存储嵌入并进行相似性搜索</span></span><br><span class="line">    FAISS,</span><br><span class="line">    <span class="comment"># 选择的示例数</span></span><br><span class="line">    k=<span class="number">2</span>,</span><br><span class="line">)</span><br><span class="line">mmr_prompt = FewShotPromptTemplate(</span><br><span class="line">    <span class="comment"># 提供了 ExampleSelector 而不是示例集</span></span><br><span class="line">    example_selector=example_selector,</span><br><span class="line">    example_prompt=example_prompt,</span><br><span class="line">    prefix=<span class="string">&quot;Give the antonym of every input&quot;</span>,</span><br><span class="line">    suffix=<span class="string">&quot;Input: &#123;adjective&#125;\nOutput:&quot;</span>,</span><br><span class="line">    input_variables=[<span class="string">&quot;adjective&quot;</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>FewShotPromptTemplate fomat</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入的 worried 是一种感觉</span></span><br><span class="line"><span class="comment"># 所以应该选择 happy/sad 的例子作为第一个</span></span><br><span class="line"><span class="built_in">print</span>(mmr_prompt.<span class="built_in">format</span>(adjective=<span class="string">&quot;worried&quot;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Give the antonym of every <span class="keyword">input</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Input</span>: happy</span><br><span class="line"><span class="keyword">Output</span>: sad</span><br><span class="line"></span><br><span class="line"><span class="keyword">Input</span>: windy</span><br><span class="line"><span class="keyword">Output</span>: calm</span><br><span class="line"></span><br><span class="line"><span class="keyword">Input</span>: worried</span><br><span class="line"><span class="keyword">Output</span>:</span><br></pre></td></tr></table></figure><h1 id="SemanticSimilarity"><a href="#SemanticSimilarity" class="headerlink" title="SemanticSimilarity"></a>SemanticSimilarity</h1><p>根据与输入的相似度选择示例，通过找到与输入具有最大余弦相似度的 embedding 例子来实现此目的</p><h1 id="Embedding"><a href="#Embedding" class="headerlink" title="Embedding"></a>Embedding</h1><p><code>embedding</code> 中文翻译是“嵌入”</p><p>在⾃然语⾔处理和机器学习领域，<code>embedding</code> 是指将单词、短语或⽂本等离散变量转换成连续向量空间的过程</p><p>向量空间通常被称为嵌⼊空间 <em>embedding space</em>，⽣成的向量则称为嵌⼊向量 <em>embedding vector</em> 或向量嵌⼊<em>vector embedding</em></p><br><p><strong>为什么需要 embedding</strong></p><p>LLM 有一些无法解决的问题：</p><ul><li>LLM 的训练数据是有时间约束的，无法获取到最新的一些信息</li><li>LLM 不知道答案后开始放飞自我，出现 hallucination</li><li>应用化（例如客服），数据需要自主提供</li></ul><p>针对上述问题，LLM 的供应商一般提供了如下机制：维护自己的数据集，用户输入 prompt 之后首先匹配自主维护的数据集，找到相关性强的部分，再结合成最终的 prompt 交给 LLM</p><p>新的问题出现了 <strong>怎么在我们的数据集中检索到和 prompt 相关的内容</strong></p><p>数据向量是将数据表示为数值向量的形式，用于方便地进行计算、分析和处理，处理为向量后计算机才可以更好的对内容机进行相关性的判断</p><br><p>LangChain 这里使用了 OpenAI 的 embedding API 生成内容对应的 embedding vectors</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">example_selector = MaxMarginalRelevanceExampleSelector.from_examples(</span><br><span class="line">    examples,</span><br><span class="line">    <span class="comment"># 用于生成用于测量语义相似性的嵌入的嵌入类（LangChain 对接了很多三方 Embedding API）</span></span><br><span class="line">    OpenAIEmbeddings(),</span><br><span class="line">    FAISS,</span><br><span class="line">    k=<span class="number">2</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>也提供了很多 LLM 的 API，例如微软 Azure 的有 <code>AzureOpenAIEmbeddings</code></p><p>不过需要部署相应的模型才能使用，模型不匹配会提示</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The embeddings operation <span class="keyword">does</span> <span class="keyword">not</span> work <span class="keyword">with</span> <span class="keyword">the</span> specified model, gpt<span class="number">-35</span>-turbo<span class="number">-16</span>k. Please choose different model <span class="keyword">and</span> <span class="keyword">try</span> again. </span><br></pre></td></tr></table></figure><h1 id="N-gram-overlap"><a href="#N-gram-overlap" class="headerlink" title="N-gram overlap"></a>N-gram overlap</h1><p><code>NGramOverlapExampleSelector</code> 根据示例与输入之间的 n-gram 重叠程度选择和排序示例</p><p>N-gram 重叠得分是一个在 0.0 到 1.0 之间（闭区间）的浮点数</p><p>选择器允许设置阈值分数，n-gram 重叠得分小于或等于阈值的示例将被排除在外；默认情况下，阈值设置为 -1.0，因此不会排除任何示例</p><p><strong>设置提示模板和示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">example_prompt = PromptTemplate(</span><br><span class="line">    input_variables=[<span class="string">&quot;input&quot;</span>, <span class="string">&quot;output&quot;</span>],</span><br><span class="line">    template=<span class="string">&quot;Input: &#123;input&#125;\nOutput: &#123;output&#125;&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># These are examples of a fictional translation task.</span></span><br><span class="line">examples = [</span><br><span class="line">    &#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;See Spot run.&quot;</span>, <span class="string">&quot;output&quot;</span>: <span class="string">&quot;Ver correr a Spot.&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;My dog barks.&quot;</span>, <span class="string">&quot;output&quot;</span>: <span class="string">&quot;Mi perro ladra.&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;Spot can run.&quot;</span>, <span class="string">&quot;output&quot;</span>: <span class="string">&quot;Spot puede correr.&quot;</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>创建 NGramOverlapExampleSelector 选择器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">example_selector = NGramOverlapExampleSelector(</span><br><span class="line">    examples=examples,</span><br><span class="line">    example_prompt=example_prompt,</span><br><span class="line">    <span class="comment"># 这是选择器停止的阈值</span></span><br><span class="line">    <span class="comment"># 默认情况下，它设置为-1.0</span></span><br><span class="line">    threshold=-<span class="number">1.0</span>,</span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  对于负阈值：</span></span><br><span class="line"><span class="string">  Selector 按 ngram 重叠分数对示例进行排序，不排除任何示例</span></span><br><span class="line"><span class="string">  对于大于 1.0 的阈值：</span></span><br><span class="line"><span class="string">  选择器排除所有示例，并返回一个空列表</span></span><br><span class="line"><span class="string">  对于等于 0.0 的阈值：</span></span><br><span class="line"><span class="string">  Selector 根据 ngram 重叠分数对示例进行排序，并且排除与输入没有 ngram 重叠的那些</span></span><br><span class="line"><span class="string">  &#x27;&#x27;&#x27;</span></span><br><span class="line">)</span><br><span class="line">dynamic_prompt = FewShotPromptTemplate(</span><br><span class="line">    example_selector=example_selector,</span><br><span class="line">    example_prompt=example_prompt,</span><br><span class="line">    prefix=<span class="string">&quot;Give the Spanish translation of every input&quot;</span>,</span><br><span class="line">    suffix=<span class="string">&quot;Input: &#123;sentence&#125;\nOutput:&quot;</span>,</span><br><span class="line">    input_variables=[<span class="string">&quot;sentence&quot;</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>FewShotPromptTemplate fomat</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># An example input with large ngram overlap with &quot;Spot can run.&quot;</span></span><br><span class="line"><span class="comment"># and no overlap with &quot;My dog barks.&quot;</span></span><br><span class="line"><span class="built_in">print</span>(dynamic_prompt.<span class="built_in">format</span>(sentence=<span class="string">&quot;Spot can run fast.&quot;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Give the Spanish translation of every <span class="keyword">input</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Input</span>: Spot can run.</span><br><span class="line"><span class="keyword">Output</span>: Spot puede correr.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Input</span>: See Spot run.</span><br><span class="line"><span class="keyword">Output</span>: Ver correr a Spot.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Input</span>: My dog barks.</span><br><span class="line"><span class="keyword">Output</span>: Mi perro ladra.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Input</span>: Spot can run fast.</span><br><span class="line"><span class="keyword">Output</span>:</span><br></pre></td></tr></table></figure><p><strong>添加新的示例到选择器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 您也可以将新示例添加到 NGramOverlapExampleSelector 中</span></span><br><span class="line">new_example = &#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;Spot plays fetch.&quot;</span>, <span class="string">&quot;output&quot;</span>: <span class="string">&quot;Spot juega a buscar.&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">example_selector.add_example(new_example)</span><br><span class="line"><span class="built_in">print</span>(dynamic_prompt.<span class="built_in">format</span>(sentence=<span class="string">&quot;Spot can run fast.&quot;</span>))</span><br></pre></td></tr></table></figure><h1 id="N-gram-操作"><a href="#N-gram-操作" class="headerlink" title="N-gram 操作"></a>N-gram 操作</h1><p>N-gram（n 元语法）是自然语言处理中的一种常用技术，用于将文本分割成连续的、固定长度的片段</p><p>一个 N-gram 是由 N 个连续的词或字符组成的序列</p><p>在N-gram中，N代表片段中的词或字符的数量。例如：</p><ul><li>2-gram（也称为 bigram）由两个连续的词组成，例如 <code>natural language</code>、<code>machine learning</code></li><li>3-gram（也称为 trigram）由三个连续的词组成，例如 <code>the quick brown</code>、<code>learn from data</code></li></ul><p>需要注意的是，较小的 N 值可能无法捕捉到长距离的语言依赖关系，而较大的 N 值可能会导致数据稀疏问题；因此，选择合适的 N 值对于具体任务和数据集是需要仔细考虑的</p><p>示例，将 “Today is a good day” 使用 2-gram 拆分多个字符串：</p><ol><li>“Today is”</li><li>“is a”</li><li>“a good”</li><li>“good day”</li></ol><br><p>Elasticsearch 中的模糊（wildcard）搜索一般就是使用 N-gram 分词器来实现</p><p><strong>创建一个测试索引，配置 N-gram 分词器</strong></p><p>关于 N-gram 分词器支持的参数可以参考<br>[<a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.10/analysis-ngram-tokenizer.html">N-gram tokenizer | Elasticsearch Guide [8.10] | Elastic]</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PUT /test-ngram-index</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;analysis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;my_analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;tokenizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my_ngram_tokenizer&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;tokenizer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;my_ngram_tokenizer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ngram&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;min_gram&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;max_gram&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;token_chars&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;letter&quot;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>分词</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my_analyzer&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;今天是个好日子！&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tokens&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;今天&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;start_offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;end_offset&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;word&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;今天是&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;start_offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;end_offset&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;word&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;天是&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;start_offset&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;end_offset&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;word&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line">      </span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="自定义示例选择器"><a href="#自定义示例选择器" class="headerlink" title="自定义示例选择器"></a>自定义示例选择器</h1><p><code>ExampleSelector</code> 必须实现两个方法：</p><ul><li><code>add_example</code> 方法，该方法接受一个示例并将其添加到 <code>ExampleSelector</code> 中</li><li><code>select_examples</code> 方法，该方法接受输入变量（用于用户输入）并返回要在 few shot 提示中使用的示例列表</li></ul><p>实现一个自定义的 <code>ExampleSelector</code>，效果是在示例中随机选择 n 个，n 作为构造参数传入</p><p><strong>自定义选择器实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.prompts.example_selector.base <span class="keyword">import</span> BaseExampleSelector</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">List</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomExampleSelector</span>(<span class="title class_ inherited__">BaseExampleSelector</span>):</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 构造器除了 examples，还需要传入 size 作为随机选择的数量参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, examples: <span class="type">List</span>[<span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]], size: <span class="built_in">int</span></span>):</span><br><span class="line">        self.examples = examples</span><br><span class="line">        self.size = size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_example</span>(<span class="params">self, example: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加新示例&quot;&quot;&quot;</span></span><br><span class="line">        self.examples.append(example)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">select_examples</span>(<span class="params">self, input_variables: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">dict</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;根据输入选择要使用的示例&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 使用了 np 的随机工具</span></span><br><span class="line">        <span class="keyword">return</span> np.random.choice(self.examples, size=self.size, replace=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">examples = [</span><br><span class="line">    &#123;<span class="string">&quot;魏&quot;</span>: <span class="string">&quot;曹丕&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;蜀&quot;</span>: <span class="string">&quot;刘备&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;吴&quot;</span>: <span class="string">&quot;孙权&quot;</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">example_selector = CustomExampleSelector(examples, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择</span></span><br><span class="line"><span class="built_in">print</span>(example_selector.select_examples(&#123;<span class="string">&quot;unuseful&quot;</span>: <span class="string">&quot;unuseful&quot;</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加新示例后选择</span></span><br><span class="line">example_selector.add_example(&#123;<span class="string">&quot;晋&quot;</span>: <span class="string">&quot;司马睿&quot;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(example_selector.select_examples(&#123;<span class="string">&quot;unuseful&quot;</span>: <span class="string">&quot;unuseful&quot;</span>&#125;))</span><br></pre></td></tr></table></figure><h1 id="选择长度"><a href="#选择长度" class="headerlink" title="选择长度"></a>选择长度</h1><p>选择器可以根据长度对示例进行选择来避免构建的提示长度超过上下文窗口 token 的限制</p><p>对于较长的输入，它会选择较少的示例，而对于较短的输入，它会选择更多的示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> FewShotPromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain.prompts.example_selector <span class="keyword">import</span> LengthBasedExampleSelector</span><br><span class="line"></span><br><span class="line">examples = [</span><br><span class="line">    &#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;happy&quot;</span>, <span class="string">&quot;output&quot;</span>: <span class="string">&quot;sad&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;tall&quot;</span>, <span class="string">&quot;output&quot;</span>: <span class="string">&quot;short&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;energetic&quot;</span>, <span class="string">&quot;output&quot;</span>: <span class="string">&quot;lethargic&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;sunny&quot;</span>, <span class="string">&quot;output&quot;</span>: <span class="string">&quot;gloomy&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;windy&quot;</span>, <span class="string">&quot;output&quot;</span>: <span class="string">&quot;calm&quot;</span>&#125;,</span><br><span class="line"></span><br><span class="line">example_prompt = PromptTemplate(</span><br><span class="line">    input_variables=[<span class="string">&quot;input&quot;</span>, <span class="string">&quot;output&quot;</span>],</span><br><span class="line">    template=<span class="string">&quot;Input: &#123;input&#125;\nOutput: &#123;output&#125;&quot;</span>,</span><br><span class="line">)</span><br><span class="line">example_selector = LengthBasedExampleSelector(</span><br><span class="line">    examples=examples, </span><br><span class="line">    example_prompt=example_prompt, </span><br><span class="line">    <span class="comment"># 这是格式化示例的最大长度</span></span><br><span class="line">    <span class="comment"># 长度由下面的 get_text_Length 函数测量</span></span><br><span class="line">    max_length=<span class="number">25</span>,</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    这是用于获取字符串长度的函数以确定要包括哪些示例</span></span><br><span class="line"><span class="string">    它被注释掉是因为，如果未指定，则将其作为默认值提供</span></span><br><span class="line"><span class="string">    get_text_length: Callable [[str], int] = lambda x: len(re.split(&quot;\n| &quot;, x))</span></span><br><span class="line"><span class="string">    默认逻辑是按照换行符或空格进行分割来判断长度</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">)</span><br><span class="line">dynamic_prompt = FewShotPromptTemplate(</span><br><span class="line">    example_selector=example_selector,</span><br><span class="line">    example_prompt=example_prompt,</span><br><span class="line">    prefix=<span class="string">&quot;Give the antonym of every input&quot;</span>,</span><br><span class="line">    suffix=<span class="string">&quot;Input: &#123;adjective&#125;\nOutput:&quot;</span>, </span><br><span class="line">    input_variables=[<span class="string">&quot;adjective&quot;</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(dynamic_prompt.<span class="built_in">format</span>(adjective=<span class="string">&quot;big&quot;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Give the antonym of every <span class="keyword">input</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Input</span>: happy</span><br><span class="line"><span class="keyword">Output</span>: sad</span><br><span class="line"></span><br><span class="line"><span class="keyword">Input</span>: tall</span><br><span class="line"><span class="keyword">Output</span>: short</span><br><span class="line"></span><br><span class="line"><span class="keyword">Input</span>: energetic</span><br><span class="line"><span class="keyword">Output</span>: lethargic</span><br><span class="line"></span><br><span class="line"><span class="keyword">Input</span>: sunny</span><br><span class="line"><span class="keyword">Output</span>: gloomy</span><br><span class="line"></span><br><span class="line"><span class="keyword">Input</span>: windy</span><br><span class="line"><span class="keyword">Output</span>: calm</span><br><span class="line"></span><br><span class="line"><span class="keyword">Input</span>: big</span><br><span class="line"><span class="keyword">Output</span>:</span><br></pre></td></tr></table></figure><p>因为输入的内容很短（big），所以根据生于长度会取更多的示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long_string = <span class="string">&quot;big and huge and massive and large and gigantic and tall and much much much much much bigger than everything else&quot;</span></span><br><span class="line"><span class="built_in">print</span>(dynamic_prompt.<span class="built_in">format</span>(adjective=long_string))</span><br></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Give the antonym of every input</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">Input:</span> happy</span><br><span class="line"><span class="symbol">Output:</span> sad</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">Input:</span> <span class="keyword">big </span><span class="keyword">and </span>huge <span class="keyword">and </span>massive <span class="keyword">and </span>large <span class="keyword">and </span>gigantic <span class="keyword">and </span>tall <span class="keyword">and </span>much much much much much <span class="keyword">bigger </span>than everything else</span><br><span class="line"><span class="symbol">Output:</span></span><br></pre></td></tr></table></figure><p>因为输入的内容很长（big and huge and massive and large and gigantic and tall and much much much much much bigger than everything else），所以选择的示例就比较少</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://python.langchain.com.cn/docs/modules/model_io/prompts/example_selectors/">例子选择器 | 🦜️🔗 Langchain</a></p><p><a href="https://zhuanlan.zhihu.com/p/634429713">OpenAI体验3 —— embedding和向量数据库(pinecone) - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> LangChain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> LangChain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LangChain 文档学习 No.2 - 提示模板</title>
      <link href="/%E5%BC%80%E5%8F%91/LangChain/LangChain%20%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%20No.2%20-%20%E6%8F%90%E7%A4%BA%E6%A8%A1%E6%9D%BF.html"/>
      <url>/%E5%BC%80%E5%8F%91/LangChain/LangChain%20%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%20No.2%20-%20%E6%8F%90%E7%A4%BA%E6%A8%A1%E6%9D%BF.html</url>
      
        <content type="html"><![CDATA[<h1 id="模板格式"><a href="#模板格式" class="headerlink" title="模板格式"></a>模板格式</h1><p>默认情况下，<code>PromptTemplate</code> 会将提供的模板视为 Python f-string</p><p>您可以通过 <code>template_format</code> 参数指定其他模板格式，如下的 <code>template_format=&quot;jinja2&quot;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保安装了 jinja2</span></span><br><span class="line"></span><br><span class="line">jinja2_template = <span class="string">&quot;告诉我一个关于&#123;&#123; content &#125;&#125;的笑话&quot;</span></span><br><span class="line">prompt_template = PromptTemplate.from_template(template=jinja2_template, template_format=<span class="string">&quot;jinja2&quot;</span>)</span><br><span class="line"></span><br><span class="line">prompt_template.<span class="built_in">format</span>(content=<span class="string">&quot;熊猫&quot;</span>)</span><br><span class="line"><span class="comment"># -&gt; 告诉我一个关于熊猫的笑话</span></span><br></pre></td></tr></table></figure><blockquote><p>Args:</p><p>​    template: The template string.</p><p>​    template_format: The template format. Should be one of “f-string” or “jinja2”.</p></blockquote><br>f-string 亦称为格式化字符串常量（formatted string literals），是 Python3.6 新引入的一种字符串格式化方法[The new f-strings in Python 3.6 | Seasoned & Agile (cito.github.io)](https://cito.github.io/blog/f-strings/)<h1 id="验证模板"><a href="#验证模板" class="headerlink" title="验证模板"></a>验证模板</h1><p>默认情况下，<code>PromptTemplate</code> 会通过检查 <code>input_variables</code> 是否与 <code>template</code> 中定义的变量匹配来验证 <code>template</code> 字符串</p><p>可以将 <code>validate_template</code> 设置为 <code>False</code> 来禁用此行为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template = <span class="string">&quot;我学习&#123;tool&#125;是因为&#123;reason&#125;&quot;</span></span><br><span class="line">prompt_template = PromptTemplate(template=template, input_variables=[<span class="string">&quot;reason&quot;</span>], validate_template=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt; pydantic.v1.error_wrappers.ValidationError: 1 validation error for PromptTemplate\n__root__\nInvalid prompt schema; check for mismatched or missing input parameters. &#x27;tool&#x27; (type=value_error)</span></span><br></pre></td></tr></table></figure><p>这里应该是文档版本问题？我使用的 LangChain 版本是 0.0.340（应该是现在的最新版本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Name: langchain</span><br><span class="line">Version: 0.0.340</span><br><span class="line">Summary: Building applications with LLMs through composability</span><br></pre></td></tr></table></figure><p>其中 <code>validate_template</code> 参数的默认值是 <code>FALSE</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">validate_template: <span class="built_in">bool</span> = <span class="literal">False</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;Whether or not to try validating the template.&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><br>如果直接使用 `from_template` 则会自动识别参数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template = <span class="string">&quot;我学习&#123;tool&#125;是因为&#123;reason&#125;.&quot;</span></span><br><span class="line">prompt_template = PromptTemplate.from_template(template)</span><br><span class="line"><span class="built_in">print</span>(prompt_template)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt; input_variables=[&#x27;reason&#x27;, &#x27;tool&#x27;] template=&#x27;我学习&#123;tool&#125;是因为&#123;reason&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="格式模板输出"><a href="#格式模板输出" class="headerlink" title="格式模板输出"></a>格式模板输出</h1><p>格式方法的输出可作为字符串、消息列表和 <code>ChatPromptValue</code> 使用</p><p>以下面 template 为例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># system message</span></span><br><span class="line">template = <span class="string">&quot;You are a helpful assistant that translates &#123;input_language&#125; to &#123;output_language&#125;.&quot;</span></span><br><span class="line">system_message_prompt = SystemMessagePromptTemplate.from_template(template)</span><br><span class="line"></span><br><span class="line"><span class="comment"># human message</span></span><br><span class="line">human_template = <span class="string">&quot;&#123;text&#125;&quot;</span></span><br><span class="line">human_message_prompt = HumanMessagePromptTemplate.from_template(human_template)</span><br><span class="line"></span><br><span class="line">chat_prompt = ChatPromptTemplate.from_messages([system_message_prompt, human_message_prompt])</span><br></pre></td></tr></table></figure><p><strong>字符串</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># format</span></span><br><span class="line">result = chat_prompt.<span class="built_in">format</span>(input_language=<span class="string">&quot;English&quot;</span>, output_language=<span class="string">&quot;French&quot;</span>, text=<span class="string">&quot;I love programming.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者 format_prompt 后 to_string</span></span><br><span class="line">result = chat_prompt.format_prompt(input_language=<span class="string">&quot;English&quot;</span>, output_language=<span class="string">&quot;French&quot;</span>, text=<span class="string">&quot;I love programming.&quot;</span>).to_string()</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt; System: You are a helpful assistant that translates English to French.\nHuman: I love programming.</span></span><br></pre></td></tr></table></figure><p><strong>消息列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># format_messages</span></span><br><span class="line">result = chat_prompt.format_messages(input_language=<span class="string">&quot;English&quot;</span>, output_language=<span class="string">&quot;French&quot;</span>, text=<span class="string">&quot;I love programming.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># format_prompt 后 to_messages</span></span><br><span class="line">result = chat_prompt.format_prompt(input_language=<span class="string">&quot;English&quot;</span>, output_language=<span class="string">&quot;French&quot;</span>, text=<span class="string">&quot;I love programming.&quot;</span>).to_messages()</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt;  [SystemMessage(content=&#x27;You are a helpful assistant that translates English to French.&#x27;, additional_kwargs=&#123;&#125;),\nHumanMessage(content=&#x27;I love programming.&#x27;, additional_kwargs=&#123;&#125;)]</span></span><br></pre></td></tr></table></figure><p><strong>ChatPromptValue</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = chat_prompt.format_prompt(input_language=<span class="string">&quot;English&quot;</span>, output_language=<span class="string">&quot;French&quot;</span>, text=<span class="string">&quot;I love programming.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt; ChatPromptValue(messages=[SystemMessage(content=&#x27;You are a helpful assistant that translates English to French.&#x27;, additional_kwargs=&#123;&#125;), HumanMessage(content=&#x27;I love programming.&#x27;, additional_kwargs=&#123;&#125;)])</span></span><br></pre></td></tr></table></figure><h1 id="部分格式化"><a href="#部分格式化" class="headerlink" title="部分格式化"></a>部分格式化</h1><p>模板中的 <code>input_variables</code> 不一定需要一次全部格式化完成，可以传入所需值的子集，以创建仅期望剩余子集值的新提示模板</p><p>LangChain 提供了两种方式来支持这种操作：</p><ul><li>使用字符串值进行部分格式化</li><li>使用返回字符串值的函数进行部分格式化</li></ul><br><p><strong>使用字符串值</strong></p><p>假设有一个模板拥有两个输入变量 <code>a</code> 和 <code>b</code>，如果在链组件中早期获得了 <code>a</code> 的值，但稍后才获得 <code>b</code> 的值，那么等到两个变量在同一个位置时将它们传递给提示模板可能会很麻烦</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prompt = PromptTemplate(template=<span class="string">&quot;&#123;a&#125;&#123;b&#125;&quot;</span>, input_variables=[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>])</span><br><span class="line">partial_prompt = prompt.partial(a=<span class="string">&quot;[param-a]&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(partial_prompt)</span><br><span class="line"><span class="built_in">print</span>(partial_prompt.<span class="built_in">format</span>(b=<span class="string">&quot;[param-b]&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt; input_variables=[&#x27;b&#x27;] partial_variables=&#123;&#x27;a&#x27;: &#x27;[param-a]&#x27;&#125; template=&#x27;&#123;a&#125;&#123;b&#125;&#x27;</span></span><br><span class="line"><span class="comment"># &gt;&gt; [param-a][param-b]</span></span><br></pre></td></tr></table></figure><p>还可以直接使用 <code>partial_variables</code> 变量初始化提示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt = PromptTemplate(template=<span class="string">&quot;&#123;a&#125;&#123;b&#125;&quot;</span>,partial_variables=&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;[param-a]&#x27;</span>&#125;,input_variables=[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>])</span><br></pre></td></tr></table></figure><br><p><strong>使用函数</strong></p><p>典型的例子是日期或时间，使用一个始终返回当前日期的函数来部分填充提示非常方便</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_get_datetime</span>():</span><br><span class="line">    now = datetime.now()</span><br><span class="line">    <span class="keyword">return</span> now.strftime(<span class="string">&quot;【%Y/%m/%d】&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">prompt = PromptTemplate(</span><br><span class="line">    template=<span class="string">&quot;告诉我一个&#123;adjective&#125;关于&#123;date&#125;日期的笑话&quot;</span>, </span><br><span class="line">    input_variables=[<span class="string">&quot;adjective&quot;</span>, <span class="string">&quot;date&quot;</span>]</span><br><span class="line">)</span><br><span class="line">partial_prompt = prompt.partial(date=_get_datetime)</span><br><span class="line"><span class="built_in">print</span>(partial_prompt.<span class="built_in">format</span>(adjective=<span class="string">&quot;有趣的&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt; 告诉我一个有趣的关于【2023/11/28】日期的笑话</span></span><br></pre></td></tr></table></figure><h1 id="少量示例提示模板"><a href="#少量示例提示模板" class="headerlink" title="少量示例提示模板"></a>少量示例提示模板</h1><p><strong>创建一个示例集</strong></p><p>每个示例应该是一个字典，其中键是输入变量，值是这些输入变量的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">examples = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;question&quot;</span>: <span class="string">&quot;Who lived longer, Muhammad Ali or Alan Turing?&quot;</span>,</span><br><span class="line">    <span class="string">&quot;answer&quot;</span>: </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Are follow up questions needed here: Yes.</span></span><br><span class="line"><span class="string">Follow up: How old was Muhammad Ali when he died?</span></span><br><span class="line"><span class="string">Intermediate answer: Muhammad Ali was 74 years old when he died.</span></span><br><span class="line"><span class="string">Follow up: How old was Alan Turing when he died?</span></span><br><span class="line"><span class="string">Intermediate answer: Alan Turing was 41 years old when he died.</span></span><br><span class="line"><span class="string">So the final answer is: Muhammad Ali</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;question&quot;</span>: <span class="string">&quot;When was the founder of craigslist born?&quot;</span>,</span><br><span class="line">    <span class="string">&quot;answer&quot;</span>: </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Are follow up questions needed here: Yes.</span></span><br><span class="line"><span class="string">Follow up: Who was the founder of craigslist?</span></span><br><span class="line"><span class="string">Intermediate answer: Craigslist was founded by Craig Newmark.</span></span><br><span class="line"><span class="string">Follow up: When was Craig Newmark born?</span></span><br><span class="line"><span class="string">Intermediate answer: Craig Newmark was born on December 6, 1952.</span></span><br><span class="line"><span class="string">So the final answer is: December 6, 1952</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;question&quot;</span>: <span class="string">&quot;Who was the maternal grandfather of George Washington?&quot;</span>,</span><br><span class="line">    <span class="string">&quot;answer&quot;</span>:</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Are follow up questions needed here: Yes.</span></span><br><span class="line"><span class="string">Follow up: Who was the mother of George Washington?</span></span><br><span class="line"><span class="string">Intermediate answer: The mother of George Washington was Mary Ball Washington.</span></span><br><span class="line"><span class="string">Follow up: Who was the father of Mary Ball Washington?</span></span><br><span class="line"><span class="string">Intermediate answer: The father of Mary Ball Washington was Joseph Ball.</span></span><br><span class="line"><span class="string">So the final answer is: Joseph Ball</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;question&quot;</span>: <span class="string">&quot;Are both the directors of Jaws and Casino Royale from the same country?&quot;</span>,</span><br><span class="line">    <span class="string">&quot;answer&quot;</span>:</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Are follow up questions needed here: Yes.</span></span><br><span class="line"><span class="string">Follow up: Who is the director of Jaws?</span></span><br><span class="line"><span class="string">Intermediate Answer: The director of Jaws is Steven Spielberg.</span></span><br><span class="line"><span class="string">Follow up: Where is Steven Spielberg from?</span></span><br><span class="line"><span class="string">Intermediate Answer: The United States.</span></span><br><span class="line"><span class="string">Follow up: Who is the director of Casino Royale?</span></span><br><span class="line"><span class="string">Intermediate Answer: The director of Casino Royale is Martin Campbell.</span></span><br><span class="line"><span class="string">Follow up: Where is Martin Campbell from?</span></span><br><span class="line"><span class="string">Intermediate Answer: New Zealand.</span></span><br><span class="line"><span class="string">So the final answer is: No</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>创建少量示例的格式化程序</strong></p><p>配置一个将少量示例格式化为字符串的格式化程序，该程序是一个 <code>PromptTemplate</code> 对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example_prompt = PromptTemplate(input_variables=[<span class="string">&quot;question&quot;</span>, <span class="string">&quot;answer&quot;</span>], template=<span class="string">&quot;Question: &#123;question&#125;\nAnswer: &#123;answer&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(example_prompt.<span class="built_in">format</span>(**examples[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Question: Who lived longer, Muhammad Ali <span class="keyword">or</span> Alan Turing?</span><br><span class="line">Answer:</span><br><span class="line">            <span class="keyword">Are</span> follow up questions needed here: Yes.</span><br><span class="line">            Follow up: How <span class="keyword">old</span> was Muhammad Ali <span class="keyword">when</span> he died?</span><br><span class="line">            Intermediate answer: Muhammad Ali was <span class="number">74</span> years <span class="keyword">old</span> <span class="keyword">when</span> he died.</span><br><span class="line">            Follow up: How <span class="keyword">old</span> was Alan Turing <span class="keyword">when</span> he died?</span><br><span class="line">            Intermediate answer: Alan Turing was <span class="number">41</span> years <span class="keyword">old</span> <span class="keyword">when</span> he died.</span><br><span class="line">            So the <span class="keyword">final</span> answer <span class="keyword">is</span>: Muhammad Ali</span><br></pre></td></tr></table></figure><p><strong>将示例和格式化程序提供给 <code>FewShotPromptTemplate</code></strong></p><p>创建一个 <code>FewShotPromptTemplate</code> 对象，该对象接受少量示例和少量示例的格式化程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">prompt = FewShotPromptTemplate(</span><br><span class="line">    examples=examples, </span><br><span class="line">    example_prompt=example_prompt, </span><br><span class="line">    suffix=<span class="string">&quot;Question: &#123;input&#125;&quot;</span>, </span><br><span class="line">    input_variables=[<span class="string">&quot;input&quot;</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(prompt.<span class="built_in">format</span>(<span class="built_in">input</span>=<span class="string">&quot;Who was the father of Mary Ball Washington?&quot;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Question:</span> <span class="string">Who</span> <span class="string">lived</span> <span class="string">longer,</span> <span class="string">Muhammad</span> <span class="string">Ali</span> <span class="string">or</span> <span class="string">Alan</span> <span class="string">Turing?</span></span><br><span class="line"><span class="attr">Answer:</span></span><br><span class="line">            <span class="attr">Are follow up questions needed here:</span> <span class="string">Yes.</span></span><br><span class="line">            <span class="attr">Follow up:</span> <span class="string">How</span> <span class="string">old</span> <span class="string">was</span> <span class="string">Muhammad</span> <span class="string">Ali</span> <span class="string">when</span> <span class="string">he</span> <span class="string">died?</span></span><br><span class="line">            <span class="attr">Intermediate answer:</span> <span class="string">Muhammad</span> <span class="string">Ali</span> <span class="string">was</span> <span class="number">74</span> <span class="string">years</span> <span class="string">old</span> <span class="string">when</span> <span class="string">he</span> <span class="string">died.</span></span><br><span class="line">            <span class="attr">Follow up:</span> <span class="string">How</span> <span class="string">old</span> <span class="string">was</span> <span class="string">Alan</span> <span class="string">Turing</span> <span class="string">when</span> <span class="string">he</span> <span class="string">died?</span></span><br><span class="line">            <span class="attr">Intermediate answer:</span> <span class="string">Alan</span> <span class="string">Turing</span> <span class="string">was</span> <span class="number">41</span> <span class="string">years</span> <span class="string">old</span> <span class="string">when</span> <span class="string">he</span> <span class="string">died.</span></span><br><span class="line">            <span class="attr">So the final answer is:</span> <span class="string">Muhammad</span> <span class="string">Ali</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="attr">Question:</span> <span class="string">When</span> <span class="string">was</span> <span class="string">the</span> <span class="string">founder</span> <span class="string">of</span> <span class="string">craigslist</span> <span class="string">born?</span></span><br><span class="line"><span class="attr">Answer:</span></span><br><span class="line">            <span class="attr">Are follow up questions needed here:</span> <span class="string">Yes.</span></span><br><span class="line">            <span class="attr">Follow up:</span> <span class="string">Who</span> <span class="string">was</span> <span class="string">the</span> <span class="string">founder</span> <span class="string">of</span> <span class="string">craigslist?</span></span><br><span class="line">            <span class="attr">Intermediate answer:</span> <span class="string">Craigslist</span> <span class="string">was</span> <span class="string">founded</span> <span class="string">by</span> <span class="string">Craig</span> <span class="string">Newmark.</span></span><br><span class="line">            <span class="attr">Follow up:</span> <span class="string">When</span> <span class="string">was</span> <span class="string">Craig</span> <span class="string">Newmark</span> <span class="string">born?</span></span><br><span class="line">            <span class="attr">Intermediate answer:</span> <span class="string">Craig</span> <span class="string">Newmark</span> <span class="string">was</span> <span class="string">born</span> <span class="string">on</span> <span class="string">December</span> <span class="number">6</span><span class="string">,</span> <span class="number">1952</span><span class="string">.</span></span><br><span class="line">            <span class="attr">So the final answer is:</span> <span class="string">December</span> <span class="number">6</span><span class="string">,</span> <span class="number">1952</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="attr">Question:</span> <span class="string">Who</span> <span class="string">was</span> <span class="string">the</span> <span class="string">maternal</span> <span class="string">grandfather</span> <span class="string">of</span> <span class="string">George</span> <span class="string">Washington?</span></span><br><span class="line"><span class="attr">Answer:</span></span><br><span class="line">            <span class="attr">Are follow up questions needed here:</span> <span class="string">Yes.</span></span><br><span class="line">            <span class="attr">Follow up:</span> <span class="string">Who</span> <span class="string">was</span> <span class="string">the</span> <span class="string">mother</span> <span class="string">of</span> <span class="string">George</span> <span class="string">Washington?</span></span><br><span class="line">            <span class="attr">Intermediate answer:</span> <span class="string">The</span> <span class="string">mother</span> <span class="string">of</span> <span class="string">George</span> <span class="string">Washington</span> <span class="string">was</span> <span class="string">Mary</span> <span class="string">Ball</span> <span class="string">Washington.</span></span><br><span class="line">            <span class="attr">Follow up:</span> <span class="string">Who</span> <span class="string">was</span> <span class="string">the</span> <span class="string">father</span> <span class="string">of</span> <span class="string">Mary</span> <span class="string">Ball</span> <span class="string">Washington?</span></span><br><span class="line">            <span class="attr">Intermediate answer:</span> <span class="string">The</span> <span class="string">father</span> <span class="string">of</span> <span class="string">Mary</span> <span class="string">Ball</span> <span class="string">Washington</span> <span class="string">was</span> <span class="string">Joseph</span> <span class="string">Ball.</span></span><br><span class="line">            <span class="attr">So the final answer is:</span> <span class="string">Joseph</span> <span class="string">Ball</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="attr">Question:</span> <span class="string">Are</span> <span class="string">both</span> <span class="string">the</span> <span class="string">directors</span> <span class="string">of</span> <span class="string">Jaws</span> <span class="string">and</span> <span class="string">Casino</span> <span class="string">Royale</span> <span class="string">from</span> <span class="string">the</span> <span class="string">same</span> <span class="string">country?</span></span><br><span class="line"><span class="attr">Answer:</span></span><br><span class="line">            <span class="attr">Are follow up questions needed here:</span> <span class="string">Yes.</span></span><br><span class="line">            <span class="attr">Follow up:</span> <span class="string">Who</span> <span class="string">is</span> <span class="string">the</span> <span class="string">director</span> <span class="string">of</span> <span class="string">Jaws?</span></span><br><span class="line">            <span class="attr">Intermediate Answer:</span> <span class="string">The</span> <span class="string">director</span> <span class="string">of</span> <span class="string">Jaws</span> <span class="string">is</span> <span class="string">Steven</span> <span class="string">Spielberg.</span></span><br><span class="line">            <span class="attr">Follow up:</span> <span class="string">Where</span> <span class="string">is</span> <span class="string">Steven</span> <span class="string">Spielberg</span> <span class="string">from?</span></span><br><span class="line">            <span class="attr">Intermediate Answer:</span> <span class="string">The</span> <span class="string">United</span> <span class="string">States.</span></span><br><span class="line">            <span class="attr">Follow up:</span> <span class="string">Who</span> <span class="string">is</span> <span class="string">the</span> <span class="string">director</span> <span class="string">of</span> <span class="string">Casino</span> <span class="string">Royale?</span></span><br><span class="line">            <span class="attr">Intermediate Answer:</span> <span class="string">The</span> <span class="string">director</span> <span class="string">of</span> <span class="string">Casino</span> <span class="string">Royale</span> <span class="string">is</span> <span class="string">Martin</span> <span class="string">Campbell.</span></span><br><span class="line">            <span class="attr">Follow up:</span> <span class="string">Where</span> <span class="string">is</span> <span class="string">Martin</span> <span class="string">Campbell</span> <span class="string">from?</span></span><br><span class="line">            <span class="attr">Intermediate Answer:</span> <span class="string">New</span> <span class="string">Zealand.</span></span><br><span class="line">            <span class="attr">So the final answer is:</span> <span class="literal">No</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="attr">Question:</span> <span class="string">Who</span> <span class="string">was</span> <span class="string">the</span> <span class="string">father</span> <span class="string">of</span> <span class="string">Mary</span> <span class="string">Ball</span> <span class="string">Washington?</span></span><br></pre></td></tr></table></figure><h1 id="少量示例-chat-提示模板"><a href="#少量示例-chat-提示模板" class="headerlink" title="少量示例 chat 提示模板"></a>少量示例 chat 提示模板</h1><p>关于如何最好地使用少样本提示，还没有确定的共识，还没有对此进行任何抽象的确定（我理解是如何在对话类型下表现提示还没有确定的模式）</p><p>文档提供了两种形式：</p><ul><li>AI 和人类消息交替</li><li>系统消息</li></ul><p><strong>AI 和人类消息交替</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 系统消息</span></span><br><span class="line">template = <span class="string">&quot;你是一个乐于助人的助手，能把汉语翻译成猫语&quot;</span></span><br><span class="line">system_message_prompt = SystemMessagePromptTemplate.from_template(template)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例对话</span></span><br><span class="line">example_human = HumanMessagePromptTemplate.from_template(<span class="string">&quot;你好&quot;</span>)</span><br><span class="line">example_ai = AIMessagePromptTemplate.from_template(<span class="string">&quot;喵喵~&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 人类输入对话</span></span><br><span class="line">human_template = <span class="string">&quot;&#123;text&#125;&quot;</span></span><br><span class="line">human_message_prompt = HumanMessagePromptTemplate.from_template(human_template)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合 ChatPromptTemplate</span></span><br><span class="line">chat_prompt = ChatPromptTemplate.from_messages(</span><br><span class="line">    [system_message_prompt, example_human, example_ai, human_message_prompt]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># format</span></span><br><span class="line">chat_prompt.<span class="built_in">format</span>(text = <span class="string">&quot;晚上好&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(chat_prompt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt; input_variables=[&#x27;text&#x27;] messages=[SystemMessagePromptTemplate(prompt=PromptTemplate(input_variables=[], template=&#x27;你是一个乐于助人的助手，能把汉语翻译成猫语&#x27;)), HumanMessagePromptTemplate(prompt=PromptTemplate(input_variables=[], template=&#x27;你好&#x27;)), AIMessagePromptTemplate(prompt=PromptTemplate(input_variables=[], template=&#x27;喵喵~&#x27;)), HumanMessagePromptTemplate(prompt=PromptTemplate(input_variables=[&#x27;text&#x27;], template=&#x27;&#123;text&#125;&#x27;))]</span></span><br></pre></td></tr></table></figure><br><p><strong>系统消息</strong></p><p>OpenAI 提供了一个可选的 <code>name</code> 参数，他们建议与系统消息一起使用来进行少样本提示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template = <span class="string">&quot;你是一个乐于助人的助手，能把汉语翻译成猫语&quot;</span></span><br><span class="line">system_message_prompt = SystemMessagePromptTemplate.from_template(template)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 区别在这里</span></span><br><span class="line"><span class="comment"># 相当于使用系统消息的 name 区分出示例内容</span></span><br><span class="line">example_human = SystemMessagePromptTemplate.from_template(</span><br><span class="line">    <span class="string">&quot;你好&quot;</span>, additional_kwargs=&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;示例-用户&quot;</span>&#125;</span><br><span class="line">)</span><br><span class="line">example_ai = SystemMessagePromptTemplate.from_template(</span><br><span class="line">    <span class="string">&quot;喵喵~&quot;</span>, additional_kwargs=&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;示例-AI&quot;</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">human_template = <span class="string">&quot;&#123;text&#125;&quot;</span></span><br><span class="line">human_message_prompt = HumanMessagePromptTemplate.from_template(human_template)</span><br><span class="line">chat_prompt = ChatPromptTemplate.from_messages(</span><br><span class="line">    [system_message_prompt, example_human, example_ai, human_message_prompt]</span><br><span class="line">)</span><br><span class="line">chat_prompt.<span class="built_in">format</span>(text = <span class="string">&quot;晚上好&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(chat_prompt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt; input_variables=[&#x27;text&#x27;] messages=[SystemMessagePromptTemplate(prompt=PromptTemplate(input_variables=[], template=&#x27;你是一个乐于助人的助手，能把汉语翻译成猫语&#x27;)), SystemMessagePromptTemplate(prompt=PromptTemplate(input_variables=[], template=&#x27;你好&#x27;), additional_kwargs=&#123;&#x27;name&#x27;: &#x27;示例-用户&#x27;&#125;), SystemMessagePromptTemplate(prompt=PromptTemplate(input_variables=[], template=&#x27;喵喵~&#x27;), additional_kwargs=&#123;&#x27;name&#x27;: &#x27;示例-AI&#x27;&#125;), HumanMessagePromptTemplate(prompt=PromptTemplate(input_variables=[&#x27;text&#x27;], template=&#x27;&#123;text&#125;&#x27;))]</span></span><br></pre></td></tr></table></figure><h1 id="消息提示模板类型"><a href="#消息提示模板类型" class="headerlink" title="消息提示模板类型"></a>消息提示模板类型</h1><p>LangChain 提供了不同类型的 <code>MessagePromptTemplate</code></p><p>最常用的：</p><ul><li>AIMessagePromptTemplate：AI 消息</li><li>SystemMessagePromptTemplate：系统消息</li><li>HumanMessagePromptTemplate：人工消息</li><li>ChatMessagePromptTemplate：指定角色名消息</li></ul><p><strong>ChatMessagePromptTemplate</strong></p><p>对话模型支持使用任意角色的情况下可以使用 <code>ChatMessagePromptTemplate</code>，该模板允许用户指定角色名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> ChatMessagePromptTemplate</span><br><span class="line"></span><br><span class="line">prompt = <span class="string">&quot;感受这被囚禁了一万年的&#123;subject&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">chat_message_prompt = ChatMessagePromptTemplate.from_template(role=<span class="string">&quot;伊利丹&quot;</span>, template=prompt)</span><br><span class="line"><span class="built_in">print</span>(chat_message_prompt.<span class="built_in">format</span>(subject=<span class="string">&quot;怒火&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt; content=&#x27;感受这被囚禁了一万年的怒火&#x27; role=&#x27;伊利丹&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>MessagesPlaceholder</strong></p><p><code>MessagesPlaceholder</code> 可以完全控制格式化过程中要呈现的消息</p><p>适用于在格式化过程中插入消息列表时（理解为一组消息的占位符）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">human_prompt = <span class="string">&quot;用&#123;count&#125;个词语概括我们迄今为止的对话质量&quot;</span></span><br><span class="line">human_message_template = HumanMessagePromptTemplate.from_template(human_prompt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 占位消息，name = conversation</span></span><br><span class="line">chat_prompt = ChatPromptTemplate.from_messages([MessagesPlaceholder(variable_name=<span class="string">&quot;conversation&quot;</span>), human_message_template])</span><br><span class="line"><span class="built_in">print</span>(chat_prompt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt; input_variables=[&#x27;conversation&#x27;, &#x27;count&#x27;] input_types=&#123;&#x27;conversation&#x27;: typing.List[typing.Union[langchain.schema.messages.AIMessage, langchain.schema.messages.HumanMessage, langchain.schema.messages.ChatMessage, langchain.schema.messages.SystemMessage, langchain.schema.messages.FunctionMessage, langchain.schema.messages.ToolMessage]]&#125; messages=[MessagesPlaceholder(variable_name=&#x27;conversation&#x27;), HumanMessagePromptTemplate(prompt=PromptTemplate(input_variables=[&#x27;count&#x27;], template=&#x27;用&#123;count&#125;个词语概括我们迄今为止的对话质量&#x27;))]</span></span><br></pre></td></tr></table></figure><p>针对 <code>conversation</code> 占位消息填充真正的消息内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">human_message = HumanMessage(content=<span class="string">&quot;学习编程最好的方式是什么&quot;</span>)</span><br><span class="line">ai_message = AIMessage(content=</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1. 选择一种编程语言：决定你想学习的编程语言</span></span><br><span class="line"><span class="string">2. 从基础知识开始：熟悉变量、数据类型和控制结构等基本编程概念</span></span><br><span class="line"><span class="string">3. 实践，实践，实践：学习编程的最佳方式是亲身体验</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">result = chat_prompt.format_prompt(conversation=[human_message, ai_message], count=<span class="string">&quot;3&quot;</span>).to_messages()</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt; [HumanMessage(content=&#x27;学习编程最好的方式是什么&#x27;), AIMessage(content=&#x27;\n1. 选择一种编程语言：决定你想学习的编程语言\n2. 从基础知识开始：熟悉变量、数据类型和控制结构等基本编程概念\n3. 实践，实践，实践：学习编程的最佳方式是亲身体验\n&#x27;), HumanMessage(content=&#x27;用3个词语概括我们迄今为止的对话质量&#x27;)]</span></span><br></pre></td></tr></table></figure><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>提示的序列化可以方便地共享、存储和版本化提示</p><p>在高层次上，序列化遵循以下设计原则：</p><ul><li>支持 JSON 和 YAML；希望支持人类在磁盘上可读的序列化方法</li><li>支持将所有内容都存储在一个文件中，或者将不同的组件（模板、示例等）存储在不同的文件中并进行引用；这也场景可以进行拆分，如长模板、大型示例、可复用组件等</li></ul><p>通过以下唯一的一个入口进行加载</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有的提示都通过 `load_prompt` 函数加载</span></span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> load_prompt</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">_type:</span> <span class="string">prompt</span></span><br><span class="line"></span><br><span class="line"><span class="attr">input_variables:</span></span><br><span class="line"></span><br><span class="line">    [<span class="string">&quot;adjective&quot;</span>, <span class="string">&quot;content&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">template:</span> </span><br><span class="line"></span><br><span class="line">    <span class="string">Tell</span> <span class="string">me</span> <span class="string">a</span> &#123;<span class="string">adjective</span>&#125; <span class="string">joke</span> <span class="string">about</span> &#123;<span class="string">content</span>&#125;<span class="string">.</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prompt = load_prompt(<span class="string">&quot;simple_prompt.yaml&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(prompt.<span class="built_in">format</span>(adjective=<span class="string">&quot;funny&quot;</span>, content=<span class="string">&quot;chickens&quot;</span>))</span><br></pre></td></tr></table></figure><p>更多的使用示例可以查看文档 <a href="https://python.langchain.com.cn/docs/modules/model_io/prompts/prompt_templates/prompt_serialization#prompttempalte-with-outputparser">序列化 （Serialization） | 🦜️🔗 Langchain</a></p><h1 id="管道提示进行组合"><a href="#管道提示进行组合" class="headerlink" title="管道提示进行组合"></a>管道提示进行组合</h1><p>想要重用提示的部分时，可以通过 <code>PipelinePrompt</code> 来实现</p><p><code>PipelinePrompt</code> 由两个主要部分组成：</p><ul><li>最终提示：返回的最终提示</li><li>管道提示：由一个字符串名称和一个提示模板组成的元组列表；每个提示模板将被格式化，然后作为相同名称的变量传递给未来的提示模板</li></ul><p><strong>定义最终提示</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">full_template = <span class="string">&quot;&quot;&quot;&#123;introduction&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;example&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;start&#125;&quot;&quot;&quot;</span></span><br><span class="line">full_prompt = PromptTemplate.from_template(full_template)</span><br></pre></td></tr></table></figure><p><strong>introduction 提示</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">introduction_template = <span class="string">&quot;&quot;&quot;你在模仿&#123;person&#125;&quot;&quot;&quot;</span></span><br><span class="line">introduction_prompt = PromptTemplate.from_template(introduction_template)</span><br></pre></td></tr></table></figure><p><strong>example 提示</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">example_template = <span class="string">&quot;&quot;&quot;下面是一个交互的示例：</span></span><br><span class="line"><span class="string">Q: &#123;example_q&#125;</span></span><br><span class="line"><span class="string">A: &#123;example_a&#125;&quot;&quot;&quot;</span></span><br><span class="line">example_prompt = PromptTemplate.from_template(example_template)</span><br></pre></td></tr></table></figure><p><strong>start 提示</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start_template = <span class="string">&quot;&quot;&quot;现在开始这么做！</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Q: &#123;question&#125;</span></span><br><span class="line"><span class="string">A:&quot;&quot;&quot;</span></span><br><span class="line">start_prompt = PromptTemplate.from_template(start_template)</span><br></pre></td></tr></table></figure><p><strong>通过 PipelinePrompt 组装</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">input_prompts = [</span><br><span class="line">    (<span class="string">&quot;introduction&quot;</span>, introduction_prompt),</span><br><span class="line">    (<span class="string">&quot;example&quot;</span>, example_prompt),</span><br><span class="line">    (<span class="string">&quot;start&quot;</span>, start_prompt)</span><br><span class="line">]</span><br><span class="line">pipeline_prompt = PipelinePromptTemplate(final_prompt=full_prompt, pipeline_prompts=input_prompts)</span><br></pre></td></tr></table></figure><p><strong>format PipelinePrompt</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(pipeline_prompt.<span class="built_in">format</span>(</span><br><span class="line">    person=<span class="string">&quot;雷军&quot;</span>,</span><br><span class="line">    example_q=<span class="string">&quot;你最喜欢的手机品牌是什么？&quot;</span>,</span><br><span class="line">    example_a=<span class="string">&quot;小米&quot;</span>,</span><br><span class="line">    question=<span class="string">&quot;你最喜欢的杀毒软件是什么？&quot;</span></span><br><span class="line">))</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">You are impersonating Elon Musk.</span><br><span class="line">Her<span class="string">e&#x27;s an example of an interaction: </span></span><br><span class="line"><span class="string">Q: What&#x27;</span>s your favorite car?</span><br><span class="line">A: Telsa</span><br><span class="line">Now, <span class="keyword">do</span> this <span class="keyword">for</span> <span class="type">real</span>!</span><br><span class="line"></span><br><span class="line">Q: What<span class="string">&#x27;s your favorite social media site?</span></span><br><span class="line"><span class="string">A:</span></span><br></pre></td></tr></table></figure><h1 id="自定义提示模板"><a href="#自定义提示模板" class="headerlink" title="自定义提示模板"></a>自定义提示模板</h1><p>自定义模板也分为两种类型：</p><ul><li>字符串提示模板</li><li>聊天提示模板</li></ul><p>在本指南中，我们将使用字符串提示模板创建自定义提示</p><p>要创建一个自定义的字符串提示模板，需要满足两个要求：</p><ul><li>它具有 <code>input_variables</code> 属性，公开了提示模板预期的输入变量</li><li>它公开了一个 <code>format</code> 方法，该方法接受与预期的 <code>input_variables</code> 相对应的关键字参数，并返回格式化后的提示</li></ul><p><strong>下面实现了构造分析函数源码的提示的模板</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> StringPromptTemplate</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> v1 <span class="keyword">as</span> pydantic_v1</span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FunctionExplainerPromptTemplate</span>(StringPromptTemplate, BaseModel):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;A custom prompt template that takes in the function name as input, and formats the prompt template to provide the source code of the function.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># input_variables</span></span><br><span class="line"><span class="meta">    @pydantic_v1.validator(<span class="params"><span class="string">&quot;input_variables&quot;</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validate_input_variables</span>(<span class="params">cls, v</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Validate that the input variables are correct.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(v) != <span class="number">1</span> <span class="keyword">or</span> <span class="string">&quot;function_name&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> v:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;function_name must be the only input_variable.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">    <span class="comment"># format</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">format</span>(<span class="params">self, **kwargs</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># Get the source code of the function</span></span><br><span class="line">        source_code = get_source_code(kwargs[<span class="string">&quot;function_name&quot;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Generate the prompt to be sent to the language model</span></span><br><span class="line">        prompt = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        给定函数名称和源码，生成函数的英文解释</span></span><br><span class="line"><span class="string">        函数名称: <span class="subst">&#123;kwargs[<span class="string">&quot;function_name&quot;</span>].__name__&#125;</span></span></span><br><span class="line"><span class="string">        源码:</span></span><br><span class="line"><span class="string">        <span class="subst">&#123;source_code&#125;</span></span></span><br><span class="line"><span class="string">        解释:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> prompt</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_prompt_type</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;function-explainer&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取源码字符串</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_source_code</span>(<span class="params">function_name</span>):</span><br><span class="line">    <span class="comment"># Get the source code of the function</span></span><br><span class="line">    <span class="keyword">return</span> inspect.getsource(function_name)</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn_explainer = FunctionExplainerPromptTemplate(input_variables=[<span class="string">&quot;function_name&quot;</span>])</span><br><span class="line"><span class="comment"># Generate a prompt for the function &quot;get_source_code&quot;</span></span><br><span class="line">prompt = fn_explainer.<span class="built_in">format</span>(function_name=get_source_code)</span><br><span class="line"><span class="built_in">print</span>(prompt)</span><br></pre></td></tr></table></figure><p>需要注意这里官方文档给的示例可能存在问题，报错信息</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> FunctionExplainerPromptTemplate(StringPromptTemplate, BaseModel):</span><br><span class="line">TypeError: metaclass <span class="keyword">conflict</span>: the metaclass <span class="keyword">of</span> a derived <span class="keyword">class</span> must be a (non-<span class="keyword">strict</span>) subclass <span class="keyword">of</span> the metaclasses <span class="keyword">of</span> <span class="keyword">all</span> its bases</span><br></pre></td></tr></table></figure><p>和 pydantic 库的版本有关，v2 版本下官方代码会存在不兼容问题，上面代码块使用 <code>from pydantic import v1 as pydantic_v1</code> 来指定了 v1 版本</p><p>Github 相关 issue：<a href="https://github.com/langchain-ai/langchain/issues/9702">DOC: Custom Templates issue with Pydantic v2 · Issue #9702 · langchain-ai&#x2F;langchain (github.com)</a></p><h1 id="特征存储"><a href="#特征存储" class="headerlink" title="特征存储"></a>特征存储</h1><p>特征存储是传统机器学习中的一个概念，确保输入模型的数据是最新的且相关的；有关更多信息，请参见：<a href="https://www.tecton.ai/blog/what-is-a-feature-store/">What Is a Feature Store? | Tecton</a></p><p>LangChain 提供了一种将这些数据与 LLMs 结合的简单方法</p><p>文档中展示如何将提示模板与特征存储连接起来，基本思想是在<strong>提示模板内部调用特征存储以检索值，然后将其格式化为提示</strong></p><p>LangChain 文档中对接如下特征存储工具：</p><ul><li>Feast：流行的开源特征存储框架</li><li>Tecton：完全托管的特征平台，专为协调完整的 ML 特征生命周期而构建，包括从转换到在线服务的全过程，并提供企业级的 SLA</li><li>Featureform：开源的、企业级的特征存储</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://python.langchain.com.cn/docs/modules/model_io/prompts/">提示(Prompts) | 🦜️🔗 Langchain</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> LangChain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> LangChain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LangChain 文档学习 No.1 - 快速开始</title>
      <link href="/%E5%BC%80%E5%8F%91/LangChain/LangChain%20%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%20No.1%20-%20%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B.html"/>
      <url>/%E5%BC%80%E5%8F%91/LangChain/LangChain%20%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%20No.1%20-%20%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B.html</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>LangChain</strong> 是一个基于语言模型开发应用程序的框架。它可以实现以下功能：</p><ul><li><strong>数据感知</strong>：将语言模型与其他数据源连接起来</li><li><strong>主体性</strong>：允许语言模型与其环境进行交互</li></ul><p>LangChain 的主要价值包括：</p><ol><li><strong>组件</strong>：用于处理语言模型的抽象，以及每个抽象的一系列实现。组件是模块化且易于使用的，无论您是否使用 LangChain 框架的其他部分，都可以轻松使用</li><li><strong>现成的管道</strong>：用于完成特定高级任务的结构化组件组合</li></ol><p>现成的管道使得入门变得容易。对于更复杂的应用程序和细致入微的用例，组件使得自定义现有管道或构建新管道变得容易</p><br><p>实践示例：</p><ul><li>聊天机器人</li><li>使用数据源回答问题（知识库）</li><li>分析结构化数据</li></ul><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>LangChain 为以下模块提供标准、可扩展的接口和外部集成（功能模块）</p><ul><li><strong>模型 I&#x2F;O</strong>：与语言模型进行接口</li><li><strong>检索</strong>：与特定于应用程序的数据进行接口</li><li><strong>管道</strong>：构建调用序列</li><li><strong>代理</strong>：让管道根据高级指令选择使用哪些工具</li><li><strong>内存</strong>：在管道运行期间保持应用程序状态</li><li><strong>回调</strong>：记录和流式传输任何管道的中间步骤</li></ul><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h2 id="LangChain"><a href="#LangChain" class="headerlink" title="LangChain"></a>LangChain</h2><p>LangChain Python 版本的安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install langchain </span><br></pre></td></tr></table></figure><h2 id="OpenAI"><a href="#OpenAI" class="headerlink" title="OpenAI"></a>OpenAI</h2><p>使用 LangChain 通常需要与一个或多个模型提供者、数据存储、API等进行集成</p><p>我们可以使用 OpenAI 的模型 API</p><p>本示例使用微软 Azure 的模型 API</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install openai</span><br></pre></td></tr></table></figure><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="构建模块"><a href="#构建模块" class="headerlink" title="构建模块"></a>构建模块</h2><p>LangChain 提供了许多可以用来构建语言模型应用程序的模块</p><p>这些模块可以作为简单应用程序中的独立模块使用，也可以组合在一起用于更复杂的用例</p><p>LangChain 应用程序的核心构建模块是 LLMChain，它结合了三个方面：</p><ul><li><strong>LLM</strong>（大语言模型）：语言模型是核心推理引擎；要使用 LangChain，您需要了解不同类型的语言模型以及如何使用它们</li><li><strong>Prompt Templates</strong>（提示词模板）：提供语言模型的指令；这控制了语言模型的输出，因此了解如何构建提示和不同的提示策略至关重要</li><li><strong>Output Parsers</strong>（输出解析器）：将 LLM 的原始响应转换为更易处理的格式，使得在下游使用输出变得容易</li></ul><h2 id="LLMs"><a href="#LLMs" class="headerlink" title="LLMs"></a>LLMs</h2><p>LangChain 中有两种类型的语言模型，称为：</p><ul><li><strong>LLMs</strong>：这是一个以字符串作为输入并返回字符串的语言模型</li><li><strong>ChatModels</strong>：这是一个以消息列表作为输入并返回消息的语言模型</li></ul><p>LLMs 的输入&#x2F;输出简单易懂，是字符串</p><p>但是 ChatModels 输入是一个 <code>ChatMessage</code> 列表，输出是一个单独的 <code>ChatMessage</code>，一个 <code>ChatMessage</code> 具有两个必需的组件：</p><ul><li><code>content</code>：这是消息的内容</li><li><code>role</code>：这是 <code>ChatMessage</code> 来自的实体的角色</li></ul><p>LangChain 提供了几个对象，用于方便地区分不同的角色：</p><ul><li><code>HumanMessage</code>：来自人类&#x2F;用户的 <code>ChatMessage</code></li><li><code>AIMessage</code>：来自AI&#x2F;助手的 <code>ChatMessage</code></li><li><code>SystemMessage</code>：来自系统的 <code>ChatMessage</code></li><li><code>FunctionMessage</code>：来自函数调用的 <code>ChatMessage</code></li></ul><p>如果这些角色都不合适，还可以使用 <code>ChatMessage</code> 类手动指定角色，有关如何最有效地使用这些不同的消息的更多信息，请参阅我们的提示指南</p><p>LangChain 为两者提供了一个标准接口，但了解这种差异以便为给定的语言模型构建提示非常有用<br>LangChain 提供的标准接口有两种方法：</p><ul><li><code>predict</code>：接受一个字符串，返回一个字符串</li><li><code>predict_messages</code>：接受一个消息列表，返回一个消息</li></ul><br><p>两者的区别，首先，让我们导入 LLM 和 ChatModel</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line">llm = OpenAI()</span><br><span class="line">chat_model = ChatOpenAI()</span><br><span class="line"></span><br><span class="line">llm.predict(<span class="string">&quot;hi!&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Hi&quot;</span></span><br><span class="line"></span><br><span class="line">chat_model.predict(<span class="string">&quot;hi!&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Hi&quot;</span></span><br></pre></td></tr></table></figure><p>使用 <code>predict</code> 方法对字符串输入进行处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">&quot;What would be a good company name for a company that makes colorful socks?&quot;</span></span><br><span class="line"></span><br><span class="line">llm.predict(text)</span><br><span class="line"><span class="comment"># &gt;&gt; Feetful of Fun</span></span><br><span class="line"></span><br><span class="line">chat_model.predict(text)</span><br><span class="line"><span class="comment"># &gt;&gt; Socks O&#x27;Color</span></span><br></pre></td></tr></table></figure><p>使用 <code>predict_messages</code> 方法对消息列表进行处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.schema <span class="keyword">import</span> HumanMessage</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;制造多彩袜子的公司的好名字是什么？&quot;</span></span><br><span class="line">messages = [HumanMessage(content=text)]</span><br><span class="line"></span><br><span class="line">llm.predict_messages(messages)</span><br><span class="line"><span class="comment"># &gt;&gt; Feetful of Fun</span></span><br><span class="line"></span><br><span class="line">chat_model.predict_messages(messages)</span><br><span class="line"><span class="comment"># &gt;&gt; Socks O&#x27;Color</span></span><br></pre></td></tr></table></figure><p>对于这两种方法，还可以将参数作为关键字参数传递，例如可以传入 <code>temperature=0</code> 来调整使用的温度，该温度将覆盖对象的配置</p><p>需要注意在运行时传入的任何值都将始终覆盖对象的配置</p><h2 id="AzureOpenAI-LLM"><a href="#AzureOpenAI-LLM" class="headerlink" title="AzureOpenAI LLM"></a>AzureOpenAI LLM</h2><p>本示例使用微软 Azure 的模型 API</p><p>可以参考官方文档 <a href="https://learn.microsoft.com/zh-cn/azure/machine-learning/prompt-flow/how-to-integrate-with-langchain?view=azureml-api-2">在提示流中与 LangChain 集成 - Azure Machine Learning | Microsoft Learn</a><br>或者 LangChain 的 LLM Integrations 文档 <a href="https://python.langchain.com.cn/docs/modules/model_io/models/llms/integrations/azure_openai_example">Azure OpenAI | 🦜️🔗 Langchain</a> | <a href="https://python.langchain.com.cn/docs/modules/model_io/models/chat/integrations/azure_chat_openai">Azure | 🦜️🔗 Langchain</a></p><p>创建 <code>LLM</code> 对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain.llms.openai <span class="keyword">import</span> AzureOpenAI</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_TYPE&quot;</span>] = <span class="string">&quot;azure&quot;</span></span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_VERSION&quot;</span>] = <span class="string">&quot;2023-03-15-preview&quot;</span></span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">llm = AzureOpenAI(</span><br><span class="line">    deployment_name=<span class="string">&quot;&quot;</span>,</span><br><span class="line">    azure_endpoint=<span class="string">&quot;&quot;</span>,</span><br><span class="line">    model_name=<span class="string">&quot;gpt-35-turbo-16k&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">result = llm.predict(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>这里可能会接收到错误的返回</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>&#x27;error&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span>&#x27;code&#x27;<span class="punctuation">:</span> &#x27;OperationNotSupported&#x27;<span class="punctuation">,</span> &#x27;message&#x27;<span class="punctuation">:</span> &#x27;The completion operation does not work with the specified model<span class="punctuation">,</span> gpt<span class="number">-35</span>-turbo<span class="number">-16</span>k. Please choose different model and try again. You can learn more about which models can be used with each operation here<span class="punctuation">:</span> https<span class="punctuation">:</span><span class="comment">//go.microsoft.com/fwlink/?linkid=2197993.&#x27;&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>原因是 <code>gpt-35-turbo-16k</code> 模型不能用于 <code>AzureOpenAI</code> 对象，应该使用 <code>AzureChatOpenAI</code>；我理解 Azure 的 AI 服务对文本处理（LangChain 中的 LLMs）和问答、聊天（LangChain 中的 ChatModels）做了区分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 AzureChatOpenAI</span></span><br><span class="line">llm = AzureChatOpenAI(</span><br><span class="line">    deployment_name=<span class="string">&quot;&quot;</span>,</span><br><span class="line">    azure_endpoint=<span class="string">&quot;&quot;</span>,</span><br><span class="line">    model_name=<span class="string">&quot;gpt-35-turbo-16k&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="提示模板"><a href="#提示模板" class="headerlink" title="提示模板"></a>提示模板</h2><p>提示模板可以将用户输入转化为完全格式化的提示的所有逻辑绑定在一起，下面是一个简单应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt = PromptTemplate.from_template(<span class="string">&quot;please tell me in which country is &#123;city_name&#125; located?&quot;</span>)</span><br><span class="line">text = prompt.<span class="built_in">format</span>(city_name=<span class="string">&quot;BeiJing&quot;</span>)</span><br><span class="line"><span class="comment"># text = please tell me in which country is BeiJing located?</span></span><br><span class="line">result = llm.predict(text)</span><br><span class="line"><span class="comment"># &gt;&gt; Beijing is located in China. </span></span><br></pre></td></tr></table></figure><p>提示模板不仅是用于将字符串进行格式化，主要的优势：</p><ul><li>多提示中抽出共同变量，只格式化一次</li><li>生成消息列表，系统消息、角色消息等</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template = <span class="string">&quot;You are a helpful assistant that translates &#123;input_language&#125; to &#123;output_language&#125;.&quot;</span></span><br><span class="line">system_message_prompt = SystemMessagePromptTemplate.from_template(template)</span><br><span class="line">human_template = <span class="string">&quot;&#123;text&#125;&quot;</span></span><br><span class="line">human_message_prompt = HumanMessagePromptTemplate.from_template(human_template)</span><br><span class="line">chat_prompt = ChatPromptTemplate.from_messages([system_message_prompt, human_message_prompt])</span><br><span class="line">messages = chat_prompt.format_messages(input_language=<span class="string">&quot;English&quot;</span>, output_language=<span class="string">&quot;French&quot;</span>, text=<span class="string">&quot;I love programming.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(messages)</span><br><span class="line"><span class="comment"># &gt;&gt; [SystemMessage(content=&#x27;You are a helpful assistant that translates English to French.&#x27;), HumanMessage(content=&#x27;I love programming.&#x27;)]</span></span><br></pre></td></tr></table></figure><p>更多详见后续提示词相关内容</p><h2 id="输出解析器"><a href="#输出解析器" class="headerlink" title="输出解析器"></a>输出解析器</h2><p><code>OutputParsers</code> 将 LLM 的原始输出转换为可以在下游使用的格式<br>输出解析器有几种主要类型：</p><ul><li>将 LLM 的文本转换为结构化信息（例如 JSON）</li><li>将 ChatMessage 转换为字符串</li><li>将除消息之外的其他信息（如 OpenAI 函数调用）转换为字符串</li></ul><p>官方例子中实现了一个<strong>将逗号分隔的列表转换为列表</strong>的解析器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.schema <span class="keyword">import</span> BaseOutputParser</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommaSeparatedListOutputParser</span>(<span class="title class_ inherited__">BaseOutputParser</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Parse the output of an LLM call to a comma-separated list.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, text: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Parse the output of an LLM call.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> text.strip().split(<span class="string">&quot;, &quot;</span>)</span><br><span class="line"></span><br><span class="line">CommaSeparatedListOutputParser().parse(<span class="string">&quot;hi, bye&quot;</span>)</span><br><span class="line"><span class="comment"># &gt;&gt; [&#x27;hi&#x27;, &#x27;bye&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="LLMChain"><a href="#LLMChain" class="headerlink" title="LLMChain"></a>LLMChain</h2><p>现在可以将所有这些组合成一个链组件</p><p>这个链组件将接收输入变量，将其传递给提示模板以创建提示，将提示传递给 LLM，然后通过一个（可选的）输出解析器将输出解析后输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> LLMChain</span><br><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> AzureChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.prompts.chat <span class="keyword">import</span> (</span><br><span class="line">    ChatPromptTemplate,</span><br><span class="line">    SystemMessagePromptTemplate,</span><br><span class="line">    HumanMessagePromptTemplate,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> langchain.schema <span class="keyword">import</span> BaseOutputParser</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommaSeparatedListOutputParser</span>(<span class="title class_ inherited__">BaseOutputParser</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Parse the output of an LLM call to a comma-separated list.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, text: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Parse the output of an LLM call.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> text.strip().split(<span class="string">&quot;, &quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_TYPE&quot;</span>] = <span class="string">&quot;azure&quot;</span></span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_VERSION&quot;</span>] = <span class="string">&quot;2023-03-15-preview&quot;</span></span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">chat_model = AzureChatOpenAI(</span><br><span class="line">    deployment_name=<span class="string">&quot;&quot;</span>,</span><br><span class="line">    azure_endpoint=<span class="string">&quot;&quot;</span>,</span><br><span class="line">    model_name=<span class="string">&quot;gpt-35-turbo-16k&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">template = <span class="string">&quot;&quot;&quot;You are a helpful assistant who generates comma separated lists.</span></span><br><span class="line"><span class="string">A user will pass in a category, and you should generate 5 objects in that category in a comma separated list.</span></span><br><span class="line"><span class="string">ONLY return a comma separated list, and nothing more.&quot;&quot;&quot;</span></span><br><span class="line">system_message_prompt = SystemMessagePromptTemplate.from_template(template)</span><br><span class="line">human_template = <span class="string">&quot;&#123;text&#125;&quot;</span></span><br><span class="line">human_message_prompt = HumanMessagePromptTemplate.from_template(human_template)</span><br><span class="line"></span><br><span class="line">chat_prompt = ChatPromptTemplate.from_messages([system_message_prompt, human_message_prompt])</span><br><span class="line">chain = LLMChain(</span><br><span class="line">    llm=chat_model,</span><br><span class="line">    prompt=chat_prompt,</span><br><span class="line">    output_parser=CommaSeparatedListOutputParser()</span><br><span class="line">)</span><br><span class="line">result = chain.run(<span class="string">&quot;DC super hero&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt; [&#x27;Superman&#x27;, &#x27;Batman&#x27;, &#x27;Wonder Woman&#x27;, &#x27;The Flash&#x27;, &#x27;Aquaman&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面的例子让 AI 成为一个输出 5 个指定分类下对象，并且使用逗号分隔的助手</p><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>本文介绍了如何创建 LangChain 应用程序的核心构建块 - LLMChains</p><p>在所有这些组件（LLMs、prompts、输出解析器）中还有很多微妙之处，会在后面持续学习</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://python.langchain.com.cn/docs/get_started/quickstart">快速入门 | 🦜️🔗 Langchain</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> LangChain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> LangChain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RECIPES - Neon City</title>
      <link href="/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/RECIPES%20-%20Neon%20City.html"/>
      <url>/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/RECIPES%20-%20Neon%20City.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://assets-prd.punchdrink.com/wp-content/uploads/2023/11/03141805/Vertical_NeonCity-500x688.jpg"></p><h1 id="霓虹都市-Neon-City"><a href="#霓虹都市-Neon-City" class="headerlink" title="霓虹都市 Neon City"></a>霓虹都市 Neon City</h1><p>在这场有趣的 highball 比赛中，Nine Bar 的老板 Lily Wang 和 Joe Briglio 展示了他们最喜欢的夏季美食之一的味道：意大利冰，尽管有一些意想不到的添加</p><p>Lily Wang 和 Joe Briglio 将 Nine Bar 描述为 “亚洲风格的鸡尾酒酒吧”，Neon City 以烧酒（shochu）为基础，辅以清酒（sake）、可尔必思（Calpico）和白酒（baijiu）</p><p>所有这些结合在一起形成了层次分明的基础，开胃利口酒和新鲜柠檬汁带来了饮料灵感中预期的浓郁柑橘味。Lily Wang 形容它 “让人耳目一新，有点时髦，拥有令人愉快的酸味”</p><h1 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h1><p><em>Serving: 1</em></p><ul><li>烧酒（最好是 Mizu Saga 大麦烧酒） - 1 盎司</li><li>清酒（最好是 Joto 柚子清酒） - 0.75 盎司</li><li>可尔必思 - 0.75 盎司</li><li>开胃利口酒（最好是 St. Agrestis Paradiso）- 0.5 盎司</li><li>白酒（最好是 Ming River） - 0.25 盎司</li><li>柠檬汁 - 0.25 盎司</li><li>Topo Chico - 加满</li></ul><p><strong>装饰</strong>：橙子片</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ul><li>将除 Topo Chico 外的所有原料放入加冰的海波杯中混合</li><li>加满 Topo Chico</li><li>用一片橙子片装饰</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="Ming-River-Baijiu"><a href="#Ming-River-Baijiu" class="headerlink" title="Ming River Baijiu"></a>Ming River Baijiu</h2><p>有意思的是这个 ”东方风格“ 的配方里用到了烧酒、清酒和白酒</p><p>白酒提到的 <em>Ming River</em>，中文名为明江白酒，是泸州老窖公司出品的一款海外产品，专门针对国外市场</p><p><a href="https://shopmingriver.com/">Welcome - Shop Ming River</a></p><p><a href="https://zhuanlan.zhihu.com/p/71534144">那些在ins上爆火的白酒！凭什么让外国人疯狂？</a></p><p>包装看起来确实比国内市场白酒更适合海外审美</p><p><img src="https://shopmingriver.com/wp-content/themes/shop-ming-river/images/header.jpg" alt="Ming River"></p><h2 id="Topo-Chico"><a href="#Topo-Chico" class="headerlink" title="Topo Chico"></a>Topo Chico</h2><p>Topo Chico 是一家墨西哥软饮料生产商，主要生产矿泉水，苏打饮料等；被可口可乐收购</p><blockquote><p>Topo Chico 气泡水长期以来被用于调制酒精饮料，这种和酒精的 “缘分” 也成为了 Topo Chico 硬苏打气泡酒的研发灵感</p><p>2020 年 10 月，可口可乐计划与啤酒巨头 Molson Coors 合作，于 2021 上半年在美国推出 Topo Chico 硬苏打气泡酒</p></blockquote><p><img src="https://image.9928.tv/UserFiles/tangjiuhui/20220414/20220414105716.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 宿醉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸡尾酒 </tag>
            
            <tag> recipes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分片不等于分布式</title>
      <link href="/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/%E5%88%86%E7%89%87%E4%B8%8D%E7%AD%89%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F.html"/>
      <url>/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/%E5%88%86%E7%89%87%E4%B8%8D%E7%AD%89%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<p>分片（sharding）是一种将数据和负载分布在几个独立数据库实例中的技术</p><p>该方法通过将原始数据集拆分为碎片（shards）来利用水平可伸缩性，然后将其分布在多个数据库实例中</p><img src="/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/%E5%88%86%E7%89%87%E4%B8%8D%E7%AD%89%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F/1yg3PV8O2RO4YegyiYeiItA.png" class="" title="img"><p>但是，即使动词 <em>distributes</em> 出现在分片的定义中，分片数据库也不是分布式数据库</p><h1 id="分片解决方案"><a href="#分片解决方案" class="headerlink" title="分片解决方案"></a>分片解决方案</h1><p>每个分片解决方案在其架构中都有一个至关重要的组件</p><p>该组件被定义为各种各样的名字，例如：协调者（coordinator）、路由器（router）、代理人（director）</p><img src="/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/%E5%88%86%E7%89%87%E4%B8%8D%E7%AD%89%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F/1kp39_8mQ0E9bIO0Lw3PGFw.png" class="" title="img"><p>协调者是唯一知道数据分布的组件，它映射客户端的请求到特殊的分片上，接着映射到对应的数据库实例</p><p>这就是为什么客户端必须通过协调者路由它们的请求</p><p>举一个例子：如果一个客户端希望插入一条数据到 <code>Car</code> 这张表，该请求首先会提交到协调者；协调者会映射该记录的主键（原文中是 <em>primary key</em>，这里应该主要指分表键）到其中一个分片，然后将请求转发给负责该分片的数据库实例</p><img src="/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/%E5%88%86%E7%89%87%E4%B8%8D%E7%AD%89%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F/1YNUB6y8WJnp0CCVAXSjQ0g.png" class="" title="img"><p>在上述示意图中，首先协调者映射键 <code>121</code> 到分片 <code>10</code>，接着插入数据到持有分片 <code>10</code>，即表 <code>car_10</code> 的数据库实例上</p><p>可是产生了一个问题：为什么在分片解决方案中需要一个协调者的角色？答案是显而易见的：分片存储在为单服务器部署设计的数据库实例上</p><blockquote><p><em>These database instances do not communicate with each other, nor do they support any protocols that would facilitate such communication. Unaware of each other, they exist in their own isolated environments, oblivious to the fact that they are part of a larger system.</em></p><p>这些数据库实例不相互通信，也不支持任何有助于这种通信的协议。它们彼此不知情，存在于自己孤立的环境中，忽略了它们是一个更大系统的一部分这一事实</p></blockquote><p>因此在分片解决方案中协调者是不可或缺的角色；如果你有兴趣深入研究碎片数据库架构，可以考虑探索 CitusData 或 Azure CosmosDB for PostgreSQL、Vitess for MySQL、Oracle 分布式自治数据库和 MongoDB sharded Cluster</p><h1 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h1><p>与分片数据库解决方案非常相似，分布式数据库也使用类似的分片技术在数据库节点集群中存储和读取数据</p><p>不同的是分布式数据库不依靠协调者组件</p><p><strong>分布式数据库建立在一个无共享的体系结构上</strong>，该体系结构没有像协调者这样的单一组件，承担着许多决策的负担：</p><img src="/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/%E5%88%86%E7%89%87%E4%B8%8D%E7%AD%89%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F/1deOgcXccWs9lKUSgLPNOww.png" class="" title="img"><p><em>集群中的所有节点都知道彼此，从而知道数据分布；通过直接通信，每个节点都可以将客户端请求路由到适当的分片所有者；此外它们还可以执行和协调多节点事务，当缩放到更多节点时，集群会自动重新平衡和拆分分片；节点维护数据的冗余副本（基于配置的复制因子），即使某些节点出现故障，也可以在不停机的情况下继续操作</em></p><p>所有这些对客户端来说都是透明的，客户端只需与任何节点建立连接，并允许该节点管理分布式方面</p><p>举个例子：一个客户端可能连接到 <code>node1</code> 然后插入了一条 <code>Car</code> 的新数据，id 为 <code>121</code>；如果 <code>node1</code> 是分片的所有者，那么它将在本地存储记录，并且采用一致性算法（consensus algorithm）将变更复制到其他节点的子集；如果不是所有者，<code>node1</code> 会将请求转发给分片的持有者，比如 <code>node4</code></p><img src="/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/%E5%88%86%E7%89%87%E4%B8%8D%E7%AD%89%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F/1weEdq2BxIpf6GiLjipns5Q.png" class="" title="img"><p>如果你有兴趣探索真正的分布式数据库的体系结构，可以考虑研究 Google Spanner、YugabyteDB、CockratchDB、Apache Cassandra 或 Apache Ignite</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在数据库领域，分片和分发经常被混为一谈，但它们有不同的用途</p><p>虽然分片涉及在多个独立实例之间拆分数据，但这并不意味着系统是分布式的；在分片解决方案中存在一个协调者，它将客户端请求引导到适当的分片，这是两者之间显著的区别</p><p>另一方面，建立在无共享体系结构上的分布式数据库缺少这种集中式协调者，这些系统中的节点相互了解，管理数据分发，并无缝处理客户端请求</p><p>这两种体系结构都有各自的优点，了解它们的细微差别对于明智的数据库设计和选择至关重要</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://medium.com/@magda7817/sharded-does-not-imply-distributed-572fdafc4040">Sharded Does Not Imply Distributed | by Denis Magda | Sep, 2023 | Medium</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LiteFlow - 组件的超时时间</title>
      <link href="/%E5%BC%80%E5%8F%91/LiteFlow/LiteFlow%20-%20%E7%BB%84%E4%BB%B6%E7%9A%84%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4.html"/>
      <url>/%E5%BC%80%E5%8F%91/LiteFlow/LiteFlow%20-%20%E7%BB%84%E4%BB%B6%E7%9A%84%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><a href="https://gitee.com/dromara/liteFlow/issues/I7I3LL">允许对EL中的每⼀个组件设置超时时间控制 · Issue #I7I3LL · dromara&#x2F;liteFlow - Gitee.com</a></p><p>issue 中需求了更细粒度的超时时间设置，允许 EL 中的每⼀个组件设置超时时间控制</p><p>如何使用可以参考官方文档</p><p><a href="https://liteflow.cc/pages/fd5984/#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">⏱️超时控制 | LiteFlow</a></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="EL-关键字"><a href="#EL-关键字" class="headerlink" title="EL 关键字"></a>EL 关键字</h2><p>在 EL 解析器中注册相关的表达式和 <code>BaseOperator</code> 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EL解析引擎</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">ExpressRunner</span> <span class="variable">EXPRESS_RUNNER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExpressRunner</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="comment">// 初始化QLExpress的Runner</span></span><br><span class="line">EXPRESS_RUNNER.addFunction(ChainConstant.THEN, <span class="keyword">new</span> <span class="title class_">ThenOperator</span>());</span><br><span class="line">EXPRESS_RUNNER.addFunction(ChainConstant.WHEN, <span class="keyword">new</span> <span class="title class_">WhenOperator</span>());</span><br><span class="line">...</span><br><span class="line">   <span class="comment">// 这里 MAX_WAIT_SECONDS = maxWaitSeconds</span></span><br><span class="line">EXPRESS_RUNNER.addFunctionAndClassMethod(ChainConstant.MAX_WAIT_SECONDS, Object.class, <span class="keyword">new</span> <span class="title class_">MaxWaitSecondsOperator</span>());</span><br><span class="line">EXPRESS_RUNNER.addFunctionAndClassMethod(ChainConstant.PARALLEL, Object.class, <span class="keyword">new</span> <span class="title class_">ParallelOperator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MaxWaitSecondsOperator"><a href="#MaxWaitSecondsOperator" class="headerlink" title="MaxWaitSecondsOperator"></a>MaxWaitSecondsOperator</h2><p><code>MaxWaitSecondsOperator</code> 实现自 <code>BaseOperator</code></p><blockquote><p><code>BaseOperator</code> 为了强化 <code>executeInner</code> 方法，会捕获抛出的 <code>QLException</code> 错误，输出友好的错误提示</p></blockquote><p><code>build</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Condition <span class="title function_">build</span><span class="params">(Object[] objects)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="comment">// 校验参数数量</span></span><br><span class="line">    OperatorHelper.checkObjectSizeEqTwo(objects);</span><br><span class="line">  <span class="comment">// 转换参数 1 为执行对象</span></span><br><span class="line">    <span class="type">Executable</span> <span class="variable">executable</span> <span class="operator">=</span> OperatorHelper.convert(objects[<span class="number">0</span>], Executable.class);</span><br><span class="line">    <span class="comment">// 获取传入的时间参数</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">maxWaitSeconds</span> <span class="operator">=</span> OperatorHelper.convert(objects[<span class="number">1</span>], Integer.class);</span><br><span class="line">    <span class="keyword">if</span> (executable <span class="keyword">instanceof</span> WhenCondition) &#123;</span><br><span class="line">        <span class="comment">// WhenCondition，直接设置等待时间</span></span><br><span class="line">        <span class="type">WhenCondition</span> <span class="variable">whenCondition</span> <span class="operator">=</span> OperatorHelper.convert(executable, WhenCondition.class);</span><br><span class="line">        whenCondition.setMaxWaitTime(maxWaitSeconds);</span><br><span class="line">        whenCondition.setMaxWaitTimeUnit(TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> whenCondition;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (executable <span class="keyword">instanceof</span> FinallyCondition) &#123;</span><br><span class="line">        <span class="comment">// FINALLY，报错</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> StrFormatter.format(<span class="string">&quot;The caller [&#123;&#125;] cannot use the keyword \&quot;maxWaitSeconds&#x27;\&quot;&quot;</span>, executable.toString());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">QLException</span>(errorMsg);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (containsFinally(executable)) &#123;</span><br><span class="line">        <span class="comment">// 处理 THEN 中的 FINALLY</span></span><br><span class="line">        <span class="type">ThenCondition</span> <span class="variable">thenCondition</span> <span class="operator">=</span> OperatorHelper.convert(executable, ThenCondition.class);</span><br><span class="line">        <span class="keyword">return</span> handleFinally(thenCondition, maxWaitSeconds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他情况，被 WHEN 包装</span></span><br><span class="line">        <span class="keyword">return</span> wrappedByTimeout(executable, maxWaitSeconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程可以概括为：</p><ul><li>校验 &amp; 准备工作<ul><li>校验参数数量；参数数量需要为 2（执行对象、超时时间）</li><li>转换第一个参数为执行对象；调用 <code>OperatorHelper.convert</code>，逻辑中很多对象都用 <code>Object</code> 引用承接，在转换方法中进行校验；个人理解是牺牲了一些可读性换取了开发的灵活性</li><li>获取超时时间参数</li></ul></li><li>包装 Condition<ul><li><code>WhenCondition</code> 直接设置等待时间</li><li><code>FinallyCondition</code> 不允许设置超时时间</li><li><code>ThenCondition</code> 中如果包含 <code>FinallyCondition</code>，会在 <code>handleFinally</code> 方法中包装成一个 <code>WhenCondition</code>，外层套一个 <code>ThenCondition</code>，将 <code>FinallyCondition</code> 排除出去，时间设置在里层的 <code>WhenCondition</code> 中</li><li>其他则被包装成 <code>TimeoutCondition</code>；<code>TimeoutCondition</code> 是 <code>WhenCondition</code> 的实现，区别在于将执行对象抛出的 <code>WhenTimeoutException</code> 转换为 <code>TimeoutException</code></li></ul></li></ul><h2 id="WhenCondition"><a href="#WhenCondition" class="headerlink" title="WhenCondition"></a>WhenCondition</h2><p><code>WhenCondition</code> 在早期版本就支持超时设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 异步线程最⻓的等待时间(只⽤于when)，默认值为15000</span><br><span class="line">liteflow.when-max-wait-time=15000</span><br><span class="line"></span><br><span class="line"># 异步线程最⻓的等待时间单位(只⽤于when)，默认值为MILLISECONDS，毫秒</span><br><span class="line">liteflow.when-max-wait-time-unit=MILLISECONDS</span><br></pre></td></tr></table></figure><p>所以对于 <code>WhenCondition</code> 的处理只需要设置合适的属性值即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (executable <span class="keyword">instanceof</span> WhenCondition) &#123;</span><br><span class="line">        <span class="comment">// WhenCondition，直接设置等待时间</span></span><br><span class="line">        <span class="type">WhenCondition</span> <span class="variable">whenCondition</span> <span class="operator">=</span> OperatorHelper.convert(executable, WhenCondition.class);</span><br><span class="line">        whenCondition.setMaxWaitTime(maxWaitSeconds);</span><br><span class="line">        whenCondition.setMaxWaitTimeUnit(TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> whenCondition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>WhenCondition</code> 执行时，会启动一个 <code>ScheduledThreadPoolExecutor</code> 来实现超时效果</p><p>具体流程可以阅读 [LiteFlow - WhenCondition 和异步超时机制 | 贫瘠之地 (kuga.fun)](<a href="https://www.kuga.fun/%E5%BC%80%E5%8F%91/LiteFlow/LiteFlow">https://www.kuga.fun/开发/LiteFlow/LiteFlow</a> WhenCondition 和异步超时机制.html)</p><h2 id="FinallyCondition"><a href="#FinallyCondition" class="headerlink" title="FinallyCondition"></a>FinallyCondition</h2><p><code>FinallyCondition</code> 不允许设置超时时间，会抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (executable <span class="keyword">instanceof</span> FinallyCondition) &#123;</span><br><span class="line">            <span class="comment">// FINALLY，报错</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> StrFormatter.format(<span class="string">&quot;The caller [&#123;&#125;] cannot use the keyword \&quot;maxWaitSeconds&#x27;\&quot;&quot;</span>, executable.toString());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">QLException</span>(errorMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么 <code>FinallyCondition</code> 不能设置超时时间呢</p><p>在 issue 里可以看到这样的表达</p><blockquote><p>如果不使用 <code>maxWaitSeconds</code> 则表示不使用超时控制。<br>此外，<code>FINALLY</code> 不能使用 <code>maxWaitSeconds</code>，其一定会被执行</p></blockquote><p>这样的实现应该是为了避免作为兜底的后置处理，因为超时反而无法正常执行了</p><h2 id="ThenCondition"><a href="#ThenCondition" class="headerlink" title="ThenCondition"></a>ThenCondition</h2><p>这个 case 的入口是一个判断方法 <code>containsFinally</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断 THEN 中是否含有 FINALLY 组件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> executable 判断对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 含有 FINALLY 组件返回 true，否则返回 false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">containsFinally</span><span class="params">(Executable executable)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> executable <span class="keyword">instanceof</span> ThenCondition</span><br><span class="line">            &amp;&amp; CollUtil.isNotEmpty(((ThenCondition) executable).getFinallyConditionList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实判断了两部分内容：</p><ul><li><code>executable</code> 对象是一个 <code>ThenCondition</code></li><li>这个 <code>ThenCondition</code> 后置处理器不为空</li></ul><br><p>满足条件后就会进入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (containsFinally(executable)) &#123;</span><br><span class="line">        <span class="comment">// 处理 THEN 中的 FINALLY</span></span><br><span class="line">        <span class="type">ThenCondition</span> <span class="variable">thenCondition</span> <span class="operator">=</span> OperatorHelper.convert(executable, ThenCondition.class);</span><br><span class="line">        <span class="keyword">return</span> handleFinally(thenCondition, maxWaitSeconds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里首先提取了 <code>ThenCondition</code> 对象</p><p>然后调用 <code>handleFinally</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 FINALLY 排除在超时控制之外</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> thenCondition  待处理的 ThenCondition</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxWaitSeconds 最大等待秒数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 处理后的 ThenCondition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ThenCondition <span class="title function_">handleFinally</span><span class="params">(ThenCondition thenCondition, Integer maxWaitSeconds)</span> &#123;</span><br><span class="line">    <span class="comment">// 进行如下转换</span></span><br><span class="line">    <span class="comment">// THEN(PRE(a),b,FINALLY(c))</span></span><br><span class="line">    <span class="comment">// =&gt; THEN(</span></span><br><span class="line">    <span class="comment">//      WHEN(THEN(PRE(a),b)),</span></span><br><span class="line">    <span class="comment">//      FINALLY(c))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义外层 THEN</span></span><br><span class="line">    <span class="type">ThenCondition</span> <span class="variable">outerThenCondition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThenCondition</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 FINALLY 转移到外层 THEN</span></span><br><span class="line">    List&lt;Executable&gt; finallyList = thenCondition.getExecutableList(ConditionKey.FINALLY_KEY);</span><br><span class="line">    finallyList.forEach(executable</span><br><span class="line">            -&gt; outerThenCondition</span><br><span class="line">            .addFinallyCondition((FinallyCondition) executable));</span><br><span class="line">    finallyList.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包装内部 THEN</span></span><br><span class="line">    <span class="type">WhenCondition</span> <span class="variable">whenCondition</span> <span class="operator">=</span> wrappedByTimeout(thenCondition, maxWaitSeconds);</span><br><span class="line">    outerThenCondition.addExecutable(whenCondition);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> outerThenCondition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里为了实现正常执行 <code>THEN</code> 操作的超时而不影响到后置组件，选择对 <code>ThenCondition</code> 进了一层包装</p><p>这里包装的目的：</p><ul><li>将 <code>ThenCondition</code> 包装为 <code>WhenCondition</code> 使其支持超时（因为 <code>WHEN</code> 原生支持超时）</li><li>最外层包装一层 <code>ThenCondition</code> 将 <code>FinallyCondition</code> 放在外面避免超时影响（因为 <code>WHEN</code> 也不支持后置处理）</li></ul><p>最终将包装好的 <code>ThenCondition</code> 返回上游业务使用</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>对于其他的类型，会被包装为 <code>TimeoutCondition</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个 Executable 包装为带有单独超时控制的 TimeoutCondition</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> executable     待包装对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxWaitSeconds 最大等待秒数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包装后的 TimeoutCondition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> TimeoutCondition <span class="title function_">wrappedByTimeout</span><span class="params">(Executable executable, Integer maxWaitSeconds)</span> &#123;</span><br><span class="line">    <span class="type">TimeoutCondition</span> <span class="variable">timeoutCondition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimeoutCondition</span>();</span><br><span class="line">    timeoutCondition.addExecutable(executable);</span><br><span class="line">    timeoutCondition.setMaxWaitTime(maxWaitSeconds);</span><br><span class="line">    timeoutCondition.setMaxWaitTimeUnit(TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> timeoutCondition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TimeoutCondition</code> 本质上是 <code>WhenCondition</code> 的子类，优化了超时日志</p><h1 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h1><p>一开始写这个标题是因为感觉 <code>ThenCondition</code> 的包装会影响到日志的输出（毕竟包装了一个 <code>WhenCondition</code> 和一个 <code>ThenCondition</code>）</p><p>但是又看了一下代码发现日志是只有 <code>Component</code> 才会输出的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getExecuteStepStr</span><span class="params">(<span class="type">boolean</span> withTimeSpent)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    CmpStep cmpStep;</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;CmpStep&gt; it = executeSteps.iterator(); it.hasNext();) &#123;</span><br><span class="line">        cmpStep = it.next();</span><br><span class="line">        <span class="keyword">if</span> (withTimeSpent) &#123;</span><br><span class="line">            str.append(cmpStep.buildStringWithTime());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            str.append(cmpStep.buildString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (it.hasNext()) &#123;</span><br><span class="line">            str.append(<span class="string">&quot;==&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.executeStepsStr = str.toString();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.executeStepsStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过想到又看到的一个 issue</p><p><a href="https://gitee.com/dromara/liteFlow/issues/I8B0MI">希望框架对并行日志进行优化 · Issue #I8B0MI · dromara&#x2F;liteFlow - Gitee.com</a></p><p>这里会不会产生影响？</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th align="center">类型</th><th align="center">操作</th></tr></thead><tbody><tr><td align="center">WhenCondition</td><td align="center">直接设置属性</td></tr><tr><td align="center">FinallyCondition</td><td align="center">不允许</td></tr><tr><td align="center">ThenCondition</td><td align="center">内部逻辑包装为 <code>WHEN</code>，外部包装一个 <code>THEN</code>，将后置处理器移至外部</td></tr><tr><td align="center">其他</td><td align="center">包装为 <code>WhenCondition</code> 的子类 <code>TimeoutCondition</code></td></tr></tbody></table><p>可以看到随着迭代关键字越来越多</p><p>功能和功能之间互相影响也越来越大</p><p>一个功能的添加需要考虑对不同已有功能的影响，需要对应出不同的实现方式</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> LiteFlow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LiteFlow </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Seata 改良版雪花算法</title>
      <link href="/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/Seata%20%E6%94%B9%E8%89%AF%E7%89%88%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95.html"/>
      <url>/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/Seata%20%E6%94%B9%E8%89%AF%E7%89%88%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h1><p>雪花算法（Snowflake Algorithm）是一种用于生成唯一标识符（Unique Identifier）的算法</p><p>它最初由 Twitter 开发并开源，用于在分布式系统中生成全局唯一 ID</p><br><p>雪花算法的原理就是生成一个的 64 位比特位的 long 类型的 ID</p><ul><li>符号位（1 位）：固定固定为 1，因为 ID 都为正数</li><li>时间戳（41 位）：毫秒级别的时间戳，大约可以使用 69 年（事实上很多实现会减去一个 offset）</li><li>机器码（10 位）：分布式服务 ID，2 ^ 10 &#x3D; 1024 台机器</li><li>序列号（12 位）：同一时间戳、同一机器下，通过序列号自增进行 ID 生成，即同一毫秒下可以生成 2 ^ 12 &#x3D; 4096 个不同的 ID</li></ul><br><p>64 位如下所示：</p><p><span style="color: green;">0</span> - <span style="color: red;">00000000000000000000000000000000000000000</span> - <span style="color: blue;">0000000000</span> - <span style="color: orange;">000000000000</span></p><ul><li><span style="color: green;">符号位（1 位）</span></li><li><span style="color: red;">时间戳（41 位）</span></li><li><span style="color: blue;">机器码（10 位）</span></li><li><span style="color: orange;">序列号（12 位）</span></li></ul><h1 id="Seata-改良"><a href="#Seata-改良" class="headerlink" title="Seata 改良"></a>Seata 改良</h1><p>在老版 Seata（1.4 以前），内置的 UUID 生成器的实现基于标准版的雪花算法</p><p>在后续的更新中 Seata 对标准雪花算法进行了改良</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Seata 认为标准的雪花算法有以下几个缺点</p><ul><li><strong>时钟敏感</strong>：因为 ID 生成总是和当前操作系统的时间戳绑定的（利用了时间的单调递增性），如果服务发生了时钟回拨，生成的 ID 就会重复；当然一些实现会避免该问题，方案一般是记录上次生成 ID 时的时间戳，如果发现当前时间小于记录时间，则说明发生了时钟回拨，则拒绝服务<br>意味着出现时钟回拨，会导致服务在一定时间内不可用</li><li><strong>突发性能有限</strong>：序列号的位长度为 12，也就是同一 ms 并发都必须低于 4096；一些实现会自旋等待，当差距较大时则抛出限流异常等拒绝服务</li></ul><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>改进的核心思想是<strong>解除与操作系统时间戳的时刻绑定</strong></p><p>生成器只在初始化时获取了系统当前的时间戳，作为初始时间戳， 但之后就不再与系统时间戳保持同步了；随后 ID 的递增，只递增序列号；当序列号溢出时，进位到时间戳位（低 12 位满），序列号重新归零</p><p>为了方便这种溢出进位，Seata 调整了 64 位 ID 的位分配策略</p><p><span style="color: green;">0</span>  - <span style="color: blue;">0000000000</span> - <span style="color: red;">00000000000000000000000000000000000000000</span> - <span style="color: orange;">000000000000</span></p><ul><li><span style="color: green;">符号位（1 位）</span></li><li><span style="color: blue;">机器码（10 位）</span></li><li><span style="color: red;">时间戳（41 位）</span></li><li><span style="color: orange;">序列号（12 位）</span></li></ul><hr><p>这样时间戳和序列号在内存上是连在一块的，在实现上就很容易用一个 <code>AtomicLong</code> 来同时记录块数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * timestamp and sequence mix in one Long</span></span><br><span class="line"><span class="comment"> * highest 11 bit: not used</span></span><br><span class="line"><span class="comment"> * middle  41 bit: timestamp</span></span><br><span class="line"><span class="comment"> * lowest  12 bit: sequence</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> AtomicLong timestampAndSequence;</span><br></pre></td></tr></table></figure><p>高 11 位（符号位 + 机器码）在服务启动时就已经确定，服务运行过程中也不会变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * business meaning: machine ID (0 ~ 1023)</span></span><br><span class="line"><span class="comment"> * actual layout in memory:</span></span><br><span class="line"><span class="comment"> * highest 1 bit: 0</span></span><br><span class="line"><span class="comment"> * middle 10 bit: workerId</span></span><br><span class="line"><span class="comment"> * lowest 53 bit: all 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> workerId;</span><br></pre></td></tr></table></figure><p>这样生成 UUID 的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 获得递增后的时间戳和序列号</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">next</span> <span class="operator">=</span> timestampAndSequence.incrementAndGet();</span><br><span class="line">   <span class="comment">// 截取低53位</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">timestampWithSequence</span> <span class="operator">=</span> next &amp; timestampAndSequenceMask;</span><br><span class="line">   <span class="comment">// 跟先前保存好的高11位进行一个或的位运算</span></span><br><span class="line">   <span class="keyword">return</span> workerId | timestampWithSequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h2><p>由上可以发现，问题得到了改善：</p><ul><li>生成器不再有 4096&#x2F;ms 的突发性能限制了；如果某个时间戳的序列号空间耗尽，它会直接推进到下一个时间戳</li><li>生成器弱依赖于操作系统时钟；在运行期间，生成器不受时钟回拨的影响<br>无论是人为回拨还是机器的时钟漂移， 因为生成器仅在启动时获取了一遍系统时钟，之后两者不再保持同步； 可能产生重复 ID 的只有在重启时的大幅度时钟回拨</li><li>对于推进到下一个时间戳的 “超前消费” 问题，如果生成器内的时间戳大大超前于系统的时间戳， 从而在重启时造成 ID 重复？实际上不可能，达到这种情况需要特别大的 QPS</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="Work-ID-优化"><a href="#Work-ID-优化" class="headerlink" title="Work ID 优化"></a>Work ID 优化</h2><p>Work ID 是分布式下的机器码，基本要求是每个实例拥有唯一的标识</p><p>常见的确定 Work ID 的方式：</p><ul><li><strong>手动配置</strong></li><li><strong>基于网络信息</strong>：因为网络信息一般带有唯一性，例如使用 IP 地址、MAC 地址、主机名等作为 Work ID 的一部分</li><li><strong>自动化生成</strong>：使用一些工具进行生成，比如依赖 ZK 节点来进行唯一的保证</li></ul><p>无论选择哪种方法，都需要确保每个机器或节点的 Work ID 是唯一的，并且在分布式系统中保持稳定；这样可以避免生成重复的 ID，确保整个系统的正确运行</p><p>Seata 基于网络信息进行 Work ID 的确定，截取本地 IPv4 地址的低 10 位作为 Work ID，很明显这样会造成 Work ID 重复，例如如下 IP</p><ul><li>192.168.4.10</li><li>192.168.8.10</li></ul><p>优化后将优先使用网卡 MAC 地址截取，若本机未配置有效的网卡，则在 <code>[0, 1023]</code> 中随机挑一个作为 ID（其实应该依然存在重复问题，只是减少了概率；感觉还是美团的 leaf 等使用 ZK 方式比较好，但是会引入新中间件，增加系统复杂度）</p><h2 id="单调递增和页分裂"><a href="#单调递增和页分裂" class="headerlink" title="单调递增和页分裂"></a>单调递增和页分裂</h2><p>Seata 改良后的雪花算法是否是单调递增的？</p><p>在标准雪花算法中，时间戳排在机器码之前，即多节点服务，依然可以保证一定程度上有序（同一 ms 内生成的 ID 可能无序，不同 ms 之间单调递增）</p><p>在 Seata 改良后的雪花算法中，机器码在时间戳之前，进一步加大了这种无序性</p><br><p>那么这种无序性是否会造成页分裂？</p><p>按照 Seata 的解释是短时期内会造成，但在有限次分裂后，不会进行新的页分裂，因为 Work ID 是有限的，最终一定会出现能容纳固定 Work ID 的页</p><blockquote><p>到达终态后，后续的ID只会在该ID所属的子序列上进行顺序增长，而不会造成页分裂</p><p>该状态下的顺序增长与 auto_increment 的顺序增长的区别是，前者有 1024 个增长位点（各个子序列的尾部），后者只有尾部一个</p><p>到这里我们可以回答开头所提出的问题了：新算法从全局来看的确不是全局递增的，但该算法是<strong>收敛</strong>的，达到稳态后，新算法同样能达成像全局顺序递增一样的效果</p></blockquote><h2 id="理论上依然存在的问题"><a href="#理论上依然存在的问题" class="headerlink" title="理论上依然存在的问题"></a>理论上依然存在的问题</h2><p>虽然 Seata 一致在论证改进后 ID 生成方式的优势，但我觉得从理论上来看依然存在一些问题（虽然很多问题从应用层面考虑认为无法出现，但并不是从理论层面解决）</p><ul><li><strong>时钟回拨后重启服务</strong>：虽然 ID 生成过程中不依赖时间戳，但如果回拨时间太长、部署时间短依然会导致 ID 重复的问题<ul><li>应用层面：不会有太长时间回拨，服务部署需要一定时间</li></ul></li><li><strong>超前消费</strong>：虽然 QPS &#x3D; 400w&#x2F;s，但理论上仍然存在超前消费，重新部署后 ID 重复问题<ul><li>应用层面：对 QPS 的要求基本不可能达到</li></ul></li><li><strong>Work ID 重复</strong>：上述 Work ID 生成操作依然会存在重复问题，只不过概率较小</li><li><strong>页合并导致的页分裂无法收敛</strong>：详情见 <a href="http://seata.io/zh-cn/blog/seata-snowflake-explain">关于新版雪花算法的答疑 | Seata</a></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://seata.io/zh-cn/blog/seata-analysis-UUID-generator/">Seata基于改良版雪花算法的分布式UUID生成器分析 | Seata</a></p><p><a href="http://seata.io/zh-cn/blog/seata-snowflake-explain">关于新版雪花算法的答疑 | Seata</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 OpenAI API 进行 Prompt 工程的最佳实践</title>
      <link href="/%E5%BC%80%E5%8F%91/AI/%E4%BD%BF%E7%94%A8%20OpenAI%20API%20%E8%BF%9B%E8%A1%8C%20Prompt%20%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html"/>
      <url>/%E5%BC%80%E5%8F%91/AI/%E4%BD%BF%E7%94%A8%20OpenAI%20API%20%E8%BF%9B%E8%A1%8C%20Prompt%20%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html</url>
      
        <content type="html"><![CDATA[<h1 id="Prompt-工程的工作原理"><a href="#Prompt-工程的工作原理" class="headerlink" title="Prompt 工程的工作原理"></a>Prompt 工程的工作原理</h1><p>由于指导遵循模型的训练方式或训练数据，有一些特定的提示格式效果特别好，与手头的任务更为一致</p><p>下面我们介绍了一些提示格式，我们认为这些格式运行可靠，但可以随意探索不同的格式，这些格式可能最适合您的任务</p><h1 id="经验法则和示例"><a href="#经验法则和示例" class="headerlink" title="经验法则和示例"></a>经验法则和示例</h1><p><strong>注意：</strong> <code>&#123;text input here&#125;</code> 是实际文本 &#x2F; 上下文的占位符</p><h2 id="使用最新版本"><a href="#使用最新版本" class="headerlink" title="使用最新版本"></a>使用最新版本</h2><p>为了最好的结果，我们通常建议使用最新、功能最强的模型</p><p>截至 2022 年 11 月，最佳选择是用于文本生成的 <code>text-davinci-003</code> 模型和用于代码生成的 <code>code-davinci-002</code> 模型</p><h2 id="提示放在开头并且使用-或者-“””-分隔提示和内容"><a href="#提示放在开头并且使用-或者-“””-分隔提示和内容" class="headerlink" title="提示放在开头并且使用 ### 或者 “”” 分隔提示和内容"></a>提示放在开头并且使用 ### 或者 “”” 分隔提示和内容</h2><p><strong>效果较差：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Summarize the text below as a bullet point list of the most important points.</span><br><span class="line"></span><br><span class="line">&#123;text input here&#125;</span><br></pre></td></tr></table></figure><p><strong>改进：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Summarize the text below as a bullet point list of the most important points.</span><br><span class="line"></span><br><span class="line">Text: &quot;&quot;&quot;</span><br><span class="line">&#123;text input here&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h2 id="对所需的上下文、结果、长度、格式、风格等进行具体和尽可能详细的描述"><a href="#对所需的上下文、结果、长度、格式、风格等进行具体和尽可能详细的描述" class="headerlink" title="对所需的上下文、结果、长度、格式、风格等进行具体和尽可能详细的描述"></a>对所需的上下文、结果、长度、格式、风格等进行具体和尽可能详细的描述</h2><p><strong>效果较差：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Write a poem about OpenAI. </span><br></pre></td></tr></table></figure><p><strong>改进：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Write a short inspiring poem about OpenAI, focusing on the recent DALL-E product launch (DALL-E is a text to image ML model) in the style of a &#123;famous poet&#125;</span><br></pre></td></tr></table></figure><h2 id="通过示例阐明所需的输出格式"><a href="#通过示例阐明所需的输出格式" class="headerlink" title="通过示例阐明所需的输出格式"></a>通过示例阐明所需的输出格式</h2><p><strong>效果较差：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Extract the entities mentioned in the text below. Extract the following 4 entity types: company names, people names, specific topics and themes.</span><br><span class="line"></span><br><span class="line">Text: &#123;text&#125;</span><br></pre></td></tr></table></figure><p>显示和告知，当显示特定的格式要求时，模型的响应会更好</p><p>这也使得以编程方式可靠地解析多个输出变得更加容易</p><p><strong>改进：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Extract the important entities mentioned in the text below. First extract all company names, then extract all people names, then extract specific topics which fit the content and finally extract general overarching themes</span><br><span class="line"></span><br><span class="line">Desired format:</span><br><span class="line">Company names: &lt;comma_separated_list_of_company_names&gt;</span><br><span class="line">People names: -||-</span><br><span class="line">Specific topics: -||-</span><br><span class="line">General themes: -||-</span><br><span class="line"></span><br><span class="line">Text: &#123;text&#125;</span><br></pre></td></tr></table></figure><h2 id="从零样本开始，然后是少量样本，它们都不起作用则微调"><a href="#从零样本开始，然后是少量样本，它们都不起作用则微调" class="headerlink" title="从零样本开始，然后是少量样本，它们都不起作用则微调"></a>从零样本开始，然后是少量样本，它们都不起作用则微调</h2><p><strong>零样本：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Extract keywords from the below text.</span><br><span class="line"></span><br><span class="line">Text: &#123;text&#125;</span><br><span class="line"></span><br><span class="line">Keywords:</span><br></pre></td></tr></table></figure><p><strong>少量样本 - 举几个例子</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Extract keywords from the corresponding texts below.</span><br><span class="line"></span><br><span class="line">Text 1: Stripe provides APIs that web developers can use to integrate payment processing into their websites and mobile applications.</span><br><span class="line">Keywords 1: Stripe, payment processing, APIs, web developers, websites, mobile applications</span><br><span class="line">##</span><br><span class="line">Text 2: OpenAI has trained cutting-edge language models that are very good at understanding and generating text. Our API provides access to these models and can be used to solve virtually any task that involves processing language.</span><br><span class="line">Keywords 2: OpenAI, language models, text processing, API.</span><br><span class="line">##</span><br><span class="line">Text 3: &#123;text&#125;</span><br><span class="line">Keywords 3:</span><br></pre></td></tr></table></figure><p><strong>微调：请参阅此处的微调最佳实践 <a href="https://docs.google.com/document/d/1h-GTjNDDKPKU_Rsd0t1lXCAnHltaXTAzQ8K2HRhQf9U/edit#">here</a></strong></p><h2 id="减少模糊、不准确的描述"><a href="#减少模糊、不准确的描述" class="headerlink" title="减少模糊、不准确的描述"></a>减少模糊、不准确的描述</h2><p><strong>效果较差：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The description for this product should be fairly short, a few sentences only, and not too much more.</span><br></pre></td></tr></table></figure><p><strong>改进：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Use a 3 to 5 sentence paragraph to describe this product.</span><br></pre></td></tr></table></figure><h2 id="与其说不该做什么不如说该做什么"><a href="#与其说不该做什么不如说该做什么" class="headerlink" title="与其说不该做什么不如说该做什么"></a>与其说不该做什么不如说该做什么</h2><p><strong>效果较差：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The following is a conversation between an Agent and a Customer. DO NOT ASK USERNAME OR PASSWORD. DO NOT REPEAT.</span><br><span class="line"></span><br><span class="line">Customer: I can’t log in to my account.</span><br><span class="line">Agent:</span><br></pre></td></tr></table></figure><p><strong>改进：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The following is a conversation between an Agent and a Customer. The agent will attempt to diagnose the problem and suggest a solution, whilst refraining from asking any questions related to PII. Instead of asking for PII, such as username or password, refer the user to the help article www.samplewebsite.com/help/faq</span><br><span class="line"></span><br><span class="line">Customer: I can’t log in to my account.</span><br><span class="line">Agent:</span><br></pre></td></tr></table></figure><h2 id="代码生成特有-使用引导词引导模型"><a href="#代码生成特有-使用引导词引导模型" class="headerlink" title="代码生成特有 - 使用引导词引导模型"></a>代码生成特有 - 使用引导词引导模型</h2><p><strong>效果较差：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Write a simple python function that</span><br><span class="line"># 1. Ask me for a number in mile</span><br><span class="line"># 2. It converts miles to kilometers</span><br></pre></td></tr></table></figure><p>在下方的代码示例中，添加 “import” 对模型进行提示，它应该使用 Python 进行编写（类似地，”SELECT” 是一个针对 SQL 语句好的提示）</p><p><strong>改进：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Write a simple python function that</span><br><span class="line"># 1. Ask me for a number in mile</span><br><span class="line"># 2. It converts miles to kilometers</span><br><span class="line"> </span><br><span class="line">import</span><br></pre></td></tr></table></figure><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>通常，我们发现 <code>model</code> 和 <code>temperature</code> 是改变模型输出最常用的参数</p><ul><li><code>model</code> - 更高性能的模型成本更高，延迟也更高</li><li><code>temperature</code> - 衡量模型输出不太可能的 tokens 的指标；温度越高，输出就越随机（通常是创造性的）；然而这并不等同于“真实性”；对于大多数实际用例，如数据提取和真实问答，0 的参数是最好的</li><li><code>max_tokens</code> - 不能控制输出的长度，是一个针对 token 生成的硬截止限制；理想情况下你不会经常达到这个极限，因为当你的模型认为它已经完成时，或者当它达到你定义的停止序列时，它就会停止</li><li><code>stop</code> - 一组字符（标记），生成后将导致文本生成停止</li></ul><p>更多的参数描述参考 <a href="https://beta.openai.com/docs/api-reference/completions/create">API reference</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://help.openai.com/en/articles/6654000-best-practices-for-prompt-engineering-with-openai-api">Best practices for prompt engineering with OpenAI API | OpenAI Help Center</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Prompt </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Guava EventBus</title>
      <link href="/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/Guava%20EventBus.html"/>
      <url>/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/Guava%20EventBus.html</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>EventBus 允许组件之间通过发布订阅方式进行交互，而不需要组件之间进行显式的注册（也意味着互相了解其存在）</p><p>它被设计专门用于使用显式注册来替代传统的 Java 进程内事件分发</p><p>它不是通用的发布订阅系统，也不是用于进程间通信的系统</p><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p>摘自 Github Guava Document <a href="https://github.com/google/guava/wiki/EventBusExplained">EventBusExplained · google&#x2F;guava Wiki · GitHub</a></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义出类和订阅的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventBusChangeRecorder</span> &#123;</span><br><span class="line">  <span class="meta">@Subscribe</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recordCustomerChange</span><span class="params">(ChangeEvent e)</span> &#123;</span><br><span class="line">    recordChange(e.getChange());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在任意地方进行初始化</span></span><br><span class="line">eventBus.register(<span class="keyword">new</span> <span class="title class_">EventBusChangeRecorder</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后进行消息的发送</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeCustomer</span><span class="params">()</span></span><br><span class="line">  <span class="type">ChangeEvent</span> <span class="variable">event</span> <span class="operator">=</span> getChangeEvent();</span><br><span class="line">  eventBus.post(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一分钟指南"><a href="#一分钟指南" class="headerlink" title="一分钟指南"></a>一分钟指南</h2><p>转换一个已经存在的以事件订阅为基础的系统来使用 EventBus 是容易的</p><h3 id="订阅者（For-Listeners）"><a href="#订阅者（For-Listeners）" class="headerlink" title="订阅者（For Listeners）"></a>订阅者（For Listeners）</h3><p>订阅特定类型的事件（例如 <code>CustomerChangeEvent</code>）</p><ul><li>传统的方式：实现一个和事件相关的接口，例如 <code>CustomerChangeEventListener</code></li><li>EventBus：创建一个方法，<code>CustomerChangeEvent</code> 作为这个方法唯一的参数，然后在方法上标记 <code>@Subscribe</code> 注解</li></ul><p>向事件生产者注册你的订阅者方法</p><ul><li>传统的方式：将对象传递给每个生产者的 <code>registerCustomerChangeEventListener</code> 方法，这些方法很少在公共接口中定义，因此除了了解每个可能的生产者，还必须了解其类型</li><li>EventBus：将方法所在对象通过 <code>EventBus.register(Object)</code> 方法注册在一个 <code>EventBus</code> 对象上，需要确保消息生产者使用的 <code>EventBus</code>  实例和进行方法注册的是同一个</li></ul><p>订阅一个普通事件的超类（supertype；例如 <code>EventObject</code> 或者 <code>Object</code>）</p><ul><li>传统的方式：不容易实现</li><li>EventBus：事件会自动分配给超类的订阅者，允许针对接口（Interface）的订阅者或者针对 <code>Object</code> 的 “通配符订阅者”</li></ul><p>要订阅或检测在没有合适事件订阅者存在的事件</p><ul><li>传统的方式：在每个事件调度方法上添加代码（可能使用 AOP）</li><li>EventBus：订阅 <code>DeadEvent</code>，随后 <code>EventBus</code> 将会通知你任何已经已经生产但是没有消费交付的事件（便与调试）</li></ul><h3 id="生产者（For-Producers）"><a href="#生产者（For-Producers）" class="headerlink" title="生产者（For Producers）"></a>生产者（For Producers）</h3><p>跟踪订阅者处理事件</p><ul><li>传统的方式：写代码管理订阅者列表，包括同步，或者使用公共类例如 <code>EventListenerList</code></li><li>EventBus：<code>EventBus</code> 已经为你实现了</li></ul><p>派发事件给订阅者</p><ul><li>传统的方式：显式实现一个向各个事件订阅者分配事件的方法，包括错误隔离和异步（如果希望如此）</li><li>EventBus：传递消息对象给一个 <code>EventBus</code> 实例的 <code>EventBus.post(Object)</code> 方法</li></ul><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>EventBus 系统和代码使用以下术语来讨论事件分发</p><table><thead><tr><th align="center">术语</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Event</td><td align="center">任何可能会被传递给一个总线的对象</td></tr><tr><td align="center">Subcribing</td><td align="center">注册一个 listener 给 <code>EventBus</code> 的行为，以便其处理方法将会接收事件</td></tr><tr><td align="center">Listener</td><td align="center">一个希望接收事件的对象，暴露处理方法（handler method）</td></tr><tr><td align="center">Handler method</td><td align="center">一个 public 方法，<code>EventBus</code> 可以使用该方法处理事件；使用 <code>@Subcribe</code> 注解进行标记</td></tr><tr><td align="center">Posting an event</td><td align="center">确保事件通过 <code>EventBus</code> 被任意订阅者接收</td></tr></tbody></table><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p><strong>为什么我必须创建自己的 <code>EventBus</code> 而不是使用单例</strong></p><p><code>EventBus</code> 并没有明确指出你如何使用它；对于针对每个组件的事件总线并没有禁止使用各自独立的实例，也没有禁止针对不同上下文、主题的时间使用独立的实例；如果进行拆分，会使得在测试中创建、删除 <code>EventBus</code> 对象更加容易、</p><p>当然，如果你想有一个大而全逻辑的 <code>EventBus</code> 单例，并不会阻止你这样做，只需让您的容器（例如 Guice）在全局范围内将 <code>EventBus</code> 创建为一个单例（或者将其存储为一个静态变量，如果想这样做的话）</p><p>总而言之，<code>EventBus</code> 不是一个单例是因为我们不想做出这种决定，你可以根据喜好决定如何使用</p><p><strong>我可以向 <code>EventBus</code> 取消注册某个订阅者吗</strong></p><p>可以，使用 <code>EventBus.unregister</code>；只不过我们发现这种需求很少见：</p><ul><li>大部分订阅者都在启动时进行注册或者懒加载，并在应用程序的生命周期中持续存在</li><li>特殊范围（scope-specific）的 <code>EventBus</code> 实例可以处理临时的事件分发（例如在请求范围的对象之间分发事件）</li><li>对于测试，<code>EventBus</code> 实例可以很容易地创建或丢弃，从而无需显式注销</li></ul><p><strong>为什么使用注解来标记订阅方法，而不是订阅者实现接口</strong></p><p>我们认为 <code>@Subscribe</code> 注解可以传达真实的意图，就像实现接口一样明确（或者更明确），同时让您可以自由地将事件订阅者方法放置在任何您希望的位置，并为它们提供需要的名称</p><p>传统的 <code>JavaEvents</code> 使用侦听器接口，该接口通常只运行少数方法——通常是一个，这有许多缺点：</p><ul><li>任何一个类都只能实现对给定事件的单个响应</li><li>订阅者接口方法可能发生冲突</li><li>方法必须以事件命名（例如 <code>handleChangeEvent</code> ），而不是以其目的（例如 <code>recordChangeInJournal</code> ）命名</li><li>每种事件都有他们自己的接口，没有一个针对事件族的通用父类接口</li></ul><p>干净清晰地实现会存在困难，解决困难导致了一种模式，即使用简单的匿名类来实现订阅器接口</p><p>比较如下两个 case</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChangeRecorder</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">setCustomer</span><span class="params">(Customer cust)</span> &#123;</span><br><span class="line">    cust.addChangeListener(<span class="keyword">new</span> <span class="title class_">ChangeListener</span>() &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customerChanged</span><span class="params">(ChangeEvent e)</span> &#123;</span><br><span class="line">        recordChange(e.getChange());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class is typically registered by the container.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventBusChangeRecorder</span> &#123;</span><br><span class="line">  <span class="meta">@Subscribe</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recordCustomerChange</span><span class="params">(ChangeEvent e)</span> &#123;</span><br><span class="line">    recordChange(e.getChange());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上在第二种情况下，意图更清晰：冗余代码（noise code）更少，事件订阅者有一个清晰而有意义的名称</p><p><strong>如果我注册了一个没有任何订阅者方法的侦听器，会发生什么？</strong></p><p>什么都不会发生</p><p>EventBus 总是设计和容器、模块系统集成，在这些情况下，让容器、工厂、环境将每个创建的对象传递给EventBus 的 <code>register</code> 方法是很方便的</p><p>这样，容器、工厂、环境创建的任何对象都可以通过公开订阅者方法挂接到系统的事件模型中</p><p><strong>在编译时可以检测到哪些 Event Bus 问题？</strong></p><p>Java 的类型系统可以明确检测到的任何问题</p><p>例如为不存在的事件类型定义订阅者方法</p><p><strong>哪些 Event Bus 问题可以在注册时立即检测到？</strong></p><p>调用 <code>register</code> 后，将立即检查正在注册的侦听器的订阅者方法的格式是否正确</p><p>特别是，任何用 <code>@Subscribe</code> 标记的方法都必须只接受一个参数</p><p>任何违反此规则的行为都将引发 <code>IllegalArgumentException</code>（这个检查可以转移到使用 APT 的编译时间，这是我们正在研究的一个解决方案）</p><p><strong>哪些 Event Bus 问题只能在稍后的运行时检测到？</strong></p><p>如果组件 post 了没有注册侦听器的事件，则可能指示错误（通常指示您错过了 <code>@Subscribe</code> 注释，或者侦听组件未加载）</p><p>（请注意，这并不一定意味着有问题；在许多情况下，应用程序会故意忽略发布的事件，尤其是当事件来自您无法控制的代码时）</p><p>要处理此类事件，请为 <code>DeadEvent</code> 类注册一个订阅者方法，每当 <code>EventBus</code> 接收到没有注册订阅者的事件时，它都会将其转换为 <code>DeadEvent</code> 并按您的方式传递，从而允许您记录它或以其他方式恢复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信事件：接收没有订阅者的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerDeadEvent</span><span class="params">(DeadEvent deadEvent)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;EventListener#listenerDeadEvent -&gt; &quot;</span> + deadEvent.getEvent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我如何测试消息订阅者和他们的订阅方法？</strong></p><p>因为侦听器类上的订阅者方法是普通方法，所以您可以简单地从测试代码中调用它们来模拟 <code>EventBus</code></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h2><p><code>EventBus</code> 承载了订阅信息和 post 事件的能力，实例和实例之间的信息互相隔离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EventBus(</span><br><span class="line">    String identifier,</span><br><span class="line">    Executor executor,</span><br><span class="line">    Dispatcher dispatcher,</span><br><span class="line">    SubscriberExceptionHandler exceptionHandler) &#123;</span><br><span class="line">  <span class="built_in">this</span>.identifier = checkNotNull(identifier);</span><br><span class="line">  <span class="built_in">this</span>.executor = checkNotNull(executor);</span><br><span class="line">  <span class="built_in">this</span>.dispatcher = checkNotNull(dispatcher);</span><br><span class="line">  <span class="built_in">this</span>.exceptionHandler = checkNotNull(exceptionHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造器来看，主要有以下主要的初始属性：</p><ul><li>identifier：该 <code>EventBus</code> 实例的简称标识</li><li>executor：执行器；默认是一个直接执行器</li><li>dispatcher：调度器；默认是单线程队列调度</li><li>exceptionHandler：异常处理器</li></ul><p><code>EventBus</code> 还有一个子类 <code>AsyncEventBus</code></p><p>区别在于可以设置 <code>Executor</code>，<code>Dispatcher</code> 默认为 <code>LegacyAsyncDispatcher</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AsyncEventBus</span><span class="params">(Executor executor, SubscriberExceptionHandler subscriberExceptionHandler)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(<span class="string">&quot;default&quot;</span>, executor, Dispatcher.legacyAsync(), subscriberExceptionHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="register-注册订阅方法"><a href="#register-注册订阅方法" class="headerlink" title="register 注册订阅方法"></a>register 注册订阅方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EventBus</span> <span class="variable">eventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line">        eventBus.register(<span class="keyword">new</span> <span class="title class_">EventListener</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法用于注册订阅方法，即处理事件的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object listener)</span> &#123;</span><br><span class="line">  <span class="comment">// 拿到所有包装的 Subscriber</span></span><br><span class="line">  Multimap&lt;Class&lt;?&gt;, Subscriber&gt; listenerMethods = findAllSubscribers(listener);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;Class&lt;?&gt;, Collection&lt;Subscriber&gt;&gt; entry : listenerMethods.asMap().entrySet()) &#123;</span><br><span class="line">    Class&lt;?&gt; eventType = entry.getKey();</span><br><span class="line">    Collection&lt;Subscriber&gt; eventMethodsInListener = entry.getValue();</span><br><span class="line"></span><br><span class="line">    CopyOnWriteArraySet&lt;Subscriber&gt; eventSubscribers = subscribers.get(eventType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存到 eventSubscribers</span></span><br><span class="line">    <span class="keyword">if</span> (eventSubscribers == <span class="literal">null</span>) &#123;</span><br><span class="line">      CopyOnWriteArraySet&lt;Subscriber&gt; newSet = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line">      <span class="comment">// key 是 event type</span></span><br><span class="line">      eventSubscribers =</span><br><span class="line">          MoreObjects.firstNonNull(subscribers.putIfAbsent(eventType, newSet), newSet);</span><br><span class="line">    &#125;</span><br><span class="line">    eventSubscribers.addAll(eventMethodsInListener);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了 Guava 包下的 cache 工具</p><p>直接看扫描订阅方法的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ImmutableList&lt;Method&gt; <span class="title function_">getAnnotatedMethodsNotCached</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">    Set&lt;? <span class="keyword">extends</span> <span class="title class_">Class</span>&lt;?&gt;&gt; supertypes = TypeToken.of(clazz).getTypes().rawTypes();</span><br><span class="line">    Map&lt;MethodIdentifier, Method&gt; identifiers = Maps.newHashMap();</span><br><span class="line">  <span class="comment">// 遍历类型</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; supertype : supertypes) &#123;</span><br><span class="line">      <span class="comment">// 遍历方法</span></span><br><span class="line">      <span class="keyword">for</span> (Method method : supertype.getDeclaredMethods()) &#123;</span><br><span class="line">        <span class="comment">// 扫描注解</span></span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(Subscribe.class) &amp;&amp; !method.isSynthetic()) &#123;</span><br><span class="line">          <span class="comment">// TODO(cgdecker): Should check for a generic parameter type and error out</span></span><br><span class="line">          Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">          <span class="comment">// check 方法参数数量</span></span><br><span class="line">          checkArgument(</span><br><span class="line">              parameterTypes.length == <span class="number">1</span>,</span><br><span class="line">              <span class="string">&quot;Method %s has @Subscribe annotation but has %s parameters. &quot;</span></span><br><span class="line">                  + <span class="string">&quot;Subscriber methods must have exactly 1 parameter.&quot;</span>,</span><br><span class="line">              method,</span><br><span class="line">              parameterTypes.length);</span><br><span class="line"><span class="comment">// check 方法参数是否是原始类型</span></span><br><span class="line">          checkArgument(</span><br><span class="line">              !parameterTypes[<span class="number">0</span>].isPrimitive(),</span><br><span class="line">              <span class="string">&quot;@Subscribe method %s&#x27;s parameter is %s. &quot;</span></span><br><span class="line">                  + <span class="string">&quot;Subscriber methods cannot accept primitives. &quot;</span></span><br><span class="line">                  + <span class="string">&quot;Consider changing the parameter to %s.&quot;</span>,</span><br><span class="line">              method,</span><br><span class="line">              parameterTypes[<span class="number">0</span>].getName(),</span><br><span class="line">              Primitives.wrap(parameterTypes[<span class="number">0</span>]).getSimpleName());</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 包装反射出的方法</span></span><br><span class="line">          <span class="type">MethodIdentifier</span> <span class="variable">ident</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodIdentifier</span>(method);</span><br><span class="line">          <span class="keyword">if</span> (!identifiers.containsKey(ident)) &#123;</span><br><span class="line">            <span class="comment">// 保存</span></span><br><span class="line">            identifiers.put(ident, method);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ImmutableList.copyOf(identifiers.values());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>主要流程：</p><ul><li>获取 <code>Object</code> 对象的类型列表</li><li>遍历方法</li><li>扫描出 <code>Subscribe</code> 方法，校验参数列表</li><li>包装为 <code>MethodIdentifier</code> 保存</li></ul><h2 id="post-发布事件"><a href="#post-发布事件" class="headerlink" title="post 发布事件"></a>post 发布事件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EventBus</span> <span class="variable">eventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line">        eventBus.register(<span class="keyword">new</span> <span class="title class_">EventListener</span>());</span><br><span class="line">        eventBus.post(<span class="number">1</span>);</span><br><span class="line">        eventBus.post(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        eventBus.post(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发布事件的操作其实就包含了对订阅者的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">  <span class="comment">// 根据 event type 查询订阅者列表</span></span><br><span class="line">  Iterator&lt;Subscriber&gt; eventSubscribers = subscribers.getSubscribers(event);</span><br><span class="line">  <span class="comment">// 如果有订阅方法，则调用 dispatch</span></span><br><span class="line">  <span class="keyword">if</span> (eventSubscribers.hasNext()) &#123;</span><br><span class="line">    dispatcher.dispatch(event, eventSubscribers);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(event <span class="keyword">instanceof</span> DeadEvent)) &#123;</span><br><span class="line">    <span class="comment">// 如果对应事件没有订阅者，则包装为死信消息</span></span><br><span class="line">    <span class="comment">// the event had no subscribers and was not itself a DeadEvent</span></span><br><span class="line">    post(<span class="keyword">new</span> <span class="title class_">DeadEvent</span>(<span class="built_in">this</span>, event));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的调度器有不同的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(Object event, Iterator&lt;Subscriber&gt; subscribers)</span> &#123;</span><br><span class="line">  checkNotNull(event);</span><br><span class="line">  checkNotNull(subscribers);</span><br><span class="line">  Queue&lt;Event&gt; queueForThread = queue.get();</span><br><span class="line">  queueForThread.offer(<span class="keyword">new</span> <span class="title class_">Event</span>(event, subscribers));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dispatching.get()) &#123;</span><br><span class="line">    dispatching.set(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Event nextEvent;</span><br><span class="line">      <span class="keyword">while</span> ((nextEvent = queueForThread.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nextEvent.subscribers.hasNext()) &#123;</span><br><span class="line">          nextEvent.subscribers.next().dispatchEvent(nextEvent.event);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      dispatching.remove();</span><br><span class="line">      queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用 <code>Subscriber</code> 的 <code>dispatchEvent</code> 方法，通过反射进行执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">dispatchEvent</span><span class="params">(<span class="keyword">final</span> Object event)</span> &#123;</span><br><span class="line">  executor.execute(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            invokeSubscriberMethod(event);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            bus.handleSubscriberException(e.getCause(), context(event));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dispatcher-调度器"><a href="#Dispatcher-调度器" class="headerlink" title="Dispatcher 调度器"></a>Dispatcher 调度器</h2><p>调度器用来改变事件发布后调用订阅方法的顺序</p><p>有三种实现：</p><ul><li>PerThreadQueuedDispatcher：每个线程内的事件都按照发布顺序调用订阅者；广度优先</li><li>LegacyAsyncDispatcher：单个全局队列中发布的事件进行排队；广度优先</li><li>ImmediateDispatcher：事件发布后立即将事件调度给订阅者，而不使用中间队列来更改调度顺序；深度优先</li></ul><h3 id="PerThreadQueuedDispatcher"><a href="#PerThreadQueuedDispatcher" class="headerlink" title="PerThreadQueuedDispatcher"></a>PerThreadQueuedDispatcher</h3><p>每个线程内的事件都按照发布顺序调用订阅者；广度优先</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PerThreadQueuedDispatcher</span> <span class="keyword">extends</span> <span class="title class_">Dispatcher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This dispatcher matches the original dispatch behavior of EventBus.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Per-thread queue of events to dispatch. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Queue&lt;Event&gt;&gt; queue =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Queue&lt;Event&gt;&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">protected</span> Queue&lt;Event&gt; <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Queues.newArrayDeque();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Per-thread dispatch state, used to avoid reentrant event dispatching. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; dispatching =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Boolean&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">protected</span> Boolean <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(Object event, Iterator&lt;Subscriber&gt; subscribers)</span> &#123;</span><br><span class="line">      checkNotNull(event);</span><br><span class="line">      checkNotNull(subscribers);</span><br><span class="line">      <span class="comment">// 获取当前线程的 event 队列</span></span><br><span class="line">      Queue&lt;Event&gt; queueForThread = queue.get();</span><br><span class="line">      <span class="comment">// 将当前发布的事件 offer 进队列</span></span><br><span class="line">      queueForThread.offer(<span class="keyword">new</span> <span class="title class_">Event</span>(event, subscribers));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断调度标记</span></span><br><span class="line">      <span class="keyword">if</span> (!dispatching.get()) &#123;</span><br><span class="line">        <span class="comment">// 调度标记，设置为 true</span></span><br><span class="line">        dispatching.set(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Event nextEvent;</span><br><span class="line">          <span class="keyword">while</span> ((nextEvent = queueForThread.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nextEvent.subscribers.hasNext()) &#123;</span><br><span class="line">              <span class="comment">// 调度订阅方法</span></span><br><span class="line">              nextEvent.subscribers.next().dispatchEvent(nextEvent.event);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 清理 ThreadLocal</span></span><br><span class="line">          dispatching.remove();</span><br><span class="line">          queue.remove();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PerThreadQueuedDispatcher</code> 隔离了线程，每个线程的事件都在一个队列下保证调度</p><p>同时使用一个线程隔离的标记 <code>dispatching</code> 当前线程的事件队列是否正在调度中</p><p>这样就达到了广度优先的效果，事件 A 和事件 B  &#x3D;&gt; [a1,a2,a3,b1,b2,b3]</p><h3 id="LegacyAsyncDispatcher"><a href="#LegacyAsyncDispatcher" class="headerlink" title="LegacyAsyncDispatcher"></a>LegacyAsyncDispatcher</h3><p>单个全局队列中发布的事件进行排队；广度优先</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LegacyAsyncDispatcher</span> <span class="keyword">extends</span> <span class="title class_">Dispatcher</span> &#123;</span><br><span class="line">    <span class="comment">/** Global event queue. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentLinkedQueue&lt;EventWithSubscriber&gt; queue =</span><br><span class="line">        Queues.newConcurrentLinkedQueue();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(Object event, Iterator&lt;Subscriber&gt; subscribers)</span> &#123;</span><br><span class="line">      checkNotNull(event);</span><br><span class="line">      <span class="keyword">while</span> (subscribers.hasNext()) &#123;</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">EventWithSubscriber</span>(event, subscribers.next()));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      EventWithSubscriber e;</span><br><span class="line">      <span class="keyword">while</span> ((e = queue.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        e.subscriber.dispatchEvent(e.event);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了一个全局事件队列 <code>ConcurrentLinkedQueue</code> 来保证顺序</p><p>以此在异步的过程中同样达到消息订阅广度的效果</p><p>事件 A 和事件 B  &#x3D;&gt; [a1,a2,a3,b1,b2,b3]</p><h3 id="ImmediateDispatcher"><a href="#ImmediateDispatcher" class="headerlink" title="ImmediateDispatcher"></a>ImmediateDispatcher</h3><p>事件发布后立即将事件调度给订阅者，而不使用中间队列来更改调度顺序；深度优先</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ImmediateDispatcher</span> <span class="keyword">extends</span> <span class="title class_">Dispatcher</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ImmediateDispatcher</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImmediateDispatcher</span>();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(Object event, Iterator&lt;Subscriber&gt; subscribers)</span> &#123;</span><br><span class="line">    checkNotNull(event);</span><br><span class="line">    <span class="keyword">while</span> (subscribers.hasNext()) &#123;</span><br><span class="line">      subscribers.next().dispatchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是事件发布后拿到订阅列表立即调度</p><p>区别排队的机制，消息和消息之间不保证先后顺序</p><p>事件 A 和事件 B 之间有可能是 [a1,a2,a3,b1,b2,b3]，也有可能是 [a1,a2,b1,b2,a3,b3]，也可能是 [a1,b1,b2,b3,a2,a3]</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/google/guava/wiki/EventBusExplained">EventBusExplained · google&#x2F;guava Wiki · GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> Guava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《电吉他系统教程1.0》学习笔记</title>
      <link href="/%E4%BA%BA%E7%94%9F/%E5%8D%8E%E5%8C%97%E6%97%A0%E6%B5%AA%E6%BC%AB/%E3%80%8A%E7%94%B5%E5%90%89%E4%BB%96%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B1.0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
      <url>/%E4%BA%BA%E7%94%9F/%E5%8D%8E%E5%8C%97%E6%97%A0%E6%B5%AA%E6%BC%AB/%E3%80%8A%E7%94%B5%E5%90%89%E4%BB%96%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B1.0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>买了人生第一把电吉他（型号是 <strong>Ibenez</strong> 的 <strong>GRG121SP</strong>）</p><p>下面是其帅照~</p><img src="/%E4%BA%BA%E7%94%9F/%E5%8D%8E%E5%8C%97%E6%97%A0%E6%B5%AA%E6%BC%AB/%E3%80%8A%E7%94%B5%E5%90%89%E4%BB%96%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B1.0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%90%89%E4%BB%96%E5%B8%85%E7%85%A7.jpg" class="" title="吉他帅照"><p>就从 B 站的视频开始吧</p><p><a href="https://www.bilibili.com/video/BV1FT411Z7iu/?spm_id_from=333.337.search-card.all.click&vd_source=d71ed59532fe75ae6e76322af844c014">【完整版】全网最简单的《电吉他系统教程1.0》适合零基础自学入门_哔哩哔哩_bilibili</a></p><p>这里记录一些动作、知识要点</p><h1 id="W1-EX1-右手空弦下拨"><a href="#W1-EX1-右手空弦下拨" class="headerlink" title="W1 EX1 - 右手空弦下拨"></a>W1 EX1 - 右手空弦下拨</h1><p><strong>动作要点</strong></p><ul><li>坐姿<ul><li>胳膊夹琴倾斜</li><li>大腿和地面平行</li><li>琴头略微上翘</li></ul></li><li>拨片<ul><li>正步姿势，拇指、食指捏住拨片</li><li>用力，拨动时拨片不要上下摇晃</li></ul></li><li>护弦<ul><li>大小鱼际都靠在弦上</li><li>拨弦时手不要悬空，否则没有护弦的效果</li></ul></li><li>拨弦<ul><li>拨弦位置应该位于两个拾音器（双双）中间</li><li>拨片面与琴弦平行</li><li>拨弦使用手腕发力，大臂和小臂不要发力，完全放松</li><li>拨弦方向沿手腕方向，类似钟摆上下运动（不是扭钥匙）；向下拨而不是向外拨</li><li>练习手腕的发力，拨下二弦时，最终拨片停在一弦上</li></ul></li></ul><p><strong>练习</strong></p><p>速度 40，第一拍弹弦，第二拍停顿，第三拍弹弦，第四拍停顿</p><h1 id="W1-EX2-12-品音高模唱"><a href="#W1-EX2-12-品音高模唱" class="headerlink" title="W1 EX2 - 12 品音高模唱"></a>W1 EX2 - 12 品音高模唱</h1><p><strong>知识要点</strong></p><ul><li>钢琴中第一个八度用 <code>C1</code> 表示，那么中音区的小字一组就表示为 <code>C4</code></li><li>一个八度中包含 12 个音，do\re\sol\la\si 中包含升降音，被称为全音，mi\fa 和 si\do 中没有加音，所以被成为半音</li><li>对应在吉他中也一样，每个品级是一个半音<br>例如：一弦 12 品是 mi，那么 13 品就是 fa，反过来间隔一个品是 re</li><li>吉他中每根弦间隔五品，是一样的音高（2、3 弦只间隔四品）<br>例如：一弦 8 品是 do，那么二弦的 13 品也是 do</li><li>吉他空弦 1 到 6 弦分别是，375263</li></ul><p><strong>动作要点</strong></p><ul><li>每次弹前都要调音</li><li>按住 12 品，12 品的音和空弦音一样，但是会高八度</li><li>按弦靠近品丝，把弦压在品丝上，不用特别用力</li><li>按动上面弦的时候，拇指位置不变，手腕需要一个转动，更高地按到上方的琴弦</li><li>按弦护弦，手指在按动琴弦的时候，护住上方琴弦，例如按动一弦的时候，互住上方的二弦；手指侧一点更方便护弦</li><li>拨弦时唱出唱名</li></ul><p><strong>练习</strong></p><p>速度 40，节奏和上面练习一致，不同的是加上这次学习内容：按品 + 唱音</p><p>顺序按照 1 -&gt; 6 再倒过来 6 -&gt; 1 弦进行</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1FT411Z7iu/?spm_id_from=333.337.search-card.all.click&vd_source=d71ed59532fe75ae6e76322af844c014">【完整版】全网最简单的《电吉他系统教程1.0》适合零基础自学入门_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 华北无浪漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电吉他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP Server-Sent Events 简单使用</title>
      <link href="/%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C/HTTP%20Server-Sent%20Events%20%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html"/>
      <url>/%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C/HTTP%20Server-Sent%20Events%20%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Server-Sent Events（SSE）是一种基于 HTTP 的服务器推送技术，它允许服务器向客户端实时发送数据</p><p>通过SSE，服务器可以主动推送数据给客户端，而无需客户端发起请求</p><p>SSE 建立在 HTTP 协议之上，使用了长连接（持久连接）来实现服务器和客户端之间的实时通信</p><p>与传统的请求-响应模型不同，SSE 允许服务器在事件发生时主动向客户端发送数据。这使得服务器可以实时地向客户端推送更新的信息、通知、状态变化等</p><p>例如 GPT 等 AI 的问答窗口，往往就是用 SSE 协议，这样可以减少用户等待响应的时间；其次模拟打字机等效果也可以增强用户体验</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>标准的 HTTP 协议中，每个 HTTP 响应都会在发送完毕后关闭连接，HTTP&#x2F;1.1 协议默认采用短连接（short-lived connections）方式</p><p>HTTP 响应的头部中会包含一个 <code>Connection</code> 字段，用于指示连接的状态，当该字段的值为 <code>close</code> 时，表示服务器会在发送完响应后主动关闭连接</p><p>也可以设置为 <code>Keep-Alive</code>，服务器可以自行决定是否在每个响应后关闭连接，在响应体中同样设置 <code>Connection</code> 为 <code>Keep-Alive</code> 可以让客户端保持连接</p><p>基于这个机制就可以实现长轮询、SSE 等效果</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket 是一种浏览器和服务器之间进行全双工通信的协议，同样基于 TCP</p><p>它提供了一种实时、高效的双向通信机制，允许服务器主动向客户端推送数据，而不需要客户端发起请求，WebSocket 协议相对于传统的 HTTP 协议更适合实时通信和实时更新的应用场景</p><p>WebSocket 不是 HTTP 协议，但是需要先使用 HTTP 协议进行协议升级</p><p><strong>对比表格</strong></p><table><thead><tr><th>协议</th><th>通信模式</th><th>场景</th></tr></thead><tbody><tr><td>HTTP</td><td>单向短连接</td><td>请求-响应</td></tr><tr><td>HTTP SSE</td><td>单向长连接</td><td>服务器推送</td></tr><tr><td>WebSocket</td><td>双向长连接</td><td>双向通信</td></tr></tbody></table><h2 id="协议细节"><a href="#协议细节" class="headerlink" title="协议细节"></a>协议细节</h2><p>要订阅服务器事件，客户端发出 GET 请求带有指定的 header：</p><ul><li><strong>Accept</strong>：<code>text/event-stream</code> 表示可接收事件流类型</li><li><strong>Cache-Control</strong>：<code>no-cache</code> 禁用任何的事件缓存</li><li><strong>Connection</strong>：<code>keep-alive</code> 表示正在使用持久连接</li></ul><p>服务器应该使用相应的响应来确认订阅：</p><ul><li><strong>Content-Type</strong>：<code>text/event-stream;charset=UTF-8</code> 表示标准要求的事件的媒体类型和编码</li><li><strong>Transfer-Encoding</strong>：<code>chunked</code> 表示服务器流式传输动态生成的内容，因此内容大小事先未知</li><li><strong>Connection</strong>：<code>keep-alive</code> 表示正在使用持久连接，</li><li><strong>Keep-Alive</strong>：例如 <code>timeout=60</code>，服务端告知客户端保持连接的时长</li></ul><hr><p><strong>数据内容</strong></p><p>事件之间由两个换行符分隔 <code>\n\n</code></p><p>每个事件由一个或多个 <code>名称:值</code> 字段组成，由单个换行符 <code>\n</code> 分隔</p><p><code>comment</code> 属性则只会有 <code>:值</code>，客户端可以根据特征判断</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id:<span class="keyword">this</span> <span class="keyword">is</span> id</span><br><span class="line">event:<span class="keyword">this</span> <span class="keyword">is</span> event name</span><br><span class="line">:<span class="keyword">this</span> <span class="keyword">is</span> comment</span><br><span class="line"><span class="keyword">data</span>:<span class="keyword">this</span> <span class="keyword">is</span> <span class="keyword">data</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">id:<span class="keyword">this</span> <span class="keyword">is</span> id</span><br><span class="line">event:<span class="keyword">this</span> <span class="keyword">is</span> event name</span><br><span class="line">:<span class="keyword">this</span> <span class="keyword">is</span> comment</span><br><span class="line"><span class="keyword">data</span>:<span class="keyword">this</span> <span class="keyword">is</span> <span class="keyword">data</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>使用 Spring 实现一个 SSE 接口，Spring MVC 已经提供了对 SSE 的支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SSEController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SSEService sseService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/sse&quot;, produces = MediaType.TEXT_EVENT_STREAM_VALUE)</span></span><br><span class="line">    <span class="keyword">public</span> SseEmitter <span class="title function_">streamEvents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SseEmitter</span> <span class="variable">emitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SseEmitter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送事件</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sentence</span> <span class="operator">=</span> sseService.giveMeASentence();</span><br><span class="line">            Stream.of(sentence.split(<span class="string">&quot;&quot;</span>)).forEach(c -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emitter.send(SseEmitter.event().data(String.valueOf(c)));</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(RandomUtil.randomInt(<span class="number">30</span>, <span class="number">100</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    emitter.completeWithError(e);</span><br><span class="line">                    log.error(<span class="string">&quot;SSE error&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            emitter.complete();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> emitter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本步骤：</p><ol><li>使用 <code>@RestController</code> 注解创建一个 Controller</li><li>REST 方法返回一个 <code>SseEmitter</code>，处理 GET 请求并产生文本&#x2F;事件流 <code>text/event-stream</code></li><li>创建一个新的 <code>SseEmitter</code>，保存它并从方法中返回</li><li>异步线程操作 <code>SseEmitter</code>，实现服务端的多次响应和对连接的关闭</li></ol><p>这里为了模拟打字机效果，操作 <code>SseEmitter</code> 时做了一个 sleep 操作，获取文案后拆分调用 <code>SseEmitter</code>，响应完成后关闭连接</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p><code>SSEService</code> 主要是提供一段文案，这个不重要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SSEService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; SENTENCES = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SENTENCES.add(<span class="string">&quot;成功不是最终的，失败不是致命的，勇气继续前进才是最重要的。 ———— 丘吉尔&quot;</span>);</span><br><span class="line">        SENTENCES.add(<span class="string">&quot;生活就像骑自行车，你必须保持前进才能保持平衡。 ———— 爱因斯坦&quot;</span>);</span><br><span class="line">        SENTENCES.add(<span class="string">&quot;成功的关键是把握机会的能力 ———— 爱迪生&quot;</span>);</span><br><span class="line">        SENTENCES.add(<span class="string">&quot;不管你走了多远，决定转身总是你自己 ———— 马丁·路德·金&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">giveMeASentence</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SENTENCES.get(RandomUtil.randomInt(SENTENCES.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>比如前端等，可以制作出打字机的效果</p><p>这里简单使用 Java 的 <code>print</code> 操作来模拟出这种效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SSEClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// SSE 接口的 URL</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sseUrl</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8080/sse&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 URL 对象</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(sseUrl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打开 HTTP 连接</span></span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置请求方法为 GET</span></span><br><span class="line">        connection.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置请求头</span></span><br><span class="line">        connection.setRequestProperty(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;text/event-stream&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送请求</span></span><br><span class="line">        connection.connect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查响应码</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">responseCode</span> <span class="operator">=</span> connection.getResponseCode();</span><br><span class="line">        <span class="keyword">if</span> (responseCode == HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">            <span class="comment">// 从连接中获取输入流</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(connection.getInputStream()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取 SSE 事件数据</span></span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 处理 SSE 事件数据</span></span><br><span class="line">                <span class="keyword">if</span> (line.length() &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">eventData</span> <span class="operator">=</span> line.substring(<span class="number">5</span>).trim();</span><br><span class="line">                System.out.print(eventData);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭输入流</span></span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Failed to connect to SSE endpoint. Response code: &quot;</span> + responseCode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断开连接</span></span><br><span class="line">        connection.disconnect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><img src="/%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C/HTTP%20Server-Sent%20Events%20%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/%E5%8A%A8%E7%94%BB.gif" class="" title="动画"><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/444011262?utm_id=0">SSE（Server-Send Events）实战 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>规则引擎简单介绍</title>
      <link href="/%E5%BC%80%E5%8F%91/LiteFlow/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D.html"/>
      <url>/%E5%BC%80%E5%8F%91/LiteFlow/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D.html</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote><p>如果你一直在开发一种产品或业务，那么经常发生的场景就是不断变化的业务需求；开发人员基于一组条件构建解决方案，随着时间的推移，这些逻辑条件可能会因业务需求或其他外部市场因素的变化而发生改变</p><p>规则引擎是解决此类问题的有效方法</p><p><a href="https://www.mohitkhare.com/blog/guide-to-rule-engines/">Guide to Rule Engines – Mohit Khare</a></p><p>美团外卖的 CRM 业务步入成熟期，规则类需求几乎撑起了这个业务所有需求的半边天；一方面规则唯一不变的是 “多变”，另一方面开发团队对 “规则开发” 的感受是乏味、疲惫和缺乏技术含量</p><p>如何解决规则开发的效率问题，最大化解放开发团队成为目前的一个 KPI</p><p><a href="https://tech.meituan.com/2017/06/09/maze-framework.html">从0到1：构建强大且易用的规则引擎 - 美团技术团队 (meituan.com)</a></p></blockquote><h2 id="什么是规则引擎"><a href="#什么是规则引擎" class="headerlink" title="什么是规则引擎"></a>什么是规则引擎</h2><p>业务规则引擎是在执行一个或多个业务规则的系统，这些规定可能来自各种业务规则：</p><ul><li>员工可以因任何原因或无原因被解雇，但不能因非法原因</li><li>所有一次性消费超过 100 美元的客户都将获得 10% 的折扣</li></ul><p>业务规则系统使这些倾向于运营决策、公司策略的规则能够与应用程序代码分开定义、测试、执行和维护；规则集用于检查条件并选择合适的业务执行操作</p><p>规则可以简单抽象为如下结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">When</span><br><span class="line">   &lt;Condition is <span class="literal">true</span>&gt;</span><br><span class="line">Then</span><br><span class="line">   &lt;Take desired Action&gt;</span><br></pre></td></tr></table></figure><p>例如一个提供折扣优惠的规则</p><p><strong>条件：</strong>当用户满足以下所有条件时</p><ul><li>至少下单过 10 个订单</li><li>平均订单价格大于 150 元</li><li>用户年龄在 20 ~ 30</li></ul><p><strong>行为：</strong>提供 20% 的折扣</p><p>规则引擎在解决面向业务的逻辑时比较有效，这些逻辑使用许多业务属性来产生某种决策</p><p>难道我们不能把这个逻辑嵌入我们的代码中吗？可以这样做，但规则化提供了修改条件和添加更多逻辑的灵活性；这些条件也许更多来由产品或业务产出，这会让它们更加容易变更，也许不需要由开发人员进行修改</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p><a href="https://github.com/hyperjumptech/grule-rule-engine#advantages-of-a-rule-engine">grule-rule-engine: Rule engine implementation in Golang Advantages of a Rule Engine</a></p><ul><li><strong>声明式编程</strong>（Declarative Programming）：规则可以很容易地表达难题的解决方案并进行验证；与代码不同，规则是用不那么复杂的语言编写的；业务分析师可以很容易地阅读和验证一套规则</li><li><strong>逻辑和数据分离</strong>（Logic and Data Separation）：数据驻留在域对象中（Domain Objects），业务逻辑驻留在规则中（Rules）；根据项目的类型，这种分离可能非常有利</li><li><strong>知识集中化</strong>（Centralization of Knowledge）：通过使用规则，您可以创建一个可执行的知识库（a repository of knowledge | a knowledge base）；这是商业政策的唯一真理；理想情况下规则是可读的，因此它们也可以作为文档</li><li><strong>改变的敏捷性</strong>（Agility To Change）：由于业务规则实际上被视为数据，根据业务的动态性质调整规则变得微不足道；不需要像正常的软件开发那样重新构建代码或部署，只需要推出规则集并将其应用于知识库即可</li></ul><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><p><a href="https://github.com/hyperjumptech/grule-rule-engine#use-cases">grule-rule-engine: Rule engine implementation in Golang use-cases</a></p><p>使用规则引擎可以更好地解决以下情况：</p><ul><li><strong>专家系统</strong>（Expert System）：必须评估事实以提供某种现实世界的结论；如果不使用 RETE 风格的规则引擎，就会编写一组 If&#x2F;else 语句的级联集，而如何评估这些语句的组合的排列将很快变得无法管理</li><li><strong>评级系统</strong>（Rating System）：例如银行系统可能希望根据客户的交易记录（事实）为每个客户创建一个 “分数”；我们可以根据他们与银行互动的频率、进出资金的多少、支付账单的速度、累计利息的多少、为自己或银行赚了多少等等来查看他们的分数变化，随后银行客户分析部门的专家可以来提供事实和规则的说明</li><li><strong>电脑游戏</strong>：玩家状态、奖励、惩罚、伤害、分数和概率系统是规则在大多数电脑游戏中发挥重要作用的许多不同例子</li><li><strong>分类系统</strong>（Classification Systems）：使用规则引擎，我们可以对信用资格、生物化学识别、保险产品风险评估、潜在安全威胁等进行分类</li><li><strong>建议系统</strong>（Suggestion System）：“规则” 只是另一种数据，这使它可以成为另一个程序的产出；这个程序可以是另一个专家系统或人工智能，规则可以由其他系统操纵以便处理关于规则集针对业务域新建模型来处理新的事实</li></ul><p>还有许多其他用例将受益于规则引擎的使用，上述情况只是潜在情况中的一小部分</p><p>不过规则引擎当然不是银弹，存在许多替代方案来解决软件中的 “知识” 问题，并且应该在最合适的地方使用这些替代方案；例如如果一个简单的 if&#x2F;else 分支就足够了，那么就不需要使用规则引擎</p><p>还有一点需要注意：一些规则引擎实现非常昂贵，但许多企业从中获得了如此多的价值，以至于运行它们的成本很容易被这些价值所抵消；对于即使是中等复杂的场景，强大的规则引擎对于解耦团队并解决业务复杂性也有显著的优势</p><div STYLE="page-break-after: always;"></div><h2 id="开源生态"><a href="#开源生态" class="headerlink" title="开源生态"></a>开源生态</h2><h3 id="Drools"><a href="#Drools" class="headerlink" title="Drools"></a>Drools</h3><p><a href="https://www.drools.org/learn/documentation.html">Drools - Documentation</a><br>Drools 使用基于规则的编程模型，允许开发人员通过编写规则来描述应用程序中的业务逻辑</p><p>特点：</p><ul><li><strong>基于规则的编程模型</strong>：Drools 使用规则引擎来编写业务规则，允许开发人员将业务逻辑从应用程序中分离出来，使其更加灵活和易于维护</li><li><strong>支持多种规则格式</strong>：包括 <strong>DRL</strong>（<em>Drools 规则语法</em>  | Drools Rule Language）、<strong>DSL</strong>（<em>领域特定语法</em> | Domain Specific Language），支持 OMG^1^ 标准下的 <strong>DMN</strong>（<em>决策模型与符号</em> | Decision Model and Notation）  ，甚至数据领域 DMG^2^ 标准的 <strong>PMML</strong>（<em>预测模型标记语言</em> | Predictive Model Markup Language）</li><li><strong>多语言支持</strong>：Drools 不仅支持 Java 语言，还支持其他编程语言如 Python 等</li><li><strong>完善的生态</strong>：Drools 下生态丰富，涉及多种工具<ul><li><strong>Drools Engine</strong>：核心 Drools 规则引擎</li><li><strong>Drools and jBPM integration</strong>：规则引擎 Drools 和工作流 jBPM 整合</li><li><strong>Business Central Workbench^3^</strong>：可视化工作台</li><li><strong>KIE Execution Server</strong>：可用于使用 REST、JMS 或 Java 接口远程执行规则的独立执行服务器</li></ul></li><li><strong>规则插件</strong>：DRL 规则文件插件高亮</li></ul><hr><p>缺点：</p><blockquote><p><em>开源 Drools 从入门到放弃</em><br>                                    ——《<a href="https://tech.meituan.com/2017/06/09/maze-framework.html">从0到1：构建强大且易用的规则引擎 - 美团技术团队 (meituan.com)</a>》</p></blockquote><ul><li>业务分析师无法独立完成规则配置：由于规则主体 DSL 是编程语言（支持 Java, Groovy, Python 等），因此仍然需要开发工程师维护</li><li>规则规模变大以后也会变得不好维护，相对硬编码的优势便不复存在</li><li>规则的语法仅适合扁平的规则，对于嵌套条件语义（<code>then</code> 中嵌套 <code>whenthen</code> 子句）的规则只能将条件进行笛卡尔积组合以后进行配置，不利于维护</li></ul><p>备注</p><blockquote><ol><li><p>OMG 是Object Management Group的缩写，是一个国际性的技术标准组织，成立于 1989 年，总部位于美国马萨诸塞州的 Needham。OMG 的成员包括软件和硬件供应商、工具提供商、服务提供商、企业和政府机构等，旨在推动和制定面向对象技术的标准和规范<br><a href="https://www.omg.org/spec/DMN">About the Decision Model and Notation Specification Version 1.4 (omg.org)</a></p></li><li><p>Data Mining Group（DMG）是一个非营利性组织，成立于 1994 年，旨在推动数据挖掘和知识发现技术的发展和应用。DMG 的成员包括数据挖掘和机器学习领域的专家、学者和工业界代表，致力于制定和推广数据挖掘标准和规范</p></li><li><p>Business Central Workbench GUI</p></li></ol><img src="/%E5%BC%80%E5%8F%91/LiteFlow/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/image-20230625034858176.png" class="" title="image-20230625034858176"></blockquote><h3 id="LiteFlow"><a href="#LiteFlow" class="headerlink" title="LiteFlow"></a>LiteFlow</h3><p><a href="https://liteflow.yomahub.com/">LiteFlow (yomahub.com)</a></p><p>可以将瀑布流式的代码，转变成以组件为核心概念的代码结构，这种结构的好处是可以任意编排，组件与组件之间是解耦的，组件可以用脚本来定义，组件之间的流转全靠规则来驱动</p><p>特点：</p><ul><li><strong>语法简单</strong>：组件由 Java（硬编码）或支持的脚本语言进行开发，规则 DSL 语法定义简单，符合 Spring 等 IOC 框架的容器思想，易于理解</li><li><strong>流程图式编排</strong>：规则描述使用流程图模式，而不是 Drools 的 <code>when...then</code> 模式，让特定流程的任务编排更加清晰、灵活</li><li><strong>并发编排</strong>：规则逻辑可以快速编排组件之间的同步、异步关系，可以自定义执行线程池</li><li><strong>丰富的脚本组件支持</strong>：支持多种脚本语言（Groovy，Javascript，QLExpress，Python，Lua，Aviator）；采用 SPI 机制进行选择脚本框架来动态编译脚本；同时支持规则文件内多脚本语言混合使用</li><li><strong>多数据源和热刷新</strong>：EL 规则和脚本组件都支持多种数据源（项目内文件、本地文件、ZK、SQL、Nacos、Apollo 等数据源），同时支持自定义实现相关规则解析类 <code>ClassXmlFlowELParser</code> 等；支持平滑热刷新</li><li><strong>补充功能丰富</strong>：有丰富的小功能支持<ul><li>声明式组件</li><li>前置、后置组件、组件切面</li><li>组件重试</li><li>异常、步骤信息汇总</li></ul></li><li><strong>规则插件</strong>：同样拥有规则高亮插件支持，也支持脚本语法高亮</li></ul><p>官方介绍：<a href="%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E.assets/LiteFlowPPT.pptx" title="LiteFLow 介绍 PPT">LiteFLow 介绍 PPT</a></p><hr><p>缺点：</p><ul><li>缺乏大范围生产考验，社区迭代速度和成熟产品相比较慢</li><li>流程图式编排使组件规则调整需要考虑前后关系</li><li>生态不完全，没有管理平台、可视化编排工具</li></ul><h3 id="Ice"><a href="#Ice" class="headerlink" title="Ice"></a>Ice</h3><p><a href="http://waitmoon.com/zh/">开源框架学习与分享 | ice (waitmoon.com)</a></p><p>Ice 使用全新的设计思想，契合解耦和复用的属性，满足最大的编排自由度</p><p>特点：</p><ul><li><strong>独特的规则编排思想</strong>：引入关系节点的与或非控制流程，在一些场景下可以更好的对流程进行控制，避免流程前后的组件影响，降低心智负担</li><li><strong>组件的时间属性</strong>：组件天然带有时间属性，可以控制执行组件生效的时间范围（对于活动类配置非常有用）</li><li><strong>组件参数</strong>：组件参数由 Json 格式的数据进行配置，对于同样的组件不同的参数不需要从业务入口或进行中的 Context 进行控制</li><li><strong>可视化后台配置</strong>：拥有可视化后台配置，对规则和节点进行配置<br><a href="http://eg.waitmoon.com/">ice配置后台 (waitmoon.com)</a></li></ul><p>官方介绍：<a href="http://waitmoon.com/ice-logic/zh/">ice 编排逻辑</a></p><hr><p>缺点：</p><ul><li>新项目，热度低，案例少</li><li>文档简陋</li></ul><h3 id="Aviator"><a href="#Aviator" class="headerlink" title="Aviator"></a>Aviator</h3><p><a href="https://github.com/killme2008/aviatorscript">killme2008&#x2F;aviatorscript: A high performance scripting language hosted on the JVM. (github.com)</a></p><p>严格来说 AviatorScript 并不是一个规则引擎，而是一个可以编译为 Java 字节码的表达式引擎</p><p>在美团的技术文章中使用该脚本语言作为规则框架使用（具体怎么实现也看不懂，可能是因为支持自定义函数）</p><p>AviatorScript 的优势</p><ul><li><p><strong>高性能</strong>：将表达式直接翻译成对应的 Java 字节码执行，编译优先模式只扫一遍，保证了性能超越绝大部分解释性的表达式引擎</p></li><li><p><strong>轻量级</strong>：其次，除了依赖 <code>commons-beanutils</code> 这个库之外（用于做反射）不依赖任何第三方库，因此整体非常轻量级，整个 jar 包大小哪怕发展到现在 5.0 这个大版本，也才 430K</p></li><li><p><strong>开放能力</strong>：Aviator 内置的函数库非常节制，除了必须的字符串处理、数学函数和集合处理之外只能自定义函数实现，保证了安全性</p></li><li><p><strong>特色</strong>：</p><ul><li><p>支持运算符重载</p></li><li><p>原生支持大整数和 <code>BigDecimal</code> 类型及运算，并且通过运算符重载和一般数字类型保持一致的运算方式</p></li><li><p>原生支持正则表达式类型及匹配运算符 <code>=~</code></p></li><li><p>类 <code>clojure</code> 的 <code>seq</code> 库及 lambda 支持，可以灵活地处理各种集合</p></li></ul></li></ul><p><strong>美团文章中使用 Aviator 对函数的扩展</strong></p><blockquote><p>自定义函数可以扩充 Aviator 功能，规则引擎可通过自定义函数执行因子及规则条件</p><p>如调用用户画像等第三方服务</p></blockquote><table><thead><tr><th>名称</th><th>示例</th><th>含义</th></tr></thead><tbody><tr><td>equals</td><td>equals(message.orderType, 0)</td><td>判断订单类型是否为 0</td></tr><tr><td>filter</td><td>filter(browseList, ‘source’, ‘dp’)</td><td>过滤点评侧浏览列表数据</td></tr><tr><td>poiPortrait</td><td>poiPortrait(message.poiId)</td><td>根据 poiId 获取商户画像数据，如商户星级属性</td></tr><tr><td>userPortrait</td><td>userPortrait(message.userId)</td><td>根据 userId 获取用户画像数据，如用户常住地城市、用户新老客属性</td></tr><tr><td>userBlackList</td><td>userBlackList(message.userId)</td><td>根据 userId 判断用户是否为黑名单用户</td></tr></tbody></table><h3 id="Grule"><a href="#Grule" class="headerlink" title="Grule"></a>Grule</h3><p><a href="https://github.com/hyperjumptech/grule-rule-engine">hyperjumptech&#x2F;grule-rule-engine: Rule engine implementation in Golang (github.com)</a></p><p>Grule 是 Go（Golang）编程语言的规则引擎库，灵感来自广受好评的 JBOSS Drools，并以更简单的方式完成</p><p>与 Drools 一样，Grule 也有自己的 DSL 或领域特定语言</p><h2 id="应用情况"><a href="#应用情况" class="headerlink" title="应用情况"></a>应用情况</h2><ul><li>美团<br><a href="https://tech.meituan.com/2017/06/09/maze-framework.html">从0到1：构建强大且易用的规则引擎 - 美团技术团队</a><br><a href="https://juejin.cn/post/6844903593326182414">大数据：美团酒旅实时数据规则引擎应用实践</a><ul><li>外卖业务绩效指标</li><li>美团点评酒旅实时触达</li></ul></li><li>京东<br><a href="https://juejin.cn/post/7216143702123987005">履约核心引擎低代码化原理与实践 - 掘金</a><ul><li>订单生产履约</li></ul></li><li>货拉拉<br><a href="https://juejin.cn/post/7195452429154910263">货拉拉大数据基于规则引擎构建运力资源供需调节系统</a><ul><li>大数据，运力供需平衡</li></ul></li><li>雪球<br><a href="https://juejin.cn/post/7234763686475219003">规则引擎在内容管理中的探索与应用</a><ul><li>内容风控</li></ul></li><li>陌陌<br><a href="https://github.com/momosecurity/aswan">momosecurity&#x2F;aswan: 陌陌风控系统静态规则引擎，零基础简易便捷的配置多种复杂规则，实时高效管控用户异常行为。 (github.com)</a><ul><li>用户风控</li></ul></li></ul><p>各种工具、云服务其实也离不开各种规则配置</p><p><strong>Octopus 告警规则</strong></p><img src="/%E5%BC%80%E5%8F%91/LiteFlow/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/image-20230627104922361.png" class="" title="image-20230627104922361"><p><strong>Sentry Alert Rule</strong></p><img src="/%E5%BC%80%E5%8F%91/LiteFlow/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/image-20230627105038925.png" class="" title="image-20230627105038925"><p><strong>阿里云物联网平台</strong></p><p><a href="https://help.aliyun.com/document_detail/42733.html?spm=a2c4g.42733.0.i3">阿里云物联网平台 - 设置数据流转规则 (aliyun.com)</a></p><p><strong>CDN</strong></p><p><a href="https://help.aliyun.com/document_detail/424607.html?spm=5176.21213303.J_6704733920.7.1c1453c9rubSy5">阿里云 CDN - 规则引擎</a></p><h1 id="规则编排思想"><a href="#规则编排思想" class="headerlink" title="规则编排思想"></a>规则编排思想</h1><p>规则引擎的核心之一就在于规则的编排方式，上面的开源框架、工具都有其不同的规则编排思想</p><p>这里就单独聊一聊不同工具的不同规则表达</p><h2 id="when-…-then"><a href="#when-…-then" class="headerlink" title="when … then"></a>when … then</h2><p><em>代表：Drools、Grule</em></p><p><code>when ... then</code> 是最典型的规则编排思想，一组规则由两部分组成：</p><ul><li>LHS（Left Hand Side）：条件分支逻辑</li><li>RHS（Right Hand Side）：执行逻辑</li></ul><blockquote><p>The <code>when</code> part of a DRL rule (also known as the <em>Left Hand Side (LHS)</em> of the rule) contains the conditions that must be met to execute an action.</p><p>The <code>then</code> part of the rule (also known as the <em>Right Hand Side (RHS)</em> of the rule) contains the actions to be performed when the conditional part of the rule has been met.</p></blockquote><p>Drools 规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rule <span class="string">&quot;SpeedUp&quot;</span></span><br><span class="line">    salience <span class="number">10</span></span><br><span class="line">    when</span><br><span class="line">        $TestCar : TestCarClass( speedUp == <span class="literal">true</span> &amp;&amp; speed &lt; maxSpeed )</span><br><span class="line">        $DistanceRecord : DistanceRecordClass()</span><br><span class="line">    then</span><br><span class="line">        $TestCar.setSpeed($TestCar.Speed + $TestCar.SpeedIncrement);</span><br><span class="line">        update($TestCar);</span><br><span class="line">        $DistanceRecord.setTotalDistance($DistanceRecord.getTotalDistance() + $TestCar.Speed);</span><br><span class="line">        update($DistanceRecord);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>Grule 规则</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rule SpeedUp <span class="string">&quot;When testcar is speeding up we keep increase the speed.&quot;</span> salience <span class="number">10</span>  &#123;</span><br><span class="line">    when</span><br><span class="line">        TestCar.SpeedUp == <span class="literal">true</span> &amp;&amp; TestCar.Speed &lt; TestCar.MaxSpeed</span><br><span class="line">    then</span><br><span class="line">        TestCar.Speed = TestCar.Speed + TestCar.SpeedIncrement;</span><br><span class="line">        DistanceRecord.TotalDistance = DistanceRecord.TotalDistance + TestCar.Speed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>when ... then</code> 的形式适合大量事实对象进入然后进行大量规则的匹配、执行操作</p><p>整个规则是平铺式的，可以使用表格来进行展示（下面就要提到 Drools 的决策表机制）</p><p>不适合处理带有流程性的规则</p><h2 id="决策表-树"><a href="#决策表-树" class="headerlink" title="决策表 \ 树"></a>决策表 \ 树</h2><p><em>代表：Drools</em></p><p>决策表其实就是另一种形式的 <code>when ... then</code> 表达，之间可以互相转换；此外 Drools 还支持非常多的规则形式，在这里列举一部分<br><a href="https://docs.drools.org/7.73.0.Final/drools-docs/html_single/index.html#drools.AuthoringAssets">Drools Documentation#Authoring rule assets</a></p><p><img src="https://docs.drools.org/7.73.0.Final/drools-docs/html_single/Workbench/AuthoringAssets/newItemMenu.png" alt="Authoring rule assets"></p><h3 id="电子表格决策表"><a href="#电子表格决策表" class="headerlink" title="电子表格决策表"></a>电子表格决策表</h3><p>Spreadsheet decision tables</p><p>电子表格决策表是包含以表格格式定义的业务规则的 XLS 或 XLSX 电子表格</p><p>决策表中的每一行都是一条规则，每一列都是一个条件、一个操作或另一个规则属性；创建并上传电子表格决策表后，定义的规则将与所有其他规则资产一样被编译为 DRL 规则</p><p><img src="https://docs.drools.org/7.73.0.Final/drools-docs/html_single/Workbench/AuthoringAssets/decision-table-example-02.png"></p><p><img src="https://img-blog.csdnimg.cn/18216cde2ef74a6aa4fbed071c4aad89.png#pic_center"></p><p>上面的决策表例子转换为 DRL 格式的规则文件内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rules.excels;</span><br><span class="line"><span class="comment">//generated from Decision Table</span></span><br><span class="line"><span class="keyword">import</span> com.ppl.demo.entity.Account;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">global List&lt;String&gt; list;</span><br><span class="line"><span class="comment">// rule values at B11, header at B6</span></span><br><span class="line">rule <span class="string">&quot;ExcelTable_11&quot;</span></span><br><span class="line">salience <span class="number">65535</span></span><br><span class="line">agenda-group <span class="string">&quot;rule-group-001&quot;</span></span><br><span class="line">when</span><br><span class="line">$account: Account(sex != <span class="string">&quot;女&quot;</span>)</span><br><span class="line">then</span><br><span class="line">list.add(<span class="string">&quot;性别不对&quot;</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">// rule values at B12, header at B6</span></span><br><span class="line">rule <span class="string">&quot;ExcelTable_12&quot;</span></span><br><span class="line">salience <span class="number">65534</span></span><br><span class="line">agenda-group <span class="string">&quot;rule-group-001&quot;</span></span><br><span class="line">when</span><br><span class="line">$account: Account(age &lt; <span class="number">22</span> || age&gt; <span class="number">28</span>)</span><br><span class="line">then</span><br><span class="line">list.add(<span class="string">&quot;年龄不合适&quot;</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">// rule values at B13, header at B6</span></span><br><span class="line">rule <span class="string">&quot;ExcelTable_13&quot;</span></span><br><span class="line">salience <span class="number">65533</span></span><br><span class="line">agenda-group <span class="string">&quot;rule-group-002&quot;</span></span><br><span class="line">when</span><br><span class="line">$account: Account(balance &lt; <span class="number">1000</span>)</span><br><span class="line">then</span><br><span class="line">list.add(<span class="string">&quot;工资太低&quot;</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="引导式决策表"><a href="#引导式决策表" class="headerlink" title="引导式决策表"></a>引导式决策表</h3><p>Guided decision tables</p><p>Drools 支持两种类型的决策表：扩展条目表（Extended entry）和有限条目表（Limited entry）</p><ul><li><p><strong>扩展条目表</strong>：扩展条目决策表是列定义指定 Pattern、Field 和 Operator 但不指定值的决策表。值或状态本身保存在决策表的主体中<br><img src="https://docs.drools.org/7.73.0.Final/drools-docs/html_single/Workbench/AuthoringAssets/dtable-extended-entry.png" alt="扩展条目表"></p></li><li><p><strong>有限条目表</strong>：除了 Pattern、Field 和 Operator 之外，Limited Entry 决策表的列定义还为其指定值<br>决策表状态保存在表的主体中，是布尔值，其中 true 具有应用或匹配列的效果；false 表示该列不适用</p><p><img src="https://docs.drools.org/7.73.0.Final/drools-docs/html_single/Workbench/AuthoringAssets/dtable-limited-entry.png" alt="有限条目表"></p></li></ul><h3 id="引导式决策图"><a href="#引导式决策图" class="headerlink" title="引导式决策图"></a>引导式决策图</h3><p>虽然可以编写单个引导决策表，但也可以编写相关表的图，其中一个表的动作可以提供另一个表条件的潜在匹配，在这种情况下表被认为是相关的</p><p><img src="https://docs.drools.org/7.73.0.Final/drools-docs/html_single/Workbench/AuthoringAssets/dtable-graph-radar.png"></p><h3 id="引导式决策树"><a href="#引导式决策树" class="headerlink" title="引导式决策树"></a>引导式决策树</h3><p>Business Central 支持编写简单的决策树</p><p><img src="https://docs.drools.org/7.73.0.Final/drools-docs/html_single/Workbench/AuthoringAssets/GuidedDecisionTreeEditorCollapse1.png"></p><p><a href="http://49.235.87.129:8080/business-central">http://49.235.87.129:8080/business-central</a></p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><em>代表：LiteFlow</em></p><p>LiteFlow 的规则语法相当于构造出一个流程图，组件作为节点，规则描述组件间执行关系：</p><ul><li>串行 <code>THEN</code></li><li>并行 <code>WHEN</code></li><li>选择 <code>SWITCH</code></li><li>条件 <code>IF</code></li><li>循环<ul><li>for 循环 <code>FOR...DO</code></li><li>while 循环 <code>WHILE...DO</code></li><li>迭代器循环 <code>ITERATOR...DO</code></li><li>跳出 <code>BREAK</code></li></ul></li><li>异常捕获 <code>CATCH</code></li><li>异或非表达 <code>AND</code>、<code>OR</code>、<code>NOT</code></li></ul><p><img src="https://liteflow.yomahub.com/img/flow_example/e10.svg" alt="LiteFlow 复杂流程编排"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">chain</span> <span class="attr">name</span>=<span class="string">&quot;chain1&quot;</span>&gt;</span></span><br><span class="line">    THEN(</span><br><span class="line">        A,</span><br><span class="line">        WHEN(</span><br><span class="line">            THEN(B, C),</span><br><span class="line">            THEN(D, E, F),</span><br><span class="line">            THEN(</span><br><span class="line">                SWITCH(G).to(</span><br><span class="line">                    THEN(H, I, WHEN(J, K)).id(&quot;t1&quot;),</span><br><span class="line">                    THEN(L, M).id(&quot;t2&quot;)</span><br><span class="line">                ),</span><br><span class="line">                N</span><br><span class="line">            )</span><br><span class="line">        ),</span><br><span class="line">        Z</span><br><span class="line">    );</span><br><span class="line"><span class="tag">&lt;/<span class="name">chain</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用子变量优化</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">chain</span> <span class="attr">name</span>=<span class="string">&quot;chain1&quot;</span>&gt;</span></span><br><span class="line">    item1 = THEN(B, C);</span><br><span class="line">    item2 = THEN(D, E, F);</span><br><span class="line">    item3_1 = THEN(H, I, WHEN(J, K)).id(&quot;t1&quot;);</span><br><span class="line">    item3_2 = THEN(L, M).id(&quot;t2&quot;);</span><br><span class="line">    item3 = THEN(SWITCH(G).to(item3_1, item3_2), N);</span><br><span class="line">    </span><br><span class="line">    THEN(</span><br><span class="line">        A,</span><br><span class="line">        WHEN(item1, item2, item3),</span><br><span class="line">        Z</span><br><span class="line">    );</span><br><span class="line"><span class="tag">&lt;/<span class="name">chain</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="关系控制"><a href="#关系控制" class="headerlink" title="关系控制"></a>关系控制</h2><p><em>代表：ice</em></p><blockquote><p>流程图式和执行树式实现的主要缺点在于，牵一发而动全身，改动一个节点需要瞻前顾后，如果考虑不到位，很容易弄错，而且这还只是一个简单的例子，现实的活动内容要比这复杂的多的多，时间线也是很多条</p><p>往往得不偿失，到头来发现还不如硬编码</p><p><a href="http://waitmoon.com/zh/guide/#%E5%8F%98%E5%8A%A8">项目简介 | ice (waitmoon.com)</a></p></blockquote><p>Ice 的规则编排强调组件生效时间和规则之间的关系</p><p>Ice 中分为两种规则节点：</p><ul><li><strong>关系节点</strong>：关系节点为了控制业务流转<ul><li>AND：<code>&amp;&amp;</code>，在执行到 false 的地方终止执行</li><li>ANY：<code>||</code>，在执行到 true 的地方终止执行</li><li>ALL：所有子节点都会执行，根据节点返回值进行不同的返回</li><li>NONE：所有子节点都会执行，无论子节点返回什么都返回 none</li><li>TRUE：所有子节点都会执行，无论子节点返回什么，都返回 true</li></ul></li><li><strong>叶子节点</strong>：叶子节点为真正处理的节点<ul><li>Flow：一些条件与规则节点，如例子中的 ScoreFlow</li><li>Result：一些结果性质的节点，如例子中的 AmountResult，PointResult</li><li>None：一些不干预流程的动作，如装配工作等</li></ul></li></ul><hr><p>文档中有一个例子来体现这样编排规则的优势：</p><p>X 公司将在国庆放假期间，开展一个为期七天的充值小活动，活动内容如下：</p><ul><li>活动时间（10.1 - 10.7）</li><li>活动内容<ul><li>充值 100 元 送 5 元余额 （10.1 - 10.7）</li><li>充值 50 元 送 10 积分 （10.5 - 10.7）</li><li>不叠加送（充值 100 元只能获得 5 元余额，不会叠加赠送 10 积分）</li></ul></li></ul><img src="/%E5%BC%80%E5%8F%91/LiteFlow/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/ice%E4%BF%AE%E6%94%B9%E5%89%8D.png" class="" title="ice修改前"><p>需要对规则进行调整：</p><ol><li><p>充值 100 元改成 80，10 积分变 20 积分，时间改成 10.8 号结束</p></li><li><p>去掉不叠加送</p></li><li><p>5 元余额不能送太多，设置个库存 100 个；库存不足充 100 元还是得送 10 积分</p></li></ol><img src="/%E5%BC%80%E5%8F%91/LiteFlow/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/ice%E4%BF%AE%E6%94%B9%E5%90%8E.png" class="" title="ice修改后"><p>优势：</p><ul><li>对于 1 的改动，只需要修改节点逻辑（<code>ScoreFlow</code>、<code>PointResult</code>）</li><li>对于 2 的改动将入口的关系节点 ANY 修改为 ALL</li><li>对于 3 由于库存的不足，相当于没有给用户发放，则 <code>AmountResult</code> 返回 false，流程还会继续向下执行，不用做任何更改</li><li>引入 ALL 节点及 <code>TimeChangeNone</code> 来修改时间，方便测试</li></ul><blockquote><p><em>思考：规则引擎到底是什么形式</em></p><p><em>Drools 或者传统的规则引擎倾向于大量业务规则下的匹配，所以也被称为决策（Decision）引擎</em></p><p><em>而 LiteFlow 更像是设计模式的延伸，组件的执行编排，但是也称为 “规则引擎”</em></p></blockquote><h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><h2 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h2><p>DSL（Domain Specific Language，领域特定语言）是一种专门用于解决特定领域问题的编程语言，它是一种特定领域的专用语言，通常具有简单、易用、高效等特点；DSL 的语法和语义通常与特定领域的问题密切相关，可以大大简化问题的表达和解决</p><p>这里以 Drools 为例，Drools 可以根据定义的 DSL 文件和 DSLR 文件，将其转换为 DRL 表达</p><p><strong>DSL</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[&lt;scope&gt;][&lt;type definition&gt;]&lt;dsl expression&gt;=&lt;replacement text&gt;</span><br><span class="line">[when] or [condition] 定义的语法应用于LHS</span><br><span class="line">[then] or [consequence] 定义的语法应用于RHS</span><br><span class="line">[*]  以上两者都适用</span><br><span class="line">[keyword] 关键字，比如 no-loop 这一类属性</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[when] There is <span class="type">a</span> <span class="variable">person</span> <span class="operator">=</span> $p:Person()</span><br><span class="line">[when] - id greater than &#123;id:\d*&#125; = id &gt; &#123;id&#125;</span><br><span class="line">[then] print = System.out.println(<span class="string">&quot;I am fired!&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>DSLR</strong></p><p>这样整个 DSLR 文件讲使用语义化的表达来描述存在 DSL 定义的特定领域内规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule <span class="string">&#x27;test-dsl&#x27;</span></span><br><span class="line"></span><br><span class="line">when</span><br><span class="line">    There is a person</span><br><span class="line">    - id greater than <span class="number">10</span></span><br><span class="line">then</span><br><span class="line">    print</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>转换后的 DRL 规则</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rule <span class="string">&#x27;test-dsl&#x27;</span></span><br><span class="line"></span><br><span class="line">when</span><br><span class="line">    $p:Person(id &gt; <span class="number">10</span>)</span><br><span class="line">then</span><br><span class="line">    System.out.println(<span class="string">&quot;I am fired!&quot;</span>)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="DMN"><a href="#DMN" class="headerlink" title="DMN"></a>DMN</h2><p>DMN 全称 Decision Model and Notation（决策模型与符号）,是一种用于表示业务决策和规则的规范，旨在帮助参与决策的人都能简单快速理解决策过程</p><p>DMN 是由 OMG 管理的一种规范，该组织下比较知名的还有 UML 等</p><p>Drools 对 DMN 有良好的支持，支持 DMN 1.3，功能完善</p><p><a href="https://github.com/kiegroup/kogito-examples">kiegroup&#x2F;kogito-examples: Kogito examples - Kogito is a cloud-native business automation technology for building cloud-ready business applications. (github.com)</a></p><p><a href="https://learn-dmn-in-15-minutes.com/learn/introduction">Learn DMN in 15 minutes | Introduction (learn-dmn-in-15-minutes.com)</a></p><img src="/%E5%BC%80%E5%8F%91/LiteFlow/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/image-20230625000439860.png" class="" title="image-20230625000439860"><p>DMN 中支持 FEEL 规则表达式</p><p>足够友好的表达语言（Friendly Enough Expression Language ）FEEL 表达式定义了 DMN 模型中决策的逻辑，FEEL 旨在通过为决策模型结构分配语义来促进决策建模和执行</p><p><a href="https://kiegroup.github.io/dmn-feel-handbook/#dmn-feel-handbook">DMN FEEL handbook – Drools DMN FEEL handbook (kiegroup.github.io)</a></p><div STYLE="page-break-after: always;"></div><h2 id="CEP"><a href="#CEP" class="headerlink" title="CEP"></a>CEP</h2><p>CEP 是复杂事件处理（Complex event processing）的缩写</p><p>事件是某个时间点应用程序域中状态发生重大变化的记录，根据域的建模方式，状态的变化可以由单个事件、多个原子事件或相关事件的层次结构表示</p><p>从复杂事件处理（CEP）的角度来看，事件是发生在特定时间点的一种事实或对象，而业务规则是如何对来自该事实或对象的数据做出反应的定义：例如在股票经纪人应用程序中，证券价格的变化、所有权从卖方到买方的变化或账户持有人余额的变化都被视为事件，因为在给定时间应用程序域的状态发生了变化</p><p>Drools 中的 Drools engine 使用复杂事件处理（CEP）来检测和处理事件集合中的多个事件，揭示事件之间存在的关系，并从事件及其关系中推断新数据</p><p>CEP 场景具有以下关键特征：</p><ul><li>场景通常处理大量事件，但只有一小部分事件是真正关心的</li><li>事件通常是不可变的，因为它们是状态改变的一条记录（是一个历史状态）</li><li>规则和查询针对事件运行，并且必须对检测到的事件模式作出反应</li><li>相关事件通常具有很强的时间关系</li><li>独立的事件是不重要的；CEP 系统优先考虑相关事件的模式及其之间的关系</li><li>事件通常需要组合和聚合</li></ul><p>鉴于这些常见的 CEP 场景特征，Drools 中的 CEP 系统支持以下特性和功能，以优化事件处理：</p><ul><li>具有适当语义的事件处理</li><li>事件检测、关联、聚合和合成</li><li>事件流（Event stream）处理</li><li>对事件之间的时间关系建模的时间约束</li><li>事件滑动窗口</li><li>会话范围的统一时钟</li><li>反应式规则</li><li>用于事件输入到 Drools 引擎的适配器</li></ul><hr><p><strong>声明事件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">declare VoiceCall</span><br><span class="line">  <span class="meta">@role( event )</span></span><br><span class="line">  <span class="meta">@timestamp( callDateTime )</span></span><br><span class="line">  <span class="meta">@duration( callDuration )</span></span><br><span class="line">  <span class="meta">@expires( 1h35m )</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>Drools 对于 CEP 有着丰富的时间规则支持</strong></p><p>在流模式下，Drools 引擎对工作内存的事件支持以下时态运算符：</p><ul><li><code>after</code></li><li><code>before</code></li><li><code>meets</code></li><li><code>during</code></li><li>…</li></ul><p>以 <code>after</code> 为例</p><p><code>$eventA : EventA(this after[3m30s, 4m] $eventB)</code> 或者 <code>3m30s &lt;= $eventA.startTimestamp - $eventB.endTimeStamp &lt;= 4m</code></p><p>表示：如果 <code>$eventA</code> 在 <code>$eventB</code> 结束后 3 分 30 秒到 4 分之间开始，则以下模式匹配；如果 <code>$eventA</code> 在 <code>$eventB</code> 结束后 3 分 30 秒之前开始，或在 <code>$eventA</code> 结束后 4 分钟之后开始，则不匹配</p><p><strong>时间 \ 长度滑动窗口</strong></p><ul><li>处理最后 2 分钟的库存点（时间滑动窗口）<br><code>StockPoint() over window:time(2m)</code></li><li>处理最后10个库存点（长度滑动窗口）<br>  <code>StockPoint() over window:length(10)</code></li></ul><p>例如以下两个 DRL 规则根据平均温度激活火灾警报；第一条规则使用滑动时间窗口来计算最后 10 分钟的平均值，而第二条规则使用滚动长度窗口来计算最近一百个温度读数的平均值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule <span class="string">&quot;Sound the alarm if temperature rises above threshold&quot;</span></span><br><span class="line">when</span><br><span class="line">  <span class="title function_">TemperatureThreshold</span><span class="params">($max : max)</span></span><br><span class="line">  Number(doubleValue &gt; $max) from <span class="title function_">accumulate</span><span class="params">(</span></span><br><span class="line"><span class="params">    SensorReading($temp : temperature)</span> over window:time(10m),</span><br><span class="line">    average($temp))</span><br><span class="line">then</span><br><span class="line">  <span class="comment">// Sound the alarm.</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule <span class="string">&quot;Sound the alarm if temperature rises above threshold&quot;</span></span><br><span class="line">when</span><br><span class="line">  <span class="title function_">TemperatureThreshold</span><span class="params">($max : max)</span></span><br><span class="line">  Number(doubleValue &gt; $max) from <span class="title function_">accumulate</span><span class="params">(</span></span><br><span class="line"><span class="params">    SensorReading($temp : temperature)</span> over window:length(<span class="number">100</span>),</span><br><span class="line">    average($temp))</span><br><span class="line">then</span><br><span class="line">  <span class="comment">// Sound the alarm.</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><div STYLE="page-break-after: always;"></div><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><blockquote><p>Behavioral design patterns are concerned with algorithms and the assignment of responsibilities between objects.</p><p>行为模式负责对象间的高效沟通和职责委派</p></blockquote><p>对于流程图式规则，我认为是行为模式的扩展，将分支组件选择同样进行了组件化</p><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><img src="/%E5%BC%80%E5%8F%91/LiteFlow/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.drawio.png" class="" title="策略模式.drawio"><p>策略模式（Strategy Pattern）定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，从而使得算法可以独立于使用它们的客户端而变化</p><p>策略模式的优点：</p><ul><li>在于它可以提高代码的灵活性和可维护性。它可以使得算法与客户端分离，从而使得客户端不需要了解算法的具体实现细节</li><li>策略对象可以在运行时动态地切换，使得客户端可以根据不同的情况选择不同的策略对象，从而实现更加灵活的算法组合和配置</li><li>将不同行为抽取到一个独立类层次结构中， 并将原始类组合成同一个， 从而减少重复代码（便于模板）</li><li>组合代替继承</li><li>符合开闭原则，无需对上下文进行修改就能够引入新的策略</li></ul><h3 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h3><img src="/%E5%BC%80%E5%8F%91/LiteFlow/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.drawio.png" class="" title="责任链模式.drawio"><p>责任链模式（Chain of Responsibility Pattern）通过将请求发送给一系列处理对象，使得每个处理对象都有机会处理请求，从而实现请求的处理与发送者的解耦</p><p>责任链模式的优点：</p><ul><li>将复杂的处理逻辑分解为多个简单的处理对象，使得代码更加清晰易懂</li><li>可以控制请求处理的顺序</li><li>满足单一职责原则，可对发起操作和执行操作的类进行解耦</li><li>符合开闭原则，可以在不更改现有代码的情况下在程序中新增处理者</li></ul><h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><img src="/%E5%BC%80%E5%8F%91/LiteFlow/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%A8%A1%E5%BC%8F.drawio.png" class="" title="流水线模式.drawio"><p>管道设计模式（Pipeline Pattern）将一个复杂的任务分解为多个独立的阶段，每个阶段都由一个独立的处理器来完成，并且处理器之间通过管道进行连接，从而形成一个处理流程</p><p>流水线模式的优点：</p><ul><li>将复杂的任务分解为多个独立的阶段</li><li>流程编排，可以复用逻辑节点</li><li>提高代码的可重用性和可测试性，因为每个处理器都可以单独测试和调试</li><li>可以利用多核处理器的优势，提高代码的并发性能</li></ul><h1 id="核心能力"><a href="#核心能力" class="headerlink" title="核心能力"></a>核心能力</h1><p>这里列举了一些规则引擎的核心机制</p><p>对于 Drools 支持的能力主要结合文档进行简单的介绍，对于 LiteFlow 等支持的能力会结合源码</p><h2 id="规则编排"><a href="#规则编排" class="headerlink" title="规则编排"></a>规则编排</h2><p>Drools 使用了 RETE 算法的变体 Phreak 来做为规则算法</p><p>LiteFlow 使用了 alibaba 开源的 QLExpress 作为规则的解析工具（QLExpress 也是一款表达式引擎，或者说是脚本语言）</p><p><a href="https://github.com/alibaba/QLExpress">alibaba&#x2F;QLExpress: QLExpress is a powerful, lightweight, dynamic language for the Java platform aimed at improving developers’ productivity in different business scenes. (github.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExpressRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExpressRunner</span>();</span><br><span class="line">DefaultContext&lt;String, Object&gt; context = <span class="keyword">new</span> <span class="title class_">DefaultContext</span>&lt;String, Object&gt;();</span><br><span class="line">context.put(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">context.put(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line">context.put(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">express</span> <span class="operator">=</span> <span class="string">&quot;a + b * c&quot;</span>;</span><br><span class="line"><span class="type">Object</span> <span class="variable">r</span> <span class="operator">=</span> runner.execute(express, context, <span class="literal">null</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">System.out.println(r);</span><br></pre></td></tr></table></figure><p>因为 QLExpress 还支持扩展操作符，所以被 LiteFlow 用来解析其 DSL 定义的规则</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">flow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nodes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">node</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yomahub.liteflow.test.parser.cmp.ACmp&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">node</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yomahub.liteflow.test.parser.cmp.BCmp&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">node</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yomahub.liteflow.test.parser.cmp.CCmp&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">node</span> <span class="attr">id</span>=<span class="string">&quot;d&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yomahub.liteflow.test.parser.cmp.DCmp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nodes</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">chain</span> <span class="attr">name</span>=<span class="string">&quot;chain1&quot;</span>&gt;</span></span><br><span class="line">        THEN(</span><br><span class="line">            a, b, WHEN(c,d)</span><br><span class="line">        );</span><br><span class="line">    <span class="tag">&lt;/<span class="name">chain</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">flow</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">flow:</span></span><br><span class="line">  <span class="attr">nodes:</span></span><br><span class="line">    <span class="attr">node:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">a</span></span><br><span class="line">        <span class="attr">class:</span> <span class="string">com.yomahub.liteflow.test.parser.cmp.ACmp</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">b</span></span><br><span class="line">        <span class="attr">class:</span> <span class="string">com.yomahub.liteflow.test.parser.cmp.BCmp</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">c</span></span><br><span class="line">        <span class="attr">class:</span> <span class="string">com.yomahub.liteflow.test.parser.cmp.CCmp</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">d</span></span><br><span class="line">        <span class="attr">class:</span> <span class="string">com.yomahub.liteflow.test.parser.cmp.DCmp</span></span><br><span class="line">  <span class="attr">chain:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">chain1</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;THEN(a, b, WHEN(c, d))&quot;</span></span><br></pre></td></tr></table></figure><p>最终的 EL <code>THEN(a, b, WHEN(c, d))</code> 都是交由 QLExpress 进行处理</p><hr><p>LiteFlowChainELBuilder#setEL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> LiteFlowChainELBuilder <span class="title function_">setEL</span><span class="params">(String elStr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (StrUtil.isBlank(elStr)) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> StrUtil.format(<span class="string">&quot;no content in this chain[&#123;&#125;]&quot;</span>, chain.getChainId());</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FlowSystemException</span>(errMsg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; errorList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">...</span><br><span class="line">                </span><br><span class="line"><span class="comment">// 解析 el 成为一个 Condition</span></span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> (Condition) EXPRESS_RUNNER.execute(elStr, context, errorList, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态成员 <code>EXPRESS_RUNNER</code> 即为 QLExpress 提供的 <code>ExpressRunner</code> 实例</p><p>在静态代码块中初始化扩展操作符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EL解析引擎</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">ExpressRunner</span> <span class="variable">EXPRESS_RUNNER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExpressRunner</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="comment">// 初始化QLExpress的Runner</span></span><br><span class="line">EXPRESS_RUNNER.addFunction(ChainConstant.THEN, <span class="keyword">new</span> <span class="title class_">ThenOperator</span>());</span><br><span class="line">EXPRESS_RUNNER.addFunction(ChainConstant.WHEN, <span class="keyword">new</span> <span class="title class_">WhenOperator</span>());</span><br><span class="line">EXPRESS_RUNNER.addFunction(ChainConstant.SWITCH, <span class="keyword">new</span> <span class="title class_">SwitchOperator</span>());</span><br><span class="line">EXPRESS_RUNNER.addFunction(ChainConstant.PRE, <span class="keyword">new</span> <span class="title class_">PreOperator</span>());</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>扩展操作符的实现就是构建 LiteFlow 最终的节点抽象 <code>Executable</code> 的抽象实现 <code>Condition</code></p><p><code>BaseOperator</code> 为了强化 <code>executeInner</code> 方法，会捕获抛出的 <code>QLException</code> 异常，输出友好的错误提示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThenOperator</span> <span class="keyword">extends</span> <span class="title class_">BaseOperator</span>&lt;ThenCondition&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ThenCondition <span class="title function_">build</span><span class="params">(Object[] objects)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">OperatorHelper.checkObjectSizeGtZero(objects);</span><br><span class="line"></span><br><span class="line"><span class="type">ThenCondition</span> <span class="variable">thenCondition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThenCondition</span>();</span><br><span class="line"><span class="keyword">for</span> (Object obj : objects) &#123;</span><br><span class="line">thenCondition.addExecutable(OperatorHelper.convert(obj, Executable.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> thenCondition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终就到了规则对象封装的三个类型</p><ul><li>Executable<ul><li>Condition：条件对象，核心属性 <code>executableGroup</code>，持有 <code>Executable</code> Map</li><li>Chain：规则链对象，核心属性 <code>conditionList</code>，持有 <code>Condition</code> 集合</li><li>Node：Node 节点，核心属性 <code>NodeComponent</code>，才是组件执行的核心</li></ul></li></ul><p>最终在 <code>FlowExecutor</code> 执行中获取 <code>Chain</code> 为入口，进行执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">chain = FlowBus.getChain(chainId);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ObjectUtil.isNull(chain)) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> StrUtil.format(<span class="string">&quot;[&#123;&#125;]:couldn&#x27;t find chain with the id[&#123;&#125;]&quot;</span>, slot.getRequestId(),</span><br><span class="line">chainId);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ChainNotFoundException</span>(errorMsg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行chain</span></span><br><span class="line">chain.execute(slotIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并发编排"><a href="#并发编排" class="headerlink" title="并发编排"></a>并发编排</h2><p>LiteFlow 中的流程图式规则表达天然支持灵活地对执行任务进行并发控制，使用关键词 <code>WHEN</code> 进行表达</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">chain</span> <span class="attr">name</span>=<span class="string">&quot;chain1&quot;</span>&gt;</span></span><br><span class="line">    THEN(</span><br><span class="line">        a,</span><br><span class="line">        WHEN(b, c, d),</span><br><span class="line">        e</span><br><span class="line">    );</span><br><span class="line"><span class="tag">&lt;/<span class="name">chain</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表示串行执行节点 a，随后并行执行节点 b、c、d，最后继续串行执行节点 e</p><p>同时拥有一些拓展功能：</p><ul><li>忽略错误：<code>WHEN(b, c, d).ignoreError(true)</code> 当 b、c、d 节点出现异常时进行忽略</li><li>任意执行成功：<code>WHEN(b, THEN(c, d), e).any(true)</code> 当 b、并行的 c 和 d、e 任意执行成功则继续向下执行</li><li>分组：<code>THEN(WHEN(a, b),WHEN(c, d))</code> 关键词 <code>WHEN</code> 天然具有分组概念</li></ul><hr><p>并发的第一步，整个规则被包装为 <code>WhenCondition</code> 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhenCondition</span> <span class="keyword">extends</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只在when类型下有效，以区分当when调用链调用失败时是否继续往下执行 默认false不继续执行</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">ignoreError</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只在when类型下有效，为true的话说明在多个并行节点下，任意一个成功，整个when就成功</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">any</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// when 单独的线程池名称</span></span><br><span class="line"><span class="keyword">private</span> String threadExecutorClass;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCondition</span><span class="params">(Integer slotIndex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">executeAsyncCondition(slotIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象中包括 <code>WHEN</code> 规则相关的属性，以及关键的 <code>executeCondition</code> 实现</p><p>实现中调用了 <code>executeAsyncCondition</code></p><p><code>executeAsyncCondition</code> 代码比较长，概括做了以下几件事：</p><ol><li>拿到 <code>Condition</code> 下的可执行元素的集合 <code>executableGroup</code>，过滤掉前后置组件（<code>PreCondition</code> 和 <code>FinallyCondition</code>）以及 <code>Node</code> 的 <code>isAccess</code> 为 false 的节点（这里是为了处理一个 bug issue：<a href="https://gitee.com/dromara/liteFlow/issues/I4XRBA">关于when和then混合使用时(有any和isAccess的情况下)，then的节点先执行的问题 · Issue #I4XRBA · dromara&#x2F;liteFlow - Gitee.com</a>）</li><li>使用 <code>ScheduledThreadPoolExecutor</code> 实现 <code>CompletableFuture</code> 异步处理超时，将 <code>Executable</code> 数据包装为 <code>ParallelSupplier</code>，调用 <code>CompletableFuture.supplyAsync</code></li><li>根据 <code>any</code> 参数使用 <code>CompletableFuture.anyOf</code> 或 <code>CompletableFuture.allOf</code>，拿到封装流程后的 <code>resultCompletableFuture</code></li><li>执行 <code>resultCompletableFuture.get</code> 进行阻塞，catch <code>InterruptedException</code></li><li>拿到已经完成的结果，对未完成的任务进行过滤（如果 <code>any</code> 为 true，那么这里拿到的是第一个完成的任务）</li><li>过滤出超时的任务，输出超时日志</li><li>根据参数 <code>isIgnoreError</code>，处理 <code>InterruptedException</code>；遍历 <code>CompletableFuture</code> 的返回值，如果异步执行失败，则抛出相应的业务异常</li></ol><h2 id="执行组件"><a href="#执行组件" class="headerlink" title="执行组件"></a>执行组件</h2><p>Drools 中没有组件的概念，但是每个规则表达中 <code>then</code> 部分直接调用 Java 代码或者由 MVEL 或 Java 定义执行逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.User;</span><br><span class="line"><span class="keyword">import</span> com.example.Product;</span><br><span class="line"><span class="keyword">import</span> com.example.ProductRecommendationService;</span><br><span class="line"></span><br><span class="line">rule <span class="string">&quot;Recommendation Rule&quot;</span></span><br><span class="line">when</span><br><span class="line">  <span class="comment">// 绑定事实对象</span></span><br><span class="line">    $user : User( $userId : userId, $history : purchaseHistory, $prefs : preferences )</span><br><span class="line">    $product : Product( $productId : productId, $categories : categories, $price : price )</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内置函数</span></span><br><span class="line">    exists( String( <span class="built_in">this</span> == $categories ) from $prefs ) <span class="comment">// 商品所属的某个类别在用户偏好中存在</span></span><br><span class="line">    not ( String( <span class="built_in">this</span> == $productId ) from $history ) <span class="comment">// 用户未购买过该商品</span></span><br><span class="line">then</span><br><span class="line">    <span class="comment">// 执行逻辑</span></span><br><span class="line">    ProductRecommendationService.recommendProduct($userId, $productId);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>LiteFlow 中的组件由 Java 代码编写（也可以脚本组件），可以作为 bean 接入 Spring</p><p><code>FlowParse</code> 及其实现</p><img src="/%E5%BC%80%E5%8F%91/LiteFlow/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/FlowParser.png" class="" title="FlowParser"><p><code>FlowExecutor</code> 的 <code>init</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找对应解析器</span></span><br><span class="line">parser = FlowParserProvider.lookup(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// FlowParserProvider.lookup</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> FlowParser <span class="title function_">lookup</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">// 自定义类必须实现以上实现类，否则报错</span></span><br><span class="line"><span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> StrUtil.format(<span class="string">&quot;can&#x27;t support the format &#123;&#125;&quot;</span>, path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地文件</span></span><br><span class="line"><span class="keyword">if</span> (isLocalConfig(path)) &#123;</span><br><span class="line"><span class="comment">// 遍历枚举 map 找到对应 factory</span></span><br><span class="line">Predicate&lt;String&gt; dictKey = LOCAL_PARSER_DICT.keySet()</span><br><span class="line">.stream()</span><br><span class="line">.filter(key -&gt; key.test(path))</span><br><span class="line">.findFirst()</span><br><span class="line">.orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">ErrorSupportPathException</span>(errorMsg));</span><br><span class="line"></span><br><span class="line">LOG.info(<span class="string">&quot;flow info loaded from local file,path=&#123;&#125;&quot;</span>, path);</span><br><span class="line"><span class="keyword">return</span> LOCAL_PARSER_DICT.get(dictKey).apply(path);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>NodeType</code> 节点类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">NodeTypeEnum</span> &#123;</span><br><span class="line">COMMON(<span class="string">&quot;common&quot;</span>, <span class="string">&quot;普通&quot;</span>, <span class="literal">false</span>, NodeComponent.class),</span><br><span class="line">SWITCH(<span class="string">&quot;switch&quot;</span>, <span class="string">&quot;选择&quot;</span>, <span class="literal">false</span>, NodeSwitchComponent.class),</span><br><span class="line">IF(<span class="string">&quot;if&quot;</span>, <span class="string">&quot;条件&quot;</span>, <span class="literal">false</span>, NodeIfComponent.class),</span><br><span class="line">FOR(<span class="string">&quot;for&quot;</span>, <span class="string">&quot;循环次数&quot;</span>, <span class="literal">false</span>, NodeForComponent.class),</span><br><span class="line">WHILE(<span class="string">&quot;while&quot;</span>, <span class="string">&quot;循环条件&quot;</span>, <span class="literal">false</span>, NodeWhileComponent.class),</span><br><span class="line">BREAK(<span class="string">&quot;break&quot;</span>, <span class="string">&quot;循环跳出&quot;</span>, <span class="literal">false</span>, NodeBreakComponent.class),</span><br><span class="line">ITERATOR(<span class="string">&quot;iterator&quot;</span>, <span class="string">&quot;循环迭代&quot;</span>, <span class="literal">false</span>, NodeIteratorComponent.class),</span><br><span class="line">SCRIPT(<span class="string">&quot;script&quot;</span>, <span class="string">&quot;脚本&quot;</span>, <span class="literal">true</span>, ScriptCommonComponent.class),</span><br><span class="line">SWITCH_SCRIPT(<span class="string">&quot;switch_script&quot;</span>, <span class="string">&quot;选择脚本&quot;</span>, <span class="literal">true</span>, ScriptSwitchComponent.class),</span><br><span class="line">IF_SCRIPT(<span class="string">&quot;if_script&quot;</span>, <span class="string">&quot;条件脚本&quot;</span>, <span class="literal">true</span>, ScriptIfComponent.class),</span><br><span class="line">FOR_SCRIPT(<span class="string">&quot;for_script&quot;</span>, <span class="string">&quot;循环次数脚本&quot;</span>, <span class="literal">true</span>, ScriptForComponent.class),</span><br><span class="line">WHILE_SCRIPT(<span class="string">&quot;while_script&quot;</span>, <span class="string">&quot;循环条件脚本&quot;</span>, <span class="literal">true</span>, ScriptWhileComponent.class),</span><br><span class="line">BREAK_SCRIPT(<span class="string">&quot;break_script&quot;</span>, <span class="string">&quot;循环跳出脚本&quot;</span>, <span class="literal">true</span>, ScriptBreakComponent.class);</span><br><span class="line">  </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>整体流程：</p><ol><li>文件解析（XML、JSON）</li><li><code>NodePropBean</code> 包装</li><li>buildNode，FlowBus 添加节点元数据<ul><li>如果是声明式组件，Spring 环境下已经是代理对象则不处理，非 Spring 环境执行 <code>LiteFlowProxyUtil.proxy2NodeComponent</code></li><li>配置组件，new Instance</li></ul></li><li>脚本组件，加载 script 脚本</li></ol><h2 id="脚本组件"><a href="#脚本组件" class="headerlink" title="脚本组件"></a>脚本组件</h2><p>在 Drools 中本身的规则表达就是 Drools 定义的类 Java 语法，同时也支持 DMN 的 FEEL 等语法，相当于脚本语言</p><p>在 LiteFlow 中支持多种脚本语言来定义组件：</p><ul><li>Groovy</li><li>Javascript</li><li>QLExpress</li><li>Python</li><li>Lua</li><li>Aviator</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">flow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nodes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">node</span> <span class="attr">id</span>=<span class="string">&quot;s1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;普通脚本&quot;</span> <span class="attr">type</span>=<span class="string">&quot;script&quot;</span> <span class="attr">language</span>=<span class="string">&quot;groovy&quot;</span>&gt;</span></span><br><span class="line">            &lt;![CDATA[</span><br><span class="line">                def a=3;</span><br><span class="line">                def b=2;</span><br><span class="line">                defaultContext.setData(&quot;s1&quot;,a*b);</span><br><span class="line">            ]]&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nodes</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">chain</span> <span class="attr">name</span>=<span class="string">&quot;chain1&quot;</span>&gt;</span></span><br><span class="line">        THEN(a);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">chain</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">flow</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>NodeComponent</code> 实现类 <code>loadScript</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScriptCommonComponent</span> <span class="keyword">extends</span> <span class="title class_">NodeComponent</span> <span class="keyword">implements</span> <span class="title class_">ScriptComponent</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">ScriptExecuteWrap</span> <span class="variable">wrap</span> <span class="operator">=</span> <span class="built_in">this</span>.buildWrap(<span class="built_in">this</span>);</span><br><span class="line">ScriptExecutorFactory.loadInstance().getScriptExecutor(<span class="built_in">this</span>.getRefNode().getLanguage()).execute(wrap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadScript</span><span class="params">(String script, String language)</span> &#123;</span><br><span class="line">log.info(<span class="string">&quot;load script for component[&#123;&#125;]&quot;</span>, getDisplayName());</span><br><span class="line">ScriptExecutorFactory.loadInstance().getScriptExecutor(language).load(getNodeId(), script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ScriptExecutorFactory.loadInstance().getScriptExecutor(language).load(getNodeId(), script)</code> 主要获取了 <code>ScriptExecutor</code> 的实现</p><img src="/%E5%BC%80%E5%8F%91/LiteFlow/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/ScriptExecutor.png" class="" title="ScriptExecutor"><p>groovy 的 ScriptEngine 由 groovy-jsr223 依赖提供 <code>org.codehaus.groovy.jsr223GroovyScriptEngineImpl</code></p><p>最终编译为 <code>CompiledScript</code> 实现，存储至 <code>compiledScriptMap</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">JSR223ScriptExecutor</span> <span class="keyword">extends</span> <span class="title class_">ScriptExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ScriptEngine scriptEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, CompiledScript&gt; compiledScriptMap = <span class="keyword">new</span> <span class="title class_">CopyOnWriteHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>思考：</p><ul><li>业务中应该有多少脚本、表达式引擎的应用？</li><li>什么场景适合 or 不适合？</li></ul><p>XXL-Job 支持的 GLUE 模式</p><p><a href="https://www.xuxueli.com/xxl-job/#3.3%20GLUE%E6%A8%A1%E5%BC%8F(Java)">XXL-JOB 3.3-GLUE模式(Java)</a></p></blockquote><h2 id="规则热更新"><a href="#规则热更新" class="headerlink" title="规则热更新"></a>规则热更新</h2><p>规则配置的热更新是规则化的重要优势，特别是很多成熟的规则引擎都提供了 GUI 后台</p><p>Drools 支持的规则读取方式：</p><ul><li><code>KieClasspathContainer</code> 项目 resource 文件</li><li><code>KieBuilder</code> 项目外文件</li><li><code>KieScanner</code> 仓库 jar 包（Workbench）</li></ul><p>Drools 的更新方式：</p><ul><li>使用 <code>KieContainerImpl.updateToKieModule</code></li><li>创建新的 <code>KieContainer</code></li><li>使用 <code>InternalKnowledgeBase</code> 的 API；粒度更细，注意规则切换非原子性带来的影响</li></ul><p>LiteFlow 的规则本质是一个执行链（<code>Chain</code> 和 <code>Condition</code>），在执行时会 copy 出一份新的执行链对象，所以对于规则的热更新应该是天然支持平滑的</p><blockquote><p>即你可以在不重启服务的情况下，进行规则的重载</p><p>并且在高并发下刷新的时候，正在执行流程的线程是完全平滑的，不会因为刷新的过程而出现中断的现象</p><p>在刷新时，正在执行的流程还是走的旧的流程；刷新好，后续 request 会自动切换到新的流程</p></blockquote><p>LiteFlow 规则更新的方式：</p><ul><li><p>在 Spring 容器中拿到 <code>FlowExecutor</code> 对象调用 <code>flowExecutor.reloadRule()</code></p></li><li><p>指定刷新某一个 Chain 的规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LiteFlowChainELBuilder.createChain().setChainName(<span class="string">&quot;chain2&quot;</span>).setEL(</span><br><span class="line">  <span class="string">&quot;THEN(a, b, WHEN(c, d))&quot;</span></span><br><span class="line">).build();</span><br></pre></td></tr></table></figure></li><li><p>配置放在中间件，利用中间件的配置监听机制进行更新</p><ul><li>ZK</li><li>Etcd</li><li>SQL（Java.sql）</li><li>Nacos</li><li>Apollo</li></ul></li></ul><p>核心原理就是定义各自数据源的 <code>Parse</code>，在解析方法中执行监听操作、挂载监听相关的回调</p><p>（不过我发现对于远程规则的配置都是全量刷新，相当于每次变更重新加载整个规则文件，不像本地规则文件一样可以配置多个？）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NacosXmlELParser</span> <span class="keyword">extends</span> <span class="title class_">ClassXmlFlowELParser</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> NacosParserHelper helper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NacosXmlELParser</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">LiteflowConfig</span> <span class="variable">liteflowConfig</span> <span class="operator">=</span> LiteflowConfigGetter.get();</span><br><span class="line">    <span class="comment">// 获取配置初始化客户端</span></span><br><span class="line">    ...</span><br><span class="line">    helper = <span class="keyword">new</span> <span class="title class_">NacosParserHelper</span>(nacosParserVO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">parseCustom</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 重新 parse</span></span><br><span class="line">Consumer&lt;String&gt; parseConsumer = t -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">parse(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> helper.getContent();</span><br><span class="line">helper.checkContent(content);</span><br><span class="line">        <span class="comment">// 监听</span></span><br><span class="line">helper.listener(parseConsumer);</span><br><span class="line"><span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NacosException</span>(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本地文件监听使用了 Apache  <code>commons.io</code> 的 <code>FileAlterationMonitor</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">observer.addListener(<span class="keyword">new</span> <span class="title class_">FileAlterationListenerAdaptor</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileChange</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;file modify,filePath=&#123;&#125;&quot;</span>, file.getAbsolutePath());</span><br><span class="line">        FlowExecutorHolder.loadInstance().reloadRule();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;file delete,filePath=&#123;&#125;&quot;</span>, file.getAbsolutePath());</span><br><span class="line">        FlowExecutorHolder.loadInstance().reloadRule();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> <code>reloadRule</code> 操作的本质是重新进行 <code>FlowExecutor</code> 的 <code>init</code> 操作，看起来也是直接刷新所有文件规则，粒度较粗</p><h2 id="决策控制"><a href="#决策控制" class="headerlink" title="决策控制"></a>决策控制</h2><p>Drools 在面对大量规则时更好的规划命中的规则（规则冲突、优先级、循环等），支持规则下一些参数控制匹配规则的行为 Execution control in the Drools engine</p><p>在 Java 应用程序中第一次调用 <code>fireAllRules</code> 后，Drools 引擎会在两个阶段重复循环：</p><ul><li><strong>事项评估</strong>（Agenda evaluation）：在这个阶段，Drools 引擎选择所有可以执行的规则；如果不存在可执行规则，则执行周期结束；如果找到了可执行规则，Drools 引擎会在议程中注册激活，然后进入工作内存行为阶段，执行规则后果操作</li><li><strong>工作内存行为</strong>（Working memory actions）：在这个阶段，Drools 引擎为之前在事项中注册的所有激活规则执行规则后果操作（每个规则的 <code>then</code> 行为部分）；在所有结果操作完成或主 Java 应用程序进程再次调用 <code>fireAllRules</code> 后，Drools 引擎返回到议程评估阶段以重新评估规则</li></ul><p><img src="https://docs.drools.org/7.73.0.Final/drools-docs/html_single/HybridReasoning/Two_Phase.png"></p><p>当事项（agenda）上存在多个规则时，执行一个规则可能会导致从议程中删除另一个规则；为了避免这种情况可以定义 Drools 引擎中执行规则的方式和时间</p><p><strong>规则优先级 Salience for rules</strong></p><p>每个规则都有一个确定执行顺序的整数优先级属性；当在激活队列中排序时，具有较高优先级值的规则被赋予更高的执行优先级</p><p>规则的默认优先级为 0，但优先级可以设置为负数或正数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">rule <span class="string">&quot;RuleA&quot;</span></span><br><span class="line">salience <span class="number">95</span> &lt;-- <span class="built_in">this</span></span><br><span class="line">when</span><br><span class="line">    $fact : MyFact( field1 == <span class="literal">true</span> )</span><br><span class="line">then</span><br><span class="line">    System.out.println(<span class="string">&quot;Rule2 : &quot;</span> + $fact);</span><br><span class="line">    update($fact);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">&quot;RuleB&quot;</span></span><br><span class="line">salience <span class="number">100</span></span><br><span class="line">when</span><br><span class="line">   $fact : MyFact( field1 == <span class="literal">false</span> )</span><br><span class="line">then</span><br><span class="line">   System.out.println(<span class="string">&quot;Rule1 : &quot;</span> + $fact);</span><br><span class="line">   $fact.setField1(<span class="literal">true</span>);</span><br><span class="line">   update($fact);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>RuleB 规则列在下面，但它的优先级值高于 RuleA 规则，因此首先执行</p><p><strong>规则事项组 Agenda groups for rules</strong></p><p>事项组是由同一事项组规则属性绑定在一起的一组规则</p><p>在任何时候，只有一个组的焦点使该组规则优先于其他事项组中的规则执行；可以通过对议程组的 <code>setFocus</code> 调用来确定焦点</p><p>还可以定义具有 <code>auto-focus</code> 属性的规则，以便下次激活规则时，将焦点自动分配给规则所分配的整个议程组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rule <span class="string">&quot;Increase balance for credits&quot;</span></span><br><span class="line">  agenda-group <span class="string">&quot;calculation&quot;</span></span><br><span class="line">when</span><br><span class="line">  ap : AccountPeriod()</span><br><span class="line">  acc : Account( $accountNo : accountNo )</span><br><span class="line">  CashFlow( type == CREDIT,</span><br><span class="line">            accountNo == $accountNo,</span><br><span class="line">            date &gt;= ap.start &amp;&amp; &lt;= ap.end,</span><br><span class="line">            $amount : amount )</span><br><span class="line">then</span><br><span class="line">  acc.balance  += $amount;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule <span class="string">&quot;Print balance for AccountPeriod&quot;</span></span><br><span class="line">  agenda-group <span class="string">&quot;report&quot;</span></span><br><span class="line">when</span><br><span class="line">  ap : AccountPeriod()</span><br><span class="line">  acc : Account()</span><br><span class="line">then</span><br><span class="line">  System.out.println( acc.accountNo +</span><br><span class="line">                      <span class="string">&quot; : &quot;</span> + acc.balance );</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>例如，<code>report</code> 事项组中的规则必须始终首先执行，<code>calculation</code> 事项组的规则必须总是其次执行；然后可以执行其他议程组中的任何剩余规则</p><p>因此，在执行其他规则之前，<code>report</code> 和 <code>caclulation</code> 组必须按该顺序接收要执行的焦点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Agenda</span> <span class="variable">agenda</span> <span class="operator">=</span> ksession.getAgenda();</span><br><span class="line">agenda.getAgendaGroup( <span class="string">&quot;report&quot;</span> ).setFocus();</span><br><span class="line">agenda.getAgendaGroup( <span class="string">&quot;calculation&quot;</span> ).setFocus();</span><br><span class="line">ksession.fireAllRules();</span><br></pre></td></tr></table></figure><p><strong>规则激活组 Activation groups for rules</strong></p><p>激活组是由相同的激活组规则属性绑定在一起的一组规则</p><p>在该组中只能执行一个规则；在满足执行该组中的规则的条件后，将从事项中删除该激活组中的所有其他挂起的规则执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule <span class="string">&quot;Print balance for AccountPeriod1&quot;</span></span><br><span class="line">  activation-group <span class="string">&quot;report&quot;</span></span><br><span class="line">when</span><br><span class="line">  ap : AccountPeriod1()</span><br><span class="line">  acc : Account()</span><br><span class="line">then</span><br><span class="line">  System.out.println( acc.accountNo +</span><br><span class="line">                      <span class="string">&quot; : &quot;</span> + acc.balance );</span><br><span class="line">end</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule <span class="string">&quot;Print balance for AccountPeriod2&quot;</span></span><br><span class="line">  activation-group <span class="string">&quot;report&quot;</span></span><br><span class="line">when</span><br><span class="line">  ap : AccountPeriod2()</span><br><span class="line">  acc : Account()</span><br><span class="line">then</span><br><span class="line">  System.out.println( acc.accountNo +</span><br><span class="line">                      <span class="string">&quot; : &quot;</span> + acc.balance );</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在示例中执行了 <code>report</code> 激活组中的其中一条规则，则第二条规则不会执行</p><p><strong>执行模式和线程安全 Rule execution modes and thread safety in the Drools engine</strong></p><ul><li><strong>被动模式</strong>（Passive mode）：当用户或应用程序显式调用 <code>fireAllRules</code> 时，Drools 引擎会评估规则</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">KieSessionConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> KieServices.Factory.get().newKieSessionConfiguration();</span><br><span class="line">config.setOption( ClockTypeOption.get(<span class="string">&quot;pseudo&quot;</span>) );</span><br><span class="line"><span class="type">KieSession</span> <span class="variable">session</span> <span class="operator">=</span> kbase.newKieSession( conf, <span class="literal">null</span> );</span><br><span class="line"><span class="type">SessionPseudoClock</span> <span class="variable">clock</span> <span class="operator">=</span> session.getSessionClock();</span><br><span class="line"></span><br><span class="line">session.insert( tick1 );</span><br><span class="line">session.fireAllRules();</span><br><span class="line"></span><br><span class="line">clock.advanceTime(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">session.insert( tick2 );</span><br><span class="line">session.fireAllRules();</span><br><span class="line"></span><br><span class="line">clock.advanceTime(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">session.insert( tick3 );</span><br><span class="line">session.fireAllRules();</span><br><span class="line"></span><br><span class="line">session.dispose();</span><br></pre></td></tr></table></figure><ul><li><strong>活动模式</strong>（Active mode）：如果用户或应用程序调用 <code>fireUntilHalt</code>，Drools 引擎以活动模式启动并不断评估规则，直到用户或应用程序显式调用 <code>halt</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">KieSessionConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> KieServices.Factory.get().newKieSessionConfiguration();</span><br><span class="line">config.setOption( ClockTypeOption.get(<span class="string">&quot;realtime&quot;</span>) );</span><br><span class="line"><span class="type">KieSession</span> <span class="variable">session</span> <span class="operator">=</span> kbase.newKieSession( conf, <span class="literal">null</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>( <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      session.fireUntilHalt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; ).start();</span><br><span class="line"></span><br><span class="line">session.insert( tick1 );</span><br><span class="line"></span><br><span class="line">... Thread.sleep( <span class="number">1000L</span> ); ...</span><br><span class="line"></span><br><span class="line">session.insert( tick2 );</span><br><span class="line"></span><br><span class="line">... Thread.sleep( <span class="number">1000L</span> ); ...</span><br><span class="line"></span><br><span class="line">session.insert( tick3 );</span><br><span class="line"></span><br><span class="line">session.halt();</span><br><span class="line">session.dispose();</span><br></pre></td></tr></table></figure><p><strong>事实传播模式 Fact propagation modes in the Drools engine</strong></p><p>Drools 引擎支持以下事实传播模式，这些模式决定 Drools 引擎如何通过引擎网络处理插入的事实，为规则执行做准备：</p><ul><li><strong>惰性</strong>（Lazy）：（默认）事实在规则执行时以批处理集合的形式传播，而不是实时传播，因为事实是由用户或应用程序独立设置的；因此事实最终通过 Drools 引擎传播的顺序可能与单独插入事实的顺序不同（没有顺序性）</li><li><strong>立即</strong>（Immediate）：事实会按照用户或应用程序插入的顺序立即传播</li><li><strong>迫切</strong>（Eager）：事实是延迟传播的（在批处理集合中），但在规则执行之前 Drools 引擎将这种传播行为用于活动属性上 <code>no-loop</code> 或 <code>lock-on-active</code> 的规则</li></ul><p>默认情况下，Drools 引擎中的 Phreak 规则算法使用惰性事实传播来改进总体规则评估；但是在少数情况下这种惰性传播行为可能会改变某些规则执行的预期结果，这些规则执行可能需要 Immediate 或 Eager 传播</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">query <span class="title function_">Q</span> <span class="params">(Integer i)</span></span><br><span class="line">    String( <span class="built_in">this</span> == i.toString() )</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">&quot;Rule&quot;</span></span><br><span class="line">  when</span><br><span class="line">    $i : Integer()</span><br><span class="line">    ?Q( $i; )</span><br><span class="line">  then</span><br><span class="line">    System.out.println( $i );</span><br><span class="line">end</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">KieSession</span> <span class="variable">ksession</span> <span class="operator">=</span> ...</span><br><span class="line">ksession.insert(<span class="number">1</span>);</span><br><span class="line">ksession.insert(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">ksession.fireAllRules();</span><br></pre></td></tr></table></figure><p>该规则仍然会被命中，因为默认的 Lazy 传播失去了顺序</p><p>在这种情况下，要更改 Drools 引擎传播模式以实现预期的规则评估，可以将 <code>@propagation(&lt;type&gt;)</code>标记添加到规则中，并将 <code>&lt;type&gt;</code> 设置为 LAZY、IMMEDIATE 或 EAGER</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">query <span class="title function_">Q</span> <span class="params">(Integer i)</span></span><br><span class="line">    String( <span class="built_in">this</span> == i.toString() )</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">&quot;Rule&quot;</span> <span class="meta">@Propagation(IMMEDIATE)</span></span><br><span class="line">  when</span><br><span class="line">    $i : Integer()</span><br><span class="line">    ?Q( $i; )</span><br><span class="line">  then</span><br><span class="line">    System.out.println( $i );</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>事项评估过滤器 Agenda evaluation filters</strong></p><p>Drools 引擎支持过滤器接口中的 <code>AgentaFilter</code> 对象，可以使用该对象在事项评估期间允许或拒绝对指定规则的评估</p><p>可以指定一个议程过滤器作为 <code>fireAllRules</code> 调用的一部分</p><p>以下示例代码只允许评估和执行以字符串 “Test” 结尾的规则；所有其他规则都会从 Drools 引擎事项中过滤掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ksession.fireAllRules( <span class="keyword">new</span> <span class="title class_">RuleNameEndsWithAgendaFilter</span>( <span class="string">&quot;Test&quot;</span> ) );</span><br></pre></td></tr></table></figure><hr><p>LiteFlow 中对于组件的流程也有其控制机制</p><p>虽然整个组件是通过 EL 表达式编排起来，但是可以重写 <code>Component</code> 相关的方法进一步进行流程控制</p><p><strong>isAccess</strong><br>推荐实现 <code>isAccess</code> 方法，表示是否进入该节点，可以用于业务参数的预先判断</p><p>这里官方文档写的比较简单；上面提过 <code>Executable</code> 其中有 <code>Node</code> 和 <code>Component</code> 的实现</p><ul><li>对于 <code>Node</code> 而言，<code>isAccess</code> 控制该组件是否执行，但是不会影响后续组件的执行</li><li>对于 <code>Condition</code>，因为后续流程需要由 <code>Condition</code> 来进行控制，例如 <code>SwitchCondition</code>、<code>IfCondition</code>，所以对于 <code>Condition</code> 相关的组件 <code>isAccess</code> 为 false 则该路线不会向下执行了</li></ul><p><strong>isEnd</strong><br>如果覆盖后，返回 true，则表示在这个组件执行完之后立马终止整个流程</p><p>对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的 <code>isSuccess</code> 为 true</p><p><strong>beforeProcess &amp; afterProcess</strong></p><p>流程的前置和后置处理器，其中前置处理器，在 <code>isAccess</code> 之后执行</p><p>所有组件通用的前后切面可以使用切面组件 <code>ICmpAroundAspect</code>；Spring 环境下也可以使用 Spring Aspect</p><p><strong>onSuccess &amp; onError</strong></p><p>流程的成功失败事件回调</p><h1 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h1><h2 id="价格计算"><a href="#价格计算" class="headerlink" title="价格计算"></a>价格计算</h2><p>LiteFlow 有一个 Demo 案例，可以简单了解是如何使用的</p><p><a href="https://liteflow.yomahub.com/pages/0a8188/">LiteFlow DEMO 案例 2 价格计算</a></p><h2 id="通知文案"><a href="#通知文案" class="headerlink" title="通知文案"></a>通知文案</h2><p>tutor-student-notify 对于发送逻辑的处理</p><p>产品曾经提过理想中的产品使用，GUI 配置、文案编辑，不需要研发参与修改；不过现实还是比较复杂的，这里使用 LiteFlow 实现一个 Demo</p><p>（具体的代码就不粘贴在这里了）</p><p>设计的组件：</p><ul><li>initContextCmp：初始化上下文</li><li>lessonInfoCmp：Lesson 信息获取</li><li>userInfoCmp：User 信息获取</li><li>teacherInfoCmp：Teacher 信息获取</li><li>lowGradeJudgeCmp：<code>IF</code> 节点，判断是否是低年级</li><li>templateKeySelectCmp：通用模板 key 选择模板，将 key 写入 Context，需要组件参数<ul><li>组件参数：模板 key</li></ul></li><li>customerHotlineCmp：客服电话参数<ul><li>组件参数：客服电话配置</li></ul></li><li>userNameParamCmp：用户昵称参数</li><li>lessonNameParamCmp：班课名称参数<ul><li>组件参数：占位符 name 和求值表达式</li></ul></li><li>sendCmp：发送</li></ul><p>规则 EL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">flow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">chain</span> <span class="attr">name</span>=<span class="string">&quot;lessonDeliveredEvent&quot;</span>&gt;</span></span><br><span class="line">        THEN(</span><br><span class="line">            initContextCmp,</span><br><span class="line">            WHEN(</span><br><span class="line">                THEN(lessonInfoCmp,teacherInfoCmp),</span><br><span class="line">                userInfoCmp),</span><br><span class="line">            IF(</span><br><span class="line">                lowGradeJudgeCmp,</span><br><span class="line">                templateKeySelectCmp.data(&#x27;low-grade&#x27;),</span><br><span class="line">                THEN(templateKeySelectCmp.data(&#x27;high-grade&#x27;),customerHotlineCmp.data(&#x27;10086&#x27;))</span><br><span class="line">            ),</span><br><span class="line">            WHEN(userNameParamCmp,lessonNameParamCmp.data(&#x27;&#123;&quot;paramName&quot;:&quot;lessonName&quot;,&quot;qlExpress&quot;:&quot;《 lessonName 》&quot;&#125;&#x27;)),</span><br><span class="line">            sendCmp</span><br><span class="line">        );</span><br><span class="line">    <span class="tag">&lt;/<span class="name">chain</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">flow</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="现有业务-退课退款"><a href="#现有业务-退课退款" class="headerlink" title="现有业务 - 退课退款"></a>现有业务 - 退课退款</h2><p>tutor-lesson-order 服务中对于退款流程的处理，感觉很接近流程式规则的思想</p><ul><li>Pipeline、组件化、组件编排</li><li>并发编排</li><li>Context 设计和工作台模式</li></ul><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p><code>RefundContext</code> 是其退款业务上下文的基类</p><img src="/%E5%BC%80%E5%8F%91/LiteFlow/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/RefundContext.png" class="" title="RefundContext"><p>以实物商品退款流程上下文 <code>PhysicalCommodityRootRefundContext</code> 为例</p><ul><li>PhysicalCommodityRootRefundContext：实物商品</li><li>UnboxedRootRefundContext：非盒子<ul><li>OrderItemEO</li><li>LessonDigest</li><li>LessonOrderEO</li><li>partRefund</li><li>refundQuantity</li><li>code</li><li>extraMap</li></ul></li><li>StandardRootRefundContext：基础退款数据<ul><li>baseParam</li><li>refundConfig</li><li>refundTs</li><li>bizRefundInfoMap</li><li>mergedRefundInfo</li></ul></li></ul><p>计算节点产出的新对象为 <code>NestedContext</code> 实现类，依靠 <code>BaseNestedRefundContext</code> 进行连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseNestedRefundContext</span> <span class="keyword">implements</span> <span class="title class_">NestedContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NestedContext parent;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, NestedContext&gt; children;</span><br><span class="line">  </span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="执行链"><a href="#执行链" class="headerlink" title="执行链"></a>执行链</h3><p>执行链的核心类是 <code>RefundPipeline</code></p><p>组链操作由 <code>RefundPipelineService</code> 提供 <code>RefundTask</code> 实现类的 bean，<code>RefundPipelines</code> 作为工具类，提供 <code>RefundTaskGroupConfig</code> 映射真实的 bean 以及最后的组装</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;RefundTask[]&gt; groupTasks(List&lt;RefundTask&gt; allTasks, RefundTaskGroupConfig groupConfig) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupConfig.keySet().stream().sorted().map(groupId -&gt; &#123;</span><br><span class="line">        Collection&lt;String&gt; taskNames = groupConfig.get(groupId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> allTasks.stream()</span><br><span class="line">                .filter(task -&gt; taskNames.contains(task.getName()))</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .toArray(<span class="keyword">new</span> <span class="title class_">RefundTask</span>[]&#123;&#125;);</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算节点-amp-执行节点"><a href="#计算节点-amp-执行节点" class="headerlink" title="计算节点 &amp; 执行节点"></a>计算节点 &amp; 执行节点</h3><p>unboxed 班课退款流程</p><ul><li><strong>加载节点 &amp; 计算节点</strong> Pipeline<ul><li>【0】base info loader<ul><li>unboxed_base_ctx_loader</li></ul></li><li>【1】biz loader<ul><li>gift_order_loader</li><li>textbook_refund_loader</li><li>dual_coupon_loader</li><li>marketing_activity_refund_loader</li><li></li></ul></li><li>【100】biz calculator<ul><li>gift_order</li><li>dual_coupon</li><li>lesson_textbook</li><li>marketing_activity_refund_calc</li></ul></li><li>【101】<ul><li>lesson_agenda</li></ul></li><li>【1000】merge calculator<ul><li>merge_refund</li></ul></li></ul></li><li><strong>执行节点</strong> Pipeline<ul><li>【0】<ul><li>refund_lesson_order</li></ul></li><li>【1】</li><li>【2】<ul><li>gift_order_post</li><li>lesson_order_delivery</li><li>record_refund</li><li>dual_coupon_post</li><li>marketing_activity_refund_post</li></ul></li></ul></li></ul><blockquote><p><em>思考：组件化后如何保证编排的正确性</em></p><p><em>如上，如果执行节点被配置到了计算节点之前会出现问题；作为工作台模式，总之具有前后顺序的组件顺序错误就会导致流程的错误</em></p><p><em>1. 组件间解耦，但还是需要注意组件之间的流程编排</em></p><p><em>2.如何对组件的编排进行校验</em></p></blockquote><h3 id="任务-x2F-并发编排"><a href="#任务-x2F-并发编排" class="headerlink" title="任务 &#x2F; 并发编排"></a>任务 &#x2F; 并发编排</h3><p><code>RefundTaskGroupConfig</code> 用来描述任务配置 <code>private final Map&lt;Integer, Collection&lt;String&gt;&gt; configValue;</code></p><p>其属性 <code>configValue</code> 的 key 用来描述并发分组即顺序，value 为 <code>RefundTask</code> bean name 的集合</p><p><code>RefundTaskGroup</code> 用来封装并发编排的任务</p><p>RefundTaskGroup</p><ul><li>tasks：<code>RefundTask</code> 集合，包含了当前 group 需要并发执行的任务</li><li>pipeline：<code>RefundPipeline</code> 和 <code>RefundTaskGroup</code> 互相持有</li></ul><p>为什么这个地方 group 需要持有 pipeline 节点？因为 task 被 group 持有，context 被 pipeline 持有，而 task 的运行需要 context</p><p>整个 pipeline 模式下对象之间的关系</p><img src="/%E5%BC%80%E5%8F%91/LiteFlow/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/%E8%AE%A2%E5%8D%95%E9%80%80%E6%AC%BE%E7%B1%BB%E7%BB%93%E6%9E%84.png" class="" title="订单退款类结构"><h3 id="LiteFlow-DSL"><a href="#LiteFlow-DSL" class="headerlink" title="LiteFlow DSL"></a>LiteFlow DSL</h3><p>上述业务对节点的编排相当于 LiteFlow 中的 <code>WHEN</code> 和 <code>THEN</code></p><p>如果表示为流程图</p><img src="/%E5%BC%80%E5%8F%91/LiteFlow/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/refund%20%E6%B5%81%E7%A8%8B%E5%9B%BE.drawio.png" class="" title="refund 流程图.drawio"><p>如果使用 LiteFLow 的 EL 表示</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">flow</span> <span class="keyword">PUBLIC</span>  <span class="string">&quot;liteflow&quot;</span> <span class="string">&quot;liteflow.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">flow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">chain</span> <span class="attr">name</span>=<span class="string">&quot;physical_commodity_calculation_task_group_config&quot;</span>&gt;</span></span><br><span class="line">        THEN(</span><br><span class="line">            unboxed_base_ctx_loader,</span><br><span class="line">            WHEN(</span><br><span class="line">                gift_order_loader,</span><br><span class="line">                textbook_refund_loader,</span><br><span class="line">                dual_coupon_loader,</span><br><span class="line">                marketing_activity_refund_loader,</span><br><span class="line">                lesson_extra_loader</span><br><span class="line">            ),</span><br><span class="line">            WHEN(</span><br><span class="line">                gift_order,</span><br><span class="line">                dual_coupon,</span><br><span class="line">                lesson_textbook,</span><br><span class="line">                marketing_activity_refund_calc</span><br><span class="line">            ),</span><br><span class="line">            lesson_agenda,</span><br><span class="line">            merge_refund</span><br><span class="line">        );</span><br><span class="line">    <span class="tag">&lt;/<span class="name">chain</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">chain</span> <span class="attr">name</span>=<span class="string">&quot;standard_refunding_task_group_config&quot;</span>&gt;</span></span><br><span class="line">        THEN(</span><br><span class="line">            refund_lesson_order,</span><br><span class="line">            WHEN(</span><br><span class="line">                gift_order_post,</span><br><span class="line">                lesson_order_delivery,</span><br><span class="line">                record_refund,</span><br><span class="line">                dual_coupon_post,</span><br><span class="line">                marketing_activity_refund_post</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">    <span class="tag">&lt;/<span class="name">chain</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">chain</span> <span class="attr">name</span>=<span class="string">&quot;physical_commodity_refund&quot;</span>&gt;</span></span><br><span class="line">        THEN(physical_commodity_calculation_task_group_config, standard_refunding_task_group_config);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">chain</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">flow</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="AI-结合思考"><a href="#AI-结合思考" class="headerlink" title="AI 结合思考"></a>AI 结合思考</h1><p> 自从今年 AI 成为热题后，各界都在考虑如何使用 AI 提供新产品、提高生产力</p><p>AI 技术可以帮助程序员更快地完成一些繁琐、重复性的任务，如代码审查、测试、调试等；此外，AI 还可以通过自动化一些流程和工作流程来简化开发流程，从而提高生产效率</p><p>而规则引擎的规则编排、甚至是脚本语法相比逻辑代码由 AI 辅助我认为更适合，甚至实现上可能更简单：</p><ul><li>规则编排有时由业务、产品、数据进行编写，不能使用复杂的开发语言；可以使用自然语言描述 AI 转换规则</li><li>规则往往被限定在一个较小的业务范围内，AI 所需的上下文较少，结果更加准确</li><li>AI 是否可以避免规则冲突、流程定义错误的人工错误</li></ul><h2 id="Drools-DRL-amp-CEP"><a href="#Drools-DRL-amp-CEP" class="headerlink" title="Drools DRL &amp; CEP"></a>Drools DRL &amp; CEP</h2><p><strong>问：</strong></p><p>我将会给一段自然语言描述，将其转换为 Drools 的 DRL 规则</p><p>每当 BuyOrder 事件发生时，等待匹配的 AckOrder 事件 10s 的时间，如果匹配成功，则发送短信给用户</p><p><strong>答：</strong></p><p>下面是将自然语言描述转换为 Drools DRL 规则的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">rule <span class="string">&quot;Match AckOrder and Send SMS&quot;</span></span><br><span class="line">when</span><br><span class="line">    <span class="comment">// 当 BuyOrder 事件发生时，等待 10s 匹配 AckOrder 事件</span></span><br><span class="line">    $buyOrder: BuyOrder()</span><br><span class="line">    not <span class="title function_">AckOrder</span><span class="params">(<span class="built_in">this</span> after[0s, 10s] $buyOrder)</span></span><br><span class="line">then</span><br><span class="line">    <span class="comment">// 匹配成功，发送短信给用户</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Your order has been acknowledged. Thank you for your purchase!&quot;</span>;</span><br><span class="line">    sendSMS($buyOrder.getPhoneNumber(), message);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在这个规则中，我们首先导入了 Java 中的 TimeUnit 类，用于指定等待 10 秒的时间</p><p>然后我们定义了一个名为 “Match AckOrder and Send SMS” 的规则，其中：</p><ul><li>当 BuyOrder 事件发生时，使用 not 关键字等待 10 秒来匹配 AckOrder 事件</li><li>如果在 10 秒内成功匹配到 AckOrder 事件，则将会执行 then 语句</li><li>在 then 语句中，我们使用 $buyOrder 对象的 getPhoneNumber() 方法获取用户的电话号码，并将消息发送给用户</li></ul><h2 id="阅读-DRL-规则"><a href="#阅读-DRL-规则" class="headerlink" title="阅读 DRL 规则"></a>阅读 DRL 规则</h2><p><strong>问：</strong></p><p>我将会给你一段 Drools DRL 规则，请用中文描述这段规则的含义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rule <span class="string">&quot;Underage&quot;</span></span><br><span class="line">  salience <span class="number">15</span></span><br><span class="line">  agenda-group <span class="string">&quot;applicationGroup&quot;</span></span><br><span class="line">  when</span><br><span class="line">    $application : LoanApplication()</span><br><span class="line">    Applicant( age &lt; <span class="number">21</span> )</span><br><span class="line">  then</span><br><span class="line">    $application.setApproved( <span class="literal">false</span> );</span><br><span class="line">    $application.setExplanation( <span class="string">&quot;Underage&quot;</span> );</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>答：</strong></p><p>这段 Drools DRL 规则的含义是：</p><p>当规则引擎匹配到一个名为 LoanApplication 的对象，并且其中的 Applicant 对象的 age 属性小于 21 岁时，就会触发这个规则</p><p>该规则的优先级为 15，它属于 agenda-group “applicationGroup” 组</p><p>触发规则后，规则引擎会将  <code>$application</code> 对象的 <code>approved</code> 属性设置为 false，表示不批准该贷款申请；同时，它会将 <code>$application</code> 对象的 <code>explanation</code> 属性设置为 <code>Underage</code>，表示不批准该贷款申请的原因是申请人未达到法定年龄</p><h2 id="自然语言辅助生成-DSL-规则"><a href="#自然语言辅助生成-DSL-规则" class="headerlink" title="自然语言辅助生成 DSL 规则"></a>自然语言辅助生成 DSL 规则</h2><p><strong>问：</strong></p><p>我将会使用语言描述规则，帮我生成 Drools DSL 文件</p><ul><li>当用户购买商品为促销商品，并且用户为普通会员，则打印日志 “当前用户为普通会员”，行为是商品价格打 9 折</li><li>当用户购买商品为促销商品，并且用户为黄金会员，则打印日志 “当前用户为普通会员”，行为为商品价格打 8 折</li></ul><p><strong>答：</strong></p><p>根据你的要求，将上述场景转换为带有表达式转换的形式，可以得到如下的 Drools DSL 文件：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[when]</span> There is <span class="selector-tag">a</span> purchase = <span class="variable">$p</span>:<span class="built_in">Purchase</span>()</span><br><span class="line"><span class="selector-attr">[when]</span> - purchase is promotional = <span class="variable">$p</span><span class="selector-class">.promotionalItem</span> == true</span><br><span class="line"><span class="selector-attr">[when]</span> - user is <span class="selector-tag">a</span> standard member = <span class="variable">$p</span><span class="selector-class">.user</span><span class="selector-class">.membershipLevel</span> == <span class="string">&quot;Standard&quot;</span></span><br><span class="line"><span class="selector-attr">[then]</span> print = System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">&quot;The current user is a&quot;</span> + <span class="variable">$p</span><span class="selector-class">.user</span><span class="selector-class">.membershipLevel</span> + <span class="string">&quot; member&quot;</span>)</span><br><span class="line"><span class="selector-attr">[then]</span> The product price is discounted by &#123;discount:\d*&#125;% = <span class="variable">$p</span><span class="selector-class">.productPrice</span> = <span class="variable">$p</span><span class="selector-class">.productPrice</span> * (<span class="number">100</span> - &#123;discount&#125;) / <span class="number">100</span></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[when]</span> There is <span class="selector-tag">a</span> purchase = <span class="variable">$p</span>:<span class="built_in">Purchase</span>()</span><br><span class="line"><span class="selector-attr">[when]</span> - purchase is promotional = <span class="variable">$p</span><span class="selector-class">.promotionalItem</span> == true</span><br><span class="line"><span class="selector-attr">[when]</span> - user is <span class="selector-tag">a</span> gold member = <span class="variable">$p</span><span class="selector-class">.user</span><span class="selector-class">.membershipLevel</span> == <span class="string">&quot;Gold&quot;</span></span><br><span class="line"><span class="selector-attr">[then]</span> print = System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">&quot;The current user is a &quot;</span> + <span class="variable">$p</span><span class="selector-class">.user</span><span class="selector-class">.membershipLevel</span> + <span class="string">&quot; member&quot;</span>)</span><br><span class="line"><span class="selector-attr">[then]</span> The product price is discounted by &#123;discount:\d*&#125;% = <span class="variable">$p</span><span class="selector-class">.productPrice</span> = <span class="variable">$p</span><span class="selector-class">.productPrice</span> * (<span class="number">100</span> - &#123;discount&#125;) / <span class="number">100</span></span><br></pre></td></tr></table></figure><p>DSLR</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rule <span class="string">&#x27;discount_standard_user&#x27;</span></span><br><span class="line"></span><br><span class="line">when</span><br><span class="line">    There is a purchase</span><br><span class="line">    - purchase is promotional</span><br><span class="line">  - user is a standard member</span><br><span class="line">then</span><br><span class="line">    print</span><br><span class="line">  The product price is discounted by <span class="number">10</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="阅读-LiteFlow-流程图式-EL"><a href="#阅读-LiteFlow-流程图式-EL" class="headerlink" title="阅读 LiteFlow 流程图式 EL"></a>阅读 LiteFlow 流程图式 EL</h2><p><strong>问：</strong></p><p>我设计如下语法：</p><ul><li><code>THEN</code> 表示串行；如 <code>TEHN(A,B,C)</code> 表示执行 A 后执行 B，最后执行 C</li><li><code>WHEN</code> 表示并行；如 <code>WHEN(A,B)</code> 表示 A 和 B 是并行的； <code>WHEN(A,then(B,C))</code> 表示 A 和 B、C 之间的执行是并行的，B 和 C 的执行是串行的</li><li><code>SWITCH</code> 表示选择，会根据返回值对下一个执行的组件进行选择；如 <code>SWITCH(A).to(B,C,D)</code>，会执行组件 A，根据返回值决定后面的流程是执行 B 或者 C 或者 D</li><li><code>IF</code> 表示判断，会根据返回的布尔类型选择下一个执行的组件；如 <code>IF(A,B,C)</code>，执行组件 A，如果返回值是 true 则执行 B，如果返回值是 false 则执行 C；如果是 <code>IF(A,B)</code>，则 false 时不会执行</li></ul><p>上述所有的关键词支持嵌套</p><p>现在我将会给你一段由上述语法组成的表达式，帮我用自然语言描述所进行的操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">THEN(</span><br><span class="line">     unboxed_base_ctx_loader,</span><br><span class="line">     WHEN(</span><br><span class="line">         gift_order_loader,</span><br><span class="line">         textbook_refund_loader,</span><br><span class="line">         dual_coupon_loader,</span><br><span class="line">         marketing_activity_refund_loader,</span><br><span class="line">         lesson_extra_loader</span><br><span class="line">     ),</span><br><span class="line">     WHEN(</span><br><span class="line">         gift_order,</span><br><span class="line">         dual_coupon,</span><br><span class="line">         lesson_textbook,</span><br><span class="line">         marketing_activity_refund_calc</span><br><span class="line">     ),</span><br><span class="line">     lesson_agenda,</span><br><span class="line">     merge_refund</span><br><span class="line"> );</span><br></pre></td></tr></table></figure><p><strong>答：</strong></p><p>这个表达式描述了一个程序的执行流程，按照以下步骤执行：</p><ol><li>首先执行 <code>unboxed_base_ctx_loader</code> 组件</li><li>接着执行两个并行的组件序列，第一个并行序列包括 <code>gift_order_loader</code>、<code>textbook_refund_loader</code>、<code>dual_coupon_loader</code>、<code>marketing_activity_refund_loader</code> 和 <code>lesson_extra_loader</code> 这些组件，这些组件会同时执行；第二个并行序列包括 <code>gift_order</code>、<code>dual_coupon</code>、<code>lesson_textbook</code> 和 <code>marketing_activity_refund_calc</code> 这些组件，这些组件也会同时执行</li><li>执行 <code>lesson_agenda</code> 组件</li><li>最后执行 <code>merge_refund</code> 组件</li></ol><p>需要注意的是，第一个并行序列中的所有组件都需要在第一个步骤中执行完毕后才能开始执行，而第二个并行序列中的所有组件都需要在第一个并行序列中的组件全部执行完毕后才能开始执行；另外，执行 <code>marketing_activity_refund_calc</code> 组件的前提是执行 <code>dual_coupon</code> 和 <code>gift_order</code> 组件，而执行 <code>merge_refund</code> 组件的前提是执行所有其他组件</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><p>博客</p><ul><li><p><a href="https://martinfowler.com/bliki/RulesEngine.html">RulesEngine (martinfowler.com)</a></p></li><li><p><a href="https://refactoring.guru/design-patterns/catalog">The Catalog of Design Patterns (refactoring.guru)</a></p></li></ul></li><li><p>官方文档</p><ul><li><a href="https://www.drools.org/learn/documentation.html">Drools - Documentation</a></li><li><a href="https://liteflow.yomahub.com/">LiteFlow (yomahub.com)</a></li><li><a href="http://waitmoon.com/zh/">开源框架学习与分享 | ice (waitmoon.com)</a></li><li><a href="https://www.yuque.com/boyan-avfmj/aviatorscript/guhmrc">AviatorScript 文档 | 介绍 (yuque.com)</a></li></ul></li><li><p>技术文章</p><ul><li><a href="https://tech.meituan.com/2017/06/09/maze-framework.html">从0到1：构建强大且易用的规则引擎 - 美团技术团队 (meituan.com)</a></li><li><a href="https://juejin.cn/post/6844903593326182414">大数据：美团酒旅实时数据规则引擎应用实践 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/7234763686475219003">规则引擎在内容管理中的探索与应用 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/7195452429154910263">货拉拉大数据基于规则引擎构建运力资源供需调节系统 - 掘金 (juejin.cn)</a></li><li><a href="https://blog.csdn.net/zhuanzhuantech/article/details/127648871">转转图书对基于Drools引擎的DMN实践_dmn引擎_转转技术团队的博客-CSDN博客</a></li><li><a href="http://www.uml.org.cn/modeler/201912044.asp">DMN 决策模型标记介绍 (uml.org.cn)</a></li><li><a href="https://www.jianshu.com/p/650ecc341417">Drools：规则加载 &amp; 动态更新方案</a></li></ul></li><li><p>开源软件</p><ul><li><a href="https://github.com/hyperjumptech/grule-rule-engine#use-cases">hyperjumptech&#x2F;grule-rule-engine: Rule engine implementation in Golang (github.com)</a></li><li><a href="https://github.com/momosecurity/aswan">momosecurity&#x2F;aswan: 陌陌风控系统静态规则引擎，零基础简易便捷的配置多种复杂规则，实时高效管控用户异常行为。 (github.com)</a></li></ul></li><li><p>其他</p><ul><li><a href="https://www.drools.org/learn/DroolsMangaRuleDrivenDevelpment_EN.pdf">DroolsMangaRuleDrivenDevelpment_EN.pdf</a></li><li><a href="https://learn-dmn-in-15-minutes.com/learn/introduction">Learn DMN in 15 minutes | Introduction (learn-dmn-in-15-minutes.com)</a></li><li><a href="https://sandbox.kie.org/#/">KIE Sandbox :: Home</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> LiteFlow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LiteFlow </tag>
            
            <tag> 规则引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redisson RateLimiter</title>
      <link href="/%E5%BC%80%E5%8F%91/Redis/Redisson%20RateLimiter.html"/>
      <url>/%E5%BC%80%E5%8F%91/Redis/Redisson%20RateLimiter.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>对于单机限流，可以使用 Guava 等工具</p><p>如果需要对所有服务进行限流，就需要使用依赖同一个数据资源</p><p>简单的方案可以使用 Redis 记录限流相关信息进行实现，Redisson 的 <code>RRateLimiter</code> 就是基于 Redis 实现的全局限流工具，使用了令牌桶的思想</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p><strong>创建限流器，尝试设置限流配置</strong></p><p>类型为 <code>RateType.OVERALL</code>，为全局限流；permits 数量为 1s 100 个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonRateLimiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">// Redisson 客户端连接 Redis</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://***&quot;</span>).setPassword(<span class="string">&quot;***&quot;</span>);</span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 创建 RRateLimiter</span></span><br><span class="line">        <span class="type">RRateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> redissonClient.getRateLimiter(<span class="string">&quot;test.limiter&quot;</span>);</span><br><span class="line">      <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> rateLimiter.trySetRate(RateType.OVERALL, <span class="number">100</span>, <span class="number">1</span>, RateIntervalUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;success:&#123;&#125;&quot;</span>, success);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改限流配置</strong></p><p>使用 <code>rateLimiter.setRate</code> 方法重新配置限流相关参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonRateLimiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://***&quot;</span>).setPassword(<span class="string">&quot;***&quot;</span>);</span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line">      </span><br><span class="line">        <span class="type">RRateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> redissonClient.getRateLimiter(<span class="string">&quot;test.limiter&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 重新配置</span></span><br><span class="line">        rateLimiter.setRate(RateType.OVERALL, <span class="number">200</span>, <span class="number">1</span>, RateIntervalUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取令牌</strong></p><p>使用 <code>rateLimiter.acquire</code> 等方法获取限流许可</p><p><code>accquire</code> 和 <code>tryAccquire</code> 的区别和大部分限流、锁工具一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonRateLimiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://***&quot;</span>).setPassword(<span class="string">&quot;***&quot;</span>);</span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line">      </span><br><span class="line">        <span class="type">RRateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> redissonClient.getRateLimiter(<span class="string">&quot;test.limiter&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// acquire</span></span><br><span class="line">        rateLimiter.acquire(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// tryAcquire</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> rateLimiter.tryAcquire(<span class="number">2</span>);</span><br><span class="line">        log.info(<span class="string">&quot;success:&#123;&#125;&quot;</span>, success);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="RRateLimiter"><a href="#RRateLimiter" class="headerlink" title="RRateLimiter"></a>RRateLimiter</h2><p>Redisson 中，操作令牌的对象被包装为了 <code>RRateLimiter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RRateLimiter</span> <span class="keyword">extends</span> <span class="title class_">RRateLimiterAsync</span>, RExpirable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">trySetRate</span><span class="params">(RateType mode, <span class="type">long</span> rate, <span class="type">long</span> rateInterval, RateIntervalUnit rateIntervalUnit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setRate</span><span class="params">(RateType mode, <span class="type">long</span> rate, <span class="type">long</span> rateInterval, RateIntervalUnit rateIntervalUnit)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">long</span> permits)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">long</span> permits)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">long</span> permits, <span class="type">long</span> timeout, TimeUnit unit)</span>;</span><br><span class="line"></span><br><span class="line">    RateLimiterConfig <span class="title function_">getConfig</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">availablePermits</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实现类 <code>RedissonRateLimiter</code> 继承了 <code>RedissonExpirable</code></p><p>提供了多个方法来拼装业务中需要用到的 key，在后续的 acquire 等方法中将作为 Lua 脚本参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonRateLimiter</span> <span class="keyword">extends</span> <span class="title class_">RedissonExpirable</span> <span class="keyword">implements</span> <span class="title class_">RRateLimiter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造方法，主要是 super RedissonExpirable</span></span><br><span class="line">  <span class="comment">// RedissonRateLimiter 本身并没有什么成员属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedissonRateLimiter</span><span class="params">(CommandAsyncExecutor commandExecutor, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(commandExecutor, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拼装全局 permits key</span></span><br><span class="line">    String <span class="title function_">getPermitsName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> suffixName(getRawName(), <span class="string">&quot;permits&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拼装单 Redis 实例 permits key</span></span><br><span class="line">    String <span class="title function_">getClientPermitsName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> suffixName(getPermitsName(), getServiceManager().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拼装全局 value key</span></span><br><span class="line">    String <span class="title function_">getValueName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> suffixName(getRawName(), <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 拼装单 Redis 实例 value key</span></span><br><span class="line">    String <span class="title function_">getClientValueName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> suffixName(getValueName(), getServiceManager().getId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>整个流程中需要用到以下的 key：</p><ul><li>name：限流配置</li><li>suffixName(getRawName(), “permits”)：许可授权记录</li><li>suffixName(getRawName(), “value”)：可用许可数量</li></ul><p><strong>在下面会详细介绍这几个 key 的作用</strong></p><h2 id="限流配置"><a href="#限流配置" class="headerlink" title="限流配置"></a>限流配置</h2><p>配置限流参数时，会使用设定的 key name 记录限流的配置信息</p><p><code>setRate</code> 和 <code>trySetRate</code> 的区别在于一个使用 <code>setNx</code>，一个使用 <code>set</code> 覆盖，并且会删除 permits 和 value 的记录</p><p>本质上就是在操作 key 设置限流属性</p><hr><p>假设 <code>RRateLimiter</code> 对象设置的 name 为 <code>test.limiter</code></p><p>其中参数 keys：</p><ol><li>test.limiter</li><li>{test.limiter}:value</li><li>{test.limiter}:value:407cd24e-03e1-4745-9684-5aea2ffd4b5f</li><li>{test.limiter}:permits</li><li>{test.limiter}:permits:407cd24e-03e1-4745-9684-5aea2ffd4b5f</li></ol><p>其中 407cd24e-03e1-4745-9684-5aea2ffd4b5f 是 Redisson 生成的标记，为了实现 Redisson 实例级别的限流控制</p><p>参数 args：</p><ol><li>rate：产出的令牌数量</li><li>rateInterval：时间间隔的毫秒值</li><li>type：类型；0 是 OVERALL 全局；1 是 PER_CLIENT Redisson 实例级别</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> valueName = KEYS[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">local</span> permitsName = KEYS[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">if</span> ARGV[<span class="number">3</span>] == <span class="string">&#x27;1&#x27;</span> <span class="keyword">then</span></span><br><span class="line">valueName = KEYS[<span class="number">3</span>];</span><br><span class="line">permitsName = KEYS[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line">redis.call(<span class="string">&#x27;hset&#x27;</span>, KEYS[<span class="number">1</span>], <span class="string">&#x27;rate&#x27;</span>, ARGV[<span class="number">1</span>]);</span><br><span class="line">redis.call(<span class="string">&#x27;hset&#x27;</span>, KEYS[<span class="number">1</span>], <span class="string">&#x27;interval&#x27;</span>, ARGV[<span class="number">2</span>]);</span><br><span class="line">redis.call(<span class="string">&#x27;hset&#x27;</span>, KEYS[<span class="number">1</span>], <span class="string">&#x27;type&#x27;</span>, ARGV[<span class="number">3</span>]);</span><br><span class="line">redis.call(<span class="string">&#x27;del&#x27;</span>, valueName, permitsName);</span><br></pre></td></tr></table></figure><p>从脚本来看，主要还是操作 Hash key，设置其 <code>rate</code>、<code>interval</code>、<code>type</code> 成员为参数中的不同值</p><p>最后删除 value、permits 的 key（因为变更了 rate，这两个记录就不准确了，Guava 的 RateLimiter 中会平滑变更，Redisson 的实现中粗暴一些，选择了直接删除）</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;hsetnx&#x27;</span>, KEYS[<span class="number">1</span>], <span class="string">&#x27;rate&#x27;</span>, ARGV[<span class="number">1</span>]);</span><br><span class="line">redis.call(<span class="string">&#x27;hsetnx&#x27;</span>, KEYS[<span class="number">1</span>], <span class="string">&#x27;interval&#x27;</span>, ARGV[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">&#x27;hsetnx&#x27;</span>, KEYS[<span class="number">1</span>], <span class="string">&#x27;type&#x27;</span>, ARGV[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>在 <code>trySetRate</code> 中直接使用 <code>hsetnx</code>，并且没有删除 key 的操作，用于初始化</p><h2 id="令牌获取"><a href="#令牌获取" class="headerlink" title="令牌获取"></a>令牌获取</h2><p>核心的令牌获取方法在 <code>tryAcquireAsync</code> 中</p><p><code>acquire</code> 和 <code>tryAcquire</code> 区别在于 <code>tryAcquire</code> 多了 timeout 参数和返回值，用于确定是否等待时间在期望值以内，<code>acquire</code> 则会阻塞，直到获取结果</p><hr><p>其中参数 keys：</p><ol><li>test.limiter</li><li>{test.limiter}:value</li><li>{test.limiter}:value:407cd24e-03e1-4745-9684-5aea2ffd4b5f</li><li>{test.limiter}:permits</li><li>{test.limiter}:permits:407cd24e-03e1-4745-9684-5aea2ffd4b5f</li></ol><p>keys 的值和限流配置部分是一样的</p><p>参数 args：</p><ol><li>value：获取的令牌数量</li><li>System.currentTimeMillis：当前时间戳</li><li>getServiceManager().generateIdArray()：生成的随机字节数，其中随机生成器使用的是 <code>ThreadLocalRandom</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">-- 获取配置，校验是否存在 RateLimiter 配置</span><br><span class="line"><span class="type">local</span> <span class="variable">rate</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;hget&#x27;</span>, KEYS[<span class="number">1</span>], <span class="string">&#x27;rate&#x27;</span>);</span><br><span class="line"><span class="type">local</span> <span class="variable">interval</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;hget&#x27;</span>, KEYS[<span class="number">1</span>], <span class="string">&#x27;interval&#x27;</span>);</span><br><span class="line"><span class="type">local</span> <span class="variable">type</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;hget&#x27;</span>, KEYS[<span class="number">1</span>], <span class="string">&#x27;type&#x27;</span>);</span><br><span class="line"><span class="keyword">assert</span>(rate ~= <span class="literal">false</span> and interval ~= <span class="literal">false</span> and type ~= <span class="literal">false</span>, <span class="string">&#x27;RateLimiter is not initialized&#x27;</span>)</span><br><span class="line"></span><br><span class="line">-- 根据 type 选择不同的 value 和 permits key</span><br><span class="line"><span class="type">local</span> <span class="variable">valueName</span> <span class="operator">=</span> KEYS[<span class="number">2</span>];<span class="string">&quot;</span></span><br><span class="line"><span class="string">local permitsName = KEYS[4];&quot;</span></span><br><span class="line">type == <span class="string">&#x27;1&#x27;</span> then <span class="string">&quot;</span></span><br><span class="line"><span class="string">  valueName = KEYS[3];</span></span><br><span class="line"><span class="string">permitsName = KEYS[5];</span></span><br><span class="line"><span class="string">end;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 判断获取的令牌数量是不是已经大于限流器的配置</span></span><br><span class="line"><span class="string">assert(tonumber(rate) &gt;= tonumber(ARGV[1]), &#x27;Requested permits amount could not exceed defined rate&#x27;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">local currentValue = redis.call(&#x27;get&#x27;, valueName);</span></span><br><span class="line"><span class="string">local res;</span></span><br><span class="line"><span class="string">if currentValue ~= false then</span></span><br><span class="line"><span class="string">  -- 查询时间窗口以外的许可</span></span><br><span class="line"><span class="string">  -- permits 的结构为 score 是发放时间戳；value 是 8 字节随机值 + 许可数量</span></span><br><span class="line"><span class="string">local expiredValues = redis.call(&#x27;zrangebyscore&#x27;, permitsName, 0, tonumber(ARGV[2]) - interval);</span></span><br><span class="line"><span class="string">local released = 0;</span></span><br><span class="line"><span class="string">for i, v in ipairs(expiredValues) do</span></span><br><span class="line"><span class="string">      -- 二进制数据，解包规则为 Bc0I</span></span><br><span class="line"><span class="string">local random, permits = struct.unpack(&#x27;Bc0I&#x27;, v);&quot;</span></span><br><span class="line">      -- 记录时间窗口许可数量</span><br><span class="line">released = released + permits;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- 存在可以释放的许可</span><br><span class="line"><span class="keyword">if</span> released &gt; <span class="number">0</span> then</span><br><span class="line">      -- 删除 permits 记录</span><br><span class="line">    redis.call(<span class="string">&#x27;zremrangebyscore&#x27;</span>, permitsName, <span class="number">0</span>, tonumber(ARGV[<span class="number">2</span>]) - interval);</span><br><span class="line">-- 重新维护下 value</span><br><span class="line"><span class="keyword">if</span> <span class="title function_">tonumber</span><span class="params">(currentValue)</span> + released &gt; tonumber(rate) <span class="type">then</span></span><br><span class="line"><span class="variable">currentValue</span> <span class="operator">=</span> tonumber(rate) - redis.call(<span class="string">&#x27;zcard&#x27;</span>, permitsName);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           currentValue = tonumber(currentValue) + released;</span><br><span class="line">        end;</span><br><span class="line">-- 更新</span><br><span class="line">        redis.call(<span class="string">&#x27;set&#x27;</span>, valueName, currentValue);</span><br><span class="line">   end;</span><br><span class="line"></span><br><span class="line">-- 是否有足够的令牌满足这次请求</span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">tonumber</span><span class="params">(currentValue)</span> &lt; tonumber(ARGV[<span class="number">1</span>]) then</span><br><span class="line">   <span class="type">local</span> <span class="variable">firstValue</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;zrange&#x27;</span>, permitsName, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;withscores&#x27;</span>);</span><br><span class="line">-- 没有，返回等待时间</span><br><span class="line">        res = <span class="number">3</span> + interval - (tonumber(ARGV[<span class="number">2</span>]) - tonumber(firstValue[<span class="number">2</span>]));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      -- 无需等待；更新 permits 和 value</span><br><span class="line">        redis.call(<span class="string">&#x27;zadd&#x27;</span>, permitsName, ARGV[<span class="number">2</span>], struct.pack(<span class="string">&#x27;Bc0I&#x27;</span>, string.len(ARGV[<span class="number">3</span>]), ARGV[<span class="number">3</span>], ARGV[<span class="number">1</span>]));</span><br><span class="line">        redis.call(<span class="string">&#x27;decrby&#x27;</span>, valueName, ARGV[<span class="number">1</span>]);</span><br><span class="line">        res = nil;</span><br><span class="line">    end;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  -- value 值不存在，说明是第一次获取令牌</span><br><span class="line">    redis.call(<span class="string">&#x27;set&#x27;</span>, valueName, rate);</span><br><span class="line">    redis.call(<span class="string">&#x27;zadd&#x27;</span>, permitsName, ARGV[<span class="number">2</span>], struct.pack(<span class="string">&#x27;Bc0I&#x27;</span>, string.len(ARGV[<span class="number">3</span>]), ARGV[<span class="number">3</span>], ARGV[<span class="number">1</span>]));</span><br><span class="line">    redis.call(<span class="string">&#x27;decrby&#x27;</span>, valueName, ARGV[<span class="number">1</span>]);</span><br><span class="line">    res = nil;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- 根据配置更新 value 和 permits 的过期时间</span><br><span class="line"><span class="type">local</span> <span class="variable">ttl</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;pttl&#x27;</span>, KEYS[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> ttl &gt; <span class="number">0</span> then</span><br><span class="line">redis.call(<span class="string">&#x27;pexpire&#x27;</span>, valueName, ttl);</span><br><span class="line">redis.call(<span class="string">&#x27;pexpire&#x27;</span>, permitsName, ttl);</span><br><span class="line">end;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p>结合 Lua 脚本中的注释，流程可以简略概括如下：</p><ol><li>校验 RateLimiter 是否存在</li><li>校验获取的令牌数量是不是已经超过 RateLimiter 的 rate 配置；assert</li><li>获取 currentValue，为现有令牌数量</li><li>currentValue 存在则查询窗口时间内发放的记录，进行释放</li><li>判断是否有足够令牌满足这次请求；满足直接发放，返回 nil；不满足则返回等待时间<br>等待时间的计算规则：3 + 令牌产出间隔 - (当前时间 - 最早一次 令牌发放时间)</li><li>根据配置更新 value 和 permits 的过期时间；简单理解，配置不存在了，value 和 permits 记录也没有存在的意义了</li></ol><p><strong>流程图</strong></p><img src="/%E5%BC%80%E5%8F%91/Redis/Redisson%20RateLimiter/Redisson%20RateLimiter%20%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="" title="Redisson RateLimiter 流程图"><h2 id="delay-时间处理"><a href="#delay-时间处理" class="headerlink" title="delay 时间处理"></a>delay 时间处理</h2><p>Redis 操作最终会返回一个 delay 时间，如果不需要等待，即已经获取到令牌则返回 nil</p><p>所以当客户端拿到最后的 delay 值后，将会进行一系列的判断和处理</p><p>核心主要是在 <code>tryAcquireAsync</code> 方法，非异步方法就是上游方法使用 get 进行阻塞获取完成结果来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CompletableFuture&lt;Boolean&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> permits, <span class="type">long</span> timeoutInMillis)</span> &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">s</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      RFuture&lt;Long&gt; future = tryAcquireAsync(RedisCommands.EVAL_LONG, permits);</span><br><span class="line">      <span class="keyword">return</span> future.thenCompose(delay -&gt; &#123;</span><br><span class="line">        <span class="comment">// Redis 返回 nil，说明立即签发了令牌</span></span><br><span class="line">          <span class="keyword">if</span> (delay == <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="literal">true</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 不限时</span></span><br><span class="line">          <span class="keyword">if</span> (timeoutInMillis == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回的 CompletableFuture</span></span><br><span class="line">              CompletableFuture&lt;Boolean&gt; f = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">              getServiceManager().getGroup().schedule(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 递归调用 tryAcquireAsync</span></span><br><span class="line">                  CompletableFuture&lt;Boolean&gt; r = tryAcquireAsync(permits, timeoutInMillis);</span><br><span class="line">                <span class="comment">// 转换 CompletableFuture 返回值</span></span><br><span class="line">                  commandExecutor.transfer(r, f);</span><br><span class="line">              &#125;, delay, TimeUnit.MILLISECONDS);</span><br><span class="line">              <span class="keyword">return</span> f;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 上面操作的耗时（当前时间 - 入口开始时间）</span></span><br><span class="line">          <span class="type">long</span> <span class="variable">el</span> <span class="operator">=</span> System.currentTimeMillis() - s;</span><br><span class="line">        <span class="comment">// 剩余期望等待时间</span></span><br><span class="line">          <span class="type">long</span> <span class="variable">remains</span> <span class="operator">=</span> timeoutInMillis - el;</span><br><span class="line">        <span class="comment">// 剩余期望等待时间小于 0，返回 false</span></span><br><span class="line">          <span class="keyword">if</span> (remains &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="literal">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          CompletableFuture&lt;Boolean&gt; f = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 剩余期望等待时间比需要等待的时间要小</span></span><br><span class="line">          <span class="keyword">if</span> (remains &lt; delay) &#123;</span><br><span class="line">            <span class="comment">// 定时返回 false</span></span><br><span class="line">              getServiceManager().getGroup().schedule(() -&gt; &#123;</span><br><span class="line">                  f.complete(<span class="literal">false</span>);</span><br><span class="line">              &#125;, remains, TimeUnit.MILLISECONDS);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 重新一轮获取</span></span><br><span class="line">              <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">              getServiceManager().getGroup().schedule(() -&gt; &#123;</span><br><span class="line">                  <span class="type">long</span> <span class="variable">elapsed</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line">                <span class="comment">// 过程中超时了</span></span><br><span class="line">                  <span class="keyword">if</span> (remains &lt;= elapsed) &#123;</span><br><span class="line">                      f.complete(<span class="literal">false</span>);</span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  CompletableFuture&lt;Boolean&gt; r = tryAcquireAsync(permits, remains - elapsed);</span><br><span class="line">                  commandExecutor.transfer(r, f);</span><br><span class="line">              &#125;, delay, TimeUnit.MILLISECONDS);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> f;</span><br><span class="line">      &#125;).toCompletableFuture();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先调用了 <code>tryAcquireAsync(RedisCommands.EVAL_LONG, permits)</code> 的重载方法；这个方法处理 delay 结果；重载的方法则是和 Redis 交互令牌获取的逻辑</p><p>拿到 Redis 返回时分为几种情况：</p><ul><li>为 null 说明不需要等待，已经获取了令牌</li><li>没有期望等待时间，生成一个定时任务，delay 为 Redis 返回的等待时间</li><li>计算剩余期望等待时间，如果为 0，则直接返回 false</li><li>剩余期望等待时间小于 delay，延迟后返回 false</li><li>最后开始递归一轮获取</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="异步任务的递归"><a href="#异步任务的递归" class="headerlink" title="异步任务的递归"></a>异步任务的递归</h2><p>Redisson 中的很多设计都是构造一个异步方法，返回值包装为 <code>CompletableFuture</code>，同步接口就是直接调用其 get 方法阻塞等待</p><p>对于异步方法如何递归呢，因为最终接口需要返回一个 <code>CompletableFuture</code>，不能 <code>CompletableFuture</code> 嵌套 <code>CompletableFuture</code>，因为上游调用方也不知道递归了几层</p><p>Redisson 的方法是在异步递归之前先定义出一个 <code>CompletableFuture</code> 作为返回值，再最后异步执行完后使用 transfer 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (timeoutInMillis == -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 返回的 CompletableFuture</span></span><br><span class="line">    CompletableFuture&lt;Boolean&gt; f = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">    getServiceManager().getGroup().schedule(() -&gt; &#123;</span><br><span class="line">        CompletableFuture&lt;Boolean&gt; r = tryAcquireAsync(permits, timeoutInMillis);</span><br><span class="line">      <span class="comment">// 异步任务中进行 transfer</span></span><br><span class="line">        commandExecutor.transfer(r, f);</span><br><span class="line">    &#125;, delay, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>transfer 的操作本质上是使用 <code>whenComplete</code>，将新的最终递归异步任务的返回值（异常）传递给返回值引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandAsyncService</span> <span class="keyword">implements</span> <span class="title class_">CommandAsyncExecutor</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;V&gt; <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(CompletionStage&lt;V&gt; future1, CompletableFuture&lt;V&gt; future2)</span> &#123;</span><br><span class="line">        future1.whenComplete((res, e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                future2.completeExceptionally(e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            future2.complete(res);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终实现异步任务的递归操作</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.cn/post/7198826344582676538?searchId=202308071543501DA8932282EC1F20B8C7">详解Redisson分布式限流的实现原理 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> Redis 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式 - Observer</title>
      <link href="/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%20-%20Observer.html"/>
      <url>/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%20-%20Observer.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>观察者模式（Observer Pattern）用来处理某个值得关注的状态的对象状态变更，进而执行相应的操作</p><p>将自身的状态改变通知给其他对象， 我们也将其称为 <em>发布者</em> （publisher）</p><p>所有希望关注发布者状态变化的其他对象被称为 <em>订阅者</em> （subscribers）</p><p>所有订阅者都必须实现同样的接口， 发布者仅通过该接口与订阅者交互， 接口中必须声明通知方法及其参数， 这样发布者在发出通知时还能传递一些上下文数据</p><p><strong>目的</strong></p><p>实现一种订阅机制，可在对象事件发生时通知多个 “观察” 该对象的其他对象；订阅者能在不与具体发布者类耦合的情况下通过接口观察发布者的状态</p><p><strong>真实世界类比</strong></p><p>商店缺货时，用户向商店登记联系电话，当补货后商店通过电话通知对该商品（事件）感兴趣的用户；而不是：</p><ul><li>用户频繁到达商店查询是否到货</li><li>商品通知所有用户缺货商品到货</li></ul><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>模拟一个场景，实现一个日志装饰，当日志信息打印异常时，进行相应日志等级的处理：</p><ul><li>warn 级别发送邮件</li><li>error 级别电话通知</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>可以对日志实现进行包装，在对应的日志级别方法进行增强</p><p>例如，实现一个 <code>MyLogger</code> 的装饰类，将增强的方法写在相关装饰的方法上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLogger</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TinyLog</span> <span class="variable">log</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TinyLog</span>(<span class="string">&quot;MyLogger&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String format, Throwable t, Object... arguments)</span> &#123;</span><br><span class="line">        log.info(format, arguments, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">warn</span><span class="params">(String format, Throwable t, Object... arguments)</span> &#123;</span><br><span class="line">        log.warn(format, arguments, t);</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(t)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;邮件通知管理员&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(String format, Throwable t, Object... arguments)</span> &#123;</span><br><span class="line">        log.error(format, arguments, t);</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(t)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;电话通知管理员&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就会存在如下问题：</p><ul><li>关注日志的逻辑需要硬编码在日志打印的核心逻辑中，监听行为和发布者、甚至和功能的主要实现耦合</li><li>无法动态增加、移除订阅者</li></ul><p>这种情况下使用观察者模式解决以上问题</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="监听者接口"><a href="#监听者接口" class="headerlink" title="监听者接口"></a>监听者接口</h3><p>所有的监听者实现该接口，当事件触发时通过该接口的实现告诉发布者需要执行的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogEventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(Throwable t)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发布者"><a href="#发布者" class="headerlink" title="发布者"></a>发布者</h3><p>维护了监听者列表，提供了供事件触发的通知行为以及订阅、移除订阅等操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogEventManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Level, List&lt;LogEventListener&gt;&gt; listeners = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LogEventManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Level level : Level.values()) &#123;</span><br><span class="line">            listeners.put(level, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(Level level, LogEventListener listener)</span> &#123;</span><br><span class="line">        List&lt;LogEventListener&gt; listenerList = listeners.get(level);</span><br><span class="line">        listenerList.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unsubscribe</span><span class="params">(Level level, LogEventListener listener)</span> &#123;</span><br><span class="line">        List&lt;LogEventListener&gt; listenerList = listeners.get(level);</span><br><span class="line">        listenerList.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(Level level, Throwable t)</span> &#123;</span><br><span class="line">        List&lt;LogEventListener&gt; listenerList = listeners.get(level);</span><br><span class="line">        <span class="keyword">for</span> (LogEventListener listener : listenerList) &#123;</span><br><span class="line">            listener.notify(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="日志装饰接入"><a href="#日志装饰接入" class="headerlink" title="日志装饰接入"></a>日志装饰接入</h3><p>只需要在具体的行为（事件）调用发布者</p><p>至于发布者的逻辑、发布者维护的监听者，不需要核心业务逻辑关注</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLogger</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TinyLog</span> <span class="variable">log</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TinyLog</span>(<span class="string">&quot;MyLogger&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LogEventManager logEventManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLogger</span><span class="params">(<span class="keyword">final</span> LogEventManager logEventManager)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.logEventManager = logEventManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String format, Throwable t, Object... arguments)</span> &#123;</span><br><span class="line">        log.info(format, arguments, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">warn</span><span class="params">(String format, Throwable t, Object... arguments)</span> &#123;</span><br><span class="line">        log.warn(format, arguments, t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(t)) &#123;</span><br><span class="line">            logEventManager.call(Level.WARN, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(String format, Throwable t, Object... arguments)</span> &#123;</span><br><span class="line">        log.error(format, arguments, t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(t)) &#123;</span><br><span class="line">            logEventManager.call(Level.ERROR, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监听者实现"><a href="#监听者实现" class="headerlink" title="监听者实现"></a>监听者实现</h3><p><strong>邮件通知实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailCallListener</span> <span class="keyword">implements</span> <span class="title class_">LogEventListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(<span class="keyword">final</span> Throwable t)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;邮件通知管理员 &quot;</span> + t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>电话通知实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneCallListener</span> <span class="keyword">implements</span> <span class="title class_">LogEventListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(<span class="keyword">final</span> Throwable t)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电话通知管理员 &quot;</span> + t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 发布者（管理）</span></span><br><span class="line">        <span class="type">LogEventManager</span> <span class="variable">logEventManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogEventManager</span>();</span><br><span class="line">        logEventManager.subscribe(Level.WARN, <span class="keyword">new</span> <span class="title class_">EmailCallListener</span>());</span><br><span class="line">        logEventManager.subscribe(Level.ERROR, <span class="keyword">new</span> <span class="title class_">PhoneCallListener</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 日志装饰类</span></span><br><span class="line">        <span class="type">MyLogger</span> <span class="variable">myLogger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLogger</span>(logEventManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印日志</span></span><br><span class="line">        <span class="type">RuntimeException</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;an error occurred&quot;</span>);</span><br><span class="line">        myLogger.warn(<span class="string">&quot;get warn&quot;</span>, exception);</span><br><span class="line">        myLogger.error(<span class="string">&quot;get error&quot;</span>, exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">七月 <span class="number">27</span>, <span class="number">2023</span> <span class="number">12</span>:09:08 上午 design.behavioral.observer.MyLogger warn</span><br><span class="line">警告: get warn</span><br><span class="line">七月 <span class="number">27</span>, <span class="number">2023</span> <span class="number">12</span>:09:08 上午 design.behavioral.observer.MyLogger error</span><br><span class="line">严重: get error</span><br><span class="line">邮件通知管理员 an error occurred</span><br><span class="line">电话通知管理员 an error occurred</span><br></pre></td></tr></table></figure><h3 id="变更订阅"><a href="#变更订阅" class="headerlink" title="变更订阅"></a>变更订阅</h3><p>业务调整，对于 error 日志也需要进行邮件通知，那么只需要调整订阅关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LogEventManager</span> <span class="variable">logEventManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogEventManager</span>();</span><br><span class="line">        logEventManager.subscribe(Level.WARN, <span class="keyword">new</span> <span class="title class_">EmailCallListener</span>());</span><br><span class="line">        logEventManager.subscribe(Level.ERROR, <span class="keyword">new</span> <span class="title class_">PhoneCallListener</span>());</span><br><span class="line">        <span class="comment">// 对 error 增加实现</span></span><br><span class="line">        logEventManager.subscribe(Level.ERROR, <span class="keyword">new</span> <span class="title class_">EmailCallListener</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">MyLogger</span> <span class="variable">myLogger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLogger</span>(logEventManager);</span><br><span class="line"></span><br><span class="line">        <span class="type">RuntimeException</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;an error occurred&quot;</span>);</span><br><span class="line">        myLogger.warn(<span class="string">&quot;get warn&quot;</span>, exception);</span><br><span class="line">        myLogger.error(<span class="string">&quot;get error&quot;</span>, exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>Apache 的 commons.io，可以有功能来监听本地文件的变更</p><h3 id="观察者-FileAlterationObserver"><a href="#观察者-FileAlterationObserver" class="headerlink" title="观察者 FileAlterationObserver"></a>观察者 FileAlterationObserver</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">FileAlterationObserver</span><span class="params">(<span class="keyword">final</span> FileEntry rootEntry, <span class="keyword">final</span> FileFilter fileFilter,</span></span><br><span class="line"><span class="params">                                 <span class="keyword">final</span> IOCase caseSensitivity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rootEntry == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Root entry is missing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rootEntry.getFile() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Root directory is missing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.rootEntry = rootEntry;</span><br><span class="line">    <span class="built_in">this</span>.fileFilter = fileFilter;</span><br><span class="line">    <span class="keyword">if</span> (caseSensitivity == <span class="literal">null</span> || caseSensitivity.equals(IOCase.SYSTEM)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.comparator = NameFileComparator.NAME_SYSTEM_COMPARATOR;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (caseSensitivity.equals(IOCase.INSENSITIVE)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.comparator = NameFileComparator.NAME_INSENSITIVE_COMPARATOR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.comparator = NameFileComparator.NAME_COMPARATOR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法中传入一个文件、过滤器等对象</p><h3 id="监听者-FileAlterationListener"><a href="#监听者-FileAlterationListener" class="headerlink" title="监听者 FileAlterationListener"></a>监听者 FileAlterationListener</h3><p><code>FileAlterationListener</code> 是一个接口，用于实现文件相关事件的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FileAlterationListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * File system observer started checking event.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer The file system observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Directory created Event.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> directory The directory created</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryCreate</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Directory changed Event.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> directory The directory changed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryChange</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Directory deleted Event.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> directory The directory deleted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryDelete</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * File created Event.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file The file created</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * File changed Event.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file The file changed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileChange</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * File deleted Event.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file The file deleted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * File system observer finished checking event.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer The file system observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册监听者"><a href="#注册监听者" class="headerlink" title="注册监听者"></a>注册监听者</h3><p>调用 <code>FileAlterationObserver</code> 的 <code>addListener</code> 方法添加监听者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a file system listener.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> listener The file system listener</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(<span class="keyword">final</span> FileAlterationListener listener)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">        listeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终监听者被保存在 <code>private final List&lt;FileAlterationListener&gt; listeners = new CopyOnWriteArrayList&lt;&gt;()</code> 属性中</p><h3 id="监控器-FileAlterationMonitor"><a href="#监控器-FileAlterationMonitor" class="headerlink" title="监控器 FileAlterationMonitor"></a>监控器 FileAlterationMonitor</h3><p>监控器 <code>FileAlterationMonitor</code> 包装了一系列观察者，以及监控间隔时间等参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileAlterationMonitor</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> interval, <span class="keyword">final</span> FileAlterationObserver... observers)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(interval);</span><br><span class="line">    <span class="keyword">if</span> (observers != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> FileAlterationObserver observer : observers) &#123;</span><br><span class="line">            addObserver(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动监控"><a href="#启动监控" class="headerlink" title="启动监控"></a>启动监控</h3><p>调用 <code>FileAlterationMonitor</code> 的 <code>start</code> 方法开启监控</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (running) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Monitor is already running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> FileAlterationObserver observer : observers) &#123;</span><br><span class="line">        observer.initialize();</span><br><span class="line">    &#125;</span><br><span class="line">    running = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (threadFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        thread = threadFactory.newThread(<span class="built_in">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FileAlterationMonitor</code> 本身是一个 <code>Runnable</code> 实现</p><p><code>run</code> 方法的实现，使用 while 循环判断，调用 <code>FileAlterationObserver</code> 的 <code>checkAndNotify</code> 来观察和通知监听者</p><p><code>Thread.sleep(interval)</code> 来进行时间间隔</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Runs this monitor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> FileAlterationObserver observer : observers) &#123;</span><br><span class="line">            observer.checkAndNotify();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(interval);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException ignored) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FileAlterationObserver</code> 的 <code>checkAndNotify</code> 就是发布者的核心方法，比较文件的变化，调用已注册监听者的相关处理方法</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>观察者模式的优点：</p><ul><li>满足了开闭原则；无需修改发布者代码就能引入新的订阅者类 （如果是发布者接口则可轻松引入发布者类）</li><li>可以在运行时建立对象之间的联系（动态订阅、解除订阅）</li></ul><p>责任链、 命令、 中介者和观察者用于处理请求发送者和接收者之间的不同连接方式：</p><ul><li>责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理</li><li>命令在发送者和请求者之间建立单向连接</li><li>中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通</li><li>观察者允许接收者动态地订阅或取消接收请求</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://refactoringguru.cn/design-patterns/observer">观察者设计模式 (refactoringguru.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LiteFlow - WhenCondition 和异步超时机制</title>
      <link href="/%E5%BC%80%E5%8F%91/LiteFlow/LiteFlow%20WhenCondition%20%E5%92%8C%E5%BC%82%E6%AD%A5%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6.html"/>
      <url>/%E5%BC%80%E5%8F%91/LiteFlow/LiteFlow%20WhenCondition%20%E5%92%8C%E5%BC%82%E6%AD%A5%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6.html</url>
      
        <content type="html"><![CDATA[<h1 id="WhenCondition"><a href="#WhenCondition" class="headerlink" title="WhenCondition"></a>WhenCondition</h1><p>对应 EL 规则中的 <code>WHEN</code> 关键字，会被包装为 <code>WhenCondition</code> 组件<img src="/%E5%BC%80%E5%8F%91/LiteFlow/LiteFlow%20WhenCondition%20%E5%92%8C%E5%BC%82%E6%AD%A5%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6/Executable.png" class="" title="Executable"></p><p>主要的并发编排逻辑主要由 <code>WhenCondition</code> 的实现方法执行</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p><code>WHEN</code> 关键字支持的属性：</p><ul><li><code>ignoreError</code>：调用链调用失败时是否继续往下执行</li><li><code>group</code>：并发分组；该属性已经弃用，因为可以使用不同的 <code>WHEN</code> 进行分组控制，例如 <code>THEN(WHEN(a,b),WHEN(c,d))</code></li><li><code>any</code>：任意节点执行成功就继续向下执行</li><li><code>threadExecutorClass</code>：线程池名称；实例化后的线程池会被放在 <code>ExecutorHelper</code> 的 <code>Map&lt;String, ExecutorService&gt; executorServiceMap</code> 属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhenCondition</span> <span class="keyword">extends</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOG</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">ignoreError</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> LocalDefaultFlowConstant.DEFAULT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">any</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String threadExecutorClass;</span><br></pre></td></tr></table></figure><h2 id="任务编排"><a href="#任务编排" class="headerlink" title="任务编排"></a>任务编排</h2><p><code>WhenCondition</code> 实现的 <code>Condition</code> 抽象方法 <code>executeCondition</code></p><p>核心操作就是将任务包装为 <code>CompletableFuture</code>：</p><ol><li>过滤前后置组件</li><li>过滤 <code>isAccess</code> false；一是过滤掉不需要执行的组件，二是不执行的组件一定是执行完成最快的，会造成 <code>any</code> 属性结果的混乱</li><li>对 <code>Condition</code> 下的 <code>Map&lt;String, List&lt;Executable&gt;&gt; executableGroup</code> 包装为 <code>CompletableFuture</code>，编排异步任务</li><li>在包装为 <code>CompletableFuture</code> 过程中使用了 <code>CompletableFutureTimeout</code> 工具，套入 <code>CompletableFutureTimeout</code> 方法进行超时判断，如果超时则用 <code>WhenFutureObj.timeOut</code> 返回超时的对象</li><li>最终将所有需要执行的任务放进集合 <code>List&lt;CompletableFuture&lt;WhenFutureObj&gt;&gt;</code></li></ol><p><strong>根据 any 属性对任务集合再次进行编排封装</strong></p><p>如果是 <code>any</code> 属性，则使用 <code>CompletableFuture.anyOf</code> 进行编排，否则使用 <code>CompletableFuture.allOf</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.isAny()) &#123;</span><br><span class="line">    <span class="comment">// 把这些 CompletableFuture 通过 anyOf 合成一个 CompletableFuture</span></span><br><span class="line">    resultCompletableFuture = CompletableFuture</span><br><span class="line">        .anyOf(completableFutureList.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[] &#123;&#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 把这些 CompletableFuture 通过 allOf 合成一个 CompletableFuture</span></span><br><span class="line">    resultCompletableFuture = CompletableFuture</span><br><span class="line">        .allOf(completableFutureList.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[] &#123;&#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终等待任务执行完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 进行执行，这句执行完后，就意味着所有的任务要么执行完毕，要么超时返回</span></span><br><span class="line">    resultCompletableFuture.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="超时实现"><a href="#超时实现" class="headerlink" title="超时实现"></a>超时实现</h2><p>Java 8 的 <code>CompletableFuture</code> 并没有 timeout 机制，虽然可以在 get 的时候指定 timeout，但是是一个同步堵塞的操作</p><p>一般的实现方案是启动一个 <code>ScheduledThreadpoolExecutor</code> 线程在 timeout</p><ul><li>时间后直接调用 <code>CompletableFuture.completeExceptionally(new TimeoutException())</code></li><li>然后用 <code>acceptEither()</code> 或者 <code>applyToEither</code> 看是执行完成还是超时</li></ul><p>Java  9 引入了 <code>orTimeout</code> 和 <code>completeOnTimeOut</code> 两个方法支持 异步 timeout 机制，底层也是使用 <code>ScheduledThreadpoolExecutor</code> 进行实现的</p><p>这里 LiteFlow 将任务和执行和超时封装成了一个 API 工具 <code>CompletableFutureTimeout</code></p><p>在上面任务包装过程中，调用了 <code>CompletableFutureTimeout.completeOnTimeout</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; CompletableFuture&lt;T&gt; <span class="title function_">completeOnTimeout</span><span class="params">(T t, CompletableFuture&lt;T&gt; future, <span class="type">long</span> timeout,</span></span><br><span class="line"><span class="params">        TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;T&gt; timeoutFuture = timeoutAfter(timeout, unit);</span><br><span class="line">    <span class="keyword">return</span> future.applyToEither(timeoutFuture, Function.identity()).exceptionally((throwable) -&gt; t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>泛型 T 下的 <code>t</code>，在任务编排中是 <code>WhenFutureObj</code> 对象</li><li><code>future</code> 是通过 <code>CompletableFuture.supplyAsync(new ParallelSupplier(executable, currChainName, slotIndex), parallelExecutor)</code> 编排的任务 <code>CompletableFuture</code> 对象，返回结果依然是 <code>WhenFutureObj</code></li><li><code>timeout</code> 是超时时间</li><li><code>unit</code> 是超时时间单位</li></ul><p><code>timeoutAfter</code> 创建出超时异常任务后，由业务任务 <code>future</code> 的 <code>applyToEither</code> 编排两个任务</p><p><strong>超时异常任务</strong></p><p>调用 <code>timeoutAfter</code> 包装超时任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; CompletableFuture&lt;T&gt; <span class="title function_">timeoutAfter</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;T&gt;();</span><br><span class="line">    <span class="comment">// timeout 时间后 抛出TimeoutException 类似于sentinel / watcher</span></span><br><span class="line">    Delayer.delayer.schedule(() -&gt; result.completeExceptionally(<span class="keyword">new</span> <span class="title class_">TimeoutException</span>()),</span><br><span class="line">            timeout, unit);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>delayer</code> 是一个 <code>ScheduledThreadPoolExecutor</code></p><p>创建出一个 <code>CompletableFuture</code>，如果该任务在 <code>get</code> 时未完成，则抛出 <code>TimeoutException</code> 异常</p><h2 id="WhenFutureObj"><a href="#WhenFutureObj" class="headerlink" title="WhenFutureObj"></a>WhenFutureObj</h2><p><code>WhenFutureObj</code> 是任务结果的包装对象</p><p>对于一个任务执行完成的状态有三种情况：</p><ul><li>成功</li><li>失败</li><li>超时</li></ul><p>在 <code>ParallelSupplier</code> 包装过程中对应了成功、失败两种返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParallelSupplier</span> <span class="keyword">implements</span> <span class="title class_">Supplier</span>&lt;WhenFutureObj&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOG</span> <span class="operator">=</span> LoggerFactory.getLogger(ParallelSupplier.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executable executableItem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String currChainId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Integer slotIndex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ParallelSupplier</span><span class="params">(Executable executableItem, String currChainId, Integer slotIndex)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.executableItem = executableItem;</span><br><span class="line"><span class="built_in">this</span>.currChainId = currChainId;</span><br><span class="line"><span class="built_in">this</span>.slotIndex = slotIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> WhenFutureObj <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">executableItem.setCurrChainId(currChainId);</span><br><span class="line">executableItem.execute(slotIndex);</span><br><span class="line">            <span class="comment">// 成功</span></span><br><span class="line"><span class="keyword">return</span> WhenFutureObj.success(executableItem.getId());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 失败</span></span><br><span class="line"><span class="keyword">return</span> WhenFutureObj.fail(executableItem.getId(), e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在超时任务中对应了超时的状态返回 <code>WhenFutureObj.timeOut(executable.getId())</code></p><p><strong>对象 build 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhenFutureObj</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> success;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> timeout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String executorName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Exception ex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> WhenFutureObj <span class="title function_">success</span><span class="params">(String executorName)</span> &#123;</span><br><span class="line"><span class="type">WhenFutureObj</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WhenFutureObj</span>();</span><br><span class="line">result.setSuccess(<span class="literal">true</span>);</span><br><span class="line">result.setTimeout(<span class="literal">false</span>);</span><br><span class="line">result.setExecutorName(executorName);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> WhenFutureObj <span class="title function_">fail</span><span class="params">(String executorName, Exception ex)</span> &#123;</span><br><span class="line"><span class="type">WhenFutureObj</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WhenFutureObj</span>();</span><br><span class="line">result.setSuccess(<span class="literal">false</span>);</span><br><span class="line">result.setTimeout(<span class="literal">false</span>);</span><br><span class="line">result.setExecutorName(executorName);</span><br><span class="line">result.setEx(ex);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> WhenFutureObj <span class="title function_">timeOut</span><span class="params">(String executorName)</span> &#123;</span><br><span class="line"><span class="type">WhenFutureObj</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WhenFutureObj</span>();</span><br><span class="line">result.setSuccess(<span class="literal">false</span>);</span><br><span class="line">result.setTimeout(<span class="literal">true</span>);</span><br><span class="line">result.setExecutorName(executorName);</span><br><span class="line">result.setEx(<span class="keyword">new</span> <span class="title class_">WhenTimeoutException</span>(</span><br><span class="line">StrUtil.format(<span class="string">&quot;Timed out when executing the component[&#123;&#125;],when-max-timeout-seconds config is:&#123;&#125;(s)&quot;</span>,</span><br><span class="line">executorName, LiteflowConfigGetter.get().getWhenMaxWaitSeconds())));</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是设置 <code>success</code>、<code>timeout</code>、异常信息等异步执行结果</p><h2 id="结果解析"><a href="#结果解析" class="headerlink" title="结果解析"></a>结果解析</h2><p>过滤出已经完成的任务，放到集合中</p><p>对于没有完成的任务就执行 <code>cancel</code> 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;WhenFutureObj&gt; allCompletableWhenFutureObjList = completableFutureList.stream().filter(f -&gt; &#123;</span><br><span class="line">    <span class="comment">// 过滤出已经完成的，没完成的就直接终止</span></span><br><span class="line">    <span class="keyword">if</span> (f.isDone()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        f.cancel(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).map(f -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        interrupted[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>集合中的任务 <code>get</code> 出任务的产出，即包装的 <code>WhenFutureObj</code></p><p>根据 <code>WhenFutureObj</code> 结果属性判断后续操作</p><ul><li>输出超时信息</li><li>如果配置中 <code>isIgnoreError</code> 不忽略异常<ul><li>根据 <code>interrupted[0]</code> 集合中的中断情况抛出异常 <code>throw new WhenExecuteException(StrUtil.format(&quot;requestId [&#123;&#125;] when execute interrupted. errorResume [false].&quot;, slot.getRequestId()))</code></li><li>循环判断 <code>CompletableFuture</code> 的返回值，如果异步执行失败，则抛出相应的业务异常；如果是超时，这里就会抛出在超时任务编排时抛出的 <code>TimeoutException</code></li></ul></li><li>如果忽略异常；则对中断输出 warn 日志</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="CompletableFuture-cancel"><a href="#CompletableFuture-cancel" class="headerlink" title="CompletableFuture cancel"></a>CompletableFuture cancel</h2><p>在 <code>WhenCondition</code> 执行流程中，对于包装的 <code>anyOf</code> <code>CompletableFuture</code> 执行完成后，存在没有结束的任务，则会调用 <code>CompletableFuture</code> 的 <code>cancel</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">cancelled</span> <span class="operator">=</span> (result == <span class="literal">null</span>) &amp;&amp;</span><br><span class="line">        internalComplete(<span class="keyword">new</span> <span class="title class_">AltResult</span>(<span class="keyword">new</span> <span class="title class_">CancellationException</span>()));</span><br><span class="line">    postComplete();</span><br><span class="line">    <span class="keyword">return</span> cancelled || isCancelled();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法参数 <code>mayInterruptIfRunning</code> 实际并没有使用，也就是说整个 <code>CompletableFuture</code> 的执行并不会被中断</p><p>在官方文档中也说</p><blockquote><p>@param mayInterruptIfRunning this value has no effect in this implementation because interrupts are not used to control processing.</p><p>这个值在这个实现中没有作用，因为中断不用于控制处理</p></blockquote><p>该方法实现自 <code>Future</code>，其定义的 <code>mayInterruptIfRunning</code> 并没有使用</p><p>StackOverFlow 中也有人提出了这样的问题，认为违反了 <code>Java.util.concurrent.Future</code> 中对 <code>cancel</code> 方法定义的约定</p><p>其原因在评论中有所讨论：</p><blockquote><ul><li><p>As mentioned in my previous (edited) comment, the <code>CompletableFuture</code> does not hold a reference to either the actual work or the <code>Thread</code> processing it. This is at least implied in the class documentation: “<em>Since (unlike FutureTask) this class has no direct control over the computation that causes it to be completed, cancellation is treated as just another form of exceptional completion</em>“</p><p>由于与 <code>FutureTask</code> 不同，<code>CompletableFuture</code> 对执行任务的线程没有直接控制，因此取消被视为另一种形式的异常完成</p></li><li><p><code>CompletableFuture</code> does not hold reference to thread, which I think it is also a problem, It is not consistency with <code>Future</code></p><p><code>CompletableFuture</code> 没有引用线程，我认为这也是一个问题，它与 <code>Future</code> 不一致</p></li></ul></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://stackoverflow.com/questions/55490668/why-does-completablefuture-implement-the-future-interface">java - Why does CompletableFuture implement the Future interface - Stack Overflow</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> LiteFlow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LiteFlow </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS 解析导致的 ssh connect to host github.com port 22 Connection refused</title>
      <link href="/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/DNS%20%E8%A7%A3%E6%9E%90%E5%AF%BC%E8%87%B4%E7%9A%84%20ssh%20connect%20to%20host%20github.com%20port%2022%20Connection%20refused.html"/>
      <url>/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/DNS%20%E8%A7%A3%E6%9E%90%E5%AF%BC%E8%87%B4%E7%9A%84%20ssh%20connect%20to%20host%20github.com%20port%2022%20Connection%20refused.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>一段时间没有使用 github SSH 操作，今天突然发现 Hexo deploy 无法正常 push 到仓库</p><p>报错信息为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh: connect to host github.com port 22: Connection refused</span><br><span class="line">fatal: Could not <span class="built_in">read</span> from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure><p>开始以为是 SSH 配置存在问题，但是检查了配置以及仓库情况并没有发现问题</p><p>此外尝试了直接使用 git 进行 pull 和 push 的操作，也无法成功</p><h1 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h1><p>查看了一些文章，此类 access 问题大致有以下原因：</p><ul><li>SSH 配置错误</li><li>22 端口被禁止</li><li>DNS 解析</li></ul><p>排除了一些可能之后尝试是 DNS 存在问题</p><p>尝试修改 IPv4 DNS 配置后依然无法访问</p><p><strong>第一步</strong></p><p>使用 <code>ssh git@github.com</code> 验证是否可以通过 SSH 连接 github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh: connect to host github.com port 22: Connection refused</span><br></pre></td></tr></table></figure><p>确实无法正常连接</p><p><strong>第二步</strong></p><p>使用 <code>ssh -v</code> 命令，<code>-v</code> 表示 verbose，会打出建立 SSH 连接过程的详细日志</p><p><code> ssh -v git@github.com</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OpenSSH_for_Windows_8.1p1, LibreSSL 3.0.2</span><br><span class="line">debug1: Connecting to github.com [127.0.0.1] port 22.</span><br><span class="line">debug1: connect to address 127.0.0.1 port 22: Connection refused</span><br><span class="line">ssh: connect to host github.com port 22: Connection refused</span><br></pre></td></tr></table></figure><p>针对 github.com 的访问会请求到 127.0.0.1，访问本机 IP 明显是不正确的</p><p>检查了 hosts 配置也没发现存在针对 github 域名的相关错误配置</p><p><strong>第三步</strong></p><p>使用 <code>nslookup</code> 命令获取 github 的 IP 地址；使用 Google 的 DNS 8.8.8.8</p><p><code>nslookup github.com 8.8.8.8</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Server:  dns.google</span><br><span class="line">Address:  8.8.8.8</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:    github.com</span><br><span class="line">Address:  20.205.243.166</span><br></pre></td></tr></table></figure><p>拿到 IP 地址 20.205.243.166</p><p><strong>第四步</strong></p><p>配置 hosts；hosts 路径一般为 <code>C:\Windows\System32\drivers\etc\hosts</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># github</span></span><br><span class="line">20.205.243.166 github.com</span><br></pre></td></tr></table></figure><p>随后继续进行 <code>ssh -T git@github.com</code> 验证则 access 成功，IP 也成功访问了配置的 20.205.243.166</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi xxx! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debug1: Authentication succeeded (publickey).</span><br><span class="line">Authenticated to github.com ([20.205.243.166]:22).</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/578435111">坑：ssh: connect to host github.com port 22: Connection refused - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/MBuger/article/details/70226712">解决ssh: connect to host github.com port 22: Connection refused_Seven17000的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> 疑难za&#39;zheng </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些 50/50 shots 酒单</title>
      <link href="/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/%E4%B8%80%E4%BA%9B%2050-50%20shots%20%E9%85%92%E5%8D%95.html"/>
      <url>/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/%E4%B8%80%E4%BA%9B%2050-50%20shots%20%E9%85%92%E5%8D%95.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>从 Ferrari  到 Hard Start，这里有 9 款我们最爱的 50&#x2F;50 shots 酒单</p></blockquote><img src="/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/%E4%B8%80%E4%BA%9B%2050-50%20shots%20%E9%85%92%E5%8D%95/Article-50-50-Shots.jpg" class="" title="img"><p>50&#x2F;50 shots 诸如 Ferrari 和 M&amp;M 多年来一致是业内宠儿；不过随着越来越受欢迎，派对者们找到了将鸡尾酒作为配料的方式，这种形式已经扩展为一种易于复制并创作的模式</p><p>这是一个简单的模板：取一杯苦杏仁酒（amaro），将其与另一种利口酒或更高度烈酒等分</p><p>各种各样的变化，无论你是在寻找一种令人大开眼界的宿醉方式：例如 Hard Start，或者是一杯复杂性堪比鸡尾酒的 shot：例如 Mezcaletti</p><p>让我们开始吧，以下是我们最喜欢的关于 50&#x2F;50 的一些 shots</p><img src="/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/%E4%B8%80%E4%BA%9B%2050-50%20shots%20%E9%85%92%E5%8D%95/Inline-50-50-Shot.jpg" class="" title="50 50 shot"><h1 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h1><p><strong><a href="https://www.diffordsguide.com/beer-wine-spirits/323/fernet-branca">Fernet Branca</a></strong> 菲奈特·布兰卡；著名的意大利苦味酒，龙胆、甘菊、藏红花等草本，在 Slovenian 橡木桶陈酿</p><p><strong><a href="https://www.diffordsguide.com/beer-wine-spirits/190/campari-bitter">Campari</a></strong> 金巴利苦酒</p><p><strong><a href="https://www.diffordsguide.com/encyclopedia/363/bws/mezcal-what-it-is-and-how-its-made">Mezcal</a></strong> 梅斯卡尔酒；龙舌兰酒的一种，墨西哥产</p><p><strong><a href="https://www.diffordsguide.com/beer-wine-spirits/1819/ramazzotti-amaro">Ramazzotti</a></strong> 雷玛佐蒂苦味酒；由多种草本、香料包括龙胆和橙皮制作的苦酒</p><p><strong>Rye Whiskey</strong> 黑麦威士忌；美国威士忌，必须从至少 51％ 的黑麦谷物中蒸馏，使用新橡木桶</p><p><strong><a href="https://www.diffordsguide.com/beer-wine-spirits/859/cynar">Cynar</a></strong> 西纳尔酒；意大利开胃酒，萃取洋蓟叶（Cynara scolymus）香味，名字来源于洋蓟叶和其他添加的植物</p><p><strong><a href="https://www.diffordsguide.com/beer-wine-spirits/1818/montenegro-amaro">Montenegro</a></strong> 蒙特内罗；意大利苦酒，由 40 种植物（包括甘草根、肉豆蔻、甜橙和苦橙）调味</p><p><strong><a href="https://www.diffordsguide.com/beer-wine-spirits/2034/nardini-amaro">Nardini</a></strong> 纳尔迪尼；传统的苦味意大利开胃酒，主要用苦橙、薄荷和龙胆调味</p><p><strong><a href="https://www.diffordsguide.com/beer-wine-spirits/6733/amaro-meletti">Amaro Meletti</a></strong> 梅乐提；意大利苦酒，用水果和香草调味</p><p><strong>Rum</strong> 朗姆；六大基酒之一，原料为甘蔗糖蜜</p><p><strong><a href="https://www.diffordsguide.com/beer-wine-spirits/6903/cappelletti">Cappelletti</a></strong> 主要用于用白葡萄酒和苏打水制作 Spritz</p><p><strong><a href="https://www.diffordsguide.com/beer-wine-spirits/6483/strega-amaro-liqueur">Strega</a></strong> 一种意大利苦酒</p><p><strong><a href="https://www.diffordsguide.com/beer-wine-spirits/324/brancamenta">Branca Menta</a></strong> 布兰卡 · 薄荷；意大利利口酒，夏季版本的 Fernet Branca，添加了薄荷</p><h1 id="阿马罗-Amaro"><a href="#阿马罗-Amaro" class="headerlink" title="阿马罗 Amaro"></a>阿马罗 Amaro</h1><p>可以看到上面很多酒都产自意大利，并且都是“Amaro”的一种，翻译为了“苦味酒”</p><p>Amaro 既是意大利语中苦的意思，也是传统上来自意大利的苦中带甜（bittersweet）利口酒的名字</p><p>Amari（Amaro 的复数）通常呈深黄褐色，以白兰地为基础，并用香草、香料和其他植物调味</p><p><strong>为什么我们如此喜爱 Amaro</strong></p><p>并不是所有人都喜欢这种令人振奋、味道强烈的苦酒</p><p>但是 Amaro 很快就成了 bartender 最好的朋友；为清淡细腻的鸡尾酒少量加入可以增加味道的复杂性，很容易理解为什么偏爱浓郁口味的爱好者会如此着迷</p><p><a href="https://www.diffordsguide.com/beer-wine-spirits/category/1202/amari">Amari (diffordsguide.com)</a></p><blockquote><p><strong>阿马罗（Amaro） 和比特酒（Bitter） 的区别</strong></p><p>阿马罗和苦精的不同之处在于它更适合纯饮，而不是用来调味</p><p>阿马罗被归为可纯饮的苦酒，而不像 Angostura 等比特酒作为鸡尾酒的点缀</p><p>马克·彼得曼在《彼得曼的苦酒与阿马罗指导手册》中这么写道：一些阿马罗需要你细细品鉴，而另一些则真的难以下咽</p><p><a href="https://zhuanlan.zhihu.com/p/36368828">什么是阿马罗？意大利苦酒手记 - 知乎 (zhihu.com)</a></p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://punchdrink.com/articles/best-shots-amaro-whiskey-mezcal/">The 9 Best Bartender’s Handshake Shots, Beyond the Ferrari | PUNCH (punchdrink.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 宿醉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸡尾酒 </tag>
            
            <tag> recipes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TransmittableThreadLocal 源码 &amp; 简单使用</title>
      <link href="/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/TransmittableThreadLocal%20%E6%BA%90%E7%A0%81%20&amp;%20%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html"/>
      <url>/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/TransmittableThreadLocal%20%E6%BA%90%E7%A0%81%20&amp;%20%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="可继承-Inheritable"><a href="#可继承-Inheritable" class="headerlink" title="可继承 Inheritable"></a>可继承 Inheritable</h1><p><code>InheritableThreadLocal</code> 是官方提供的类，区别于 <code>ThreadLocal</code> 的功能就是使子线程创建时会赋值父线程当时的 <code>ThreadLocal</code> 值（引用），实现开启线程后将线程本地变量传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里如果将 ThreadLocal 实现换为 ThreadLocal，则子线程内获取为 null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; THREAD_LOCAL = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        THREAD_LOCAL.set(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; &quot;</span> + THREAD_LOCAL.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot; &quot;</span> + THREAD_LOCAL.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread[main,<span class="number">5</span>,main] Hello World</span><br><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main] Hello World</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><code>ThreadLocal</code> 对象本质是 <code>Thread</code> 内 <code>threadLocalMap</code> 的 key</p><p><code>InheritableThreadLocal</code> 功能的实现需要两方支持：</p><ul><li><code>InheritableThreadLocal</code> 将父类 <code>ThreadLocal</code> 关于 map 的实现重写为支持新的 map（inheritableThreadLocals）</li><li><code>Thread</code> 内提供 <code>InheritableThreadLocal</code> 使用的 map，并且在线程创建期间将父线程的 map 值传递给子线程</li></ul><p><strong>InheritableThreadLocal 重写方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritableThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes the child&#x27;s initial value for this inheritable thread-local</span></span><br><span class="line"><span class="comment">     * variable as a function of the parent&#x27;s value at the time the child</span></span><br><span class="line"><span class="comment">     * thread is created.  This method is called from within the parent</span></span><br><span class="line"><span class="comment">     * thread before the child is started.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This method merely returns its input argument, and should be overridden</span></span><br><span class="line"><span class="comment">     * if a different behavior is desired.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentValue the parent thread&#x27;s value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the child thread&#x27;s initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> T <span class="title function_">childValue</span><span class="params">(T parentValue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the map associated with a ThreadLocal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create the map associated with a ThreadLocal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue value for the initial entry of the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Thread init 赋值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">                      <span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">                      <span class="type">boolean</span> inheritThreadLocals)</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">        <span class="comment">// 如果参数开关开启，父线程存在 inheritableThreadLocals，则进行 createInheritedMap 并赋值</span></span><br><span class="line">        <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.inheritableThreadLocals =</span><br><span class="line">                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">        <span class="built_in">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set thread ID */</span></span><br><span class="line">        tid = nextThreadID();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><p><code>InheritableThreadLocal</code> 在部分场景有其局限性：</p><ul><li><p>只能在线程创建初始化时期赋值，线程池中的线程一般是复用的，所以如果使用线程池则无法传递</p><p>当然这种行为符合预期的，因为 Inheritable 强调的就是<strong>继承性</strong>，线程池的场景强调的是<strong>传递性</strong></p><blockquote><p>但对于使用线程池等会池化复用线程的执行组件的情况，线程由线程池创建好，并且线程是池化起来反复使用的；这时父子线程关系的<code>ThreadLocal</code>值传递已经没有意义，应用需要的实际上是把 <strong>任务提交给线程池时</strong>的<code>ThreadLocal</code>值传递到 <strong>任务执行时</strong></p><p><a href="https://github.com/alibaba/transmittable-thread-local#-%E5%8A%9F%E8%83%BD">alibaba&#x2F;transmittable-thread-local: transmittable-thread-local-功能</a></p></blockquote></li><li><p>传递的是引用而不是拷贝，使用中需要注意引用数据修改的影响；也没有提供拷贝相关的能力实现</p></li></ul><p><strong>线程池复用则无法传递</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 单线程线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; THREAD_LOCAL = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">// 为了让线程池 init 一个新线程</span></span><br><span class="line">        EXECUTOR.execute(() -&gt; System.out.println(<span class="string">&quot;init&quot;</span>));</span><br><span class="line"></span><br><span class="line">        THREAD_LOCAL.set(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 复用线程</span></span><br><span class="line">        EXECUTOR.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; &quot;</span> + THREAD_LOCAL.get());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot; &quot;</span> + THREAD_LOCAL.get());</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init</span><br><span class="line">Thread[main,<span class="number">5</span>,main] Hello World</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main] <span class="literal">null</span></span><br></pre></td></tr></table></figure><h1 id="可传递-Transmittable"><a href="#可传递-Transmittable" class="headerlink" title="可传递 Transmittable"></a>可传递 Transmittable</h1><p>alibaba 开源的 <a href="https://github.com/alibaba/transmittable-thread-local">transmittable-thread-local</a> 可以解决满足需要</p><p><code>ThreadLocal</code>的需求场景即<code>TransmittableThreadLocal</code>的潜在需求场景，如果你的业务需要 <em>在使用线程池等会池化复用线程的执行组件情况下传递 <code>ThreadLocal</code> 值</em> 则是 <code>TransmittableThreadLocal</code> 目标场景</p><p>下面是几个典型场景例子：</p><ol><li>分布式跟踪系统 或 全链路压测（即链路打标）</li><li>日志收集记录系统上下文</li><li><code>Session</code> 级 <code>Cache</code></li><li>应用容器或上层框架跨应用代码给下层<code>SDK</code>传递信息</li></ol><p>官方文档写的非常详细，我就不赘述了，具体可以去查看官方文档～</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>关于使用官方文档也描述的非常详细，这里就简单列举一下 Java 代码</p><p>依赖为 2.12.6 版本</p><blockquote><p>从<code>TTL v2.13+</code>开始，升级到<code>Java 8</code>。<br>如果需要<code>Java 6</code>的支持，使用版本<code>2.12.x</code></p><p> <a href="https://search.maven.org/artifact/com.alibaba/transmittable-thread-local"><img src="https://camo.githubusercontent.com/bc33d0e5608d42d034de759fc7e6a2c4a65bbd3b9231c0d3f4f7bb815e5d08c0/68747470733a2f2f696d672e736869656c64732e696f2f6d6176656e2d63656e7472616c2f762f636f6d2e616c69626162612f7472616e736d69747461626c652d7468726561642d6c6f63616c3f76657273696f6e5072656669783d322e31322e26636f6c6f723d6c6967687467726579266c6f676f3d6170616368652d6d6176656e266c6f676f436f6c6f723d7768697465" alt="Maven Central"></a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;transmittable-thread-local&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.12</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="装饰-Runnable"><a href="#装饰-Runnable" class="headerlink" title="装饰 Runnable"></a>装饰 Runnable</h3><p>使用 <code>TtlRunnable</code> 和 <code>TtlCallable</code> 来修饰传入线程池的 <code>Runnable</code> 和 <code>Callable</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 TransmittableThreadLocal</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; THREAD_LOCAL = <span class="keyword">new</span> <span class="title class_">TransmittableThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        EXECUTOR.execute(() -&gt; System.out.println(<span class="string">&quot;init&quot;</span>));</span><br><span class="line"></span><br><span class="line">        THREAD_LOCAL.set(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 装饰 Runnable 为 TtlRunnable</span></span><br><span class="line">        <span class="type">TtlRunnable</span> <span class="variable">ttlRunnable</span> <span class="operator">=</span> TtlRunnable.get(() -&gt; System.out.println(Thread.currentThread() + <span class="string">&quot; &quot;</span> + THREAD_LOCAL.get()));</span><br><span class="line">        EXECUTOR.execute(ttlRunnable);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot; &quot;</span> + THREAD_LOCAL.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init</span><br><span class="line">Thread[main,<span class="number">5</span>,main] Hello World</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main] Hello World</span><br></pre></td></tr></table></figure><p><strong>需要注意：</strong>即使提交同一个 <code>Runnable</code> 任务到线程池，每次都需要进行装饰操作，否则抓取的仍是上一次的上下文信息</p><h3 id="装饰线程池"><a href="#装饰线程池" class="headerlink" title="装饰线程池"></a>装饰线程池</h3><p>省去每次 <code>Runnable</code> 和 <code>Callable</code> 传入线程池时的修饰，这个逻辑可以在线程池中完成</p><p>通过工具类 <code>TtlExecutors</code> 完成，有下面的方法：</p><ul><li><code>getTtlExecutor</code>：修饰接口 <code>Executor</code></li><li><code>getTtlExecutorService</code>：修饰接口 <code>ExecutorService</code></li><li><code>getTtlScheduledExecutorService</code>：修饰接口 <code>ScheduledExecutorService</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; THREAD_LOCAL = <span class="keyword">new</span> <span class="title class_">TransmittableThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 装饰线程池 ExecutorService</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">EXECUTOR</span> <span class="operator">=</span> TtlExecutors.getTtlExecutorService(Executors.newSingleThreadExecutor());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        EXECUTOR.execute(() -&gt; System.out.println(<span class="string">&quot;init&quot;</span>));</span><br><span class="line"></span><br><span class="line">        THREAD_LOCAL.set(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 不需要再装饰 Runnable</span></span><br><span class="line">        EXECUTOR.execute(() -&gt; System.out.println(Thread.currentThread() + <span class="string">&quot; &quot;</span> + THREAD_LOCAL.get()));</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot; &quot;</span> + THREAD_LOCAL.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init</span><br><span class="line">Thread[main,<span class="number">5</span>,main] Hello World</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main] Hello World</span><br></pre></td></tr></table></figure><h2 id="源码及思想"><a href="#源码及思想" class="headerlink" title="源码及思想"></a>源码及思想</h2><h3 id="TransmittableThreadLocal"><a href="#TransmittableThreadLocal" class="headerlink" title="TransmittableThreadLocal"></a>TransmittableThreadLocal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransmittableThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">InheritableThreadLocal</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">TtlCopier</span>&lt;T&gt;</span><br></pre></td></tr></table></figure><p>继承了 <code>InheritableThreadLocal</code>，实现了 <code>TtlCopier</code></p><p>重点关注 <code>set</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!disableIgnoreNullValueSemantics &amp;&amp; <span class="literal">null</span> == value) &#123;</span><br><span class="line">        <span class="comment">// may set null to remove value</span></span><br><span class="line">        remove();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.set(value);</span><br><span class="line">        addThisToHolder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用父类 <code>InheritableThreadLocal</code> 的 <code>set</code> 方法之后，调用了 <code>addThisToHolder</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addThisToHolder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!holder.get().containsKey(<span class="built_in">this</span>)) &#123;</span><br><span class="line">        holder.get().put((TransmittableThreadLocal&lt;Object&gt;) <span class="built_in">this</span>, <span class="literal">null</span>); <span class="comment">// WeakHashMap supports null value.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>this</code> 对象，即 <code>TransmittableThreadLocal</code> 对象作为 key 放进 <code>holder</code> 中，这里的 <code>holder</code> 是一个泛形为 Map 的 <code>InheritableThreadLocal</code>，下面会进行分析</p><p>这里的 Map 只用来作为 Set，**WeakHashMap supports null value.**；类似的思想还有使用 <code>ConcurrentHashMap</code> 实现并发安全的 Set</p><h3 id="holder"><a href="#holder" class="headerlink" title="holder"></a>holder</h3><p><code>holder</code> 是 <code>TransmittableThreadLocal</code> 进行扩展的关键一环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InheritableThreadLocal&lt;WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt;&gt; holder =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt; initialValue() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt; childValue(WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt; parentValue) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;(parentValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>是一个匿名内部类，重写了 <code>InheritableThreadLocal</code> 的 <code>initialValue</code> 和 <code>childValue</code> 方法</p><ul><li>initialValue：直接创建 Map</li><li>childValue：<code>ThreadLocal.createInheritedMap</code> 中复制值时调用，重写实现为包装一个新 Map</li></ul><p>在上一步的 <code>addThisToHolder</code> 操作中，会将 <code>TransmittableThreadLocal</code> 的 <code>this</code> 对象放进 <code>holder</code> 的 Map 中</p><h3 id="TtlRunnable"><a href="#TtlRunnable" class="headerlink" title="TtlRunnable"></a>TtlRunnable</h3><p>使用 <code>TtlRunnable</code> 的静态方法 <code>get</code> 对普通的 <code>Runnable</code> 进行装饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TtlRunnable <span class="title function_">get</span><span class="params">(<span class="meta">@Nullable</span> Runnable runnable, <span class="type">boolean</span> releaseTtlValueReferenceAfterRun, <span class="type">boolean</span> idempotent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == runnable) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里避免过度装饰，只装饰一层</span></span><br><span class="line">    <span class="keyword">if</span> (runnable <span class="keyword">instanceof</span> TtlEnhanced) &#123;</span><br><span class="line">        <span class="comment">// avoid redundant decoration, and ensure idempotency</span></span><br><span class="line">        <span class="keyword">if</span> (idempotent) <span class="keyword">return</span> (TtlRunnable) runnable;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already TtlRunnable!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 包装成 TtlRunnable 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TtlRunnable</span>(runnable, releaseTtlValueReferenceAfterRun);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终通过 <code>TtlRunnable</code> 的构造器包装成 <code>TtlRunnable</code> 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">TtlRunnable</span><span class="params">(<span class="meta">@NonNull</span> Runnable runnable, <span class="type">boolean</span> releaseTtlValueReferenceAfterRun)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.capturedRef = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;Object&gt;(capture());</span><br><span class="line">    <span class="built_in">this</span>.runnable = runnable;</span><br><span class="line">    <span class="built_in">this</span>.releaseTtlValueReferenceAfterRun = releaseTtlValueReferenceAfterRun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个 <code>ThreadLocal</code> 传递的关键都在 <code>capturedRef</code> 对象，赋值的关键逻辑在 <code>Transmitter.capture</code> 方法</p><h3 id="Transmitter"><a href="#Transmitter" class="headerlink" title="Transmitter"></a>Transmitter</h3><p><code>Transmitter</code> 扮演传递者的角色，是 <code>TransmittableThreadLocal</code> 的公有静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Transmitter</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Capture all &#123;<span class="doctag">@link</span> TransmittableThreadLocal&#125; and registered &#123;<span class="doctag">@link</span> ThreadLocal&#125; values in the current thread.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the captured &#123;<span class="doctag">@link</span> TransmittableThreadLocal&#125; values</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@since</span> 2.3.0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">capture</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Snapshot</span>(captureTtlValues(), captureThreadLocalValues());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; <span class="title function_">captureTtlValues</span><span class="params">()</span> &#123;</span><br><span class="line">            HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttl2Value = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line">            <span class="keyword">for</span> (TransmittableThreadLocal&lt;Object&gt; threadLocal : holder.get().keySet()) &#123;</span><br><span class="line">                ttl2Value.put(threadLocal, threadLocal.copyValue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ttl2Value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>创建一个 <code>Snapshot</code> 的对象，将 <code>holder</code> 中的 keys（也就是将 <code>WeakHashMap</code> 当作 Set 来使用，key 为 <code>TransmittableThreadLocal</code> 对象）遍历取出，同时调用 <code>copyValue</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">copyValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> copy(get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">copy</span><span class="params">(T parentValue)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> parentValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基础的 <code>TransmittableThreadLocal</code> 实现就是将 value get 出来，不涉及 copy 等操作</p><p>完成这些后，<code>TtlRunnable</code> 就实例化完成，并且保存了 <code>Snapshot</code> 结构，保存当前时间点、当前线程下的 <code>TransmittableThreadLocal</code> 对象及其 value</p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>最终放入线程池的 <code>Runnable</code> 是被装饰的 <code>TtlRunnable</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 获取当时保存的 父线程 + 装饰那一刻的 Snapshot</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">captured</span> <span class="operator">=</span> capturedRef.get();</span><br><span class="line">  <span class="comment">// captured == null 说明该 Runnable 已经被 run 了</span></span><br><span class="line">  <span class="comment">// capturedRef.compareAndSet(captured, null) 使用原子类保证争抢执行资格</span></span><br><span class="line">    <span class="keyword">if</span> (captured == <span class="literal">null</span> || releaseTtlValueReferenceAfterRun &amp;&amp; !capturedRef.compareAndSet(captured, <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;TTL value reference is released after run!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// replay 重放</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">backup</span> <span class="operator">=</span> replay(captured);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 执行被装饰的真正的 Runnable</span></span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// restore 恢复</span></span><br><span class="line">        restore(backup);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="replay"><a href="#replay" class="headerlink" title="replay"></a>replay</h3><p>保存当前时间的副本，依靠传参进入的快照 <code>captured</code> 将设置当前线程的上下文环境</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">replay</span><span class="params">(<span class="meta">@NonNull</span> Object captured)</span> &#123;</span><br><span class="line"><span class="comment">// 取出快照</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Snapshot</span> <span class="variable">capturedSnapshot</span> <span class="operator">=</span> (Snapshot) captured;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Snapshot</span>(replayTtlValues(capturedSnapshot.ttl2Value), replayThreadLocalValues(capturedSnapshot.threadLocal2Value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; <span class="title function_">replayTtlValues</span><span class="params">(<span class="meta">@NonNull</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; captured)</span> &#123;</span><br><span class="line">            HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; backup = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 注意这里的 holder，此时已经在子线程内了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> Iterator&lt;TransmittableThreadLocal&lt;Object&gt;&gt; iterator = holder.get().keySet().iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">                TransmittableThreadLocal&lt;Object&gt; threadLocal = iterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// backup</span></span><br><span class="line">                backup.put(threadLocal, threadLocal.get());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// clear the TTL values that is not in captured</span></span><br><span class="line">                <span class="comment">// avoid the extra TTL values after replay when run task</span></span><br><span class="line">                <span class="keyword">if</span> (!captured.containsKey(threadLocal)) &#123;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    threadLocal.superRemove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// set TTL values to captured</span></span><br><span class="line">            setTtlValuesTo(captured);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// call beforeExecute callback</span></span><br><span class="line">            doExecuteCallback(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> backup;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里就是为了拿到副本，<strong>为什么需要拿到副本而不是直接根据快照设置值并恢复呢</strong></p><blockquote><p>当我们提交的任务被划分的线程有自己的上下文（任务的提交和实际执行中间存在时间差，如果这个时间段出现了上下文的更新，那么直接覆盖将导致本次更新丢失），那么就需要保证在任务执行的时候是当时的上下文，执行完毕后需要还原</p></blockquote><ol><li>获取当前线程，上线文快照</li><li>如果当前线程有快照里面不存在的上下文，那么先清除掉</li><li>将创建TtlRunnable时保存的快照设置到当前线程的上下文中（实现 <code>ThreadLocal</code> 传递的核心）</li><li><code>doExecuteCallback</code> 执行钩子方法</li><li>返回保存的副本</li></ol><h3 id="restore"><a href="#restore" class="headerlink" title="restore"></a>restore</h3><p>根据 replay 时生成的副本对上下文环境进行恢复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">restore</span><span class="params">(<span class="meta">@NonNull</span> Object backup)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Snapshot</span> <span class="variable">backupSnapshot</span> <span class="operator">=</span> (Snapshot) backup;</span><br><span class="line">    restoreTtlValues(backupSnapshot.ttl2Value);</span><br><span class="line">    restoreThreadLocalValues(backupSnapshot.threadLocal2Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">restoreTtlValues</span><span class="params">(<span class="meta">@NonNull</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; backup)</span> &#123;</span><br><span class="line">    <span class="comment">// call afterExecute callback</span></span><br><span class="line">    doExecuteCallback(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> Iterator&lt;TransmittableThreadLocal&lt;Object&gt;&gt; iterator = holder.get().keySet().iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">        TransmittableThreadLocal&lt;Object&gt; threadLocal = iterator.next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the TTL values that is not in backup</span></span><br><span class="line">        <span class="comment">// avoid the extra TTL values after restore</span></span><br><span class="line">        <span class="keyword">if</span> (!backup.containsKey(threadLocal)) &#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">            threadLocal.superRemove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore TTL values</span></span><br><span class="line">    setTtlValuesTo(backup);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据副本恢复当前线程的 <code>ThreadLocal</code></p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>对线程池的装饰实现和 <code>Runnable</code> 一致，将真正的线程池包装在 Wrapper 对象中</p><p>根据线程池实现的不同，有三个方法：</p><ul><li>getTtlExecutor：返回 <code>Executor</code></li><li>getTtlExecutorService：返回 <code>ExecutorService</code></li><li>getTtlScheduledExecutorService：返回 <code>ScheduledExecutorService</code></li></ul><p>以 <code>getTtlExecutor</code> 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Executor <span class="title function_">getTtlExecutor</span><span class="params">(<span class="meta">@Nullable</span> Executor executor)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否是 TtlAgent 加载、或者是 TtlEnhanced，避免重复装饰</span></span><br><span class="line">    <span class="keyword">if</span> (TtlAgent.isTtlAgentLoaded() || executor == <span class="literal">null</span> || executor <span class="keyword">instanceof</span> TtlEnhanced) &#123;</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ExecutorTtlWrapper</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExecutorTtlWrapper</span>(executor, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExecutorTtlWrapper</span> <span class="keyword">implements</span> <span class="title class_">Executor</span>, TtlWrapper&lt;Executor&gt;, TtlEnhanced &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> idempotent;</span><br><span class="line"></span><br><span class="line">    ExecutorTtlWrapper(<span class="meta">@NonNull</span> Executor executor, <span class="type">boolean</span> idempotent) &#123;</span><br><span class="line">        <span class="built_in">this</span>.executor = executor;</span><br><span class="line">        <span class="built_in">this</span>.idempotent = idempotent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 帮忙调用了 TtlRunnable.get</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(<span class="meta">@NonNull</span> Runnable command)</span> &#123;</span><br><span class="line">        executor.execute(TtlRunnable.get(command, <span class="literal">false</span>, idempotent));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以本质上就是包装为 <code>ExecutorTtlWrapper</code> 后重写了提交任务等方法，实现内主动去调用了装饰方法</p><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p>个人认为 <code>Transmittable</code> 核心的思想：</p><ul><li>不同 <code>ThreadLocal</code> 之间的关系，保存、赋值、恢复等操作的流程</li><li>并发场景下的实现，使用原子类、副本的保存和恢复等</li></ul><img src="/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/TransmittableThreadLocal%20%E6%BA%90%E7%A0%81%20&%20%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/%E6%97%B6%E5%BA%8F%E5%9B%BE.png" class="" title="时序图"><img src="/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/TransmittableThreadLocal%20%E6%BA%90%E7%A0%81%20&%20%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/ThrealLocal%20%E6%93%8D%E4%BD%9C.webp" class="" title="ThrealLocal 操作"><h2 id="扩展-TTL"><a href="#扩展-TTL" class="headerlink" title="扩展 TTL"></a>扩展 TTL</h2><p>上面提到 <code>InheritableThreadLocal</code> 没有提供拷贝相关的能力，TTL 也进行了支持</p><p><code>SuppliedTransmittableThreadLocal</code> 继承了 <code>TransmittableThreadLocal</code>，提供了传参 <code>Supplier</code> 和 <code>TtlCopier</code> 来进行初始值、继承值拷贝、传递值拷贝的设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SuppliedTransmittableThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">TransmittableThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// initialValue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier;</span><br><span class="line">    <span class="comment">// childValue InheritableThreadLocal</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TtlCopier&lt;T&gt; copierForChildValue;</span><br><span class="line">    <span class="comment">// copy</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TtlCopier&lt;T&gt; copierForCopy;</span><br><span class="line"></span><br><span class="line">    SuppliedTransmittableThreadLocal(Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier, TtlCopier&lt;T&gt; copierForChildValue, TtlCopier&lt;T&gt; copierForCopy) &#123;</span><br><span class="line">        <span class="keyword">if</span> (supplier == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;supplier is null&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.supplier = supplier;</span><br><span class="line">        <span class="built_in">this</span>.copierForChildValue = copierForChildValue;</span><br><span class="line">        <span class="built_in">this</span>.copierForCopy = copierForCopy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> T <span class="title function_">childValue</span><span class="params">(T parentValue)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (copierForChildValue != <span class="literal">null</span>) <span class="keyword">return</span> copierForChildValue.copy(parentValue);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">super</span>.childValue(parentValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">copy</span><span class="params">(T parentValue)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (copierForCopy != <span class="literal">null</span>) <span class="keyword">return</span> copierForCopy.copy(parentValue);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">super</span>.copy(parentValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过静态方法 <code>withInitial</code>、<code>withInitialAndCopier</code> 进行创建</p><p><strong>简单使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Student&gt; THREAD_LOCAL = </span><br><span class="line">        TransmittableThreadLocal.withInitialAndCopier(</span><br><span class="line">        () -&gt; <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;默认&quot;</span>, <span class="number">0</span>), </span><br><span class="line">        value -&gt; <span class="keyword">new</span> <span class="title class_">Student</span>(value.name + <span class="string">&quot; Inherit&quot;</span>, value.age),</span><br><span class="line">        value -&gt; <span class="keyword">new</span> <span class="title class_">Student</span>(value.name + <span class="string">&quot; Transmit&quot;</span>, value.age)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 装饰线程池 ExecutorService</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">EXECUTOR</span> <span class="operator">=</span></span><br><span class="line">        TtlExecutors.getTtlExecutorService(Executors.newSingleThreadExecutor());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程设置前：&quot;</span> + THREAD_LOCAL.get());</span><br><span class="line"></span><br><span class="line">        THREAD_LOCAL.set(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程设置后：&quot;</span> + THREAD_LOCAL.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> THREAD_LOCAL.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;新线程：&quot;</span> + student);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        THREAD_LOCAL.set(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三2&quot;</span>, <span class="number">21</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程修改：&quot;</span> + THREAD_LOCAL.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池</span></span><br><span class="line">        EXECUTOR.execute(() -&gt; &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> THREAD_LOCAL.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程池：&quot;</span> + student);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主线程设置前：ThreadLocalTest.Student(name=默认, age=<span class="number">0</span>)</span><br><span class="line">主线程设置后：ThreadLocalTest.Student(name=张三, age=<span class="number">20</span>)</span><br><span class="line">主线程修改：ThreadLocalTest.Student(name=张三<span class="number">2</span>, age=<span class="number">21</span>)</span><br><span class="line">新线程：ThreadLocalTest.Student(name=张三 Inherit, age=<span class="number">20</span>)</span><br><span class="line">线程池：ThreadLocalTest.Student(name=张三<span class="number">2</span> Transmit, age=<span class="number">21</span>)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/alibaba/transmittable-thread-local/tree/2.x">alibaba&#x2F;transmittable-thread-local at 2.x (github.com)</a></p><p><a href="https://www.jianshu.com/p/f92721fb0e29">TransmittableThreadLocal源码分析 - 简书 (jianshu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>REST VS gRPC</title>
      <link href="/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/REST%20VS%20gRPC.html"/>
      <url>/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/REST%20VS%20gRPC.html</url>
      
        <content type="html"><![CDATA[<p>在很长的一段时间，REST 都是一种且唯一一种构建 API 的 “标准”；它在某种程度上取代了 SOAP，后者是一个 “太多 XML” 的丑陋烂摊子</p><p>但是近些年新的选择出现了，2015 年，Facebook 向公众发布了 GraphQL，2016 年谷歌紧随其后发布了 gRPC</p><p>在本文中，我们将关注仍然被广泛使用的后者，并将其与 REST 进行比较</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>下表将概述所讨论的要点，并显示 REST 和 gRPC 的亮点</p><table><thead><tr><th align="center">Toic</th><th align="center">REST</th><th align="center">gRPC</th></tr></thead><tbody><tr><td align="center"><strong>Standardization</strong></td><td align="center">无标准</td><td align="center">定义完善</td></tr><tr><td align="center"><strong>Paradigm</strong></td><td align="center">基于资源</td><td align="center">RPC</td></tr><tr><td align="center"><strong>Service modes</strong></td><td align="center">只有 unary</td><td align="center">Unary, client streaming, server streaming 和 bidirectional streaming</td></tr><tr><td align="center"><strong>Requirements</strong></td><td align="center">各种 HTTP 版本，JSON 解析</td><td align="center">HTTP&#x2F;2, 依赖语言实现</td></tr><tr><td align="center"><strong>API design</strong></td><td align="center">代码第一</td><td align="center">设计第一</td></tr><tr><td align="center"><strong>Default data format</strong></td><td align="center">JSON</td><td align="center">Protobuf</td></tr><tr><td align="center"><strong>Web browser support</strong></td><td align="center">原生</td><td align="center">gRPC web, via workarounds</td></tr><tr><td align="center"><strong>Tools</strong></td><td align="center">更成熟</td><td align="center">语言支持各不相同，有些具有出色的实现</td></tr></tbody></table><h1 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h1><p>REST 其中之一的缺点就是缺乏标准化，因为 REST 与其说是 API 标准（standard），不如说是一种范式（paradigm），许多人在谈论它时都有不同的含义</p><p>大多数情况下，所谓的 “REST API” 更倾向于基于 HTTP 协议和 JSON 格式的 API，但是使用 XML 代替 JSON 仍然会使 API 符合 RESTful 规范，尽管这种方式没有被广泛使用；REST 这个术语甚至与 HTTP 无关，在使用 REST API 时，这可能会导致很多混乱，例如使用者可能会自动期望某些 REST API 端点的幂等性或缓存性，即使没有明确定义</p><p>相比之下，gRPC 定义完善；例如， <a href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md">gRPC implementation over HTTP&#x2F;2</a>  非常详细</p><h1 id="基本区别"><a href="#基本区别" class="headerlink" title="基本区别"></a>基本区别</h1><p>REST 和 gRPC 的规范是不同的</p><p>REST 中一切都以资源为中心，这些资源可以被检索和操作；如果我们以一本书作为示例资源，REST API 通常会提供以下接口：</p><ul><li><code>GET /books</code> 获取所有书籍，可能带有用于筛选项和分页相关参数</li><li><code>GET /books/&#123;id&#125;</code> 获取特定的书</li><li><code>POST /books</code> 创建一本书</li><li><code>DELETE /books/&#123;id&#125;</code> 删除一本书</li></ul><p>大多数基于 HTTP 的 REST API 都遵循这种模式，虽然效果不错，但是依然存在难以用这样的规范表达的情况</p><p>举一个例子，如果我想创建多本书，而不想为每本书重复调用 <code>POST/books</code>（出于性能、幂等性或其他原因），该如何处理；我是否应该定义 <code>POST/books/batch</code> 接口，这仍然符合 RESTful 吗？虽然在技术上很容易解决，但开发人员之间经常会因为存在争议而进行讨论</p><p>而 gRPC 是一个RPC框架。它以服务方法为中心；如果我们以图书 API 为例，使用 gRPC，我们将使用以下方法创建 <code>BookService</code></p><ul><li><code>GetBooks()</code></li><li><code>GetBook()</code></li><li><code>CreateBook()</code></li><li><code>DeleteBook()</code></li></ul><p>可以随心所欲地命名这些方法，并需要我们需要的任何参数；如果我们现在想添加一个方法来创建多本书，没有什么能阻止我们添加 <code>CreateBooks()</code> 方法</p><p>gRPC 在设计 API 时提供了更多的 “自由”，因为有更少的（自我强加的）限制</p><h2 id="服务模式"><a href="#服务模式" class="headerlink" title="服务模式"></a>服务模式</h2><p>gRPC 支持四种服务方式：</p><ul><li><strong>Unary：</strong>发送一个请求，接受一个响应</li><li><strong>Server steaming：</strong>发送一个请求，接收多个响应</li><li><strong>Client streaming：</strong>发送多个请求，接收一个响应</li><li><strong>Bidirectional streaming：</strong>发送多个请求，接收多个响应</li></ul><p>这是 gRPC 相比只支持 Unary 方式的 REST 非常好的优势，在 REST API 中支持其他服务模式需要使用不同的协议，例如 server-sent events 或 websocket，这并不是非常 “RESTful”</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>REST API 经常只工作在各种 HTTP 版本之上，只要编程语言有 HTTP 客户端和 JSON 解析器，处理 REST 的 API 是轻而易举的</p><p>gRPC 明确需要 HTTP&#x2F;2 协议的支持；近些年这种问题越来越少，因为大多数代理和框架都增加了对 HTTP&#x2F;2 的支持；不过需要注意，由于 gRPC 需要生成代码（用于创建客户端或服务器存根），因此并不是所有编程语言都支持</p><h1 id="API-设计"><a href="#API-设计" class="headerlink" title="API 设计"></a>API 设计</h1><p>REST API 通常是其实现的结果，称为 “代码优先（code-first）”；虽然可以先用 OpenAPI 进行设计，然后生成服务器存根，但这并不是许多开发人员采用的方法；如果有一个 OpenAPI 定义，那么 OpenAPI 定义很可能是从 API 实现生成的；因此 API 定义与实现紧密耦合，错误地更改模型可能会导致无意中破坏 API</p><p>gRPC 使用不同的方法，在实现 API 之前必须定义 API，称为 “设计优先（design-first）”，然后根据这个 API 定义生成客户端和服务器存根，这需要提前进行，因为不能直接实现 API</p><p>这两种方法各有利弊。通常的 REST API 方法允许更快的迭代，因为服务器始终是真实接口的来源；而使用 gRPC，需要在调整实现之前首先更改 API 的定义可能会比较烦人，但是它通过显式定义 API 带来了一些安全优点</p><h1 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h1><p>REST 和 gRPC 都会使用不同的格式来进行数据传输；大部分 REST API 使用 JSON，gRPC 则会默认使用 <a href="https://protobuf.dev/">Protocol Buffers</a>（Protobuf），让我们来比较这两者</p><p>JSON 对数据类型的支持有限，也有一些怪癖（例如大数字需要表示为字符串）；它是一种文本格式，便于阅读；字段名是序列化的，这会占用一些空间，在一些编程语言中需要使用反射来反序列化 JSON 格式的数据，会比较慢</p><p>如上所述，gRPC API 的消息类型首先被定义为 Protocol Buffers；对于受支持的编程语言，可以自动生成（反）序列化消息的代码；并且由于它是一种二进制格式，不需要序列化字段名，因此它使用的空间比等效的  JSON 消息更少；当然缺点是不再具备人类可读性，需要 Protobuf 定义来反序列化消息，可能会对开发人员造成一些阻碍</p><p>下面的 JSON 示例将占用大约 66 个字节（去掉空格）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;persons&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Max&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">23</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Mike&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">52</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>等效的序列化 protobuf 信息仅使用 19 个字节</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>x0A070A034D617810170A080A04486<span class="number">16E731034</span></span><br></pre></td></tr></table></figure><h2 id="大型数据"><a href="#大型数据" class="headerlink" title="大型数据"></a>大型数据</h2><p>Protobuf 设计用于序列化和反序列化内存中的数据，因此不建议使用 Protobuf &#x2F; gRPC 传输大型数据；大多数 gRPC 实现对单个消息的默认限制为 4MB</p><p>使用 REST API 处理大数据量（例如文件上传）是相当直接的，接收到的文件可以被视为流，只需使用很少的内存</p><p>这在 gRPC 中并非不可能，但需要更多的手动操作：文件必须在发送方分为几个部分，然后每个块将作为单独的数据通过客户端流传输方法发送到服务器，服务器接收每个块，并可以从中构造数据流，从而产生与 REST API 类似的行为，尽管需要付出更多努力</p><h1 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h1><p>这就是 REST 真正的闪光点，它由 Web 浏览器天然支持，因此可以轻松地使用 Web 应用程序中的 REST API</p><p>gRPC 不直接由浏览器支持，因为它需要明确的 HTTP&#x2F;2 支持和访问某些 HTTP&#x2F;2 功能，而 web 浏览器不提供这些功能</p><p>gRPC Web 可以作为一种变通方式；这是 gRPC 协议的一个微小变化，使其可供 web 浏览器使用</p><p>对于某些编程语言，框架中已经包含了 gRPC Web 支持；而对于不支持的语言，需要一个代理来将 gRPC 请求转换为 gRPC Web 请求，反之亦然</p><p>与不需要特殊依赖的 REST API 相比，gRPC API 在从 Web 上使用时更麻烦</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>gRPC 和 REST 工具在编程语言和框架之间差异很大，在某些情况下，gRPC 感觉更 “原生（native）”，而在另一些情况下，REST 工具则更高级</p><p>对 gRPC 而言适当语言支持更为重要，因为它需要工具来生成客户端和服务器存根（stubs）；对于不受支持的编程语言则就不那么幸运了</p><p>REST API 的客户端总是可以手动创建的，虽然可能需要一些努力；存在从 Open API 定义创建 REST 客户端的工具，但与 gRPC 相比，对开发人员的经验要求更少</p><p>由于 REST API 存在的时间要长得多，因此存在更多有助于构建、测试和部署 REST API 的工具；它们的功能通常比 gRPC 工具更高级</p><p>这也是我们构建 Kreya 的主要原因之一，它试图成为最好的 gRPC GUI 客户端（同时也支持 REST）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>REST 和 gRPC 都有各自的优点和缺点</p><p>从 Web 应用中处理 REST API 通常来说更简单；此外 REST API 使用更广泛，这使得一些开发人员使用它更容易，因为他们可能不了解 gRPC</p><p>在我看来，gRPC 在服务器到服务器的通信（例如微服务之间）方面无疑具有优势，能够共享准确的 API 定义并用多种编程语言创建 API 客户端，这是一个巨大的胜利</p><p>对于 “我应该使用 REST 还是 gRPC” 的问题没有标准答案，有些 API 可能具有独特的情况，gRPC 或 REST 其中一个可能更适合，或者程序员对其中一者的使用更顺手、更熟练</p><p>所有这些都是理由，所以每个人都应该自己决定使用哪种技术</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://kreya.app/blog/rest-vs-grpc/">https://kreya.app/blog/rest-vs-grpc/</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal &amp; Memory Leak</title>
      <link href="/%E5%BC%80%E5%8F%91/Java/ThreadLocal%20&amp;%20Memory%20Leak.html"/>
      <url>/%E5%BC%80%E5%8F%91/Java/ThreadLocal%20&amp;%20Memory%20Leak.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>在项目中我们可以通过 <code>ThreadLocal</code> 来存储用户信息</p><p>其中一般会在过滤器&#x2F;拦截器的入口处初始化用户信息，并在执行结束后对其进行清理</p><p>这样从请求进来一直到返回，我们只需要通过线程变量 <code>ThreadLocal</code> 获取用户信息即可，而不用每次都从数据库查出来</p><p>因为 <code>ThreadLocal</code> 是线程安全的，<strong>所以通常声明为一个静态单例变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ThreadLocal&lt;UserInfo&gt; CURRENT_USER = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserInfo <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CURRENT_USER.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(UserInfo userInfo)</span> &#123;</span><br><span class="line">        CURRENT_USER.set(userInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        CURRENT_USER.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以在拦截器中通过 <code>set()</code> 方法存储鉴权成功的用户数据，在业务逻辑中通过 <code>get()</code> 获取用户数据了</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><blockquote><p>This class provides thread-local variables.  These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own,independently initialized copy of the variable</p></blockquote><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><strong>构造方法</strong></p><p><code>ThreadLocal</code> 仅存在一个无参构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadLocal</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h2><p><strong>set()</strong></p><p>使用 <code>set()</code> 方法向其赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用 <code>Thread.currentThread()</code> 获取当前线程；<code>Thread.currentThread()</code> 是一个 native 方法</p><p><strong>ThreadLocalMap</strong></p><p>接下来调用了 <code>getMap(Thread t)</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Get the map associated with a ThreadLocal. Overridden in InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  t the current thread</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the map</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的是线程对象的一个线程变量 <code>ThreadLocal.ThreadLocalMap threadLocals = null</code>，初始的默认值是 null，返回后回到 <code>set()</code> </p><p>当拿到的默认值是 null 时，则会创建一个 map 将值放入 map 中；不为 null 时将值直接放入 map</p><p><code>ThreadLocalMap</code> 是线程安全的，除此之外在这里可以先视作 <code>HashMap</code>，也是基于散列存储的 Map</p><p><strong>createMap()</strong></p><p>当第一次使用 <code>ThreadLocalMap</code> 时，需要调用 <code>createMap()</code> 进行创建</p><p><code>createMap()</code> 内调用了 <code>ThreadLocalMap</code> 的构造方法，把自己线程对象作为参数传了进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除去创建 <code>Entry</code> 数组对象和重置负载因子的操作，本质上将 KV 根据线程对象的 <code>threadLocalHashCode</code> 放到了相应的数组位置上，K 就是线程对象，V 是 <code>ThreadLocal</code> 要存储的值</p><p>所以需要注意：</p><ul><li><code>ThreadLocalMap</code> 中的 K 是线程对象，V 是要存储的值</li><li>所有的线程都在使用同一个 <code>ThreadLocalMap</code> 对象，K 是各自的线程对象</li></ul><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal.ThreadLocalMap</code> 内存储的是 <code>Entry[]</code></p><p><code>Entry</code> 的 key 是一个弱引用，而 value 为强引用</p><h2 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h2><p><strong>get()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取的方法，首先获取当前线程拥有的 <code>ThreadLocalMap</code>，然后将自己对象作为 K 进行取值</p><p>如果 <code>ThreadLocalMap</code> 不存在，则进行初始化 <code>setInitialValue()</code>，初始化结束后返回 null</p><p>所以也可以通过继承 <code>ThreadLocal</code> 后重写 <code>initialValue()</code> 来设置默认的返回值</p><h2 id="删除值"><a href="#删除值" class="headerlink" title="删除值"></a>删除值</h2><p><strong>remove()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先获取线程对象中保存的 <code>ThreadLocalMap</code>，如果不为 null 则调用 <code>remove()</code></p><p><strong>ThreadLocalMap 的 remove()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简而言之就是以线程对象作为 K 对 V 进行删除</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>比较反直觉的是，操作 <code>ThreadLocal</code> 对象，但数据并不存储在 <code>ThrealLocal</code>，而是存储在线程对象的 <code>ThreadLocal.ThreadLocalMap</code> 中</p><ul><li><code>ThreadLocal</code> 更像是一个工具类，用来操作 <code>ThreadLocal.ThreadLocalMap</code></li><li><code>ThreadLocal.ThreadLocalMap</code> 内存储 <code>Entry[]</code>，因为一个线程可能使用了多个 <code>ThreadLocal</code></li><li><code>ThreadLocal</code> 对象被作为 key 进行使用</li><li><code>ThreadLocal.ThreadLocalMap</code> 的 key 是弱引用，弱引用的目的是为了便于对 <code>ThreadLocal</code> 对象本身进行回收</li></ul><h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p><code>ThreadLocal</code> 整个使用过程中会创建出哪些对象：</p><ul><li><code>ThreadLocal</code> 对象</li><li><code>ThreadLocal.ThreadLocalMap</code> 对象，在 <code>Thread</code> 对象中被持有</li><li><code>ThreadLocal.ThreadLocalMap</code> 中的 <code>Entry</code> 对象</li><li><code>ThreadLocal.ThreadLocalMap</code> 中的 <code>Entry</code> 对象中的 K 和 V</li></ul><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><code>ThreadLocal</code> 对象一般不存在泄漏问题：</p><ul><li><code>ThreadLocal</code> 是操作 <code>ThreadLocal.ThreadLocalMap</code> 的 key，实例化数量不多</li><li><code>Entry</code> 弱引用的设计就是为了及时回收 <code>ThreadLocal</code> 对象</li></ul><h2 id="ThreadLocal-ThreadLocalMap"><a href="#ThreadLocal-ThreadLocalMap" class="headerlink" title="ThreadLocal.ThreadLocalMap"></a>ThreadLocal.ThreadLocalMap</h2><p>基本也不会存在泄漏问题，该对象被 <code>Thread</code> 对象持有，并且只是一个 Map 结构的引用</p><h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><p><code>Entry</code> 本身是一个引用对象，其通过 <code>ThreadLocal.ThreadLocalMap</code> 的操作方法进行释放，例如 <code>set</code>、<code>remove</code> 中的 <code>replaceStaleEntry</code>、<code>expungeStaleEntry</code> 方法</p><p><code>Entry</code> 对象的 key 即为 <code>ThreadLocal</code> 对象，上面已经提到了因为弱引用的设计一般会被及时回收</p><p><code>Entry</code> 对象的 value 为强引用，它只会因为 <code>Entry</code> 对象的回收而被回收，这是最有可能发生内存泄漏的地方，可能存在作为 key 的 <code>ThreadLocal</code> 对象已经被回收，但是 value 无法回收的情况</p><p>当然在设计中，<code>ThreadLocal.ThreadLocalMap</code> 的一些操作会检查整个 Map（<code>replaceStaleEntry</code>、<code>expungeStaleEntry</code>），从而对 key 已经回收的 <code>Entry</code> 进行释放，避免内存泄漏</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>上述可见，<code>Entry</code> 时最有可能会造成内存泄漏的地方</p><ul><li>没有手动调用 <code>remove</code> 方法，同时 <code>ThreadLocal</code> 无论是否回收，value 都可能在一定时间内、或者一直无法被回收</li><li>错误地创建 <code>Thread</code> 对象，而没有对旧的线程对象进行回收</li><li>这里有一个 Tomcat 机制相关的问题从而导致泄漏，我并没看懂…<br><a href="https://stackoverflow.com/questions/17968803/threadlocal-memory-leak">java - ThreadLocal &amp; Memory Leak - Stack Overflow</a></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.cn/post/7083332935096467463">为什么ThreadLocal是线程安全的？ - 掘金 (juejin.cn)</a></p><p><a href="https://blog.csdn.net/weixin_39970883/article/details/126010873">Tomcat线程复用与Threadlocal引发的惨案_线程复用 threadlocal_小沈同学呀的博客-CSDN博客</a></p><p><a href="https://stackoverflow.com/questions/17968803/threadlocal-memory-leak">java - ThreadLocal &amp; Memory Leak - Stack Overflow</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 泛型</title>
      <link href="/%E5%BC%80%E5%8F%91/Java/Java%20%E6%B3%9B%E5%9E%8B.html"/>
      <url>/%E5%BC%80%E5%8F%91/Java/Java%20%E6%B3%9B%E5%9E%8B.html</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p>泛型，即<strong>参数化类型</strong></p><p>一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在调用时传入具体的类型（类型实参）</p><h2 id="为什么要引入泛型"><a href="#为什么要引入泛型" class="headerlink" title="为什么要引入泛型"></a>为什么要引入泛型</h2><p>使用泛型进行声明可以让编译器会在编译阶段就能够帮我们发现错误类型对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="string">&quot;string&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型转换异常 ClassCastException</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student)list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p>泛型是一种语法糖，在编译阶段就会进行泛型擦除，泛型信息不会进入到运行时阶段（事实上有些泛型信息会被保留，见下文的 API 介绍）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">Class</span> <span class="variable">classStringArrayList</span> <span class="operator">=</span> stringArrayList.getClass();</span><br><span class="line"><span class="type">Class</span> <span class="variable">classIntegerArrayList</span> <span class="operator">=</span> integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// equals = true 说明最后的 Class 信息不包含泛型信息</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">equals</span> <span class="operator">=</span> Objects.equals(classStringArrayList, classIntegerArrayList);</span><br></pre></td></tr></table></figure><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>泛型的使用分为三种类型：泛型类、泛型接口、泛型方法</p><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口</p><p>最典型的就是各种集合类，如：List、Set、Map</p><p><strong>简单的泛型类</strong></p><p>泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsClass</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定</span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GenericsClass</span><span class="params">(T key)</span> &#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span> &#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明该类泛型为 String</span></span><br><span class="line"><span class="keyword">final</span> GenericsClass&lt;String&gt; genericsClass = <span class="keyword">new</span> <span class="title class_">GenericsClass</span>&lt;&gt;(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值返回的就是声明的类型</span></span><br><span class="line"><span class="comment">// key = ”张三“</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> genericsClass.getKey();</span><br></pre></td></tr></table></figure><p><strong>不指明泛型则没有限定</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">GenericsClass</span> <span class="variable">genericsClass1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericsClass</span>&lt;&gt;(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="type">GenericsClass</span> <span class="variable">genericsClass2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericsClass</span>&lt;&gt;(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// key1 是 String</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">key1</span> <span class="operator">=</span> genericsClass1.getKey();</span><br><span class="line"><span class="comment">// key2 是 Integer</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">key2</span> <span class="operator">=</span> genericsClass2.getKey();</span><br></pre></td></tr></table></figure><p><strong>泛型不能使用 instanceof 操作</strong></p><p>编译错误 Expression expected</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="comment">// 不能使用 instanceof 操作</span></span><br><span class="line">    <span class="keyword">if</span> (T <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中</p><p><strong>简单的泛型接口</strong></p><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericsIntf</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类，未声明泛型实参，依赖创建对象时声明的泛型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class GenericsIntfImpl&lt;T&gt; implements GenericsIntf&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class GenericsIntfImpl implements GenericsIntf&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsIntfImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">GenericsIntf</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GenericsIntfImpl</span><span class="params">(<span class="keyword">final</span> T t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> GenericsIntfImpl&lt;String&gt; impl = <span class="keyword">new</span> <span class="title class_">GenericsIntfImpl</span>&lt;String&gt;(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> impl.get();</span><br></pre></td></tr></table></figure><p>也可以在实现类中向泛型接口声明固定的泛型实参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入泛型实参时：</span></span><br><span class="line"><span class="comment"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口 GenericsIntf&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 但是我们可以为T传入无数个实参，形成无数种类型的 GenericsIntf 接口。</span></span><br><span class="line"><span class="comment"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span><br><span class="line"><span class="comment"> * 即：GenericsIntf&lt;T&gt;，public T get();中的的T都要替换成传入的 String 类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsIntfImpl2</span> <span class="keyword">implements</span> <span class="title class_">GenericsIntf</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">GenericsIntfImpl2</span> <span class="variable">impl2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericsIntfImpl2</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> impl2.get();</span><br><span class="line">Assert.assertEquals(s, <span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>泛型类，是在实例化类的时候指明泛型的具体类型</p><p><strong>而泛型方法，是在调用方法的时候指明泛型的具体类型</strong> </p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>泛型方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsMethod</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tClass 传入的泛型实参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment">     * 2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment">     * 3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment">     * 4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">genericsMethod</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; tClass)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="keyword">return</span> tClass.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">GenericsMethod</span> <span class="variable">genericsMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericsMethod</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同的入参有不同的返回值</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> genericsMethod.genericsMethod(Student.class);</span><br><span class="line"><span class="keyword">final</span> <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> genericsMethod.genericsMethod(Dog.class);</span><br></pre></td></tr></table></figure><p>泛型方法的特征很容易混淆，定义一个复杂些的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsComplex</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GenericsComplex</span><span class="params">(<span class="keyword">final</span> T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 此处并不是泛型方法</span></span><br><span class="line"><span class="comment">     * 只是因为返回值的泛型是类中已经声明过的泛型，所以可以直接使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 首先在 public 与返回值之间的 &lt;T&gt; 必不可少，这表明这是一个泛型方法，并且声明了一个泛型 T</span></span><br><span class="line"><span class="comment">     * 这个 T 可以出现在这个泛型方法的任意位置.</span></span><br><span class="line"><span class="comment">     * 泛型的数量也可以为任意多个 </span></span><br><span class="line"><span class="comment">     * 如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;...&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getKeyName</span><span class="params">(<span class="keyword">final</span> GenericsClass&lt;T&gt; generics)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;container key :&quot;</span> + generics.getKey());</span><br><span class="line">        <span class="comment">//当然这个例子举的不太合适，只是为了说明泛型方法的特性</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">T</span> <span class="variable">test</span> <span class="operator">=</span> generics.getKey();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这不是一个泛型方法，是一个普通的方法</span></span><br><span class="line"><span class="comment">     * 只是使用了 Generic&lt;Number&gt; 这个泛型类做形参而已</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(<span class="keyword">final</span> GenericsClass&lt;Number&gt; obj)</span> &#123;</span><br><span class="line">        System.out.println(obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类中泛型方法"><a href="#类中泛型方法" class="headerlink" title="类中泛型方法"></a>类中泛型方法</h3><p>定义一个泛型类，其中包含<strong>普通方法使用泛型类声明的泛型</strong>和<strong>泛型方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsMethod2</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">(<span class="keyword">final</span> T t)</span> &#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line">    <span class="comment">// 由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">(<span class="keyword">final</span> E t)</span> &#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在泛型类中声明了一个泛型方法，使用泛型T</span></span><br><span class="line">    <span class="comment">// 注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">show3</span><span class="params">(<span class="keyword">final</span> T t)</span> &#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个对象，声明泛型为 String</span></span><br><span class="line"><span class="keyword">final</span> GenericsMethod2&lt;String&gt; method2 = <span class="keyword">new</span> <span class="title class_">GenericsMethod2</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// show1() 不是泛型方法，使用的是泛型类的泛型声明，所以只能传 String 类型的参数</span></span><br><span class="line">method2.show1(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// show2() 是泛型方法，泛型和类中声明的泛型无关</span></span><br><span class="line">method2.show2(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺财&quot;</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// show3() 也是泛型方法，虽然也使用 &lt;T&gt; 作为泛型参数，但和类中的 T 没有关系，只和参数的类型you</span></span><br><span class="line">method2.show3(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>));</span><br></pre></td></tr></table></figure><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>泛型方法可以使用在可变参数上</p><p>定义方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">printMsg</span><span class="params">(<span class="keyword">final</span> T... args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> T t : args) &#123;</span><br><span class="line">        System.out.print(t + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 张三 200 4 李四 </span></span><br><span class="line"><span class="built_in">this</span>.printMsg(<span class="string">&quot;张三&quot;</span>, <span class="number">200</span>, <span class="number">4L</span>, <span class="string">&quot;李四&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>静态方法无法直接使用定义在类上的泛型，因为泛型在对象实例化时传入，静态方法无法获取类上的泛型信息</p><p>所以<strong>如果静态方法想使用泛型，就必须定义成泛型方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticGenericsMethod</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Animal</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同理，这里的 T 只针对该方法，和类上的 T 不是一个东西</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Animal</span>&gt; <span class="keyword">void</span> <span class="title function_">staticShow</span><span class="params">(<span class="keyword">final</span> T obj)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static&quot;</span>);</span><br><span class="line">        System.out.println(obj.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="keyword">final</span> T obj)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;param&quot;</span>);</span><br><span class="line">        System.out.println(obj.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺财&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法，方法参数要求传入 Animal 的子类</span></span><br><span class="line">StaticGenericsMethod.staticShow(dog);</span><br><span class="line"><span class="comment">// 成员方法，实例对象泛型要求传入 Animal 的子类</span></span><br><span class="line"><span class="keyword">final</span> StaticGenericsMethod&lt;Dog&gt; method = <span class="keyword">new</span> <span class="title class_">StaticGenericsMethod</span>&lt;&gt;();</span><br><span class="line">method.show(dog);</span><br></pre></td></tr></table></figure><p><strong>需要注意，静态泛型方法会导致类型转换异常</strong></p><p>正常的类型转换，都会在编译阶段提示错误</p><p><code>Inconvertible types; cannot cast &#39;java.lang.Integer&#39; to &#39;java.lang.String&#39;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 Integer 类型转换为 String 类型，明显是错误的</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String)integer;</span><br></pre></td></tr></table></figure><p>构造一个静态泛型方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">convert</span><span class="params">(<span class="keyword">final</span> Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (T)obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法后再进行转换，则只会在运行时抛出 <code>java.lang.ClassCastException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">convert</span> <span class="operator">=</span> convert(integer);</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String)convert;</span><br></pre></td></tr></table></figure><p>原因是因为 Java 的泛型方法属于伪泛型，<strong>在编译的时候将进行类型擦除</strong></p><p>普通的泛型方法在类构建时已经明确制定了对应的类型，而在静态泛型方法中，类型是无法直接推测的，缺少了明确的类型，最终造成类型转化异常</p><p>编译后的 convert 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">String</span>&gt; T <span class="title function_">convert</span><span class="params">(<span class="keyword">final</span> Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (T)obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>子类和父类的泛型不能被认为是父类的同一种泛型</p><p>定义一个方法，参数要求 GenericsClass 对象且泛型为 Number</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(<span class="keyword">final</span> GenericsClass&lt;Number&gt; num)</span> &#123;</span><br><span class="line">    System.out.println(num.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个泛型为 Integer 类型的对象，则无法调用该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> GenericsClass&lt;Integer&gt; genericsClass = <span class="keyword">new</span> <span class="title class_">GenericsClass</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// Required type: GenericsClass &lt;Number&gt;</span></span><br><span class="line"><span class="comment">// Provided: GenericsClass &lt;Integer&gt;</span></span><br><span class="line"><span class="built_in">this</span>.get(genericsClass);</span><br></pre></td></tr></table></figure><p>虽然 <code>Integer</code> 是 <code>Number</code> 的子类，但明显 <code>GenericsClass &lt;Integer&gt; </code> 不能被看作 <code>GenericsClass&lt;Number&gt;</code></p><p><strong>同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的</strong></p><p>可以使用泛型通配符 <code>?</code> 及 <code>extends</code> 和 <code>super</code> 解决此类问题</p><p><strong>注意：<code>?</code> 是实参，并不是形参，它代表所有 Object 类</strong></p><p>修改上面的代码，<code>GenericsClass&lt;? extends Number&gt;</code> 表示对象的泛型可以是继承 <code>Number</code> 的任何类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(<span class="keyword">final</span> GenericsClass&lt;? extends Number&gt; num)</span> &#123;</span><br><span class="line">    System.out.println(num.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>extends</code> 和 <code>super</code> 区别：</p><ul><li>extends 规定了上界，即规定了泛型实参的<strong>最底层父类</strong></li><li>super 规定了下界，即规定了泛型实参<strong>最上层的子类（实现类）</strong></li></ul><h1 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h1><h2 id="ParameterizedType"><a href="#ParameterizedType" class="headerlink" title="ParameterizedType"></a>ParameterizedType</h2><p>当泛型为类上泛型时，通过 Class 对象的 <code>getGenericSuperclass</code> 方法将会获取到 <code>ParameterizedType</code> 的 <code>Type</code> 接口对象，即为类上定义的泛型信息</p><p>可以使用 <code>getActualTypeArguments</code> 获取真实的泛型类型参数</p><p><strong>定义泛型类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericClass</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGenericInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getGenericSuperclass();</span><br><span class="line">        System.out.println(genericSuperclass.getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// real type</span></span><br><span class="line">        <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> ((ParameterizedType)genericSuperclass).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">        System.out.println(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> <span class="keyword">extends</span> <span class="title class_">GenericClass</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Run</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Run</span>();</span><br><span class="line">        run.showGenericInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sun</span>.reflect.generics.reflectiveObjects.ParameterizedTypeImpl</span><br><span class="line">java.util.List&lt;generic.Student&gt;</span><br></pre></td></tr></table></figure><p>从 <code>getGenericSuperclass</code> 获取到的对象是 <code>ParameterizedTypeImpl</code>，即 <code>ParameterizedType</code> 的实现类</p><p>从中还可以获取到真实的泛型信息 <code>Student</code></p><p>如果是一个嵌套的泛型结构呢</p><p>修改下 <code>showGenericInfo</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGenericInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getGenericSuperclass();</span><br><span class="line">    System.out.println(genericSuperclass.getClass());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">// real type</span></span><br><span class="line">    <span class="keyword">while</span> (genericSuperclass <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">        <span class="type">Type</span> <span class="variable">actualTypeArgument</span> <span class="operator">=</span> ((ParameterizedType)genericSuperclass).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">        System.out.println(actualTypeArgument);</span><br><span class="line">        genericSuperclass = actualTypeArgument;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> <span class="keyword">extends</span> <span class="title class_">GenericClass</span>&lt;List&lt;Student&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Run</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Run</span>();</span><br><span class="line">        run.showGenericInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sun</span>.reflect.generics.reflectiveObjects.ParameterizedTypeImpl</span><br><span class="line">--------------------------</span><br><span class="line">java.util.List&lt;generic.Student&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">generic</span>.Student</span><br></pre></td></tr></table></figure><p>可以看出泛型 <code>List&lt;Student&gt;</code>，第一次获取到的 <code>ParameterizedType</code> 是 <code>List</code> 信息，它依然是一个 <code>ParameterizedType</code> 对象，而后还可以获取到下面定义的 <code>Student</code></p><h2 id="getGenericInterfaces"><a href="#getGenericInterfaces" class="headerlink" title="getGenericInterfaces"></a>getGenericInterfaces</h2><p>泛型接口同理，不过需要通过 <code>getGenericInterfaces</code> 方法进行获取</p><p><code>public Type[] getGenericInterfaces()</code> 因为接口是一对多，所以这里获取到的是一个数组，也是 <code>ParameterizedType</code></p><p><strong>定义泛型接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericInterface</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">showGenericInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getGenericInterfaces()[<span class="number">0</span>];</span><br><span class="line">        System.out.println(genericSuperclass.getClass());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// real type</span></span><br><span class="line">        <span class="keyword">while</span> (genericSuperclass <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            <span class="type">Type</span> <span class="variable">actualTypeArgument</span> <span class="operator">=</span> ((ParameterizedType)genericSuperclass).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">            System.out.println(actualTypeArgument);</span><br><span class="line">            genericSuperclass = actualTypeArgument;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> <span class="keyword">implements</span> <span class="title class_">GenericInterface</span>&lt;List&lt;Student&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Run</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Run</span>();</span><br><span class="line">        run.showGenericInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sun</span>.reflect.generics.reflectiveObjects.ParameterizedTypeImpl</span><br><span class="line">--------------------------</span><br><span class="line">java.util.List&lt;generic.Student&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">generic</span>.Student</span><br></pre></td></tr></table></figure><h2 id="TypeVariable"><a href="#TypeVariable" class="headerlink" title="TypeVariable"></a>TypeVariable</h2><p>当使用泛型方法时，其参数或者返回值拿到的泛型信息为 <code>TypeVariable</code></p><p>这时只能拿到泛型定义时的边界信息，如果没有边界信息则会擦除为 <code>Object</code></p><p><strong>定义泛型方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericMethod</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getMethods()[<span class="number">0</span>];</span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericParameterType</span> <span class="operator">=</span> method.getGenericParameterTypes()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">TypeVariable</span> <span class="variable">typeVariable</span> <span class="operator">=</span> (TypeVariable)genericParameterType;</span><br><span class="line">        System.out.println(typeVariable.getName());</span><br><span class="line">        System.out.println(Arrays.toString(typeVariable.getBounds()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericMethod</span> <span class="variable">genericMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericMethod</span>();</span><br><span class="line">        genericMethod.method(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T</span><br><span class="line">[<span class="keyword">class</span> <span class="title class_">java</span>.lang.Object]</span><br></pre></td></tr></table></figure><p>如果规定了边界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">String</span>&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(T obj)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T</span><br><span class="line">[<span class="keyword">class</span> <span class="title class_">java</span>.lang.String]</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>很多 JSON 工具都定义了类似名为 <code>TypeReference</code> 的类，其作用就是通过泛型类来传递需要反序列化的泛型信息，避免泛型擦除</p><p>如 fastjson 中的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeReference</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> ConcurrentMap&lt;Type, Type&gt; classTypeCache</span><br><span class="line">            = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Type, Type&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Type type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new type literal. Derives represented class from type</span></span><br><span class="line"><span class="comment">     * parameter.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Clients create an empty anonymous subclass. Doing so embeds the type</span></span><br><span class="line"><span class="comment">     * parameter in the anonymous class&#x27;s type hierarchy so we can reconstitute it</span></span><br><span class="line"><span class="comment">     * at runtime despite erasure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">TypeReference</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Type</span> <span class="variable">superClass</span> <span class="operator">=</span> getClass().getGenericSuperclass();</span><br><span class="line"></span><br><span class="line">        <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> ((ParameterizedType) superClass).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">Type</span> <span class="variable">cachedType</span> <span class="operator">=</span> classTypeCache.get(type);</span><br><span class="line">        <span class="keyword">if</span> (cachedType == <span class="literal">null</span>) &#123;</span><br><span class="line">            classTypeCache.putIfAbsent(type, type);</span><br><span class="line">            cachedType = classTypeCache.get(type);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.type = cachedType;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以通过 <code>TypeReference</code> 对象保存需要反序列化的泛型信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSON.toJSONString(Arrays.asList(student1, student2));</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; list = JSON.parseObject(jsonStr, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;Student&gt;&gt;() &#123;&#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Student(name=张三, age=<span class="number">20</span>), Student(name=李四, age=<span class="number">21</span>)]</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/s10461/article/details/53941091">java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一_VieLei的博客-CSDN博客_java泛型</a></p><p><a href="https://zhuanlan.zhihu.com/p/262271430">Java泛型 | Jackson TypeReference获取泛型类型信息 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态模式 - State</title>
      <link href="/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%20-%20State.html"/>
      <url>/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%20-%20State.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>状态模式基于<strong>有限状态机</strong>（FSM finite state machine）的概念，主要思想是程序在任意时刻一定处于 N 种有限数量的状态中，并且在特定状态中执行特定状态的操作并可以流转至下一状态（也可不变）</p><p>这些数量有限且预先定义的状态切换规则被称为 <em>状态流转</em></p><p><strong>目的</strong><br>将状态以及状态行为等属性和业务对象解耦，是一种基于组合模式进行逻辑委托的行为模式</p><p><strong>现实世界类比</strong><br>地铁电动闸门会根据当前状态和用户行为进行不同的操作并且流转为下一状态：</p><ul><li>关闭状态<ul><li>用户刷卡成功 -&gt; 开门 &amp; 流转至开启状态</li><li>用户刷卡失败 -&gt; 提示刷卡失败</li></ul></li><li>开启状态<ul><li>用户刷卡 -&gt; 提示刷卡无效</li><li>等待 -&gt; 流转至开启关闭状态</li></ul></li></ul><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>模拟一个场景，需要对审批工单进行相应操作</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一开始对于工单审批的状态定义比较简单</p><ol><li>用户填写工单，状态初始为 [草稿]</li><li>用户提交工单，工单状态进入 [待审核]，向管理员发送邮件通知</li><li>管理员审核工单，工单状态进入 [通过]，向用户发送邮件通知</li><li>管理员驳回工单，工单状态进入 [驳回]，向用户发送邮件通知</li><li>[驳回] 的工单用户可以再次提交，进入 [待审核]，向管理员发送邮件通知</li><li>用户执行工单，工单状态进入 [已执行]</li></ol><p>后续随着对于工单审核流程的迭代，需要定义更多的状态以及行为</p><p>例如需要将工单状态的 [已执行] 拆分为 [执行成功] 和 [执行失败]，执行失败会向用户和管理员发送执行失败的结果邮件通知，并且失败的工单可以进行再次执行</p><p>整个状态的流转规则在核心业务代码中往往使用 <code>if...else</code> 语句实现，再加上迭代越来越多的状态以及行为，会导致判断语句愈发臃肿</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先可以定义出一个行为目录：</p><ul><li>提交</li><li>通过</li><li>驳回</li><li>执行</li></ul><p>接下来结合行为和状态就可以定义出如下的状态表</p><table><thead><tr><th align="center">当前状态 | 流转状态</th><th align="center">草稿</th><th align="center">待审核</th><th align="center">驳回</th><th align="center">通过</th><th align="center">已执行</th></tr></thead><tbody><tr><td align="center"><strong>草稿</strong></td><td align="center">&#x2F;</td><td align="center">提交</td><td align="center">&#x2F;</td><td align="center">&#x2F;</td><td align="center">&#x2F;</td></tr><tr><td align="center"><strong>待审核</strong></td><td align="center">&#x2F;</td><td align="center">&#x2F;</td><td align="center">驳回</td><td align="center">审核</td><td align="center">&#x2F;</td></tr><tr><td align="center"><strong>驳回</strong></td><td align="center">&#x2F;</td><td align="center">提交</td><td align="center">&#x2F;</td><td align="center">&#x2F;</td><td align="center">&#x2F;</td></tr><tr><td align="center"><strong>通过</strong></td><td align="center">&#x2F;</td><td align="center">&#x2F;</td><td align="center">&#x2F;</td><td align="center">&#x2F;</td><td align="center">执行</td></tr><tr><td align="center"><strong>已执行</strong></td><td align="center">&#x2F;</td><td align="center">&#x2F;</td><td align="center">&#x2F;</td><td align="center">&#x2F;</td><td align="center">&#x2F;</td></tr></tbody></table><h3 id="状态枚举"><a href="#状态枚举" class="headerlink" title="状态枚举"></a>状态枚举</h3><p>定义出工单的各种状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">WorkOrderState</span> &#123;</span><br><span class="line"></span><br><span class="line">    DRAFT(<span class="number">0</span>, <span class="string">&quot;草稿&quot;</span>),</span><br><span class="line">    WAIT_REVIEW(<span class="number">0</span>, <span class="string">&quot;待审核&quot;</span>),</span><br><span class="line">    REVIEWED(<span class="number">0</span>, <span class="string">&quot;通过&quot;</span>),</span><br><span class="line">    REJECTED(<span class="number">0</span>, <span class="string">&quot;驳回&quot;</span>),</span><br><span class="line">    DONE(<span class="number">0</span>, <span class="string">&quot;已执行&quot;</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    WorkOrderState(<span class="keyword">final</span> <span class="type">int</span> code, <span class="keyword">final</span> String desc) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工单业务实体"><a href="#工单业务实体" class="headerlink" title="工单业务实体"></a>工单业务实体</h3><p>工单信息的业务实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkOrder</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String optionContent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WorkOrderState state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象状态处理器"><a href="#抽象状态处理器" class="headerlink" title="抽象状态处理器"></a>抽象状态处理器</h3><p>抽象的状态处理器，默认实现为不支持相应操作，抛出 <code>IllegalStateException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstreactStateHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(WorkOrder workOrder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.IllegalState(workOrder, <span class="string">&quot;submit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">pass</span><span class="params">(WorkOrder workOrder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.IllegalState(workOrder, <span class="string">&quot;pass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(WorkOrder workOrder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.IllegalState(workOrder, <span class="string">&quot;reject&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(WorkOrder workOrder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.IllegalState(workOrder, <span class="string">&quot;run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">IllegalState</span><span class="params">(WorkOrder workOrder, String option)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(String</span><br><span class="line">            .format(<span class="string">&quot;不支持的操作 ID:[%s] 当前状态:[%s] 操作:[%s]&quot;</span>, workOrder.getId(), workOrder.getState().getDesc(), option));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态处理器实现"><a href="#状态处理器实现" class="headerlink" title="状态处理器实现"></a>状态处理器实现</h3><p>对抽象处理器相应的方法进行实现</p><p><strong>草稿状态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DraftStateHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstreactStateHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(WorkOrder workOrder)</span> &#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">            String.format(<span class="string">&quot;工单状态 [%s] -&gt; [%s]&quot;</span>, workOrder.getState().getDesc(), WorkOrderState.WAIT_REVIEW.getDesc()));</span><br><span class="line">        System.out.println(<span class="string">&quot;向管理员发送需要审核邮件通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>待审核状态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WaitReviewStateHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstreactStateHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">pass</span><span class="params">(WorkOrder workOrder)</span> &#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">            String.format(<span class="string">&quot;工单状态 [%s] -&gt; [%s]&quot;</span>, workOrder.getState().getDesc(), WorkOrderState.REVIEWED.getDesc()));</span><br><span class="line">        System.out.println(<span class="string">&quot;向用户发送审核通过邮件通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(WorkOrder workOrder)</span> &#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">            String.format(<span class="string">&quot;工单状态 [%s] -&gt; [%s]&quot;</span>, workOrder.getState().getDesc(), WorkOrderState.REJECTED.getDesc()));</span><br><span class="line">        System.out.println(<span class="string">&quot;向用户发送审核驳回邮件通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过状态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReviewedStateHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstreactStateHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(WorkOrder workOrder)</span> &#123;</span><br><span class="line">        System.out</span><br><span class="line">            .println(String.format(<span class="string">&quot;工单状态 [%s] -&gt; [%s]&quot;</span>, workOrder.getState().getDesc(), WorkOrderState.DONE.getDesc()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的实现类比即可</p><h3 id="状态处理器管理员"><a href="#状态处理器管理员" class="headerlink" title="状态处理器管理员"></a>状态处理器管理员</h3><p>为什么会有 “状态处理器管理员” 的角色</p><p>事实上如果是面向对象的思想，会有所区别：</p><ul><li>状态和状态的行为应该是一体的，在本例中拆分成了枚举类和状态处理器</li><li>状态流转在某些程序中应该是连续的，但是在 Web 开发中每次请求都是无状态的，所以需要管理员的角色根据当前业务状态选择合适的处理器进行处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StateHandlerHolder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;WorkOrderState, AbstreactStateHandler&gt; HANDLERS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        HANDLERS = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        HANDLERS.put(WorkOrderState.DRAFT, <span class="keyword">new</span> <span class="title class_">DraftStateHandler</span>());</span><br><span class="line">        HANDLERS.put(WorkOrderState.WAIT_REVIEW, <span class="keyword">new</span> <span class="title class_">WaitReviewStateHandler</span>());</span><br><span class="line">        HANDLERS.put(WorkOrderState.REVIEWED, <span class="keyword">new</span> <span class="title class_">ReviewedStateHandler</span>());</span><br><span class="line">        HANDLERS.put(WorkOrderState.REJECTED, <span class="keyword">new</span> <span class="title class_">RejectedStateHandler</span>());</span><br><span class="line">        HANDLERS.put(WorkOrderState.DONE, <span class="keyword">new</span> <span class="title class_">DoneStateHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(WorkOrder workOrder)</span> &#123;</span><br><span class="line">        HANDLERS.get(workOrder.getState()).submit(workOrder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pass</span><span class="params">(WorkOrder workOrder)</span> &#123;</span><br><span class="line">        HANDLERS.get(workOrder.getState()).pass(workOrder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(WorkOrder workOrder)</span> &#123;</span><br><span class="line">        HANDLERS.get(workOrder.getState()).reject(workOrder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(WorkOrder workOrder)</span> &#123;</span><br><span class="line">        HANDLERS.get(workOrder.getState()).run(workOrder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WorkOrder</span> <span class="variable">workOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkOrder</span>();</span><br><span class="line">        workOrder.setId(<span class="number">1</span>);</span><br><span class="line">        workOrder.setState(WorkOrderState.DRAFT);</span><br><span class="line"></span><br><span class="line">        <span class="type">StateHandlerHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StateHandlerHolder</span>();</span><br><span class="line">        holder.submit(workOrder);</span><br><span class="line"></span><br><span class="line">        workOrder.setState(WorkOrderState.WAIT_REVIEW);</span><br><span class="line">        holder.pass(workOrder);</span><br><span class="line"></span><br><span class="line">        holder.submit(workOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">工单状态 [草稿] -&gt; [待审核]</span><br><span class="line">向管理员发送需要审核邮件通知</span><br><span class="line">    </span><br><span class="line">工单状态 [待审核] -&gt; [通过]</span><br><span class="line">向用户发送审核通过邮件通知</span><br><span class="line">    </span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalStateException: 不支持的操作 ID:[<span class="number">1</span>] 当前状态:[待审核] 操作:[submit]</span><br></pre></td></tr></table></figure><h3 id="扩展新状态"><a href="#扩展新状态" class="headerlink" title="扩展新状态"></a>扩展新状态</h3><p>将工单状态的 [已执行] 拆分为 [执行成功] 和 [执行失败]，执行失败会向用户和管理员发送执行失败的结果邮件通知，并且失败的工单可以进行再次执行</p><p>可以看出扩展了状态，并且没有扩展行为，那么可以按照以下步骤进行实现：</p><ol><li>增加新的状态枚举对象</li><li>修改已审核状态下执行操作的实现</li><li>进行新状态处理器实现</li><li>注册至状态处理器管理员中</li></ol><p><strong>已审核状态处理器实现修改</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReviewedStateHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstreactStateHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(WorkOrder workOrder)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> RandomUtil.randomInt(<span class="number">0</span>, <span class="number">100</span>) &gt; <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                String.format(<span class="string">&quot;工单状态 [%s] -&gt; [%s]&quot;</span>, workOrder.getState().getDesc(), WorkOrderState.SUCCESS.getDesc()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                String.format(<span class="string">&quot;工单状态 [%s] -&gt; [%s]&quot;</span>, workOrder.getState().getDesc(), WorkOrderState.FAILED.getDesc()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>新的状态处理器实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuccessStateHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstreactStateHandler</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FailedStateHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstreactStateHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(<span class="keyword">final</span> WorkOrder workOrder)</span> &#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">            String.format(<span class="string">&quot;工单状态 [%s] -&gt; [%s]&quot;</span>, workOrder.getState().getDesc(), WorkOrderState.WAIT_REVIEW.getDesc()));</span><br><span class="line">        System.out.println(<span class="string">&quot;向管理员发送需要审核邮件通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WorkOrder</span> <span class="variable">workOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkOrder</span>();</span><br><span class="line">        workOrder.setId(<span class="number">1</span>);</span><br><span class="line">        workOrder.setState(WorkOrderState.FAILED);</span><br><span class="line"></span><br><span class="line">        <span class="type">StateHandlerHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StateHandlerHolder</span>();</span><br><span class="line">        holder.submit(workOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">工单状态 [执行失败] -&gt; [待审核]</span><br><span class="line">向管理员发送需要审核邮件通知</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>状态模式是行为模式的一种</p><ul><li><p>优点</p><ul><li>可以在独立于其他状态的情况下添加新状态或修改已有状态， 减少维护成本</li><li>清理掉核心代码中大量的分支判断</li><li>状态处理的实现可以结构化，可以实现模板方法、复用公共代码</li></ul></li><li><p>缺点</p><ul><li>状态不复杂的业务没必要过度设计</li><li>需要在策略中定义所有行为（虽然可以使用基类进行默认实现），即定义出一个规则表</li></ul></li></ul><p><strong>状态模式和策略模式</strong></p><p>状态模式和策略模式都基于组合来进行实现，都是委派业务逻辑给其他实现类来达到解耦的目的</p><p>策略模式使得这些实现类对象相互之间完全独立， 它们不知道其他对象的存在</p><p>但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://refactoringguru.cn/design-patterns/state">状态设计模式 (refactoringguru.cn)</a><a href="https://www.kancloud.cn/digest/xing-designpattern/143730">https://www.kancloud.cn/digest/xing-designpattern/143730</a>)</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 部署 Github Pages 404 问题</title>
      <link href="/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/Hexo%20%E9%83%A8%E7%BD%B2%20Github%20Pages%20404%20%E9%97%AE%E9%A2%98.html"/>
      <url>/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/Hexo%20%E9%83%A8%E7%BD%B2%20Github%20Pages%20404%20%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>突然发现 Hexo 中的有些文章突然打不开了</p><p>表现是点击无反应，无论是点击 “阅读原文” 还是在归档等页面中点击文章标题都无法正常打开</p><p>查看控制台发现对页面的请求 404 了</p><h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><p><strong>Github 的 Actions 正常</strong></p><p>也没出现部署失败的情况</p><img src="/%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/Hexo%20%E9%83%A8%E7%BD%B2%20Github%20Pages%20404%20%E9%97%AE%E9%A2%98/image-20230427231601450.png" class="" title="image-20230427231601450"><p>查看 push 上来的源文件，发现可能是因为大小写问题</p><p>文件路径为 <code>...bridge</code> ，而请求的路径为 <code>...Bridge</code>，尝试将路径手动修改为小写，发现正常跳转</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>查询了一下，基本上可以确定原因为 git 默认忽略大小写</p><ol><li>首先 push 了小写标题的文章</li><li>修改了文章标题为大写，此时 Hexo 解析其他页面也更换了大写</li><li>但是因为 git 忽略大小写，所以更名为大写的内容并没有 push 到仓库，导致解析 pages 时没有更新相应的资源路径；此时点击 Hexo 生成的其他页面则资源名称已经更新为大写，导致 404</li></ol><h2 id="修改-git-config-文件"><a href="#修改-git-config-文件" class="headerlink" title="修改 git config 文件"></a>修改 git config 文件</h2><p>在博客根目录下编辑 <code>./.git/config</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line">filemode = <span class="literal">false</span></span><br><span class="line">bare = <span class="literal">false</span></span><br><span class="line">logallrefupdates = <span class="literal">true</span></span><br><span class="line">symlinks = <span class="literal">false</span></span><br><span class="line">ignorecase = <span class="literal">true</span></span><br><span class="line"><span class="comment"># ignorecase = false</span></span><br></pre></td></tr></table></figure><p>修改 <code>ignorecase</code> 为 false</p><p>进行推送即可，也可以直接重新 push 整个项目</p><h2 id="全部重新-push"><a href="#全部重新-push" class="headerlink" title="全部重新 push"></a>全部重新 push</h2><p>在博客根目录 <code>./.deploy_git</code> 目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -rf *</span><br><span class="line">git commit -m <span class="string">&#x27;clean all file&#x27;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>使用 Hexo 插件进行 deploy</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">hexo clean</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://1mhz.me/2015/hexo-deploy-case-sensitive/">Hexo 部署到 Github Pages 文件夹大小写问题 &#x2F;&#x2F; Yizhao He’s Notes (1mhz.me)</a></p><p><a href="https://blog.csdn.net/weixin_43219615/article/details/102536642">利用hexo在GitHub搭建博客改变tag因为大小写问题而404的解决方法_hexo的next用tag就404_轨迹 ‎‎ ‎‎的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> 疑难杂症 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LiteFlow - 执行器初始化</title>
      <link href="/%E5%BC%80%E5%8F%91/LiteFlow/LiteFlow%20-%20%E6%89%A7%E8%A1%8C%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96.html"/>
      <url>/%E5%BC%80%E5%8F%91/LiteFlow/LiteFlow%20-%20%E6%89%A7%E8%A1%8C%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h1 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h1><p>基于 SpringBoot 的实现方式自然使用到了 starter 机制，核心代码在 <code>liteflow-spring-boot-starter</code> 包下</p><p>首先来看 <code>spring.factories</code> 文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">  com.yomahub.liteflow.springboot.config.LiteflowPropertyAutoConfiguration,\</span></span><br><span class="line"><span class="string">  com.yomahub.liteflow.springboot.config.LiteflowMainAutoConfiguration</span></span><br></pre></td></tr></table></figure><p>可以看到一共有两个重要的自动装配的配置类：</p><ul><li><strong>LiteflowPropertyAutoConfiguration</strong>：配置属性的解析，封装为 <code>LiteflowConfig</code> 实例</li><li><strong>LiteflowMainAutoConfiguration</strong>：LiteFlow 的核心功能对象在该配置类下实例化<ul><li><strong>SpringAware</strong>：Spring ApplicationContext 的获取与封装，便于后续业务中获取 bean 的操作</li><li><strong>ComponentScanner</strong>：组件扫描器，用于扫描与封装 <code>NodeComponent</code> 节点的实现类</li><li><strong>FlowExecutor</strong>：规则执行器</li><li><strong>LiteflowExecutorInit</strong>：设置服务启动时初始化配置生效，用于启动时主动进行初始化操作</li><li><strong>MonitorBus</strong>：监控类元数据</li></ul></li></ul><h2 id="LiteflowPropertyAutoConfiguration"><a href="#LiteflowPropertyAutoConfiguration" class="headerlink" title="LiteflowPropertyAutoConfiguration"></a>LiteflowPropertyAutoConfiguration</h2><p>总的来说就是对配置属性的合并和封装，实例化 <code>LiteflowConfig</code>，便于后续业务的使用</p><p>合并了 <code>liteflow</code> 配置和 <code>liteflow.monitor</code> 配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;LiteflowProperty.class, LiteflowMonitorProperty.class&#125;)</span></span><br><span class="line"><span class="meta">@PropertySource(</span></span><br><span class="line"><span class="meta">        name = &quot;Liteflow Default Properties&quot;,</span></span><br><span class="line"><span class="meta">        value = &quot;classpath:/META-INF/liteflow-default.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiteflowPropertyAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LiteflowConfig <span class="title function_">liteflowConfig</span><span class="params">(LiteflowProperty property, LiteflowMonitorProperty liteflowMonitorProperty)</span>&#123;</span><br><span class="line">        <span class="type">LiteflowConfig</span> <span class="variable">liteflowConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiteflowConfig</span>();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        liteflowConfig.setPrintExecutionLog(property.isPrintExecutionLog());</span><br><span class="line">        liteflowConfig.setSubstituteCmpClass(property.getSubstituteCmpClass());</span><br><span class="line">        <span class="keyword">return</span> liteflowConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖前置 <code>LiteflowProperty</code> 和 <code>LiteflowMonitorProperty</code> bean，即流程配置参数和监控器的配置参数类</p><h2 id="LiteflowMainAutoConfiguration"><a href="#LiteflowMainAutoConfiguration" class="headerlink" title="LiteflowMainAutoConfiguration"></a>LiteflowMainAutoConfiguration</h2><p>配置核心的各种实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123;LiteflowPropertyAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(LiteflowConfig.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;liteflow&quot;, name = &quot;enable&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="meta">@Import(SpringAware.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiteflowMainAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化ComponentScanner</span></span><br><span class="line">    <span class="comment">//多加一个SpringAware的意义是，确保在执行这个的时候，SpringAware这个bean已经被初始化</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ComponentScanner <span class="title function_">componentScanner</span><span class="params">(LiteflowConfig liteflowConfig, SpringAware springAware)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ComponentScanner</span>(liteflowConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化FlowExecutor</span></span><br><span class="line">    <span class="comment">//多加一个SpringAware的意义是，确保在执行这个的时候，SpringAware这个bean已经被初始化</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FlowExecutor <span class="title function_">flowExecutor</span><span class="params">(LiteflowConfig liteflowConfig, SpringAware springAware)</span> &#123;</span><br><span class="line">        <span class="type">FlowExecutor</span> <span class="variable">flowExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlowExecutor</span>();</span><br><span class="line">        flowExecutor.setLiteflowConfig(liteflowConfig);</span><br><span class="line">        <span class="keyword">return</span> flowExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FlowExecutor的初始化工作，和实例化分开来</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;liteflow&quot;, name = &quot;parse-on-start&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> LiteflowExecutorInit <span class="title function_">liteflowExecutorInit</span><span class="params">(FlowExecutor flowExecutor)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LiteflowExecutorInit</span>(flowExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化MonitorBus</span></span><br><span class="line">    <span class="comment">//多加一个SpringAware的意义是，确保在执行这个的时候，SpringAware这个bean已经被初始化</span></span><br><span class="line">    <span class="meta">@Bean(&quot;monitorBus&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;liteflow&quot;, name = &quot;monitor.enable-log&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> MonitorBus <span class="title function_">monitorBus</span><span class="params">(LiteflowConfig liteflowConfig, SpringAware springAware)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MonitorBus</span>(liteflowConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 bean 的加载顺序：LiteflowPropertyAutoConfiguration -&gt; LiteflowConfig -&gt; ComponentScanner &amp; FlowExecutor &amp; MonitorBus -&gt; LiteflowExecutorInit</p><p>LiteflowExecutorInit 和 MonitorBus 依赖不同的配置条件，其中 <code>liteflow.parse-on-start</code> 默认是 true，<code>liteflow.monitor.enable-log</code> 默认是 false</p><h1 id="ComponentScanner"><a href="#ComponentScanner" class="headerlink" title="ComponentScanner"></a>ComponentScanner</h1><p><code>ComponentScanner</code> 在项目中也被缩写为 <code>cmp</code>，主要是依赖 Spring 的 <code>BeanPostProcessor</code> 来对 <code>NodeComponent</code> 的各种实现进行发现、保存、扩展等一系列操作</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>配置类中使用了其构造方法进行实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ComponentScanner</span><span class="params">(LiteflowConfig liteflowConfig)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.liteflowConfig = liteflowConfig;</span><br><span class="line">    <span class="keyword">if</span> (liteflowConfig.getPrintBanner()) &#123;</span><br><span class="line">        <span class="comment">// 打印liteflow的LOGO</span></span><br><span class="line">        LOGOPrinter.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法中主要进行了两个操作：</p><ol><li><p>填充属性 liteflowConfig</p></li><li><p>打印 LOGO（可以看出这个是启动的第一个 bean）；LOGOPrinter 就是一个打印 LOGO 的静态方法工具类</p></li></ol><h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>既然实现了 <code>BeanPostProcessor</code> 接口，那么重点就需要关注其对于 before 和 after 钩子方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentScanner</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>before 方法是一个空实现，重点关注 after 方法</p><h3 id="声明式组件"><a href="#声明式组件" class="headerlink" title="声明式组件"></a>声明式组件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是不是声明式组件</span></span><br><span class="line"><span class="comment">//如果是，就缓存到类属性的map中</span></span><br><span class="line"><span class="keyword">if</span> (LiteFlowProxyUtil.isDeclareCmp(bean.getClass())) &#123;</span><br><span class="line">    LOG.info(<span class="string">&quot;proxy component[&#123;&#125;] has been found&quot;</span>, beanName);</span><br><span class="line">    List&lt;NodeComponent&gt; nodeComponents = LiteFlowProxyUtil.proxy2NodeComponent(bean, beanName);</span><br><span class="line">    nodeComponents.forEach(</span><br><span class="line">            nodeComponent -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">nodeId</span> <span class="operator">=</span> nodeComponent.getNodeId();</span><br><span class="line">                nodeId = StrUtil.isEmpty(nodeId) ? beanName : nodeId;</span><br><span class="line">                nodeComponentMap.put(nodeId, nodeComponent);</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 只有注解支持单bean多Node,所以一个直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (nodeComponents.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nodeComponents.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何判断是否是一个声明式组件，实现方法是 <code>LiteFlowProxyUtil.isDeclareCmp</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断一个bean是否是声明式组件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isDeclareCmp</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">    <span class="comment">// 查看bean里的method是否有方法标记了@LiteflowMethod标注</span></span><br><span class="line">    <span class="comment">// 这里的bean有可能是cglib加强过的class，所以要先进行个判断</span></span><br><span class="line">    Class&lt;?&gt; targetClass = getUserClass(clazz);</span><br><span class="line">    <span class="comment">// 判断是否有方法标记了@LiteflowMethod标注，有则为声明式组件</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(targetClass.getMethods())</span><br><span class="line">        .anyMatch(method -&gt; method.getAnnotation(LiteflowMethod.class) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取真实的用户定义类</li><li>判断类中的方法是否标记了 <code>@LiteflowMethod</code></li></ol><h3 id="实现类组件"><a href="#实现类组件" class="headerlink" title="实现类组件"></a>实现类组件</h3><p>实现类组件有两种：</p><ul><li>继承自 <code>NodeComponent</code> 的逻辑组件</li><li>实现自 <code>ICmpAroundAspect</code> 的切面组件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件的扫描发现，扫到之后缓存到类属性map中</span></span><br><span class="line"><span class="keyword">if</span> (NodeComponent.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">    LOG.info(<span class="string">&quot;component[&#123;&#125;] has been found&quot;</span>, beanName);</span><br><span class="line">    <span class="type">NodeComponent</span> <span class="variable">nodeComponent</span> <span class="operator">=</span> (NodeComponent) bean;</span><br><span class="line">    nodeComponentMap.put(beanName, nodeComponent);</span><br><span class="line">    <span class="keyword">return</span> nodeComponent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件Aop的实现类加载</span></span><br><span class="line"><span class="keyword">if</span> (ICmpAroundAspect.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">    LOG.info(<span class="string">&quot;component aspect implement[&#123;&#125;] has been found&quot;</span>, beanName);</span><br><span class="line">    cmpAroundAspect = (ICmpAroundAspect) bean;</span><br><span class="line">    <span class="keyword">return</span> cmpAroundAspect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扫描组件的逻辑都是这类方式：</p><ol><li>判断是否是其实现</li><li>转型</li><li>保存到对应引用或对象</li></ol><p>可以看到对于逻辑组件，是一个 map 结构，存在多个组件；而对于切面组件，只能存在一个（事实上这段逻辑没有对实现进行判断，也就是说如果有多个实现的 bean 会进行覆盖，测试中也发现是这样）</p><h3 id="脚本组件"><a href="#脚本组件" class="headerlink" title="脚本组件"></a>脚本组件</h3><p>脚本组件也有两种：</p><ul><li><code>@ScriptBean</code> 修饰的脚本 bean</li><li><code>@ScriptMethod</code> 修饰的脚本方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描@ScriptBean修饰的类</span></span><br><span class="line"><span class="type">ScriptBean</span> <span class="variable">scriptBean</span> <span class="operator">=</span> AnnoUtil.getAnnotation(clazz, ScriptBean.class);</span><br><span class="line"><span class="keyword">if</span> (ObjectUtil.isNotNull(scriptBean)) &#123;</span><br><span class="line">    <span class="type">ScriptBeanProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptBeanProxy</span>(bean, clazz, scriptBean);</span><br><span class="line">    ScriptBeanManager.addScriptBean(scriptBean.value(), proxy.getProxyScriptBean());</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描@ScriptMethod修饰的类</span></span><br><span class="line">List&lt;Method&gt; scriptMethods = Arrays.stream(clazz.getMethods()).filter(method -&gt; &#123;</span><br><span class="line">    <span class="type">ScriptMethod</span> <span class="variable">scriptMethod</span> <span class="operator">=</span> AnnoUtil.getAnnotation(method, ScriptMethod.class);</span><br><span class="line">    <span class="keyword">return</span> ObjectUtil.isNotNull(scriptMethod) &amp;&amp; StrUtil.isNotEmpty(scriptMethod.value());</span><br><span class="line">&#125;).collect(Collectors.toList());</span><br><span class="line"><span class="keyword">if</span> (CollUtil.isNotEmpty(scriptMethods)) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Method&gt;&gt; scriptMethodsGroupByValue = CollStreamUtil.groupBy(scriptMethods, method -&gt; &#123;</span><br><span class="line">        <span class="type">ScriptMethod</span> <span class="variable">scriptMethod</span> <span class="operator">=</span> AnnoUtil.getAnnotation(method, ScriptMethod.class);</span><br><span class="line">        <span class="keyword">return</span> scriptMethod.value();</span><br><span class="line">    &#125;, Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;Method&gt;&gt; entry : scriptMethodsGroupByValue.entrySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        List&lt;Method&gt; methods = entry.getValue();</span><br><span class="line">        <span class="type">ScriptMethodProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptMethodProxy</span>(bean, clazz, methods);</span><br><span class="line"></span><br><span class="line">        ScriptBeanManager.addScriptBean(key, proxy.getProxyScriptMethod());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是将不同的脚本形式包装成代理类，转换成 bean 后放入 <code>ScriptBeanManager</code> 进行管理</p><p>转换的核心在 <code>getProxyScriptMethod</code> 方法，这个会在脚本相关源码中进一步分析</p><h1 id="FlowExecutor"><a href="#FlowExecutor" class="headerlink" title="FlowExecutor"></a>FlowExecutor</h1><p>流程规则主要执行器，也是一个规则表执行的主要入口</p><p>这里主要关注其构造流程，初始化在后面的 <code>LiteflowExecutorInit</code> 中讲解</p><h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FlowExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置FlowExecutor的Holder，虽然大部分地方都可以通过Spring上下文获取到，但放入Holder，还是为了某些地方能方便的取到</span></span><br><span class="line">    FlowExecutorHolder.setHolder(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 初始化DataBus</span></span><br><span class="line">    DataBus.init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FlowExecutor</span><span class="params">(LiteflowConfig liteflowConfig)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.liteflowConfig = liteflowConfig;</span><br><span class="line">    <span class="comment">// 把liteFlowConfig设到LiteFlowGetter中去</span></span><br><span class="line">    LiteflowConfigGetter.setLiteflowConfig(liteflowConfig);</span><br><span class="line">    <span class="comment">// 设置FlowExecutor的Holder，虽然大部分地方都可以通过Spring上下文获取到，但放入Holder，还是为了某些地方能方便的取到</span></span><br><span class="line">    FlowExecutorHolder.setHolder(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (BooleanUtil.isTrue(liteflowConfig.isParseOnStart())) &#123;</span><br><span class="line">        <span class="built_in">this</span>.init(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化DataBus</span></span><br><span class="line">    DataBus.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Spring 的启动方式，使用了无参构造，随后将 liteflowConfig 用 set 方法进行赋值，带有参数的构造方法应该是为了非 Spring 环境准备的，因为在 Spring 环境中 liteflowConfig 使用了 properties 的机制，而 FlowExecutor 通过 <code>@Bean</code> 进行实例化</p><p>可以看到无参构造中主要进行了 <code>DataBus.init()</code> 操作</p><h2 id="DataBus"><a href="#DataBus" class="headerlink" title="DataBus"></a>DataBus</h2><p>数据 BUS，主要用来管理 Slot，用以分配和回收</p><p>Slot 即整个规则流程调用时的管理者，保存了整个规则进行中的数据、组件步骤等信息，每一次调用会生成新的 Slot，并且互相隔离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;Integer, Slot&gt; SLOTS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentLinkedQueue&lt;Integer&gt; QUEUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 SLOTS 没有初始化</span></span><br><span class="line">    <span class="keyword">if</span> (MapUtil.isEmpty(SLOTS)) &#123;</span><br><span class="line">        <span class="comment">// 获取 liteflowConfig，在 Spring 环境中这里会使用已经注入的 SpringAware 从 ApplicationContext 中获取</span></span><br><span class="line">        <span class="type">LiteflowConfig</span> <span class="variable">liteflowConfig</span> <span class="operator">=</span> LiteflowConfigGetter.get();</span><br><span class="line">        <span class="comment">// 从配置中获取 slot size 参数</span></span><br><span class="line">        currentIndexMaxValue = liteflowConfig.getSlotSize();</span><br><span class="line">        <span class="comment">// 初始化 SLOTS</span></span><br><span class="line">        SLOTS = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化 QUEUE</span></span><br><span class="line">        QUEUE = IntStream.range(<span class="number">0</span>, currentIndexMaxValue)</span><br><span class="line">            .boxed()</span><br><span class="line">            .collect(Collectors.toCollection(ConcurrentLinkedQueue::<span class="keyword">new</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 SLOTS 用来保存分配的序号和 Slot 对象，QUEUE 则是用来保存 index</p><p>即在并发的情况下，能够分配的运行资格由 QUEUE 控制，QUEUE 会根据并发情况进行扩容，具体的资格由 0 ~ n 的 int 值来表示</p><h1 id="LiteflowExecutorInit"><a href="#LiteflowExecutorInit" class="headerlink" title="LiteflowExecutorInit"></a>LiteflowExecutorInit</h1><p>执行器初始化类，主要用于在启动时执行执行器的初始化方法，避免在运行执行器时第一次初始化而耗费时间</p><p>该类实例化的意义就是控制上面对象 FlowExecutor 的初始化操作，如果不在配置中设置启动初始化，则 FlowExecutor 的初始化工作会放在调用时进行 <code>@ConditionalOnProperty(prefix = &quot;liteflow&quot;, name = &quot;parse-on-start&quot;, havingValue = &quot;true&quot;)</code></p><h2 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiteflowExecutorInit</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FlowExecutor flowExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LiteflowExecutorInit</span><span class="params">(FlowExecutor flowExecutor)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.flowExecutor = flowExecutor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">flowExecutor.init(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类实现了 Spring 钩子 InitializingBean，afterPropertiesSet 进行 <code>FlowExecutor</code> 的初始化操作</p><h2 id="FlowExecutor-的-init"><a href="#FlowExecutor-的-init" class="headerlink" title="FlowExecutor 的 init"></a>FlowExecutor 的 init</h2><p><code>LiteflowExecutorInit</code> 的实例化是为了 init <code>FlowExecutor</code>，而 <code>FlowExecutor</code> 的初始化主要目的是 parse 规则文件</p><h3 id="ID-生成器"><a href="#ID-生成器" class="headerlink" title="ID 生成器"></a>ID 生成器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行id生成器的初始化</span></span><br><span class="line">IdGeneratorHolder.init();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 单例创建</span></span><br><span class="line">    INSTANCE = <span class="keyword">new</span> <span class="title class_">IdGeneratorHolder</span>();</span><br><span class="line">    <span class="type">LiteflowConfig</span> <span class="variable">liteflowConfig</span> <span class="operator">=</span> LiteflowConfigGetter.get();</span><br><span class="line">    <span class="comment">// 获取配置项中的生成器类路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">requestIdGeneratorClass</span> <span class="operator">=</span> liteflowConfig.getRequestIdGeneratorClass();</span><br><span class="line"></span><br><span class="line">    RequestIdGenerator requestIdGenerator;</span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(requestIdGeneratorClass)) &#123;</span><br><span class="line">      <span class="comment">// 默认为 DefaultRequestIdGenerator</span></span><br><span class="line">      requestIdGenerator = <span class="keyword">new</span> <span class="title class_">DefaultRequestIdGenerator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 实例化自定义生成器</span></span><br><span class="line">      Class&lt;RequestIdGenerator&gt; idGenerateClass = (Class&lt;RequestIdGenerator&gt;) Class</span><br><span class="line">        .forName(requestIdGeneratorClass);</span><br><span class="line">      <span class="comment">// 注册进 bean 容器</span></span><br><span class="line">      requestIdGenerator = ContextAwareHolder.loadContextAware().registerBean(idGenerateClass);</span><br><span class="line">    &#125;</span><br><span class="line">    INSTANCE.setRequestIdGenerator(requestIdGenerator);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RequestIdGeneratorException</span>(e.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IdGeneratorHolder</code> 用于保存实例化后的 ID 生成器 <code>RequestIdGenerator</code>，是一个单例</p><p>基本流程就是获取配置项上的生成器类路径，然后通过反射进行实例化，保存到 <code>IdGeneratorHolder</code> 这个角色中，如果没有进行配置则使用默认实现 <code>DefaultRequestIdGenerator</code></p><p><strong>默认实现 DefaultRequestIdGenerator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultRequestIdGenerator</span> <span class="keyword">implements</span> <span class="title class_">RequestIdGenerator</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">generate</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> IdUtil.fastSimpleUUID();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hutool 下的简单 UUID 生成</p><h3 id="规则文件源路径"><a href="#规则文件源路径" class="headerlink" title="规则文件源路径"></a>规则文件源路径</h3><p>在上面流程中加载了逻辑组件，接下来就是解析规则表</p><p><strong>规则路径为空</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">ruleSource</span> <span class="operator">=</span> liteflowConfig.getRuleSource();</span><br><span class="line"><span class="keyword">if</span> (StrUtil.isBlank(ruleSource)) &#123;</span><br><span class="line">   <span class="comment">// 查看有没有Parser的SPI实现</span></span><br><span class="line">   <span class="comment">// 所有的Parser的SPI实现都是以custom形式放入的，且只支持xml形式</span></span><br><span class="line">   ServiceLoader&lt;ParserClassNameSpi&gt; loader = ServiceLoader.load(ParserClassNameSpi.class);</span><br><span class="line">   Iterator&lt;ParserClassNameSpi&gt; it = loader.iterator();</span><br><span class="line">   <span class="keyword">if</span> (it.hasNext()) &#123;</span><br><span class="line">      <span class="type">ParserClassNameSpi</span> <span class="variable">parserClassNameSpi</span> <span class="operator">=</span> it.next();</span><br><span class="line">      ruleSource = <span class="string">&quot;el_xml:&quot;</span> + parserClassNameSpi.getSpiClassName();</span><br><span class="line">      liteflowConfig.setRuleSource(ruleSource);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ruleSource为空，而且没有spi形式的扩展，那么说明真的没有ruleSource</span></span><br><span class="line">      <span class="comment">// 这种情况有可能是基于代码动态构建的</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一块逻辑是在判断当配置文件的规则源路径为空的情况，此时会使用 SPI 工具 <code>ServiceLoader</code> 去加载自定义实现的规则加载器去放置新的规则路径</p><p><strong>项目文件和本地文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果有前缀的，则不需要再进行分割了，说明是一个整体</span></span><br><span class="line"><span class="comment">// 如果没有前缀，说明是本地文件，可能配置多个，所以需要分割</span></span><br><span class="line">List&lt;String&gt; sourceRulePathList;</span><br><span class="line"><span class="keyword">if</span> (ReUtil.contains(PREFIX_FORMAT_CONFIG_REGEX, ruleSource)) &#123;</span><br><span class="line">   sourceRulePathList = ListUtil.toList(ruleSource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">afterHandleRuleSource</span> <span class="operator">=</span> ruleSource.replace(StrUtil.SPACE, StrUtil.EMPTY);</span><br><span class="line">   sourceRulePathList = ListUtil.toList(afterHandleRuleSource.split(<span class="string">&quot;,|;&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LiteFlow 的特性可以支持从本地文件加载规则，所以在此处判断规则是来源于项目文件还是本地文件</p><p>根据规则前缀 <code>String PREFIX_FORMAT_CONFIG_REGEX = &quot;xml:|json:|yml:|el_xml:|el_json:|el_yml:&quot;</code> 的正则来匹配；如果是本地文件则根据 <code>,|;</code> 来进行分割</p><p>将规则文件的路径都放置在 <code>sourceRulePathList</code> 这个集合中</p><h3 id="规则文件解析"><a href="#规则文件解析" class="headerlink" title="规则文件解析"></a>规则文件解析</h3><p>获取规则源后要对规则文件进行解析</p><h4 id="复合规则配置"><a href="#复合规则配置" class="headerlink" title="复合规则配置"></a>复合规则配置</h4><p>这里应该是实现不同格式规则加载的特性，需要进行相关配置 <code>supportMultipleType</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FlowParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Set&lt;String&gt; parserNameSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; rulePathList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String path : sourceRulePathList) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 查找对应的解析器</span></span><br><span class="line">      parser = FlowParserProvider.lookup(path);</span><br><span class="line">      parserNameSet.add(parser.getClass().getName());</span><br><span class="line">      <span class="comment">// 替换掉前缀标识（如：xml:/json:），保留剩下的完整地址</span></span><br><span class="line">      path = ReUtil.replaceAll(path, PREFIX_FORMAT_CONFIG_REGEX, <span class="string">&quot;&quot;</span>);</span><br><span class="line">      rulePathList.add(path);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 支持多类型的配置文件，分别解析</span></span><br><span class="line">      <span class="keyword">if</span> (BooleanUtil.isTrue(liteflowConfig.isSupportMultipleType())) &#123;</span><br><span class="line">         <span class="comment">// 解析文件</span></span><br><span class="line">         parser.parseMain(ListUtil.toList(path));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (CyclicDependencyException e) &#123;</span><br><span class="line">      LOG.error(e.getMessage());</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> StrUtil.format(<span class="string">&quot;init flow executor cause error for path &#123;&#125;,reason:&#123;&#125;&quot;</span>, path,</span><br><span class="line">            e.getMessage());</span><br><span class="line">      LOG.error(e.getMessage(), e);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FlowExecutorNotInitException</span>(errorMsg);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程如下：</p><ol><li>遍历规则路径，查找对应的解析器</li><li>记录解析器类名（主要是用于后续非多类型解析器判断使用）</li><li>路径放入规则路径集合</li><li>如果支持多类型配置文件解析，则直接进行解析 <code>parser.parseMain(ListUtil.toList(path))</code></li><li>catch 异常，打印日志</li></ol><h4 id="单类型配置"><a href="#单类型配置" class="headerlink" title="单类型配置"></a>单类型配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单类型的配置文件，需要一起解析</span></span><br><span class="line"><span class="keyword">if</span> (BooleanUtil.isFalse(liteflowConfig.isSupportMultipleType())) &#123;</span><br><span class="line">   <span class="comment">// 检查Parser是否只有一个，因为多个不同的parser会造成子流程的混乱</span></span><br><span class="line">   <span class="keyword">if</span> (parserNameSet.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> <span class="string">&quot;cannot have multiple different parsers&quot;</span>;</span><br><span class="line">      LOG.error(errorMsg);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MultipleParsersException</span>(errorMsg);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 进行多个配置文件的一起解析</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (parser != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 解析文件</span></span><br><span class="line">         parser.parseMain(rulePathList);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigErrorException</span>(<span class="string">&quot;parse error, please check liteflow config property&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (CyclicDependencyException e) &#123;</span><br><span class="line">      LOG.error(e.getMessage(), e);</span><br><span class="line">      LOG.error(e.getMessage());</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ChainDuplicateException e) &#123;</span><br><span class="line">      LOG.error(e.getMessage(), e);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> StrUtil.format(<span class="string">&quot;init flow executor cause error for path &#123;&#125;,reason: &#123;&#125;&quot;</span>, rulePathList,</span><br><span class="line">            e.getMessage());</span><br><span class="line">      LOG.error(e.getMessage(), e);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FlowExecutorNotInitException</span>(errorMsg);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单类型的流程主要针对解析器数量进行了判断，也是使用 <code>parser.parseMain(ListUtil.toList(path))</code> 进入解析流程</p><h4 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h4><p>这里主要先来看 <code>LocalXmlFlowELParser</code> 的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalXmlFlowELParser</span> <span class="keyword">extends</span> <span class="title class_">XmlFlowELParser</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseMain</span><span class="params">(List&lt;String&gt; pathList)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      List&lt;String&gt; contentList = PathContentParserHolder.loadContextAware().parseContent(pathList);</span><br><span class="line">      parse(contentList);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PathContentParserHolder.loadContextAware().parseContent(pathList)</code> 的操作用于获取文件中的内容，即规则的 EL 表达式等（就是读文件，不过会根据不同环境选择不同的实现）</p><p>最后执行 <code>BaseXmlFlowParser</code> 抽象类提供的 <code>parse</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(List&lt;String&gt; contentList)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="keyword">if</span> (CollectionUtil.isEmpty(contentList)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   List&lt;Document&gt; documentList = ListUtil.toList();</span><br><span class="line">   <span class="keyword">for</span> (String content : contentList) &#123;</span><br><span class="line">      <span class="comment">// 解析 XML org.dom4j.DocumentHelper，转换为 Document 对象</span></span><br><span class="line">      <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> DocumentHelper.parseText(content);</span><br><span class="line">      documentList.add(document);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 解析 node</span></span><br><span class="line">   ParserHelper.parseNodeDocument(documentList);</span><br><span class="line">   <span class="comment">// 解析 chain</span></span><br><span class="line">   ParserHelper.parseChainDocument(documentList, CHAIN_NAME_SET, <span class="built_in">this</span>::parseOneChain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ParserHelper"><a href="#ParserHelper" class="headerlink" title="ParserHelper"></a>ParserHelper</h4><p>以 <code>XML</code> 格式的规则表达为例</p><p><strong>解析 node</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * xml 形式的主要解析过程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> documentList documentList</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parseNodeDocument</span><span class="params">(List&lt;Document&gt; documentList)</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (Document document : documentList) &#123;</span><br><span class="line">      <span class="comment">// 获取 root 标签</span></span><br><span class="line">      <span class="type">Element</span> <span class="variable">rootElement</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">      <span class="comment">// 获取 nodes 标签</span></span><br><span class="line">      <span class="type">Element</span> <span class="variable">nodesElement</span> <span class="operator">=</span> rootElement.element(NODES);</span><br><span class="line">      <span class="comment">// 当存在&lt;nodes&gt;节点定义时，解析node节点</span></span><br><span class="line">      <span class="keyword">if</span> (ObjectUtil.isNotNull(nodesElement)) &#123;</span><br><span class="line">         List&lt;Element&gt; nodeList = nodesElement.elements(NODE);</span><br><span class="line">         String id, name, clazz, type, script, file, language;</span><br><span class="line">         <span class="keyword">for</span> (Element e : nodeList) &#123;</span><br><span class="line">            id = e.attributeValue(ID);</span><br><span class="line">            name = e.attributeValue(NAME);</span><br><span class="line">            clazz = e.attributeValue(_CLASS);</span><br><span class="line">            type = e.attributeValue(TYPE);</span><br><span class="line">            script = e.getText();</span><br><span class="line">            file = e.attributeValue(FILE);</span><br><span class="line">            language = e.attributeValue(LANGUAGE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建 node</span></span><br><span class="line">            <span class="type">NodePropBean</span> <span class="variable">nodePropBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodePropBean</span>().setId(id)</span><br><span class="line">               .setName(name)</span><br><span class="line">               .setClazz(clazz)</span><br><span class="line">               .setScript(script)</span><br><span class="line">               .setType(type)</span><br><span class="line">               .setFile(file)</span><br><span class="line">               .setLanguage(language);</span><br><span class="line"></span><br><span class="line">            ParserHelper.buildNode(nodePropBean);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从配置的 <code>XML</code> 规则中解析标签</li><li>找到 <code>nodes</code> 的标签；name 常量定义在 <code>ChainConstant.NODES</code></li><li>遍历 <code>nodes</code> 下面的每一个 <code>node</code> 标签，构建 <code>NodePropBean</code> node 对象</li><li><code>ParserHelper.buildNode(nodePropBean)</code> 开始解析节点，解析完成后会放置在 <code>FlowBus</code> 中（解析过程中还在分辨是普通节点还是脚本节点，这个放到脚本相关源码中再看）</li></ol><p><strong>解析 chain</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parseChainDocument</span><span class="params">(List&lt;Document&gt; documentList, Set&lt;String&gt; chainNameSet,</span></span><br><span class="line"><span class="params">      Consumer&lt;Element&gt; parseOneChainConsumer)</span> &#123;</span><br><span class="line">   <span class="comment">// 先在元数据里放上chain</span></span><br><span class="line">   <span class="comment">// 先放有一个好处，可以在parse的时候先映射到FlowBus的chainMap，然后再去解析</span></span><br><span class="line">   <span class="comment">// 这样就不用去像之前的版本那样回归调用</span></span><br><span class="line">   <span class="comment">// 同时也解决了不能循环依赖的问题</span></span><br><span class="line">   documentList.forEach(document -&gt; &#123;</span><br><span class="line">      <span class="comment">// 解析chain节点</span></span><br><span class="line">      List&lt;Element&gt; chainList = document.getRootElement().elements(CHAIN);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 先在元数据里放上chain</span></span><br><span class="line">      chainList.forEach(e -&gt; &#123;</span><br><span class="line">         <span class="comment">// 校验加载的 chainName 是否有重复的</span></span><br><span class="line">         <span class="comment">// TODO 这里是否有个问题，当混合格式加载的时候，2个同名的Chain在不同的文件里，就不行了</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">chainName</span> <span class="operator">=</span> Optional.ofNullable(e.attributeValue(ID)).orElse(e.attributeValue(NAME));</span><br><span class="line">         <span class="keyword">if</span> (!chainNameSet.add(chainName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ChainDuplicateException</span>(String.format(<span class="string">&quot;[chain name duplicate] chainName=%s&quot;</span>, chainName));</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         FlowBus.addChain(chainName);</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">// 清空</span></span><br><span class="line">   chainNameSet.clear();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析每一个chain</span></span><br><span class="line">   <span class="keyword">for</span> (Document document : documentList) &#123;</span><br><span class="line">      <span class="type">Element</span> <span class="variable">rootElement</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">      List&lt;Element&gt; chainList = rootElement.elements(CHAIN);</span><br><span class="line">      chainList.forEach(parseOneChainConsumer);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从 <code>XML</code> 规则中解析 <code>chain</code> 标签</li><li>遍历标签处理 chain 数据</li><li>获取 chainName，规则为如果没有配置独立的 id 就使用 name</li><li>加入 chainNameSet，如果 name 重复则抛出异常（这种方式无法处理多文件的重复问题，我理解带来的影响就是会导致解析的 chain 被覆盖）</li><li>先将 name 加入元数据管理类 <code>FlowBus</code>；这个流程是预装载，其元数据管理中的 map value 是占位对象</li><li>遍历 chain 标签，调用传入的 <code>Consumer</code> 方法开始解析；<code>Consumer</code> 方法为 <code>Parser</code> 实现的 <code>parseOneChain</code> 方法</li></ol><h4 id="EL-规则组装器"><a href="#EL-规则组装器" class="headerlink" title="EL 规则组装器"></a>EL 规则组装器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parseOneChainEl</span><span class="params">(JsonNode chainNode)</span> &#123;</span><br><span class="line">   <span class="comment">// 构建chainBuilder</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">chainId</span> <span class="operator">=</span> Optional.ofNullable(chainNode.get(ID)).orElse(chainNode.get(NAME)).textValue();</span><br><span class="line">   <span class="type">String</span> <span class="variable">el</span> <span class="operator">=</span> chainNode.get(VALUE).textValue();</span><br><span class="line">   <span class="type">LiteFlowChainELBuilder</span> <span class="variable">chainELBuilder</span> <span class="operator">=</span> LiteFlowChainELBuilder.createChain().setChainId(chainId);</span><br><span class="line">   chainELBuilder.setEL(el).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>parseOneChainEl</code> 后主要是获取 el 规则，创建 <code>LiteFlowChainELBuilder</code> 对象后在 <code>setEL</code> 的步骤中会进行 EL 规则的解析，最终返回 <code>List&lt;Condition&gt; conditionList</code></p><p>规则的解析使用了阿里开源的 QLExpress，后面会单独一篇来讲解</p><p>基本上到这里，相关的执行组件就已经初始化完毕了</p><p>后续具体的执行就是获取 <code>Chain</code> 对象的 <code>conditionList</code>，遍历 list 进行执行</p><h1 id="MonitorBus"><a href="#MonitorBus" class="headerlink" title="MonitorBus"></a>MonitorBus</h1><p>监控类元数据，打印执行器类</p><p>需要配置 condition 参数 <code>monitor.enable-log</code></p><h2 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ScheduledExecutorService</span> <span class="variable">printLogScheduler</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MonitorBus</span><span class="params">(LiteflowConfig liteflowConfig)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.liteflowConfig = liteflowConfig;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (BooleanUtil.isTrue(liteflowConfig.getEnableLog())) &#123;</span><br><span class="line">      <span class="built_in">this</span>.printLogScheduler.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">MonitorTimeTask</span>(<span class="built_in">this</span>), liteflowConfig.getDelay(),</span><br><span class="line">            liteflowConfig.getPeriod(), TimeUnit.MILLISECONDS);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向定时线程池设置任务，任务为 <code>new MonitorTimeTask(this)</code>，是一个 <code>TimerTask</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorTimeTask</span> <span class="keyword">extends</span> <span class="title class_">TimerTask</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MonitorBus monitorBus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MonitorTimeTask</span><span class="params">(MonitorBus monitorBus)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.monitorBus = monitorBus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">monitorBus.printStatistics();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>run</code> 方法为调用 <code>MonitorBus.printStatistics</code></p><h2 id="打印统计数据"><a href="#打印统计数据" class="headerlink" title="打印统计数据"></a>打印统计数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, BoundedPriorityBlockingQueue&lt;CompStatistics&gt;&gt; statisticsMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStatistics</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      Map&lt;String, BigDecimal&gt; compAverageTimeSpent = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, BigDecimal&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Entry&lt;String, BoundedPriorityBlockingQueue&lt;CompStatistics&gt;&gt; entry : statisticsMap.entrySet()) &#123;</span><br><span class="line">         <span class="type">long</span> <span class="variable">totalTimeSpent</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (CompStatistics statistics : entry.getValue()) &#123;</span><br><span class="line">            totalTimeSpent += statistics.getTimeSpent();</span><br><span class="line">         &#125;</span><br><span class="line">         compAverageTimeSpent.put(entry.getKey(), <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(totalTimeSpent)</span><br><span class="line">            .divide(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(entry.getValue().size()), <span class="number">2</span>, RoundingMode.HALF_UP));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      List&lt;Entry&lt;String, BigDecimal&gt;&gt; compAverageTimeSpentEntryList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">            compAverageTimeSpent.entrySet());</span><br><span class="line"></span><br><span class="line">      Collections.sort(compAverageTimeSpentEntryList, (o1, o2) -&gt; o2.getValue().compareTo(o1.getValue()));</span><br><span class="line"></span><br><span class="line">      <span class="type">StringBuilder</span> <span class="variable">logStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">      logStr.append(<span class="string">&quot;以下为LiteFlow中间件统计信息：\n&quot;</span>);</span><br><span class="line">      logStr.append(<span class="string">&quot;======================================================================================\n&quot;</span>);</span><br><span class="line">      logStr.append(<span class="string">&quot;===================================SLOT INFO==========================================\n&quot;</span>);</span><br><span class="line">      logStr.append(MessageFormat.format(<span class="string">&quot;SLOT TOTAL SIZE : &#123;0&#125;\n&quot;</span>, liteflowConfig.getSlotSize()));</span><br><span class="line">      logStr.append(MessageFormat.format(<span class="string">&quot;SLOT OCCUPY COUNT : &#123;0&#125;\n&quot;</span>, DataBus.OCCUPY_COUNT));</span><br><span class="line">      logStr.append(<span class="string">&quot;===============================TIME AVERAGE SPENT=====================================\n&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (Entry&lt;String, BigDecimal&gt; entry : compAverageTimeSpentEntryList) &#123;</span><br><span class="line">         logStr.append(MessageFormat.format(<span class="string">&quot;COMPONENT[&#123;0&#125;] AVERAGE TIME SPENT : &#123;1&#125;\n&quot;</span>, entry.getKey(),</span><br><span class="line">               entry.getValue()));</span><br><span class="line">      &#125;</span><br><span class="line">      logStr.append(<span class="string">&quot;======================================================================================\n&quot;</span>);</span><br><span class="line">      LOG.info(logStr.toString());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      LOG.error(<span class="string">&quot;print statistics cause error&quot;</span>, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>statisticsMap</code> 是用来保存组件执行时上报的数据，在 <code>printStatistics</code> 方法中对数据进行整理和打印</p><p>主要数据：</p><ul><li>slot 槽位现在的大小（用来衡量最大并发度）</li><li>slot 当前的占用数量（展示当前并发度）</li><li>各个组件的平均耗时</li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> LiteFlow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LiteFlow </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RECIPES - Maison Premiere’s Tom Collins</title>
      <link href="/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/RECIPES%20-%20Maison%20Premiere%E2%80%99s%20Tom%20Collins.html"/>
      <url>/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/RECIPES%20-%20Maison%20Premiere%E2%80%99s%20Tom%20Collins.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://assets-prd.punchdrink.com/wp-content/uploads/2023/03/16224141/Article-Tom-Collins-Underrated-Classic-Cocktail-Recipe-500x688.jpg"></p><h1 id="Maison-Premiere-的汤姆柯林斯"><a href="#Maison-Premiere-的汤姆柯林斯" class="headerlink" title="Maison Premiere 的汤姆柯林斯"></a>Maison Premiere 的汤姆柯林斯</h1><p><a href="https://punchdrink.com/recipes/maison-premieres-tom-collins/">Maison Premiere’s Tom Collins Cocktail Recipe | PUNCH (punchdrink.com)</a></p><p>对于某些调酒师来说，“被低估” 并不一定意味着鲜为人知</p><p>Maison Premiere 的威廉·埃利奥特（William Elliott）认为，汤姆柯林斯是无处不在的经典，值得 ”好好对待“</p><p>关键在于找到一个轻度桶陈的老汤姆（他使用的是 Ransom Old Tom），并且，虽然常见的是在玻璃杯里进行调制，不过一个合适的汤姆柯林斯应该经过 shake 并过滤</p><p>在布鲁克林的酒吧里，埃利奥特对鸡尾酒的基底采用了类似吉姆雷特（Gimlet）的方式，需要柠檬汁和柠檬甜酒（lemon cordial）的鲜明组合，再加上少量的橙味苦精</p><h2 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h2><p><em>Serving: 1</em></p><ul><li>老汤姆金酒（最好是 Ransom）- 1.5 盎司（<a href="https://www.diffordsguide.com/beer-wine-spirits/2344/ransom-old-tom-gin">Ransom Old Tom Gin</a>）</li><li>柠檬甜酒 - 1 盎司（见注释）</li><li>海军力量金酒 - 0.5 盎司（最好是 Hayman’s Royal Dock <a href="https://www.diffordsguide.com/beer-wine-spirits/3066/haymans-royal-dock-of-deptford-gin">Hayman’s Royal Dock of Deptford Gin</a>）</li><li>柠檬汁 - 0.5 盎司</li><li>橙味苦精 - 3 dashes</li><li>苏打水 - 加满</li></ul><p><strong>装饰</strong>：安高天娜苦精、柠檬轮、糖霜、吸管</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>将前五种原料加入摇壶中，加冰进行 shake</li><li>滤入加冰的 12 盎司柯林斯玻璃杯中，将安高天娜苦精滴浮在表面</li><li>用柠檬轮和糖霜装饰，插入吸管</li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="柠檬甜酒（Lemon-Cordial）"><a href="#柠檬甜酒（Lemon-Cordial）" class="headerlink" title="柠檬甜酒（Lemon Cordial）"></a>柠檬甜酒（Lemon Cordial）</h3><p>将 10 个柠檬皮、32 盎司白糖和 1 盎司伏特加放在容器中混合，经过一夜或放置 12 小时</p><p>加入 32 盎司柠檬汁，搅拌至白糖溶解</p><p>过滤（fine-strain）</p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 宿醉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸡尾酒 </tag>
            
            <tag> recipes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoogleCode ConcurrentLinkedHashMap</title>
      <link href="/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/GoogleCode%20ConcurrentLinkedHashMap.html"/>
      <url>/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/GoogleCode%20ConcurrentLinkedHashMap.html</url>
      
        <content type="html"><![CDATA[<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><h2 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h2><p>ConcurrentLinkedHashMap 构造方法私有，只能通过其静态内部类 <code>Builder</code> 来进行实例化</p><blockquote><p>一个完全支持并发检索的哈希表，可调节更新预期并发度，以及限制其最大容量</p><p>该实现与 <code>ConcurrentHashMap</code> 的不同之处在于维护了一个页面替换算法（page replacement algorithm），用于在 map 超出容量时删除元素</p><p>这个 map 实现没有共有的构造器，它的实例是通过 <code>Builder</code> 创建的</p></blockquote><p><code>Builder</code> 支持链式赋值，使用如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ConcurrentLinkedHashMap&lt;Integer, String&gt; map =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedHashMap</span>.Builder&lt;Integer, String&gt;()</span><br><span class="line">            .maximumWeightedCapacity(<span class="number">2</span>)</span><br><span class="line">            .weigher(Weighers.singleton())</span><br><span class="line">            .listener((key, value) -&gt; System.out.println(<span class="string">&quot;元素被丢弃了 key=&quot;</span> + key + <span class="string">&quot; value=&quot;</span> + value))</span><br><span class="line">            .concurrencyLevel(<span class="number">32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>build()</code> 方法进行 <code>ConcurrentLinkedHashMap </code> 的实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConcurrentLinkedHashMap&lt;K, V&gt; <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">  checkState(capacity &gt;= <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedHashMap</span>&lt;K, V&gt;(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到如果 <code>capacity</code>，即 <code>maximumWeightedCapacity</code> 未进行赋值，则会抛出异常，其他参数均有默认值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 默认为 -1，结合上面的逻辑，不进行赋值实例化时会抛出异常</span></span><br><span class="line">  capacity = -<span class="number">1</span>;</span><br><span class="line">  weigher = Weighers.entrySingleton();</span><br><span class="line">  initialCapacity = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">  concurrencyLevel = DEFAULT_CONCURRENCY_LEVEL;</span><br><span class="line">  listener = (EvictionListener&lt;K, V&gt;) DiscardingListener.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="maximumWeightedCapacity"><a href="#maximumWeightedCapacity" class="headerlink" title="maximumWeightedCapacity"></a>maximumWeightedCapacity</h2><p>表示该 map 最大能够允许的最大重量，并且有可能暂时超过它（我理解可能驱逐元素是一个惰性过程）</p><p>在实例化 <code>ConcurrentLinkedHashMap</code> 时，使用原子类作为容量的记录器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ConcurrentLinkedHashMap</span><span class="params">(Builder&lt;K, V&gt; builder)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    capacity = <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(Math.min(builder.capacity, MAXIMUM_CAPACITY));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及 <code>capacity</code> 的方法：</p><ul><li>capacity：获取当前 capacity</li><li>setCapacity：设置 capacity</li><li>hasOverflowed：判断当前重量大小是否超过了 capacity</li></ul><h2 id="initialCapacity"><a href="#initialCapacity" class="headerlink" title="initialCapacity"></a>initialCapacity</h2><p>表示初始化底层存放元素的 map 容量，默认为 16</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ConcurrentLinkedHashMap</span><span class="params">(Builder&lt;K, V&gt; builder)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    data = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMapV8</span>&lt;K, Node&lt;K, V&gt;&gt;(builder.initialCapacity, <span class="number">0.75f</span>, concurrencyLevel);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentLinkedHashMap 底层实现存储的结构是 <code>ConcurrentHashMapV8</code>，看到其参数和 JUC 下面的 <code>ConcurrentHashMap</code> 一样大致就可以猜到该参数的作用，本质上也是在预估数据量来避免频繁 resize 操作</p><p>对于该参数是如何用于实例化 <code>ConcurrentHashMapV8</code> ，在后面的 <code>concurrencyLevel</code> 参数进行展示</p><p>该参数只用于实例化 <code>ConcurrentHashMapV8</code></p><h2 id="concurrencyLevel"><a href="#concurrencyLevel" class="headerlink" title="concurrencyLevel"></a>concurrencyLevel</h2><p>预估的并发线程数</p><p>和 <code>initialCapacity</code> 参数一样，都是为了实例化 <code>ConcurrentHashMapV8</code>，其参数的作用也和 <code>ConcurrentHashMap</code> 一样（作者都是 Doug Lea）</p><p><code>ConcurrentHashMap</code> 提高并发性能的思想就是 cell 化，按照底层 Entry 数组头元素作为并发粒度，那么 <code>concurrencyLevel</code> 和 <code>initialCapacity</code> 这两个参数必然同时影响底层数组的大小创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMapV8</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + initialCapacity / loadFactor);</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="weigher"><a href="#weigher" class="headerlink" title="weigher"></a>weigher</h2><p>重量器，用来衡量一个元素占用了多少重量，默认为 <code>SingletonWeigher</code></p><p>因为 ConcurrentLinkedHashMap 的核心功能是在限制 map 内元素的占用，那么衡量一个元素的权重就被抽象为了 <code>Weigher</code></p><p>其中除了 <code>Weigher</code> 还提供了 <code>EntryWeigher</code> 的抽象，用于对整个 KV 进行重量的衡量</p><p>对于 <code>Weigher</code> 实现，会被转换为 <code>EntryWeigher</code> 实现（统一入口）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Builder&lt;K, V&gt; <span class="title function_">weigher</span><span class="params">(Weigher&lt;? <span class="built_in">super</span> V&gt; weigher)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.weigher = (weigher == Weighers.singleton())</span><br><span class="line">      ? Weighers.&lt;K, V&gt;entrySingleton()</span><br><span class="line">      : <span class="keyword">new</span> <span class="title class_">BoundedEntryWeigher</span>&lt;K, V&gt;(Weighers.asEntryWeigher(weigher));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>EntryWeigherView</code> 就是用来将 <code>Weigher</code> 包装为 <code>EntryWeigher</code> 的实现</p><p>列举一些自带的实现</p><ul><li>Weigher<ul><li>SingletonWeigher：一个 value 的重量视为 1</li><li>CollectionWeigher：value 为集合类型，重量为集合的 size</li><li>ListWeigher：value 为 list 类型，重量为 list 的 size</li><li>MapWeigher：value 为 map 类型，重量为 map 的 size</li></ul></li><li>EntryWeigher<ul><li>BoundedEntryWeigher：内部为 <code>EntryWeigher</code> 实现，要求重量大于等于 1</li><li>SingletonEntryWeigher：一个 KV 的重量视为 1</li><li>EntryWeigherView：用于包装 <code>Weigher</code> 的实现</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ConcurrentLinkedHashMap</span><span class="params">(Builder&lt;K, V&gt; builder)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// The eviction support</span></span><br><span class="line">    weigher = builder.weigher;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该参数会在 put 元素以及一系列获取 ordered 视图操作中被使用</p><h2 id="listener"><a href="#listener" class="headerlink" title="listener"></a>listener</h2><p><code>EvictionListener</code> 的实现，用于驱逐元素时调用该实现的 <code>onEviction(K key, V value)</code> 方法进行通知</p><p>默认值为 <code>DiscardingListener.INSTANCE</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ConcurrentLinkedHashMap</span><span class="params">(Builder&lt;K, V&gt; builder)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="comment">// The notification queue and listener</span></span><br><span class="line">    listener = builder.listener;</span><br><span class="line">    pendingNotifications = (listener == DiscardingListener.INSTANCE)</span><br><span class="line">        ? (Queue&lt;Node&lt;K, V&gt;&gt;) DISCARDING_QUEUE</span><br><span class="line">        : <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;Node&lt;K, V&gt;&gt;();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看出，如果 listener 是一个默认值，则 <code>pendingNotifications</code> 也会使用默认队列，其实现就是空实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** A queue that discards all additions and is always empty. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DiscardingQueue</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;Object&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Object e)</span> &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object e)</span> &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Object <span class="title function_">poll</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Object <span class="title function_">peek</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Iterator&lt;Object&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123; <span class="keyword">return</span> emptyList().iterator(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>驱逐元素时不会进行通知，使用了<strong>空对象模式</strong></p><blockquote><p>在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查</p><p>Null 对象不是检查空值，而是反应一个不做任何动作的关系，这样的 Null 对象也可以在数据不可用的时候提供默认的行为</p></blockquote><h1 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h1><p><code>put</code> 和 <code>putIfAbsent</code> 最终都调用 <code>put(K key, V value, boolean onlyIfAbsent)</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> put(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> put(key, value, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">V <span class="title function_">put</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">  <span class="comment">// 入参校验</span></span><br><span class="line">  checkNotNull(key);</span><br><span class="line">  checkNotNull(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算权重</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> weigher.weightOf(key, value);</span><br><span class="line"><span class="comment">// 包装节点</span></span><br><span class="line">  <span class="keyword">final</span> WeightedValue&lt;V&gt; weightedValue = <span class="keyword">new</span> <span class="title class_">WeightedValue</span>&lt;V&gt;(value, weight);</span><br><span class="line">  <span class="keyword">final</span> Node&lt;K, V&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K, V&gt;(key, weightedValue);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// put 调用</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K, V&gt; prior = data.putIfAbsent(node.key, node);</span><br><span class="line">    <span class="comment">// 第一次写入 key，视为一次 Add</span></span><br><span class="line">    <span class="keyword">if</span> (prior == <span class="literal">null</span>) &#123;</span><br><span class="line">      afterWrite(<span class="keyword">new</span> <span class="title class_">AddTask</span>(node, weight));</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 存在 key 并且 onlyIfAbsent = true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent) &#123;</span><br><span class="line">      afterRead(prior);</span><br><span class="line">      <span class="keyword">return</span> prior.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 走到该 case，说明 key 存在并且 onlyIfAbsent = false</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">final</span> WeightedValue&lt;V&gt; oldWeightedValue = prior.get();</span><br><span class="line">     <span class="comment">// 并发错误下跳出，由 data.putIfAbsent(node.key, node) 继续取值</span></span><br><span class="line">      <span class="keyword">if</span> (!oldWeightedValue.isAlive()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 更新权重，视情况进行 Update 或者 read</span></span><br><span class="line">      <span class="keyword">if</span> (prior.compareAndSet(oldWeightedValue, weightedValue)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">weightedDifference</span> <span class="operator">=</span> weight - oldWeightedValue.weight;</span><br><span class="line">        <span class="keyword">if</span> (weightedDifference == <span class="number">0</span>) &#123;</span><br><span class="line">          afterRead(prior);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          afterWrite(<span class="keyword">new</span> <span class="title class_">UpdateTask</span>(prior, weightedDifference));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldWeightedValue.value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算权重"><a href="#计算权重" class="headerlink" title="计算权重"></a>计算权重</h2><p>经过参数校验后，首先要进行权重的计算和包装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算权重</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> weigher.weightOf(key, value);</span><br><span class="line"><span class="comment">// 包装节点</span></span><br><span class="line"><span class="keyword">final</span> WeightedValue&lt;V&gt; weightedValue = <span class="keyword">new</span> <span class="title class_">WeightedValue</span>&lt;V&gt;(value, weight);</span><br><span class="line"><span class="keyword">final</span> Node&lt;K, V&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K, V&gt;(key, weightedValue);</span><br></pre></td></tr></table></figure><p>权重的计算就是调用了 <code>EntryWeigher</code> 实现的 <code>weightOf()</code> 方法</p><p>随后将权重值和 value 包装进 <code>WeightedValue</code>，并包装为 <code>Node</code></p><p><code>Node</code> 即为链表的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">AtomicReference</span>&lt;WeightedValue&lt;V&gt;&gt; <span class="keyword">implements</span> <span class="title class_">Linked</span>&lt;Node&lt;K, V&gt;&gt;</span><br></pre></td></tr></table></figure><p>整个保存 KV 的核心结构（上面提到的 <code>ConcurrentHashMapV8</code>）保存的其实是 key 和 <code>Node</code> 的数据：<code>final ConcurrentMap&lt;K, Node&lt;K, V&gt;&gt; data;</code></p><h2 id="无冲突"><a href="#无冲突" class="headerlink" title="无冲突"></a>无冲突</h2><p>随后调用 <code>data</code> 的 <code>putIfAbsent</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K, V&gt; prior = data.putIfAbsent(node.key, node);</span><br></pre></td></tr></table></figure><p>根据返回的 prior 节点情况，判断后续流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次写入 key，视为一次 Add</span></span><br><span class="line">  <span class="keyword">if</span> (prior == <span class="literal">null</span>) &#123;</span><br><span class="line">    afterWrite(<span class="keyword">new</span> <span class="title class_">AddTask</span>(node, weight));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 存在 key 并且 onlyIfAbsent = true，视为一次 Read</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent) &#123;</span><br><span class="line">    afterRead(prior);</span><br><span class="line">    <span class="keyword">return</span> prior.getValue();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这两种情况均可以视为无冲突情况：</p><ul><li>不存在 prior</li><li>存在 prior 但是 onlyIfAbsent &#x3D; true</li></ul><p>随后执行相应的 Add 或者 Read 任务（后面解释任务的操作）</p><h2 id="需要更新"><a href="#需要更新" class="headerlink" title="需要更新"></a>需要更新</h2><p>当 key 已经存在，那么上述 put 方法其实并未完成，只是返回了 K 对应的 value 对象（节点）</p><p>可以猜测下面流程需要做的操作：</p><ul><li>替换 key 对应的 value；因为 value 和权重是绑定关系，也即替换了权重</li><li>进行 Task 流程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 走到该 case，说明 key 存在并且 onlyIfAbsent = false</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="keyword">final</span> WeightedValue&lt;V&gt; oldWeightedValue = prior.get();</span><br><span class="line">  <span class="comment">// 并发错误下跳出，由 data.putIfAbsent(node.key, node) 继续取值</span></span><br><span class="line">  <span class="keyword">if</span> (!oldWeightedValue.isAlive()) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新权重，视情况进行 Update 或 Read</span></span><br><span class="line">  <span class="keyword">if</span> (prior.compareAndSet(oldWeightedValue, weightedValue)) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">weightedDifference</span> <span class="operator">=</span> weight - oldWeightedValue.weight;</span><br><span class="line">    <span class="keyword">if</span> (weightedDifference == <span class="number">0</span>) &#123;</span><br><span class="line">      afterRead(prior);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      afterWrite(<span class="keyword">new</span> <span class="title class_">UpdateTask</span>(prior, weightedDifference));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldWeightedValue.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先获取 prior 节点的 <code>WeightedValue</code> 结构，当该结构 <code>isAlive()</code> 为 false 时，说明现在的 prior 节点在并发环境下已经成为过去式了，需要跳出循环，重新进行最开始的获取流程</li><li>当旧节点没问题，就会调用 CAS 方法来替换新的 weight 和 value，如果替换成功则会根据权重差值来进行 Read 或者 Update 任务</li><li>如果 CAS 失败，则会继续对节点进行判断，重复流程</li></ol><h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><h2 id="按-K-删除"><a href="#按-K-删除" class="headerlink" title="按 K 删除"></a>按 K 删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;K, V&gt; node = data.remove(key);</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  makeRetired(node);</span><br><span class="line">  afterWrite(<span class="keyword">new</span> <span class="title class_">RemovalTask</span>(node));</span><br><span class="line">  <span class="keyword">return</span> node.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先依赖 <code>data</code> 的 <code>remove(key)</code> 方法，拿到节点后进行判断，如果等于 null，说明该 key 没有对应的值，就不需要考虑后续流程了</li><li>如果节点不等 null，需要进行 <code>makeRetired()</code>，本质是修改节点 <code>WeightedValue</code> 的权重为负数（在添加流程中，依靠权重是否为负作为 value 被删除的标志）</li><li>随后进行 Removal 任务</li></ol><h2 id="按-KV-删除"><a href="#按-KV-删除" class="headerlink" title="按 KV 删除"></a>按 KV 删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;K, V&gt; node = data.get(key);</span><br><span class="line">  <span class="keyword">if</span> ((node == <span class="literal">null</span>) || (value == <span class="literal">null</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  WeightedValue&lt;V&gt; weightedValue = node.get();</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (weightedValue.contains(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tryToRetire(node, weightedValue)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.remove(key, node)) &#123;</span><br><span class="line">          afterWrite(<span class="keyword">new</span> <span class="title class_">RemovalTask</span>(node));</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        weightedValue = node.get();</span><br><span class="line">        <span class="keyword">if</span> (weightedValue.isAlive()) &#123;</span><br><span class="line">          <span class="comment">// retry as an intermediate update may have replaced the value with</span></span><br><span class="line">          <span class="comment">// an equal instance that has a different reference identity</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在删除的基础上多了对 value 的比较</p><p>当 key 存在时，这里用了多个嵌套判断来实现目的或保证并发：</p><ol><li>value 是否能对应上，对应不上直接返回删除失败</li><li>让 value 退休，调用 <code>tryToRetire(node, weightedValue)</code> 方法，如果失败就重新获取节点的 value，进行存活判断，如果依然存活则重复整个流程（从 1 开始）</li><li>调用 <code>data.remove(key, node)</code> 方法，如果成功则进行 Removal 任务，失败则重新整个流程</li></ol><h2 id="tryToRetire"><a href="#tryToRetire" class="headerlink" title="tryToRetire"></a>tryToRetire</h2><p>在上述删除流程中，都需要调用 <code>tryToRetire</code> 方法</p><p>本质上是将节点置为失效状态，失效状态根据节点 value 中的 <code>WeightedValue</code> 的 <code>weight</code> 来标示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">tryToRetire</span><span class="params">(Node&lt;K, V&gt; node, WeightedValue&lt;V&gt; expect)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (expect.isAlive()) &#123;</span><br><span class="line">    <span class="keyword">final</span> WeightedValue&lt;V&gt; retired = <span class="keyword">new</span> <span class="title class_">WeightedValue</span>&lt;V&gt;(expect.value, -expect.weight);</span><br><span class="line">    <span class="keyword">return</span> node.compareAndSet(expect, retired);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后置读写"><a href="#后置读写" class="headerlink" title="后置读写"></a>后置读写</h1><p>在上述流程中，各种操作都离不开调用 <code>afterRead</code> 和 <code>afterWrite</code> 方法</p><p>后置读写的操作本质上就是在调整链表结构来实现 LRU，对元素进行写入、驱逐和排序</p><h2 id="afterWrite"><a href="#afterWrite" class="headerlink" title="afterWrite"></a>afterWrite</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterWrite</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">    <span class="comment">// 写缓冲区添加任务</span></span><br><span class="line">    writeBuffer.add(task);</span><br><span class="line">    <span class="comment">// 设置 drain 状态为 REQUIRED</span></span><br><span class="line">    drainStatus.lazySet(REQUIRED);</span><br><span class="line">    <span class="comment">// 执行缓冲区的任务</span></span><br><span class="line">    tryToDrainBuffers();</span><br><span class="line">    <span class="comment">// 通知监听器</span></span><br><span class="line">    notifyListener();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 drainStatus 是一个被 <code>AtomicReference</code> 包装的 <code>DrainStatus</code>，代表当前缓冲操作的状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">DrainStatus</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** A drain is not taking place. */</span></span><br><span class="line">    IDLE &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="type">boolean</span> <span class="title function_">shouldDrainBuffers</span><span class="params">(<span class="type">boolean</span> delayable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !delayable;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** A drain is required due to a pending write modification. */</span></span><br><span class="line">    REQUIRED &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="type">boolean</span> <span class="title function_">shouldDrainBuffers</span><span class="params">(<span class="type">boolean</span> delayable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** A drain is in progress. */</span></span><br><span class="line">    PROCESSING &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="type">boolean</span> <span class="title function_">shouldDrainBuffers</span><span class="params">(<span class="type">boolean</span> delayable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Determines whether the buffers should be drained.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delayable if a drain should be delayed until required</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> if a drain should be attempted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">shouldDrainBuffers</span><span class="params">(<span class="type">boolean</span> delayable)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 drainStatus 被并发安全并 lazy 设置为 <code>REQUIRED</code> 后，<code>tryToDrainBuffers()</code> 方法来执行对缓冲区的操作</p><p><strong>tryToDrainBuffers</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">tryToDrainBuffers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (evictionLock.tryLock()) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            drainStatus.lazySet(PROCESSING);</span><br><span class="line">            drainBuffers();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            drainStatus.compareAndSet(PROCESSING, IDLE);</span><br><span class="line">            evictionLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取锁资格，evictionLock 是一个 <code>ReentrantLock</code>：<code>evictionLock = new ReentrantLock();</code></p><p>再将 drainStatus 状态设置为 <code>PROCESSING</code>；最后调用核心的 <code>drainBuffers</code> 方法</p><p>当执行结束后将 drainStatus CAS 修改为 <code>IDLE</code>，进行解锁</p><h2 id="afterRead"><a href="#afterRead" class="headerlink" title="afterRead"></a>afterRead</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterRead</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 buffer 的 index，这里为了避免对热 entries 的争抢</span></span><br><span class="line">    <span class="comment">// 个人理解类似针对缓冲区的 cell 机制</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">bufferIndex</span> <span class="operator">=</span> readBufferIndex();</span><br><span class="line">    <span class="comment">// 根据 bufferIndex 将 node 记录在 readBuffer 中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">writeCount</span> <span class="operator">=</span> recordRead(bufferIndex, node);</span><br><span class="line">    <span class="comment">// drain 操作</span></span><br><span class="line">    drainOnReadIfNeeded(bufferIndex, writeCount);</span><br><span class="line">    <span class="comment">// 通知监听器</span></span><br><span class="line">    notifyListener();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>recordRead</code> 的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">recordRead</span><span class="params">(<span class="type">int</span> bufferIndex, Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">    <span class="comment">// The location in the buffer is chosen in a racy fashion as the increment</span></span><br><span class="line">    <span class="comment">// is not atomic with the insertion. This means that concurrent reads can</span></span><br><span class="line">    <span class="comment">// overlap and overwrite one another, resulting in a lossy buffer.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">counter</span> <span class="operator">=</span> readBufferWriteCount[bufferIndex];</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">writeCount</span> <span class="operator">=</span> counter.get();</span><br><span class="line">    counter.lazySet(writeCount + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) (writeCount &amp; READ_BUFFER_INDEX_MASK);</span><br><span class="line">    readBuffers[bufferIndex][index].lazySet(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> writeCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取 readBufferWriteCount 的 counter 的 value 后 +1 写入</p><blockquote><p>这里注释中说明了这个操作不是原子的，意味着可以并发读取，并且会导致 buffer 的重叠和覆盖，还不清楚为什么这样处理</p><p>根据后续代码这里记录的 count 主要是用于控制读缓冲区的 drain 操作，可能不需要那么准确，猜测这样处理的原因是因为没必要为了并发安全牺牲性能</p></blockquote><p>随后将 node 记录在 readBuffers 中</p><p><strong>drainOnReadIfNeeded</strong></p><p>该方法就是用于 drain 读缓冲区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">drainOnReadIfNeeded</span><span class="params">(<span class="type">int</span> bufferIndex, <span class="type">long</span> writeCount)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 pending 数量，当前线程对应缓冲区在上一步操作的写数量 - 读缓冲区处理的数量（计算差值判断是否到了需要刷新的阈值）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">pending</span> <span class="operator">=</span> (writeCount - readBufferDrainAtWriteCount[bufferIndex].get());</span><br><span class="line">    <span class="comment">// READ_BUFFER_THRESHOLD = 32</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">delayable</span> <span class="operator">=</span> (pending &lt; READ_BUFFER_THRESHOLD);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">DrainStatus</span> <span class="variable">status</span> <span class="operator">=</span> drainStatus.get();</span><br><span class="line">    <span class="comment">// 判断是否需要 drain</span></span><br><span class="line">    <span class="keyword">if</span> (status.shouldDrainBuffers(delayable)) &#123;</span><br><span class="line">    tryToDrainBuffers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据读 count 计算 pending 数量，根据 pending 值来判断是否执行 drain 操作</p><p>其中对于操作的判断来自于 <code>DrainStatus</code>，即状态枚举实现的抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">DrainStatus</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** A drain is not taking place. */</span></span><br><span class="line">    IDLE &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="type">boolean</span> <span class="title function_">shouldDrainBuffers</span><span class="params">(<span class="type">boolean</span> delayable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !delayable;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** A drain is required due to a pending write modification. */</span></span><br><span class="line">    REQUIRED &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="type">boolean</span> <span class="title function_">shouldDrainBuffers</span><span class="params">(<span class="type">boolean</span> delayable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** A drain is in progress. */</span></span><br><span class="line">    PROCESSING &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="type">boolean</span> <span class="title function_">shouldDrainBuffers</span><span class="params">(<span class="type">boolean</span> delayable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Determines whether the buffers should be drained.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delayable if a drain should be delayed until required</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> if a drain should be attempted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">shouldDrainBuffers</span><span class="params">(<span class="type">boolean</span> delayable)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到：</p><ul><li>对于 <code>REQUIRED</code>，说明需要立即刷新缓冲区（这个状态最直接是来自于写操作）</li><li>对于 <code>PROCESSING</code>，说明当前其他线程正在处理，所以不需要该线程再进行操作了</li><li>对于 <code>IDLE</code>，则根据 pending 数量得到的 delayable 来判断</li></ul><p>最后也是调用 <code>tryToDrainBuffers</code> 方法来对缓冲区进行 drain 操作</p><h2 id="drainWriteBuffer"><a href="#drainWriteBuffer" class="headerlink" title="drainWriteBuffer"></a>drainWriteBuffer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">drainWriteBuffer</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; WRITE_BUFFER_DRAIN_THRESHOLD; i++) &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> writeBuffer.poll();</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    task.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取一定数量的 task，然后执行 task 的 run 方法</p><p>每一次 drain 操作都有一个阈值（WRITE_BUFFER_DRAIN_THRESHOLD &#x3D; 16），应该是为每个线程分摊工作量，在 read 中也是这样类似的设计</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/** Adds the node to the page replacement policy. */</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AddTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K, V&gt; node;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">    AddTask(Node&lt;K, V&gt; node, <span class="type">int</span> weight) &#123;</span><br><span class="line">      <span class="built_in">this</span>.weight = weight;</span><br><span class="line">      <span class="built_in">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;evictionLock&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      weightedSize.lazySet(weightedSize.get() + weight);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ignore out-of-order write operations</span></span><br><span class="line">      <span class="keyword">if</span> (node.get().isAlive()) &#123;</span><br><span class="line">        evictionDeque.add(node);</span><br><span class="line">        evict();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes a node from the page replacement policy. */</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RemovalTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K, V&gt; node;</span><br><span class="line"></span><br><span class="line">    RemovalTask(Node&lt;K, V&gt; node) &#123;</span><br><span class="line">      <span class="built_in">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;evictionLock&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// add may not have been processed yet</span></span><br><span class="line">      evictionDeque.remove(node);</span><br><span class="line">      makeDead(node);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Updates the weighted size and evicts an entry on overflow. */</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">UpdateTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> weightDifference;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K, V&gt; node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UpdateTask</span><span class="params">(Node&lt;K, V&gt; node, <span class="type">int</span> weightDifference)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.weightDifference = weightDifference;</span><br><span class="line">      <span class="built_in">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;evictionLock&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      weightedSize.lazySet(weightedSize.get() + weightDifference);</span><br><span class="line">      applyRead(node);</span><br><span class="line">      evict();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>对于 task 的实现，有 3 种：</p><ul><li><code>AddTask</code><ul><li>调整 weight</li><li><code>evictionDeque</code> 添加节点（尾插）</li><li>调用驱逐方法 <code>evict</code></li></ul></li><li><code>RemovalTask</code><ul><li><code>evictionDeque</code> 移除节点</li><li>设置节点 dead（包括调整 weight）</li></ul></li><li><code>UpdateTask</code><ul><li>调整 weight</li><li>调整 node 到尾部</li><li>调用驱逐方法 <code>evict</code></li></ul></li></ul><p><strong>为什么 <code>UpdateTask</code> 也需要驱逐元素？</strong>因为 weight 的计算方法是由实现类提供的，可能根据不同的情况计算 weight，更新操作也可能更新 weight，所以需要进行驱逐操作</p><p><strong>驱逐方法 evict</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">evict</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Attempts to evict entries from the map if it exceeds the maximum</span></span><br><span class="line">    <span class="comment">// capacity. If the eviction fails due to a concurrent removal of the</span></span><br><span class="line">    <span class="comment">// victim, that removal may cancel out the addition that triggered this</span></span><br><span class="line">    <span class="comment">// eviction. The victim is eagerly unlinked before the removal task so</span></span><br><span class="line">    <span class="comment">// that if an eviction is still required then a new victim will be chosen</span></span><br><span class="line">    <span class="comment">// for removal.</span></span><br><span class="line">    <span class="comment">// 判断是否超过 weight 阈值</span></span><br><span class="line">    <span class="keyword">while</span> (hasOverflowed()) &#123;</span><br><span class="line">      <span class="keyword">final</span> Node&lt;K, V&gt; node = evictionDeque.poll();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If weighted values are used, then the pending operations will adjust</span></span><br><span class="line">      <span class="comment">// the size to reflect the correct weight</span></span><br><span class="line">      <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Notify the listener only if the entry was evicted</span></span><br><span class="line">      <span class="keyword">if</span> (data.remove(node.key, node)) &#123;</span><br><span class="line">        <span class="comment">// 待通知队列</span></span><br><span class="line">        pendingNotifications.add(node);</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">// 标记删除</span></span><br><span class="line">      makeDead(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法就是为了实现 LRU，如果超出了 weight，则会从 <code>evictionDeque</code> 中 poll 出元素后，记录待通知队列，标记删除</p><p>标记删除删除的是 Map 结构中的元素（修改其 weight 标记删除），其中 node 也是 Map 中持有的引用</p><h2 id="drainReadBuffers"><a href="#drainReadBuffers" class="headerlink" title="drainReadBuffers"></a>drainReadBuffers</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">drainReadBuffers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> (<span class="type">int</span>) Thread.currentThread().getId();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start + NUMBER_OF_READ_BUFFERS;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">    drainReadBuffer(i &amp; READ_BUFFERS_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">drainReadBuffer</span><span class="params">(<span class="type">int</span> bufferIndex)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">writeCount</span> <span class="operator">=</span> readBufferWriteCount[bufferIndex].get();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; READ_BUFFER_DRAIN_THRESHOLD; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) (readBufferReadCount[bufferIndex] &amp; READ_BUFFER_INDEX_MASK);</span><br><span class="line">      <span class="keyword">final</span> AtomicReference&lt;Node&lt;K, V&gt;&gt; slot = readBuffers[bufferIndex][index];</span><br><span class="line">      <span class="keyword">final</span> Node&lt;K, V&gt; node = slot.get();</span><br><span class="line">      <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      slot.lazySet(<span class="literal">null</span>);</span><br><span class="line">      <span class="comment">// 本质上就是将 evictionDeque 中对应的 node 移动到队尾（LRU）</span></span><br><span class="line">      applyRead(node);</span><br><span class="line">      readBufferReadCount[bufferIndex]++;</span><br><span class="line">&#125;</span><br><span class="line">readBufferDrainAtWriteCount[bufferIndex].lazySet(writeCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述操作可以概括成几个要点：</p><ul><li>每一次 drain 操作分配了 buffer 操作的阈值</li><li>获取 node，释放 node</li><li>将 node 移动到队尾</li><li>记录 readBufferDrainAtWriteCount</li></ul><h1 id="驱逐监听器"><a href="#驱逐监听器" class="headerlink" title="驱逐监听器"></a>驱逐监听器</h1><p>最后就是 <code>notifyListener</code> 方法调用 <code>EvictionListener</code> 的实现来进行元素驱逐的通知功能</p><p>相关的方法在 <code>afterRead</code>、<code>afterWrite</code>、<code>setCapacity</code> 中被调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">notifyListener</span><span class="params">()</span> &#123;</span><br><span class="line">    Node&lt;K, V&gt; node;</span><br><span class="line">    <span class="keyword">while</span> ((node = pendingNotifications.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">  listener.onEviction(node.key, node.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历 pendingNotifications 中被驱逐的 node，调用 listener 的 <code>onEviction</code> 方法</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/ben-manes/concurrentlinkedhashmap">ben-manes&#x2F;concurrentlinkedhashmap: A ConcurrentLinkedHashMap for Java (github.com)</a></p><p><a href="https://code.google.com/p/concurrentlinkedhashmap/">https://code.google.com/p/concurrentlinkedhashmap/</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空对象模式 - Null Object</title>
      <link href="/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F%20-%20Null%20Object.html"/>
      <url>/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F%20-%20Null%20Object.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>空对象模式（Null Object Pattern），使用空对象的行为（空实现、校验等）来代替对 Null 值的判断；空对象并不是在检查空值，而是通过对象的行为实现不进行任何动作或者校验的效果，以此对调用方隐藏更多的实现细节</p><p><strong>目的</strong><br>向上层隐藏更多的实现细节，加强系统的稳定性，减少判空判断</p><p><strong>现实世界类比</strong><br>在现实世界中也很难表达 ”空“ 这个概念，往往会使用 ”空盒子“、”空间“ 来进行表达，类比在代码中就是使用表现空概念的对象，而不是判空 <code>obj == null</code> 来实现对空的判断</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>模拟这样一个场景，对用户展示一些商品信息，其中要根据用户的属性对商品进行过滤</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>对于最终过滤后的商品，如果无法满足一定数量，例如商品数量 &lt; 3，就会从通用商品池中选择一定数量的商品进行补位</p><p>这样的需求在代码流程中如何设计，如果在过滤流程、VO 转换流程等阶段来实现，就会让逻辑看起来不太顺畅</p><p>这时就可以考虑使用空对象模式</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="全部商品信息"><a href="#全部商品信息" class="headerlink" title="全部商品信息"></a>全部商品信息</h3><p>先定义出一个商品信息集合，当然这些商品信息可以通过接口、数据库系统等来获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodsInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Pair&lt;Integer, Integer&gt; ageRange;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;GoodsInfo&gt; <span class="title function_">getAllGoodsInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">GoodsInfo</span>(<span class="string">&quot;洗衣机&quot;</span>, <span class="number">10</span>, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">20</span>, <span class="number">50</span>), BigDecimal.valueOf(<span class="number">2000.0</span>)),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">GoodsInfo</span>(<span class="string">&quot;笔记本电脑&quot;</span>, <span class="number">21</span>, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">15</span>, <span class="number">50</span>), BigDecimal.valueOf(<span class="number">4999.0</span>)),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">GoodsInfo</span>(<span class="string">&quot;扫地机器人&quot;</span>, <span class="number">5</span>, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">25</span>, <span class="number">55</span>), BigDecimal.valueOf(<span class="number">2500.0</span>)),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">GoodsInfo</span>(<span class="string">&quot;厨具&quot;</span>, <span class="number">30</span>, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">30</span>, <span class="number">60</span>), BigDecimal.valueOf(<span class="number">89.0</span>)),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">GoodsInfo</span>(<span class="string">&quot;文具&quot;</span>, <span class="number">100</span>, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">8</span>, <span class="number">30</span>), BigDecimal.valueOf(<span class="number">30.0</span>)),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">GoodsInfo</span>(<span class="string">&quot;空调&quot;</span>, <span class="number">6</span>, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">30</span>, <span class="number">60</span>), BigDecimal.valueOf(<span class="number">5100.0</span>)),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">GoodsInfo</span>(<span class="string">&quot;儿童玩具&quot;</span>, <span class="number">40</span>, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">10</span>, <span class="number">50</span>), BigDecimal.valueOf(<span class="number">100.0</span>))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户类"><a href="#用户类" class="headerlink" title="用户类"></a>用户类</h3><p>一个简单的用户信息，后续业务将会根据 <code>age</code> 和 <code>expectPrice</code> 属性对展示的商品进行过滤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Pair&lt;BigDecimal, BigDecimal&gt; expectPrice;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤规则接口及实现"><a href="#过滤规则接口及实现" class="headerlink" title="过滤规则接口及实现"></a>过滤规则接口及实现</h3><p>提供过滤规则接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GoodsFilterHandler</span> &#123;</span><br><span class="line">    List&lt;GoodsInfo&gt; <span class="title function_">filter</span><span class="params">(List&lt;GoodsInfo&gt; goodsInfos, User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>根据年龄进行过滤实现</strong></p><p>根据商品信息上的年龄和用户的年龄进行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgeFilter</span> <span class="keyword">implements</span> <span class="title class_">GoodsFilterHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;GoodsInfo&gt; <span class="title function_">filter</span><span class="params">(<span class="keyword">final</span> List&lt;GoodsInfo&gt; goodsInfos, <span class="keyword">final</span> User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> goodsInfos.stream().filter(</span><br><span class="line">            goodsInfo -&gt; goodsInfo.getAgeRange().getKey() &lt;= user.getAge() &amp;&amp; goodsInfo.getAgeRange().getValue() &gt;= user</span><br><span class="line">                .getAge()).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>根据期望价格区间进行过滤实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExpectPriceFilter</span> <span class="keyword">implements</span> <span class="title class_">GoodsFilterHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;GoodsInfo&gt; <span class="title function_">filter</span><span class="params">(<span class="keyword">final</span> List&lt;GoodsInfo&gt; goodsInfos, <span class="keyword">final</span> User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> goodsInfos.stream().filter(</span><br><span class="line">            goodsInfo -&gt; user.getExpectPrice().getKey().compareTo(goodsInfo.getPrice()) &lt;= <span class="number">0</span></span><br><span class="line">                &amp;&amp; user.getExpectPrice().getValue().compareTo(goodsInfo.getPrice()) &gt;= <span class="number">0</span>).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤流程模板方法及实现"><a href="#过滤流程模板方法及实现" class="headerlink" title="过滤流程模板方法及实现"></a>过滤流程模板方法及实现</h3><p>该抽象类主要进行两部分操作：</p><ul><li>实现类注册过滤器实现</li><li><code>filter</code> 方法根据注册的过滤器实现对结果集进行过滤，其中在最后通过工厂方法对结果集生成不同的 <code>Converter</code> 实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractGoodsFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;GoodsFilterHandler&gt; <span class="title function_">goodsFilterHandlers</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">filter</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        List&lt;GoodsFilterHandler&gt; goodsFilterHandlers = goodsFilterHandlers();</span><br><span class="line">        List&lt;GoodsInfo&gt; curGoods = GoodsInfo.getAllGoodsInfo();</span><br><span class="line">        <span class="keyword">for</span> (GoodsFilterHandler handler : goodsFilterHandlers) &#123;</span><br><span class="line">            curGoods = handler.filter(curGoods, user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成不同的 Converter 实现类</span></span><br><span class="line">        <span class="keyword">return</span> GoodsInfoConverterFactory.buildConverter(curGoods).buildVO();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Common 实现</strong></p><p>注册了过滤规则的两个实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonGoodsFilter</span> <span class="keyword">extends</span> <span class="title class_">AbstractGoodsFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;GoodsFilterHandler&gt; <span class="title function_">goodsFilterHandlers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">AgeFilter</span>(), <span class="keyword">new</span> <span class="title class_">ExpectPriceFilter</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换器工厂与实现"><a href="#转换器工厂与实现" class="headerlink" title="转换器工厂与实现"></a>转换器工厂与实现</h3><ul><li><code>buildConverter</code> 方法根据结果集生成不同的实现类</li><li><code>CommonConverter</code> 没有行为</li><li><code>LackConverter</code> 即空对象模式的实现，会在返回的结果集上补充模拟商品（好吧，感觉这个例子有点牵强）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodsInfoConverterFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_GOODS_INFO_LACK_SIZE</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GoodsInfoConverterFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GoodsInfoConverter <span class="title function_">buildConverter</span><span class="params">(List&lt;GoodsInfo&gt; goodsInfos)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtil.isEmpty(goodsInfos) || goodsInfos.size() &lt; DEFAULT_GOODS_INFO_LACK_SIZE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LackConverter</span>(goodsInfos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonConverter</span>(goodsInfos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GoodsInfoConverter</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> List&lt;GoodsInfo&gt; result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">buildVO</span><span class="params">()</span> &#123;</span><br><span class="line">            List&lt;GoodsInfo&gt; res = convert();</span><br><span class="line">            <span class="keyword">return</span> res.stream().map(GoodsInfo::getName).collect(Collectors.toList());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;GoodsInfo&gt; <span class="title function_">convert</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">GoodsInfoConverter</span><span class="params">(<span class="keyword">final</span> List&lt;GoodsInfo&gt; result)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.result = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CommonConverter</span> <span class="keyword">extends</span> <span class="title class_">GoodsInfoConverter</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">CommonConverter</span><span class="params">(<span class="keyword">final</span> List&lt;GoodsInfo&gt; result)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> List&lt;GoodsInfo&gt; <span class="title function_">convert</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LackConverter</span> <span class="keyword">extends</span> <span class="title class_">GoodsInfoConverter</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LackConverter</span><span class="params">(<span class="keyword">final</span> List&lt;GoodsInfo&gt; result)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> List&lt;GoodsInfo&gt; <span class="title function_">convert</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;GoodsInfo&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(result);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> result.size(); i &lt; DEFAULT_GOODS_INFO_LACK_SIZE; i++) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">GoodsInfo</span>(<span class="string">&quot;模拟商品&quot;</span>, <span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>任意构造一个用户，经过过滤器返回其展示的优先级高的商品</p><p>其中根据过滤规则，用户 1 无法满足 &gt;&#x3D; 3 的条件，所以使用了模拟商品进行补位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    user1.setAge(<span class="number">20</span>);</span><br><span class="line">    user1.setExpectPrice(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(BigDecimal.valueOf(<span class="number">10</span>), BigDecimal.valueOf(<span class="number">500</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user2.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    user2.setAge(<span class="number">50</span>);</span><br><span class="line">    user2.setExpectPrice(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(BigDecimal.valueOf(<span class="number">2000</span>), BigDecimal.valueOf(<span class="number">7000</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="type">CommonGoodsFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonGoodsFilter</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [文具, 儿童玩具, 模拟商品]</span></span><br><span class="line">    List&lt;String&gt; res1 = filter.filter(user1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [洗衣机, 笔记本电脑, 扫地机器人, 空调]</span></span><br><span class="line">    List&lt;String&gt; res2 = filter.filter(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调整规则</strong></p><p>可以看到最终空对象的业务逻辑（这里是判断 size 小于阈值，也可以理解为一种空行为）和整个过滤逻辑无关，业务逻辑中也不需要进行判空（工厂方法除外），对于上游 <code>AbstractGoodsFilter</code> 而言，它只是在执行过滤逻辑，而具体结果集并不关心，结果集的转换由空对象实现来实现</p><p>如果产品需求进行变动，当 size 小于 3 时直接抛出异常，则整个大的业务逻辑都不需要变动，只需要改变空对象的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LackConverter</span> <span class="keyword">extends</span> <span class="title class_">GoodsInfoConverter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LackConverter</span><span class="params">(<span class="keyword">final</span> List&lt;GoodsInfo&gt; result)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;GoodsInfo&gt; <span class="title function_">convert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;推荐商品属性 size &lt; &quot;</span> + DEFAULT_GOODS_INFO_LACK_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>上面的例子在使用空对象实现来进行特殊的业务流程，还可以使用空对象模式来对默认行为进行空实现，这样可以减少上游调用的判空代码</p><p>例如 Google 的 <code>ConcurrentLinkedHashMap</code></p><p>在实例化过程中（使用 <code>ConcurrentLinkedHashMap.Builder</code> 对象），<code>listener</code> 参数的默认值就是一个固定的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;</span><br><span class="line">      capacity = -<span class="number">1</span>;</span><br><span class="line">      weigher = Weighers.entrySingleton();</span><br><span class="line">      initialCapacity = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">      concurrencyLevel = DEFAULT_CONCURRENCY_LEVEL;</span><br><span class="line">      <span class="comment">// 默认实现 DiscardingListener.INSTANCE</span></span><br><span class="line">      listener = (EvictionListener&lt;K, V&gt;) DiscardingListener.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在通过 <code>Builder</code> 进行实例化中，真正创建的 <code>ConcurrentLinkedHashMap</code> 对象会根据默认值设置一个通知队列 <code>pendingNotifications</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ConcurrentLinkedHashMap</span><span class="params">(Builder&lt;K, V&gt; builder)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// The notification queue and listener</span></span><br><span class="line">    listener = builder.listener;</span><br><span class="line">    pendingNotifications = (listener == DiscardingListener.INSTANCE)</span><br><span class="line">        ? (Queue&lt;Node&lt;K, V&gt;&gt;) DISCARDING_QUEUE</span><br><span class="line">        : <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;Node&lt;K, V&gt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是默认值则会使用 <code>DISCARDING_QUEUE</code></p><p><code>DISCARDING_QUEUE</code> 就是一种空实现，会丢弃所有的通知（即不通知）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** A queue that discards all entries. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Queue&lt;?&gt; DISCARDING_QUEUE = <span class="keyword">new</span> <span class="title class_">DiscardingQueue</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** A queue that discards all additions and is always empty. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DiscardingQueue</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Object e)</span> &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object e)</span> &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> Object <span class="title function_">poll</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> Object <span class="title function_">peek</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> Iterator&lt;Object&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123; <span class="keyword">return</span> emptyList().iterator(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>空对象模式的优点：</p><ul><li>它可以加强系统的稳固性，能有有效地防止空指针报错对整个系统的影响，使系统更加稳定</li><li>它能够实现对空对象情况的定制化的控制，能够掌握处理空对象的主动权</li><li>它并不依靠 Client 来保证整个系统的稳定运行</li><li>它通过 <code>isNull</code> 对 <code>==null</code> 的替换，显得更加优雅，更加易懂</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://baike.baidu.com/item/%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/22932789?fr=aladdin">空对象模式_百度百科 (baidu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用信鸽解释 HTTPS</title>
      <link href="/%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C/%E7%94%A8%E4%BF%A1%E9%B8%BD%E8%A7%A3%E9%87%8A%20HTTPS.html"/>
      <url>/%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C/%E7%94%A8%E4%BF%A1%E9%B8%BD%E8%A7%A3%E9%87%8A%20HTTPS.html</url>
      
        <content type="html"><![CDATA[<p>密码学是一门深奥难懂的学科，它充满了数学证明；但除非是正在开发密码系统，否则不必了解太多深层次的知识</p><p>如果你打开这篇文章是希望创造下一代 HTTPS 协议，那么很抱歉，只有“鸽子”是远远不够的；如果你的目的不在于此，那么请欣赏这篇文章</p><h1 id="爱丽丝、鲍勃和-……-鸽子？"><a href="#爱丽丝、鲍勃和-……-鸽子？" class="headerlink" title="爱丽丝、鲍勃和 …… 鸽子？"></a>爱丽丝、鲍勃和 …… 鸽子？</h1><p>在互联网上的任何活动（阅读这篇文章、在 Amazon 平台购买商品、上传猫咪图片）归根结底是同服务器发送或者接收消息</p><p>可能听起来有点抽象，所以让我们想象一下这些信息是由<strong>信鸽</strong>（carrier pigeons）传递的，我知道这个比喻看起来很随意，但相信我，HTTPS 的工作方式是一样的，尽管要快得多</p><p>此外，后面会使用爱丽丝、鲍勃、马洛里来代替服务器、用户和黑客；如果这不是你第一次尝试理解密码概念，你会认出这些名字，因为它们在相关技术文献中被广泛使用</p><h1 id="第一次幼稚的交流"><a href="#第一次幼稚的交流" class="headerlink" title="第一次幼稚的交流"></a>第一次幼稚的交流</h1><p>如果爱丽丝想要发送一条消息给鲍勃，她将这条消息绑在信鸽的腿上让它飞向鲍勃；鲍勃收到了消息，看了看觉得非常好</p><p>但是如果马洛里拦截了爱丽丝正在飞行的信鸽随后替换了消息呢？鲍勃无法知道消息在运输的过程中被篡改了</p><p>这就是 <strong>HTTP</strong> 的工作原理，很可怕对吧，我不会通过 HTTP 发送我的银行凭证，你也不会</p><h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><p>如果爱丽丝和鲍勃很狡猾，他们互相定义了一套加密规则来书写消息，例如将字母表中的每一个字母都位移 3 位来表示</p><p>举个例子：D -&gt; A，E -&gt; B，F -&gt; C，原本的消息 “secret message” 将会被替换成 “pbzobq jbppxdb”</p><p>现在如果马洛里拦截了信鸽，她将无法将信息转换为有意义的内容，也无法理解它的意思，因为她不知道加密方式（secret code）；但是鲍勃可以轻易地将消息反向解码，根据 A -&gt; D，B -&gt; E，C -&gt; F 的规则，将 “pbzobq jbppxdb” 解码回 “secret message”</p><p>成功了！</p><p>这就被称为<strong>对称加密</strong>（symmetric key cryptography），因为如果知道了如何解码，就知道了如何加密</p><p>上面描述的密码通常被称为<strong>凯撒密码</strong>（Caesar cipher）；在现实生活中，我们通常使用更为复杂的方式，但主要思想是一样的</p><h1 id="我们如何确定密钥？"><a href="#我们如何确定密钥？" class="headerlink" title="我们如何确定密钥？"></a>我们如何确定密钥？</h1><p>如果除了发送者和接收者之外没有人知道使用了什么密钥，对称加密是非常安全的；在凯撒密码中，密钥是我们将每个字母移动多少个字母的偏移量；在上述示例中，使用了偏移量 3，也可以使用 4 或 12 等等</p><p>这个例子的问题是，如果爱丽丝和鲍勃在开始用鸽子发送消息之前没有见面，他们将无法安全地建立密钥；如果他们将密钥随消息一起发送，那么马洛里就会拦截并发现密钥，这将会导致马洛里在爱丽丝和鲍勃在给消息加密之后依然可以随意获取、篡改消息</p><p>这就是<strong>中间人攻击</strong>（Man in the Middle Attack）的典型示例，避免这种攻击的唯一方法是一起更改加密系统</p><h1 id="信鸽携带的盒子"><a href="#信鸽携带的盒子" class="headerlink" title="信鸽携带的盒子"></a>信鸽携带的盒子</h1><p>所以爱丽丝和鲍勃想出了一个更好的方案，当鲍勃想要向爱丽丝发送消息时，将遵循以下步骤：</p><ul><li>鲍勃给爱丽丝发送一只鸽子，身上不携带任何信息</li><li>爱丽丝让这只鸽子携带一个盒子，盒子有锁而且是打开状态，钥匙在爱丽丝这里，将鸽子返还给鲍勃</li><li>鲍勃将消息放入盒子，锁上锁，并再次将鸽子发给爱丽丝</li><li>爱丽丝获取到盒子，使用自己的钥匙打开盒子后阅读盒子内的消息</li></ul><p>这种方式马洛里在拦截到信鸽后也无法修改内容，因为他并没有盒子的钥匙；当爱丽丝希望给鲍勃发送消息时，遵循同样的流程</p><p>爱丽丝和鲍勃就是使用了通常称为<strong>非对称加密</strong>（asymmetric key cryptography）的技术，之所以称为<strong>不对称</strong>（asymmetric），是因为即使可以对消息进行加密（锁上盒子），也无法解密消息（打开盒子）</p><p>在技术术语中，盒子被称为<strong>公钥</strong>（public key），盒子外锁的钥匙称为<strong>私钥</strong>（private key）</p><h1 id="如何相信这个盒子？"><a href="#如何相信这个盒子？" class="headerlink" title="如何相信这个盒子？"></a>如何相信这个盒子？</h1><p>如果理解了上述内容，会发现依然存在一个问题；当鲍勃接收到盒子时，如何确定这个盒子发送于爱丽丝而不是马洛里拦截了鸽子，将盒子换成了她持有钥匙的盒子呢？</p><p>爱丽丝决定在盒子上签名，这样当鲍勃收到盒子时，他检查签名就可以知道这是不是爱丽丝发送的盒子</p><p>可能会有人这样想，鲍勃一开始是如何识别爱丽丝的签名的？爱丽丝和鲍勃面临同样的问题，所以他们决定，让泰德来代替爱丽丝来进行签名</p><p>谁是泰特？泰德是一个非常有名、知名且值得信赖的人，泰德给任何个人签名，每个人都相信他只会给合法的人签名</p><p>接下来，泰德只有在确定要求签名的人是爱丽丝的情况下才会在爱丽丝盒子上签名；因此马洛里让泰德在自己的盒子上签上爱丽丝的名字，所以会被鲍勃发现这是一个骗局</p><p>在技术术语中，泰德通常被称为<strong>认证机构</strong>（Certification Authority），您阅读本文时使用的浏览器附带了各种认证机构的签名</p><p>所以当我们第一次连接网络并且相信盒子，是因为我们相信泰德，并且泰德告诉我们这个盒子是合法的</p><h1 id="沉重的盒子"><a href="#沉重的盒子" class="headerlink" title="沉重的盒子"></a>沉重的盒子</h1><p>爱丽丝和鲍勃现在有了一个可靠的通信系统，但他们意识到携带盒子的鸽子比只携带信息的鸽子飞行的要慢，因为盒子有一定重量</p><p>所以他们决定，将使用盒子（非对称加密）来加密密钥，而使用对称密码对消息进行加密（还记得凯撒密码吗？）</p><p>这样就可以两全其美：<strong>兼顾非对称密码的可靠性和对称密码的效率</strong></p><p>在现实世界中，没有飞行缓慢的鸽子，但使用非对称加密消息比使用对称加密更慢，因此我们只使用非对称加密来交换加密密钥</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://baida.dev/articles/https-explained-with-carrier-pigeons">HTTPS explained with carrier pigeons</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰模式 - Decorator</title>
      <link href="/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%20-%20Decorator.html"/>
      <url>/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%20-%20Decorator.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>装饰模式（Decorator Pattern）也叫装饰器模式，可以实现在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能；它是通过创建一个包装对象（装饰器），也就是装饰来包裹真实的对象（委托对象）</p><p><strong>目的</strong><br>更灵活地对对象方法进行扩展，也可以使多个装饰器共同作用，装饰器之间也可以任意组合</p><p><strong>现实世界类比</strong><br>嵌入式设备，摄像头通过接口连接计算机，安装合适的驱动和软件，整个硬件环境就可以具备摄影机的功能；而在具备摄影功能的基础上再连接新的设备遥控底盘，就变成了可以移动的摄像车</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>模拟一个场景，需要对对象进行序列化，实现一个序列化工具</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>假设要求序列化方式有多种实现，这个没问题，继承接口进行多实现</p><p>现在要对功能进行拓展，增加对于序列化结果的补充方法（PS.直接改变方法逻辑也是可以的，不过后面代码直接使用的 JSON 实现，不太好设置一个修改方法中间逻辑的例子，所以这样看起来有点像代理模式，后面会有我对于装饰模式和代理模式区别的看法），例如对于结果进行摘要或者输出到文件等操作</p><p>在这样的基础上，想要对原有实现方法进行增强、扩展，就需要创建新的实现类，或者再进行一层抽象来达到目的，那如果我需要即进行摘要又进行文件输出呢？</p><p>可以看出此时存在的问题：</p><ul><li>每次对于方法逻辑的修改可能会变动原有代码</li><li>扩展和扩展之间的乘积关系，需要定义更多的抽象</li><li>无法动态插拔实现</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="序列化器接口"><a href="#序列化器接口" class="headerlink" title="序列化器接口"></a>序列化器接口</h3><p>只定义一个序列化方法，传入对象输出序列化后的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">serialize</span><span class="params">(Object obj)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化器实现"><a href="#序列化器实现" class="headerlink" title="序列化器实现"></a>序列化器实现</h3><p>提供两种不同的实现，一种进行 JSON 序列化，一种调用 <code>toString</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSON 序列化器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonSerializer</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// toString 序列化器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToStringSerializer</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(<span class="keyword">final</span> Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化器装饰"><a href="#序列化器装饰" class="headerlink" title="序列化器装饰"></a>序列化器装饰</h3><p>序列化器装饰可以再抽出一个接口继承序列化器接口，这里因为都可以使用同一个 <code>serialize</code> 方法，就不再定义新的接口了</p><p>同时对于序列化器装饰基类，可以定义为抽象类，再使用模板方法来由后续实现类来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializerDecorator</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Serializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SerializerDecorator</span><span class="params">(<span class="keyword">final</span> Serializer serializer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(<span class="keyword">final</span> Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> serializer.serialize(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="摘要序列化器装饰"><a href="#摘要序列化器装饰" class="headerlink" title="摘要序列化器装饰"></a>摘要序列化器装饰</h3><p>重写 <code>serialize</code> 方法，再获取序列化结果后再进行摘要的计算并返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializerDigestDecorator</span> <span class="keyword">extends</span> <span class="title class_">SerializerDecorator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DigestAlgorithm digestAlgorithm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SerializerDigestDecorator</span><span class="params">(<span class="keyword">final</span> Serializer serializer, DigestAlgorithm digestAlgorithm)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(serializer);</span><br><span class="line">        <span class="built_in">this</span>.digestAlgorithm = digestAlgorithm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(<span class="keyword">final</span> Object obj)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="built_in">super</span>.serialize(obj);</span><br><span class="line">        <span class="comment">// 返回的是序列化后的摘要信息</span></span><br><span class="line">        <span class="keyword">return</span> DigestUtil.digester(digestAlgorithm).digestHex(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件输出序列化器装饰"><a href="#文件输出序列化器装饰" class="headerlink" title="文件输出序列化器装饰"></a>文件输出序列化器装饰</h3><p>重写 <code>serialize</code> 方法，在获取序列化结果后，输出至文件并返回序列化数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializerFileDecorator</span> <span class="keyword">extends</span> <span class="title class_">SerializerDecorator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FileWriter fileWriter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SerializerFileDecorator</span><span class="params">(<span class="keyword">final</span> Serializer serializer, String filePath)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(serializer);</span><br><span class="line">        <span class="built_in">this</span>.fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(filePath));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(<span class="keyword">final</span> Object obj)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="built_in">super</span>.serialize(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入文件</span></span><br><span class="line">        fileWriter.write(s);</span><br><span class="line">        fileWriter.flush();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>装饰器和装饰器之间可以任意、不限次数地嵌套，最终的结果会经过每个装饰器和委托对象的处理</p><p>暴露相关的方法还可以实现动态地更新装饰器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// obj</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JSON 序列化器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Serializer</span> <span class="variable">jsonSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonSerializer</span>();</span><br><span class="line">        System.out.println(jsonSerializer.serialize(student));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 包装 digest 装饰</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Serializer</span> <span class="variable">digestDecorator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SerializerDigestDecorator</span>(jsonSerializer, DigestAlgorithm.SHA1);</span><br><span class="line">        System.out.println(digestDecorator.serialize(student));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 包装 file 装饰</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Serializer</span> <span class="variable">fileDecorator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SerializerFileDecorator</span>(digestDecorator, <span class="string">&quot;./serialize.txt&quot;</span>);</span><br><span class="line">        System.out.println(fileDecorator.serialize(student));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// to string 序列化器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Serializer</span> <span class="variable">toStringSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToStringSerializer</span>();</span><br><span class="line">        System.out.println(toStringSerializer.serialize(student));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 包装 digest 装饰 和 file 装饰</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Serializer</span> <span class="variable">toStringFileDecorator</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SerializerFileDecorator</span>(<span class="keyword">new</span> <span class="title class_">SerializerDigestDecorator</span>(toStringSerializer, DigestAlgorithm.MD5),</span><br><span class="line">                <span class="string">&quot;./serialize2.txt&quot;</span>);</span><br><span class="line">        System.out.println(toStringFileDecorator.serialize(student));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="装饰-amp-代理"><a href="#装饰-amp-代理" class="headerlink" title="装饰 &amp; 代理"></a>装饰 &amp; 代理</h1><p>在这里需要讨论一个问题，装饰模式和代理模式都是对方法进行增强或者扩展，那么它们到底有什么区别？</p><p>网络上也有很多讨论，下面是一些观点和我的看法：</p><ul><li><p><strong>组合、聚合是装饰模式，继承是代理模式</strong><br>看起来有一定道理，感觉装饰模式要想实现嵌套的效果是需要使用组合来实现，但也会存在使用组合来实现的代理模式（静态代理）；是不是从一定角度来看的话，组合、聚合、继承这种结构的选择，和实现什么设计模式并无关系？</p><blockquote><p>The real difference is not ownership (composition versus aggregation), but rather type-information.</p><p><a href="https://stackoverflow.com/questions/18618779/differences-between-proxy-and-decorator-pattern">oop - Differences between Proxy and Decorator Pattern - Stack Overflow</a></p></blockquote></li><li><p><strong>装饰模式用于添加功能，代理模式用于增强功能</strong><br>我觉得不合理，设计模式不应该根据 “规范” 来进行分类，也不会根据模糊的描述来命名</p></li><li><p><strong>装饰模式在执行期间才会由客户端控制，使装饰器和委托对象建立联系，在此之前装饰器类只知道委托对象的接口；代理模式在编译期间就已经知道代理对象的具体信息（无论这个对象是通过代理类方法创建还是通过注入）</strong><br>我认为这个是相较而言最有标志性的区别了；装饰的行为发生在代码执行过程中，无论是创建新的装饰器增强委托类，还是取消委托对象的装饰器，都是动态的；而代理类从一开始就明确了自己的委托类</p><blockquote><p>But a <strong>Proxy</strong> <em>always</em> knows the (more) specific type of the delegatee. In other words, the <strong>Proxy</strong> and its delegatee will have the same base type, but the <strong>Proxy</strong> points to some derived type. A <strong>Decorator</strong> points to its own base type. Thus, the difference is in compile-time information about the type of the delegatee.</p></blockquote></li><li><p><strong>装饰模式的委托对象来自外部，代理模式的委托对象可以自已创建</strong><br>引申于上一个观点，对于 “具体信息” 的了解就决定了代理对象可以直接创建出委托对象</p></li></ul><p>事实上网络上对于装饰模式、代理模式的界定也一直在讨论中，感觉不一定需要关注到底什么是装饰什么是代理，还是能够使用合理的设计解决</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用装饰模式可以更灵活地对对象方法进行扩展</p><ul><li>优点<ul><li>无需创建新子类即可扩展对象的行为</li><li>可以在运行时添加或删除对象的功能</li><li>装饰器可以任意组合</li><li>可以将实现了许多不同行为的一个大类拆分为多个较小的类来满足单一职责原则</li></ul></li><li>缺点<ul><li>虽然可以支持运行时添加或删除对象的功能，但是实际实现起来比较困难（装饰栈）</li><li>装饰栈一定是有序的</li><li>初始化代码变得繁杂</li></ul></li></ul><p><strong>装饰模式的适用环境</strong></p><ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责</li><li>需要动态地给一个对象增加功能，这些功能也可以动态地被撤销</li><li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时<br>不能采用继承的情况主要有两种：第一种是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如 <code>final</code> 类）</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://refactoringguru.cn/design-patterns/decorator">装饰设计（装饰者模式 &#x2F; 装饰器模式） (refactoringguru.cn)</a></p><p><a href="https://stackoverflow.com/questions/18618779/differences-between-proxy-and-decorator-pattern">oop - Differences between Proxy and Decorator Pattern - Stack Overflow</a></p><p><a href="https://www.kancloud.cn/digest/xing-designpattern/143730">设计模式（九）装饰模式（Decorator） · 写最好的设计模式专栏 · 看云 (kancloud.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>啤酒花：你需要知道的知识</title>
      <link href="/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/%E5%95%A4%E9%85%92%E8%8A%B1%EF%BC%9A%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86.html"/>
      <url>/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/%E5%95%A4%E9%85%92%E8%8A%B1%EF%BC%9A%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86.html</url>
      
        <content type="html"><![CDATA[<img src="/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/%E5%95%A4%E9%85%92%E8%8A%B1%EF%BC%9A%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86/hops.jpg" class=""><p>记录显示第一个喝到啤酒的人距今有 9000 年之久，但奇怪的是，人们使用啤酒花为了防腐，或者为了添加风味和香气的历史并不久远</p><p>如今，啤酒中不添加啤酒花是不可思议的行为；它不仅可以保护啤酒的新鲜，也可以丰富啤酒的味道</p><p>本文将介绍你可能不知道的啤酒花知识，现在是时候了解关于家庭酿造的基本原料之一的新东西了</p><h1 id="认识啤酒花"><a href="#认识啤酒花" class="headerlink" title="认识啤酒花"></a>认识啤酒花</h1><h2 id="什么是啤酒花"><a href="#什么是啤酒花" class="headerlink" title="什么是啤酒花"></a>什么是啤酒花</h2><p>啤酒花来自啤酒花植物雌株，也被称为 Humulus Lupulus；它们的形状像一个倒置的绿色松果，啤酒花是这种特殊植物的花朵；奇怪的事实是：酒花不是葡萄藤，它是一个茎，这意味着植物不会用卷须而是用它的嫩枝来攀爬</p><p>酿酒师使用包含在这些花中的精油和树脂，你必须将其叶子剥开，才能得到黄色的蛇麻素腺，在这其中你可以找到添加到啤酒中的物质</p><p>在市场中可以看到啤酒花有很多种包装方式，最常见的是看到它的颗粒或是干花状态；一些人使用啤酒花精油，所以最近有人开发了一种叫做 hop hash 或 hop crack 的蛇麻粉（lupulin powder）来供使用</p><h2 id="为什么需要它们"><a href="#为什么需要它们" class="headerlink" title="为什么需要它们"></a>为什么需要它们</h2><p>一开始啤酒酿酒师在酿造过程中使用啤酒花是为了将啤酒保存更长时间，因为在那个时代，保存食物的方法很少，冰箱还没有发明，所以人们必须找到自然的方法来防止食物和饮料变质，他们尝试了了不同的草本植物和油等物质，但没有效果显著的方法</p><p>在法国一些记载记录了在 9 世纪啤酒酿造过程中开始有啤酒花的加入，德国人也有在 12 世纪开始使用它作为防腐剂的记录，并开始在欧洲和英国推广，在那个时代之前生产的不使用啤酒花的啤酒，现如今被人称为 Gruit 或 Grut</p><p>啤酒花也有助于赋予啤酒独特的香气和风味；它是苦的，有一些方法可以根据啤酒花来衡量啤酒的苦味；根据品种和种植地的不同，啤酒花具有不同的味道和香味，然后将其转移到啤酒中</p><p>啤酒花的苦味与麦芽的甜味形成对比，啤酒花种类和质量的不同会提供出各种各样的物质</p><h2 id="从哪里找到它们"><a href="#从哪里找到它们" class="headerlink" title="从哪里找到它们"></a>从哪里找到它们</h2><p>啤酒花生长需要特殊的环境，它们在纬度 35 到 55 度之间生长最事宜，南北半球维度范围都差不多</p><p>它们更喜欢平坦的地形，此外还会受到寒冷冬季和夏季日照时间长的显著影响，所以最好给它们找个避风的地方；这些情况并不常见，所以在某些国家更有可能发生</p><p>啤酒花最重要的产区位于德国、捷克共和国、美国和英国；美国和德国都是啤酒花的主要生产国，酿酒师倾向于将它们分别称为 “新世界酒花” 和 “旧世界酒花”</p><p>啤酒花们不需要照顾也能蓬勃生长，它们找到了在大自然中生存的方法；当然也有野生啤酒花分布在其他地方，比如澳大利亚，那里并没有专门种植啤酒花的农场</p><h2 id="如何用于啤酒"><a href="#如何用于啤酒" class="headerlink" title="如何用于啤酒"></a>如何用于啤酒</h2><p>在使用啤酒花时，必须将它们分为两个不同的类别</p><p>用于获得苦味的啤酒花 α 酸含量很高，这种特质使啤酒味道更加苦涩，但是它会在香气和风味方面不够精致；要获得啤酒花中的苦味物质并将其作用于啤酒，需要将啤酒花进行煮沸，苦味的程度往往取决于煮沸啤酒花的时间，时间越长苦味物质就会越多</p><p>另一类是香味啤酒花，它们的 α 酸含量较低更依赖精油，这一特质使它们的味道更加独特和美味；为了萃取出啤酒花的香味和风味，需要非常小心地处理，如果花很长时间进行煮沸，将失去它们独特的特性</p><p>也有一些种类的啤酒花具有类似的 α 酸和精油特性，使这两种特性互相平衡</p><p>你不能忘记啤酒花的主要用途，它是啤酒的防腐剂，它们的抗菌能力可以防止产品在没有任何冷藏手段的情况下过快变质；我们现在有更好的方法来保存啤酒，但这并不重要，啤酒花已经成为酿造过程中必不可少的基础；很难相信啤酒花并不是自啤酒酿造历史开始就被使用</p><img src="/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/%E5%95%A4%E9%85%92%E8%8A%B1%EF%BC%9A%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86/Why-are-hops-added-to-beer.jpg" class=""><h2 id="有趣小知识"><a href="#有趣小知识" class="headerlink" title="有趣小知识"></a>有趣小知识</h2><ul><li>啤酒花植物雄株不产生为啤酒提供独特风味和香气所需的精油，这就是为什么啤酒花农场只使用雌株</li><li>啤酒花家族和大麻同属同一科：大麻科（Cannabaceae）；正因如此如果喝太多的话，啤酒会让你流口水是可以理解的（啤酒花的汉语被翻译为蛇麻，译者这么翻译的原因肯定是因为分类学；当然这里应该是作者的玩笑，表达的是对啤酒的喜爱，啤酒花里是没有四氢大麻酚的）</li><li>罗马人过去把啤酒花做成沙拉食用，就像现在人们吃芦笋的方式一样</li><li>你可以给鸡喂食啤酒花，啤酒花适合它们的消化系统，可以防止细菌进入肠道；但是啤酒花并不适合猫和狗，可能对其有毒，导致这些宠物高烧甚至死亡；因此，如果你家里有宠物，请确保啤酒花原料远离它们</li><li>啤酒（beer）和艾尔啤酒（ale）之间的区别一直存在着一场战争，当啤酒花开始成为酿造过程中的一种基本原料时，酿酒师开始将加了啤酒花的啤酒称为 beer，而 ale 称呼的就是不含啤酒花的产品；一些国家禁止在酿造过程中使用啤酒花，在亨利六世（Henry VI）的干预下，他喜欢喝加了啤酒花的啤酒，啤酒花才成为了酿造中必不可少的一环</li></ul><h1 id="啤酒和啤酒花的化学"><a href="#啤酒和啤酒花的化学" class="headerlink" title="啤酒和啤酒花的化学"></a>啤酒和啤酒花的化学</h1><h2 id="什么是-hop-harvest"><a href="#什么是-hop-harvest" class="headerlink" title="什么是 hop harvest"></a>什么是 hop harvest</h2><p>啤酒花必须在特定的时间内收获，一系列因素决定了什么是适合收获的季节，例如球果成熟度和水分含量、天气条件和啤酒花生长过程中的虫害压力等等；一年中收获啤酒花的最佳时间是秋季，即 8 月下旬和 9 月大部分时间</p><p>已有科学研究表明，采收日期对啤酒花品质有着重要影响，推迟收获可能被误认为会获得更好的收益，但事实证明啤酒花可能会失去部分特有的香气，也会缩短它们的存储寿命，氧化可能会加速最终导致啤酒花的挥发性香味消失</p><p>另一方面，过早收获会降低风味并会降低未来收获季节的产量；在有大量啤酒花农场的地区，他们计算出当球果达到 dry matter 的 23% 时是适合的收获时间；根据啤酒花的种类和环境条件的不同，啤酒花种植户每 4 到 7 天就会增加 1% 的 dry matter</p><p>啤酒花上的一些明显变化将提供线索说明是否准备好收割，例如花朵从绿色变为略带黄色的羊皮纸质地、蛇麻素腺也从浅黄色变为深黄色接近橙色；收货时，需要确保球果没有完全变为褐色</p><h2 id="什么让啤酒花味道如此不同"><a href="#什么让啤酒花味道如此不同" class="headerlink" title="什么让啤酒花味道如此不同"></a>什么让啤酒花味道如此不同</h2><p>如上所述，啤酒花的不同风味和香气主要取决于它们生长的地方，不同的天气条件、土壤和种植方式会以不同的形式最终影响啤酒花的特性</p><p>此外，收获的时间也可能会影响啤酒花的风味和香气</p><p>另一个关于味道的重要因素是每种啤酒花中的 α 酸和精油的含量；它们中的大多数在其含量上有所差异，但只有少数品种的啤酒花具有这些物质的平衡，这使它们变得苦涩，但充满独特的味道</p><p>α 酸所占的比重，通常在 2% 至 19% 之间；欧洲人对啤酒花更感兴趣，它们的啤酒花含有 5% 至 9% 的 α 酸；Dual-compound 啤酒花在欧洲更为常见；同时，美国啤酒花品种的 α 酸含量较高，在 8% 至 19% 之间，这会使得这些啤酒花更苦</p><h2 id="啤酒花的品种"><a href="#啤酒花的品种" class="headerlink" title="啤酒花的品种"></a>啤酒花的品种</h2><p>啤酒花有很多种，但它们都可以集中在三种类型：贵族啤酒花（Noble Hops）、美式啤酒花（American Hops）和英式啤酒花（English Hops）</p><p>贵族啤酒花来自德国和捷克共和国，被认为是最经典的啤酒花类型；其中包括 Saaz 和 Tettnanger 等品种，这些类型的啤酒花含有较少的 α 酸，并含有高水平的蛇麻烯精油</p><p>美式啤酒花往往更大胆，而且香味更加明显；它们含有大量的月桂烯精油，这使它们散发出松树和柑橘的香味，可以将 Cascade 和 Centennial 品种分类在这一类别</p><p>最后，英式啤酒花更加精致微妙；它们的月桂烯含量很低，这赋予了它们泥土、木质、草本等味道；与贵族啤酒花和美式啤酒花相比，英式啤酒花只使用在世界各地少量的啤酒品种，但它们对酿造英式啤酒至关重要</p><h2 id="添加的时机"><a href="#添加的时机" class="headerlink" title="添加的时机"></a>添加的时机</h2><p>通常酿酒师在糖化后加入啤酒花，这是谷物从麦芽变成麦芽汁后，需要开始进行煮沸的时候</p><p>当啤酒花和麦芽汁一起煮沸时，会启动一个叫做异构化（isomerisation）的过程；这个操作会将 α 酸转化为 异构的 α 酸（iso-alpha acids）；这一过程使最终产物产生苦味，啤酒花煮沸的时间越久，啤酒就会越苦，所以一般建议啤酒花的煮沸时间不超过 45 分钟</p><p>如果你想更专注于啤酒花风味，你必须减少其煮沸时间；稍后加入啤酒花，让它们沸腾的时间在 15 分钟到 30 分钟之间</p><p>如果啤酒花的香气更重要，那么最好在最后加入，煮沸时间不超过 5 分钟</p><p>一些酿酒师甚至在发酵过程中再加入啤酒花，这种做法被称为干投（dry hopping），包括在麦芽汁冷却后将啤酒花浸泡其中；这种方法可能需要几天甚至几周的时间，但并不是每个人都认为这种做法起到了实质性作用（个人认为，干投的问题在于成本和收益不成正比，只要成本大一定会有收益的）</p><p>对于苦味的测量，有 IBU（International Bitterness Unit） 这一国际统一单位，酿酒师在使用 α 酸时应熟悉这些测量方法</p><p>啤酒公司一般都有能够精确测量苦度值的机器，对于家酿者，可以使用一些公式对 IBU 进行计算（<a href="https://homebrewacademy.com/ibu-calculator/">IBU calculator</a>）</p><h1 id="啤酒花品种入门"><a href="#啤酒花品种入门" class="headerlink" title="啤酒花品种入门"></a>啤酒花品种入门</h1><h2 id="贵族酒花（Noble-x2F-Continental-Hops）"><a href="#贵族酒花（Noble-x2F-Continental-Hops）" class="headerlink" title="贵族酒花（Noble&#x2F;Continental Hops）"></a>贵族酒花（Noble&#x2F;Continental Hops）</h2><p>这种啤酒花品种的啤酒口感细腻、辛辣，具有花香和泥土味，起源于中欧，主要产地是捷克共和国和德国，它们的拉格（lagers）和皮尔森（pilsners）啤酒具有标志性的风味特征，要归功于这种啤酒花品种含有高比例的的蛇麻烯精油（essential oil humulene）</p><p>酿酒师将其描述为辛辣、药草、草本、花香、黑胡椒等味道；四种 α 酸含量低的贵族品种被认为是传统品种，包括：</p><ul><li>德国 - 斯派尔特（German Spalt）</li><li>德国 - 哈拉道（German Hallertau）</li><li>德国 - 泰特昂（German Tettnang）</li><li>德国 - 赫斯布鲁克（Czech Hersbrucker）</li><li>捷克 - 萨兹（Czech Saaz）</li></ul><p>酿酒师通常使用这些具有辛辣、平稳的苦味和花香的啤酒花来制作低 IBU 的啤酒，例如：</p><ul><li>Bohemian Pilsner Urquell</li><li>Samuel Adams Noble Pils</li><li>Trumer Pils</li><li>Czech Saaz characteristics</li></ul><h2 id="英式酒花（English-Hops）"><a href="#英式酒花（English-Hops）" class="headerlink" title="英式酒花（English Hops）"></a>英式酒花（English Hops）</h2><p>这种类型的啤酒花由 15 世纪的法兰德斯（Flanders）开始进口，因为具有优良的防腐特质可以帮助啤酒保持长久的新鲜</p><p>英式酒花类似于欧洲的品种，但具有更多的木质、辛辣、水果味和泥土味，以及较低的月桂烯含量</p><p>酿酒师将这些啤酒花描述为泥土、香草、花香、草本和水果，最常见的类型有：</p><ul><li>福格（Fuggle）</li><li>东肯特郡古丁（East Kent Golding）</li><li>朝圣者（Pilgrim）</li><li>十字燕雀（Bramling Cross）</li><li>塔吉特（Target）</li><li>挑战者（Challenger）</li></ul><p>酿酒师将选择这种啤酒花品种来酿造以下风格：</p><ul><li>Peter’s Best Bitter</li><li>Abbot Ale</li><li>Spitfire’s Amber Kentish Ale</li><li>Timothy Taylor Landlord</li></ul><h2 id="美式酒花（American-Hops）"><a href="#美式酒花（American-Hops）" class="headerlink" title="美式酒花（American Hops）"></a>美式酒花（American Hops）</h2><p>这种酒花品种体积大、更苦、特点鲜明，你可以在市场上找到超过 50 种不同的品种</p><p>大多数美国酿酒师都使用它们来酿造带有树脂、松脂和柑橘味的浅色啤酒</p><p>基本上这些非常芳香的植物是几乎所有美式 IPA （American IPA）的标志，赋予它们明显的香味和苦味；酿酒师通常对这种啤酒花品种的描述包括热带水果、柑橘、葡萄柚、辛辣、树脂和松脂，最受欢迎的美国啤酒花列表包括著名的四个 C：</p><ul><li>奇努克（Chinook）</li><li>卡斯卡特（Cascade）</li><li>哥伦布（Columbus）</li><li>世纪（Centennial）</li></ul><p>你也可以使用更偏向水果风味的品种：</p><ul><li>西楚（Citra）</li><li>西姆科（Simcoe）</li><li>亚麻黄（Amarillo）</li></ul><p>许多美国人喜欢四种 C 酿造的啤酒，特别是：</p><ul><li>Racer 5 IPA</li><li>Sierra Nevada Pale Ale</li><li>Amber IPA</li><li>American West Coast IPA</li><li>Ranger IPA</li></ul><h2 id="新世界酒花（New-World-Hops）"><a href="#新世界酒花（New-World-Hops）" class="headerlink" title="新世界酒花（New World Hops）"></a>新世界酒花（New World Hops）</h2><p>尽管这些啤酒花来自世界各地，但它们都具有相同的热带水果和柑橘风味，现在最流行的是：</p><ul><li>西楚（Citra）：来自美国，带有柑橘、柠檬、菠萝和芒果味道</li><li>埃尔德拉多（El Dorado）：来自美国，带有甜瓜、菠萝等味道</li><li>亚麻黄（Amarillo）：来自美国，带有柑橘和橙子味道</li><li>马赛克（Mosaic）：这种美国啤酒花带有百香果、浆果、柑橘、芒果等味道，还有独特的糖果感觉</li><li>银河（Galaxy）：来自澳大利亚，带有柑橘、热带水果等风味</li><li>莫图伊卡（Motueka）：来自新西兰，具备热带水果、柠檬等风味</li></ul><p>使用这些啤酒花的啤酒很流行，你应该试试：</p><ul><li>Hazy IPA</li><li>NEIPA</li><li>Feral Biggie Juice</li></ul><p>如今全球市场上可用的啤酒花类型几乎无穷无尽；一些数据估计，酿造产业种植了 120 种不同的啤酒花，甚至还有更多的实验品种或许很快就会进入市场</p><img src="/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/%E5%95%A4%E9%85%92%E8%8A%B1%EF%BC%9A%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86/American-hops.jpg" class=""><h1 id="啤酒花的风味"><a href="#啤酒花的风味" class="headerlink" title="啤酒花的风味"></a>啤酒花的风味</h1><blockquote><p>When I read descriptions with flowery language, I find it not just useless—but sometimes misleading. </p></blockquote><p>首先，啤酒花的味道和香气极其复杂，即使是在一个品种中，不同品质的表达也可能是万花筒，也取决于啤酒花的使用方式以及与其他品种的组合；在早些年，识别出许多饮酒者熟悉的主力品种（Cascade - 卡斯卡特、Chinook - 奇努克）就足够了，但是如今已经无法满足现状，那么啤酒厂该如何传达啤酒的味道呢？</p><p>其次，如果直接陈列出味道和香气可能会过于抽象，但如果使用 “椰子” 来进行描述，是我们都可以理解的表达</p><p>为了达到这个目的，Barth-Hass 公司的 Georg Drexler 与一位香水制造商合作，提出了一个啤酒花风味的分类法，描述这项研究的学术论文尚未公开，但 Milk The Funk 发布了 Drexler 的分类方法</p><p>下面是他提出的几个类别，也附带了拥有这种风味、表达比较明显的啤酒花品种（括号内）</p><ul><li><strong>花香（<em>Ella</em>）</strong>：接骨木花、洋甘菊花、山谷百合、茉莉花、苹果花、玫瑰、天竺葵、康乃馨、丁香、薰衣草</li><li><strong>柑橘（<em>Mandarina Bavaria</em>）</strong>：葡萄柚、橙子、青柠、柠檬、佛手柑、柠檬草、姜、橘子</li><li><strong>甜水果（<em>Mosaic</em>）</strong>：香蕉、西瓜、蜜瓜、桃子、杏子、百香果、荔枝、干果、李子、菠萝、樱桃、猕猴桃、芒果、番石榴</li><li><strong>绿色水果（<em>Hallertau Blanc</em>）</strong>：梨、昆斯、苹果、鹅莓、白葡萄酒葡萄</li><li><strong>红浆果（<em>Monroe</em>）</strong>：黑加仑、红加仑、蓝莓、树莓、黑莓、草莓、野生草莓、蔓越莓</li><li><strong>焦糖（<em>Triskel</em>）</strong>：黄油、巧克力、酸奶、蜂蜜、奶油、焦糖、太妃糖、咖啡，香草、冬加豆（Tonka，零陵香豆，<a href="https://www.nosetime.com/xiangshui/116580.html">祖玛珑 馥郁典藏系列-末药与冬加豆</a>）</li><li><strong>木质（<em>Relax</em>）</strong>：烟草、干邑白兰地、橡木、皮革、半圆、香料、没药、树脂、泥土、雪松、松树</li><li><strong>薄荷（<em>Polaris</em>）</strong>：薄荷、柠檬油、樟脑、薄荷醇、葡萄酒酵母</li><li><strong>香草（<em>Columbus</em>）</strong>：爱夫芝、郁金香、罗勒、欧芹、龙蒿、莳萝、茴香、百里香、迷迭香、马郁兰、绿茶、红茶、伴侣茶、鼠尾草</li><li><strong>辛辣（<em>Saazer</em>）</strong>：胡椒、辣椒、咖喱、杜松子、茴香、肉豆蔻、甘草、丁香、生姜面包、茴香籽</li><li><strong>青草（<em>Herkules</em>）</strong>：新鲜切割的草、干草、番茄叶、青椒、荨麻</li><li><strong>植物（<em>Summit</em>）</strong>：芹菜汤、芹菜根、韭菜、洋葱、朝鲜蓟、大蒜、野生大蒜</li></ul><p><em>PS</em>：比较多，风味本身就是一门玄学，当然最标志的热带水果，甚至是核果等还是会体现的很明显</p><img src="/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/%E5%95%A4%E9%85%92%E8%8A%B1%EF%BC%9A%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86/Hop-Flavor-Wheel-sgn.png" class=""><p>flavor wheel 下载地址</p><p><a href="https://peertobeer.net/category/beer-downloads/">Downloads Archives - Peer To Beer</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://homebrewacademy.com/beer-hops/">Beer Hops: All You Need to Know | Homebrew Academy</a></p><p><a href="https://www.beervanablog.com/beervana/2020/1/5/describing-the-flavor-of-hops">Describing the Flavors of Hops — Beervana (beervanablog.com)</a></p><p><a href="https://renegadebrewing.com/hops/">What Are Hops In Beer? (Why Add It?) (renegadebrewing.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 宿醉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 精酿啤酒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Guava RateLimiter</title>
      <link href="/%E5%BC%80%E5%8F%91/%E5%B9%B6%E5%8F%91/Guava%20RateLimiter.html"/>
      <url>/%E5%BC%80%E5%8F%91/%E5%B9%B6%E5%8F%91/Guava%20RateLimiter.html</url>
      
        <content type="html"><![CDATA[<h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><p>限流是保护高并发系统的三把利器之一（限流、缓存、降级）；其目的是通过对并发访问或请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务或进行流量整形</p><p>限流的类型可大致分为：</p><ul><li>限制总并发数 - 数据库连接池、线程池</li><li>限制瞬时并发数 - nginx 的 limitconn 模块、Java Semaphore 限制并发</li><li>限制时间窗口内的平均速率 - Guava 的 RateLimiter</li><li>其他 - 根据网络流量、CPU 占用率、内存占用率等作为标准来进行限流</li></ul><h1 id="桶漏-amp-令牌桶"><a href="#桶漏-amp-令牌桶" class="headerlink" title="桶漏 &amp; 令牌桶"></a>桶漏 &amp; 令牌桶</h1><p>桶漏和令牌桶指的是限流的两种模型，其目的都是限流以达到限制时间窗口内的平均速率的目的</p><p>桶漏是接收请求，并按照一定的速率通过请求</p><p>令牌桶是按照固定的速率生产令牌，请求需要获取对应的令牌才能通过</p><h1 id="RateLimiter"><a href="#RateLimiter" class="headerlink" title="RateLimiter"></a>RateLimiter</h1><p>Guava 是 Java 领域优秀的开源项目，它包含了 Google 在 Java 项目中使用一些核心库</p><p>其中就有限流相关的 <code>RateLimiter</code> 工具，底层基于令牌桶思想，提供了平滑突发限流（SmoothBursty）和平滑预热限流（SmoothWarmingUp）多种实现</p><p>类图属性如下：</p><img src="/%E5%BC%80%E5%8F%91/%E5%B9%B6%E5%8F%91/Guava%20RateLimiter/RateLimiter%E7%B1%BB%E5%9B%BE.png" class=""><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>最终的实现类都是 <code>SmoothRateLimiter</code> 的内部类，但是创建方法放在了更上层的 <code>RateLimiter</code> 中（工厂）</p><p>调用 <code>RateLimiter.create()</code> 静态方法进行创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NO.1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RateLimiter <span class="title function_">create</span><span class="params">(<span class="type">double</span> permitsPerSecond)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> create(SleepingStopwatch.createFromSystemTimer(), permitsPerSecond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NO.2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RateLimiter <span class="title function_">create</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">long</span> warmupPeriod, TimeUnit unit)</span> &#123;</span><br><span class="line">    checkArgument(warmupPeriod &gt;= <span class="number">0</span>, <span class="string">&quot;warmupPeriod must not be negative: %s&quot;</span>, warmupPeriod);</span><br><span class="line">    <span class="keyword">return</span> create(</span><br><span class="line">        SleepingStopwatch.createFromSystemTimer(), permitsPerSecond, warmupPeriod, unit, <span class="number">3.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SmoothBursty</strong></p><p>先看参数列表为 <code>double permitsPerSecond</code> 的方法，<code>SleepingStopwatch.createFromSystemTimer()</code> 创建了一个 <code>SleepingStopwatch</code> 后调用了下一层创建方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> RateLimiter <span class="title function_">create</span><span class="params">(SleepingStopwatch stopwatch, <span class="type">double</span> permitsPerSecond)</span> &#123;</span><br><span class="line">    <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmoothBursty</span>(stopwatch, <span class="number">1.0</span> <span class="comment">/* maxBurstSeconds */</span>);</span><br><span class="line">    rateLimiter.setRate(permitsPerSecond);</span><br><span class="line">    <span class="keyword">return</span> rateLimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SleepingStopwatch</code> 的目的是记录创建时间和计算相对时间，整个 <code>RateLimiter</code> 的时间都是相对创建时间而言的，也就是时间的运算依赖 <code>SleepingStopwatch</code> 对象</p><p><code>new SmoothBursty(stopwatch, 1.0)</code> 的参数除了时间相关的对象，就是 <code>maxBurstSeconds = 1</code> 了，可以看出默认的 <code>SmoothBursty</code> 其应对突发流量的设置是多存储时间为 1s 的许可</p><p>而后调用了 <code>rateLimiter.setRate(permitsPerSecond)</code>，这个先放在后面</p><p><strong>SmoothWarmingUp</strong></p><p>参数列表为 <code>double permitsPerSecond, long warmupPeriod, TimeUnit unit</code> 的方法，先对参数进行了校验，随后也调用了下一层的创建方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> RateLimiter <span class="title function_">create</span><span class="params">(</span></span><br><span class="line"><span class="params">    SleepingStopwatch stopwatch,</span></span><br><span class="line"><span class="params">    <span class="type">double</span> permitsPerSecond,</span></span><br><span class="line"><span class="params">    <span class="type">long</span> warmupPeriod,</span></span><br><span class="line"><span class="params">    TimeUnit unit,</span></span><br><span class="line"><span class="params">    <span class="type">double</span> coldFactor)</span> &#123;</span><br><span class="line">    <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmoothWarmingUp</span>(stopwatch, warmupPeriod, unit, coldFactor);</span><br><span class="line">    rateLimiter.setRate(permitsPerSecond);</span><br><span class="line">    <span class="keyword">return</span> rateLimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程和 <code>SmoothBursty</code> 类似，多了 <code>warmupPeriod</code> 相关的参数，也是用来实现 WarmingUp 的关键参数</p><p>后面也调用了 <code>rateLimiter.setRate(permitsPerSecond)</code></p><h2 id="设置-rate"><a href="#设置-rate" class="headerlink" title="设置 rate"></a>设置 rate</h2><p>rate 的设置关键参数是 <code>permitsPerSecond</code>，这是使用者传入的参数，代表每秒希望生产的许可数量（不一定代表 QPS，因为每次请求许可不一定请求一个）</p><p>调用 <code>RateLimiter</code> 的 <code>setRate</code> 方法进行设置，在每次创建 <code>RateLimiter</code> 时，创建方法在实例化后也会调用一次该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setRate</span><span class="params">(<span class="type">double</span> permitsPerSecond)</span> &#123;</span><br><span class="line">    checkArgument(</span><br><span class="line">        permitsPerSecond &gt; <span class="number">0.0</span> &amp;&amp; !Double.isNaN(permitsPerSecond), <span class="string">&quot;rate must be positive&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex()) &#123; <span class="comment">// 获取锁</span></span><br><span class="line">        doSetRate(permitsPerSecond, stopwatch.readMicros());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先进行参数校验，随后获取锁调用 <code>doSetRate</code> 方法；这里可以进行一个猜想，设置 rate 和获取许可保证并发的锁一定是同一把，看起来统一封装到了 <code>mutex()</code> 方法里，而后调用了 <code>doSetRate</code></p><p><strong>SmoothRateLimiter 的 doSetRate</strong></p><p>在 <code>RateLimiter</code> 中，<code>doSetRate</code> 是一个抽象方法，<code>SmoothRateLimiter </code> 进行了实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doSetRate</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">long</span> nowMicros)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doSetRate</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">    resync(nowMicros);</span><br><span class="line">    <span class="type">double</span> <span class="variable">stableIntervalMicros</span> <span class="operator">=</span> SECONDS.toMicros(<span class="number">1L</span>) / permitsPerSecond;</span><br><span class="line">    <span class="built_in">this</span>.stableIntervalMicros = stableIntervalMicros;</span><br><span class="line">    doSetRate(permitsPerSecond, stableIntervalMicros);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先调用 <code>resync</code> 方法重新计算 <code>this.storedPermits</code> 和 <code>this.nextFreeTicketMicros</code> 这两个重要属性；这是一个常用的方法，在后续流程中会有多个操作都调用该方法，具体实现在后面进行分析</p><p>根据参数 <code>permitsPerSecond</code> 计算出一秒内许可生产的间隔，赋值给 <code>this.stableIntervalMicros</code></p><p>继续调用 <code>doSetRate</code></p><p><strong>SmoothBursty 的 doSetRate</strong></p><p><code>SmoothRateLimiter</code>  的 <code>doSetRate</code> 也是一个抽象方法，<code>SmoothBursty </code> 进行了实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doSetRate</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">double</span> stableIntervalMicros)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doSetRate</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">double</span> stableIntervalMicros)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">oldMaxPermits</span> <span class="operator">=</span> <span class="built_in">this</span>.maxPermits;</span><br><span class="line">    maxPermits = maxBurstSeconds * permitsPerSecond;</span><br><span class="line">    <span class="keyword">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class="line">        <span class="comment">// if we don&#x27;t special-case this, we would get storedPermits == NaN, below</span></span><br><span class="line">        storedPermits = maxPermits;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 等比缩放已经存储的许可数量</span></span><br><span class="line">        storedPermits =</span><br><span class="line">            (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">            ? <span class="number">0.0</span> <span class="comment">// initial state</span></span><br><span class="line">            : storedPermits * maxPermits / oldMaxPermits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要计算了新的 <code>maxPermits</code>，并根据旧的 <code>maxPermits</code>，即 <code>oldMaxPermits</code> 计算了 <code>storedPermits</code> 的值</p><p>相当于设置了新的 <code>permitsPerSecond</code>，需要计算新的 <code>maxPermits</code>，并等比缩放已经存储的许可数量</p><h2 id="获取许可（permits）"><a href="#获取许可（permits）" class="headerlink" title="获取许可（permits）"></a>获取许可（permits）</h2><p>创建 <code>RateLimiter</code> 对象后，使用 <code>acquire</code> 或者 <code>tryAcquire</code> 方法来获取许可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">10</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">sleepTime</span> <span class="operator">=</span> rateLimiter.acquire(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>最终的返回值是等待的时间，并且在返回之前该线程一直在等待</p><p>着重看下 <code>acquire</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> permits)</span> &#123; <span class="comment">// 参数 permits 代表一次需要获取的许可数量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">microsToWait</span> <span class="operator">=</span> reserve(permits); <span class="comment">// 调用 reserve 方法</span></span><br><span class="line">    stopwatch.sleepMicrosUninterruptibly(microsToWait); <span class="comment">// microsToWait &gt; 0 则 sleep</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * microsToWait / SECONDS.toMicros(<span class="number">1L</span>); <span class="comment">// 换算成 s 返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是通过 <code>reserve</code> 方法，返回的是一个需要等待的微秒值 <code>microsToWait</code>，如果大于 0 则进行 sleep 操作（使用的同样是 Guava 包下的 <code>Uninterruptibles</code>，先不关注）</p><p>最终将等待的微秒换算成单位秒返回</p><p><strong>reserve</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserve</span><span class="params">(<span class="type">int</span> permits)</span> &#123;</span><br><span class="line">    checkPermits(permits); <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mutex()) &#123; <span class="comment">// 上锁</span></span><br><span class="line">        <span class="keyword">return</span> reserveAndGetWaitLength(permits, stopwatch.readMicros());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法里主要做了两部分操作</p><ol><li>校验参数 <code>permits</code> 合法性，其实就是是否大于 0 <code>checkArgument(permits &gt; 0, &quot;Requested permits (%s) must be positive&quot;, permits);</code></li><li>使用 <code>synchronized</code> 关键字上锁（<code>mutex</code> 方法返回的是 <code>this.mutexDoNotUseDirectly</code> 一个 <code>Object</code> 对象），上锁后执行 <code>reserveAndGetWaitLength</code> 方法</li></ol><p><strong>reserveAndGetWaitLength</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserveAndGetWaitLength</span><span class="params">(<span class="type">int</span> permits, <span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">momentAvailable</span> <span class="operator">=</span> reserveEarliestAvailable(permits, nowMicros);</span><br><span class="line">    <span class="keyword">return</span> max(momentAvailable - nowMicros, <span class="number">0</span>); <span class="comment">// 计算一下是不是需要 wait</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过方法名 “获取等待长度”，可以知道这里主要是通过 <code>reserveEarliestAvailable</code> 获取一个时间（这个时间在后面的方法中可知是下一次获取许可的时间）后，在次方法最终确认需要等待的时间并返回 <code>max(momentAvailable - nowMicros, 0)</code>，如果不需要等待（<code>momentAvailable - nowMicros &lt; 0</code>），则返回 0</p><p><strong>arliestAvailable</strong></p><p><code>RateLimiter</code> 是一个抽象类，这个方法是一个抽象方法，由 <code>SmoothRateLimiter</code> 进行了实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="type">long</span> <span class="title function_">reserveEarliestAvailable</span><span class="params">(<span class="type">int</span> permits, <span class="type">long</span> nowMicros)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserveEarliestAvailable</span><span class="params">(<span class="type">int</span> requiredPermits, <span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">    resync(nowMicros); <span class="comment">// 重新计算 storedPermits 和 nextFreeTicketMicros</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">returnValue</span> <span class="operator">=</span> nextFreeTicketMicros; <span class="comment">// 保存 nextFreeTicketMicros，因为后面可能会被更新</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">storedPermitsToSpend</span> <span class="operator">=</span> min(requiredPermits, <span class="built_in">this</span>.storedPermits); <span class="comment">// 仓库能提供的许可</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">freshPermits</span> <span class="operator">=</span> requiredPermits - storedPermitsToSpend; <span class="comment">// 这次请求超出仓库能力的许可</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">waitMicros</span> <span class="operator">=</span> <span class="comment">// 等待时间</span></span><br><span class="line">        storedPermitsToWaitTime(<span class="built_in">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class="line">        + (<span class="type">long</span>) (freshPermits * stableIntervalMicros);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros); <span class="comment">// 根据等待时间延长下一次能够获取许可的时间</span></span><br><span class="line">    <span class="built_in">this</span>.storedPermits -= storedPermitsToSpend; <span class="comment">// 调整仓库许可数量；即 freshPermits &gt; 0，storedPermits 一定 = 0</span></span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行就调用了方法 <code>resync()</code>，该方法的目的是重新计算 <code>this.storedPermits</code> 和 <code>this.nextFreeTicketMicros</code> 这两个重要属性</p><p>接下来的几行操作可以概括为：如果需要获取的许可大于当前已经存储的许可，那么计算出超出的许可数量 <code>freshPermits</code>，调用 <code>storedPermitsToWaitTime</code> 方法返回值加上 <code>超出的许可数量 × 许可生产间隔</code> 即可算出需要额外等待的时长；这里对于 <code>SmoothBursty</code> 来说，返回固定是 0，也就是额外的等待时间就是 <code>超出的许可数量 × 许可生产间隔</code></p><p>最后更新这次操作后 <code>this.nextFreeTicketMicros</code> 和 <code>this.storedPermits</code> 的值，返回一开始保存的 <code>this.nextFreeTicketMicros</code></p><p><strong>这里需要思考一个问题</strong>：为什么返回的是 <code>resync</code> 后的 <code>nextFreeTicketMicros</code>？如果令牌数量不够，这个值不是被向后更新了吗？这里就体现出 <code>RateLimiter</code> 整体的一个思想，即每一个请求过来本质上都能拿到许可，无非是等待多长时间才能执行，对于超出部分来说，当前线程不用等待，将这部分时间全部交给下一个线程来进行等待了，我自己概括起来就是 <strong>惰性计算 + 以当前线程为主</strong></p><p><strong>resync</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resync</span><span class="params">(<span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">    <span class="comment">// if nextFreeTicket is in the past, resync to now</span></span><br><span class="line">    <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">newPermits</span> <span class="operator">=</span> (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();</span><br><span class="line">        storedPermits = min(maxPermits, storedPermits + newPermits);</span><br><span class="line">        nextFreeTicketMicros = nowMicros;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的目的是重新计算 <code>this.storedPermits</code> 和 <code>this.nextFreeTicketMicros</code> 这两个重要属性</p><p>如果当前时间超过了之前计算的下一次获取许可的时间，则开始更新：</p><ol><li>先计算新产生的许可数量（<code>coolDownIntervalMicros()</code> 返回的是许可生产的固定间隔）</li><li>更新 <code>this.storedPermits</code> 为合适的值（<code>SmoothBursty</code> 最多只能多存储 1s 的许可）</li><li>更新 <code>this.nextFreeTicketMicros</code> 为参数 <code>nowMicros</code></li></ol><h2 id="预热（WarmingUp）"><a href="#预热（WarmingUp）" class="headerlink" title="预热（WarmingUp）"></a>预热（WarmingUp）</h2><p>上面的分析主要是对 <code>SmoothBursty</code> 进行了分析，还提供了一种实现是 <code>SmoothWarmingUp</code></p><p><code>SmoothWarmingUp</code> 适用于资源需要预热的场景，相比 <code>SmoothBursty</code> 是对突发流量进行保证，通过 <code>maxBurstSeconds</code> 来计算额外存储的令牌数量，<code>SmoothWarmingUp</code> 使用 <code>warmupPeriod</code> 参数来设置预热的时长</p><p>由于预热机制的存在，其生产许可的速度是应该是动态的，如下图</p><img src="/%E5%BC%80%E5%8F%91/%E5%B9%B6%E5%8F%91/Guava%20RateLimiter/%E8%AE%B8%E5%8F%AF%E9%A2%84%E7%83%AD.drawio.png" class="" title="许可预热.drawio"><p>其许可数量越多，说明还没到稳定时期，许可的生产间隔就要越长；许可少说明处于稳定期</p><p><strong>关键属性计算</strong></p><p>根据该图可以计算出一些数值，首先需要确定的是，从 <code>thresholdPermits</code> 到 0 的时间，是从 <code>maxPermits</code> 到 <code>thresholdPermits</code> 时间的一半，也就是梯形的面积是长方形面积的 2 倍，梯形的面积是 <code>warmupPeriod</code></p><p>因为在创建 <code>SmoothWarmingUp</code> 默认的 coldFactor 为 3 <code>SleepingStopwatch.createFromSystemTimer(), permitsPerSecond, warmupPeriod, unit, 3.0);</code> </p><p>梯形面积为 <code>warmupPeriod</code>，而长方形面积为 <code>stableInterval × thresholdPermits</code>，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warmupPeriod = <span class="number">2</span> * stableInterval * thresholdPermits</span><br></pre></td></tr></table></figure><p>由此，我们得出 <code>thresholdPermits</code> 的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thresholdPermits = <span class="number">0.5</span> * warmupPeriod / stableInterval</span><br></pre></td></tr></table></figure><p>然后我们根据梯形面积的计算公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warmupPeriod = <span class="number">0.5</span> * (stableInterval + coldInterval) * (maxPermits - thresholdPermits)</span><br></pre></td></tr></table></figure><p>得出 <code>maxPermits</code> 为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxPermits = thresholdPermits + <span class="number">2.0</span> * warmupPeriod / (stableInterval + coldInterval)</span><br></pre></td></tr></table></figure><p>这样，我们就得到了 <code>thresholdPermits</code> 和 <code>maxPermits</code> 的值</p><p>最后是冷却时间的间隔，对应到图中代表的是斜线的斜率，即由稳定到冷却中的速度；在代码中为：</p><p>该方法 <code>SmoothBursty</code> 的实现始终返回 0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">coolDownIntervalMicros</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> warmupPeriodMicros / maxPermits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>doSetRate</strong></p><p>上面分析了 <code>SmoothBursty</code> 的 <code>doSetRate</code> 实现，这里来看 <code>SmoothWarmingUp</code> 的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doSetRate</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">double</span> stableIntervalMicros)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">oldMaxPermits</span> <span class="operator">=</span> maxPermits;</span><br><span class="line">    <span class="type">double</span> <span class="variable">coldIntervalMicros</span> <span class="operator">=</span> stableIntervalMicros * coldFactor; <span class="comment">// coldFactor 是固定的 3</span></span><br><span class="line">    thresholdPermits = <span class="number">0.5</span> * warmupPeriodMicros / stableIntervalMicros;</span><br><span class="line">    maxPermits =</span><br><span class="line">        thresholdPermits + <span class="number">2.0</span> * warmupPeriodMicros / (stableIntervalMicros + coldIntervalMicros);</span><br><span class="line">    slope = (coldIntervalMicros - stableIntervalMicros) / (maxPermits - thresholdPermits); <span class="comment">// 计算斜率，对边 / 临边</span></span><br><span class="line">    <span class="keyword">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class="line">        <span class="comment">// if we don&#x27;t special-case this, we would get storedPermits == NaN, below</span></span><br><span class="line">        storedPermits = <span class="number">0.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        storedPermits =</span><br><span class="line">            (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">            ? maxPermits <span class="comment">// initial state is cold</span></span><br><span class="line">            : storedPermits * maxPermits / oldMaxPermits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是计算了相关的属性并赋值给成员变量，计算方法都和上图一致</p><p><strong>acquire 的 storedPermitsToWaitTime</strong></p><p><code>acquire</code> 流程和 <code>SmoothBursty</code> 基本一致，区别在于 <code>storedPermitsToWaitTime</code> 方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserveEarliestAvailable</span><span class="params">(<span class="type">int</span> requiredPermits, <span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">    resync(nowMicros);</span><br><span class="line">    <span class="type">long</span> <span class="variable">returnValue</span> <span class="operator">=</span> nextFreeTicketMicros;</span><br><span class="line">    <span class="type">double</span> <span class="variable">storedPermitsToSpend</span> <span class="operator">=</span> min(requiredPermits, <span class="built_in">this</span>.storedPermits);</span><br><span class="line">    <span class="type">double</span> <span class="variable">freshPermits</span> <span class="operator">=</span> requiredPermits - storedPermitsToSpend;</span><br><span class="line">    <span class="type">long</span> <span class="variable">waitMicros</span> <span class="operator">=</span></span><br><span class="line">        storedPermitsToWaitTime(<span class="built_in">this</span>.storedPermits, storedPermitsToSpend) <span class="comment">// 在于这里的方法</span></span><br><span class="line">        + (<span class="type">long</span>) (freshPermits * stableIntervalMicros);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);</span><br><span class="line">    <span class="built_in">this</span>.storedPermits -= storedPermitsToSpend;</span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>waitMicros</code> 由两部分组成，一部分是从 <code>storedPermits</code> 中获取花费的时间，一部分是等待 <code>freshPermits</code> 产生花费的时间；<code>SmoothBursty</code> 的该方法实现固定返回 0，即不存在从 <code>storedPermits</code> 获取许可的花费，而 <code>SmoothWarmingUp</code> 实现较为复杂</p><p>由于需要预热，所以从存储的许可中中取许可需要花费一定的时间，其实就是要计算下图中，阴影部分的面积</p><img src="/%E5%BC%80%E5%8F%91/%E5%B9%B6%E5%8F%91/Guava%20RateLimiter/%E8%AE%B8%E5%8F%AF%E9%A2%84%E7%83%AD%E8%8E%B7%E5%8F%96%E8%AE%B8%E5%8F%AF.drawio.png" class="" title="许可预热获取许可.drawio"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">storedPermitsToWaitTime</span><span class="params">(<span class="type">double</span> storedPermits, <span class="type">double</span> permitsToTake)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">availablePermitsAboveThreshold</span> <span class="operator">=</span> storedPermits - thresholdPermits;</span><br><span class="line">    <span class="type">long</span> <span class="variable">micros</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// measuring the integral on the right part of the function (the climbing line)</span></span><br><span class="line">    <span class="comment">// 如果右边梯形部分有 permits，那么先从右边部分获取 permits，计算梯形部分的阴影部分的面积</span></span><br><span class="line">    <span class="keyword">if</span> (availablePermitsAboveThreshold &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="comment">// 从右边部分获取的 permits 数量</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">permitsAboveThresholdToTake</span> <span class="operator">=</span> min(availablePermitsAboveThreshold, permitsToTake);</span><br><span class="line">        <span class="comment">// TODO(cpovirk): Figure out a good name for this variable.</span></span><br><span class="line">        <span class="comment">// 梯形面积公式：(上底 + 下底) × 高 / 2</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">length</span> <span class="operator">=</span> permitsToTime(availablePermitsAboveThreshold)</span><br><span class="line">            + permitsToTime(availablePermitsAboveThreshold - permitsAboveThresholdToTake);</span><br><span class="line">        micros = (<span class="type">long</span>) (permitsAboveThresholdToTake * length / <span class="number">2.0</span>);</span><br><span class="line">        permitsToTake -= permitsAboveThresholdToTake;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// measuring the integral on the left part of the function (the horizontal line)</span></span><br><span class="line">    <span class="comment">// 加上长方形部分的阴影面积</span></span><br><span class="line">    micros += (stableIntervalMicros * permitsToTake);</span><br><span class="line">    <span class="keyword">return</span> micros;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于给定的 x 值，计算 y 值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> <span class="title function_">permitsToTime</span><span class="params">(<span class="type">double</span> permits)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> stableIntervalMicros + permits * slope;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终将这部分等待时间返回，达到预热等待的目的</p><h1 id="重点问题"><a href="#重点问题" class="headerlink" title="重点问题"></a>重点问题</h1><h2 id="许可从哪来"><a href="#许可从哪来" class="headerlink" title="许可从哪来"></a>许可从哪来</h2><p>经过上面的分析，可以得出，所谓的许可是惰性的运算，并不是表面理解的可能存在一个线程在生产许可，而是当请求进入时才会计算许可相关的数据（下一次许可时间、存储的许可数量、满足当前请求许可需要等待的时间等），然后对该请求行为进行处理</p><h2 id="并发安全是如何保证的"><a href="#并发安全是如何保证的" class="headerlink" title="并发安全是如何保证的"></a>并发安全是如何保证的</h2><p>并发主要出现在两个地方，<code>setRate</code> 设置速率方法和 <code>acquire</code> 获取许可方法内，并且这两个方法也互斥</p><p>关键的方法在 <code>reserve()</code> 内</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserve</span><span class="params">(<span class="type">int</span> permits)</span> &#123;</span><br><span class="line">    checkPermits(permits);</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex()) &#123;</span><br><span class="line">        <span class="keyword">return</span> reserveAndGetWaitLength(permits, stopwatch.readMicros());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么着重关注 <code>mutex()</code> 返回了什么对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Can&#x27;t be initialized in the constructor because mocks don&#x27;t call the constructor.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Object mutexDoNotUseDirectly;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">mutex</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">mutex</span> <span class="operator">=</span> mutexDoNotUseDirectly;</span><br><span class="line">    <span class="keyword">if</span> (mutex == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            mutex = mutexDoNotUseDirectly;</span><br><span class="line">            <span class="keyword">if</span> (mutex == <span class="literal">null</span>) &#123;</span><br><span class="line">                mutexDoNotUseDirectly = mutex = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mutex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会有几个疑问与答案：</p><ul><li><code>Object mutex = mutexDoNotUseDirectly</code> 为什么不直接操作 <code>this.mutexDoNotUseDirectly</code>，要使用一个临时变量</li><li><code>mutexDoNotUseDirectly</code> 锁对象的创建有必要使用懒汉式吗？<code>RateLimiter</code> 在实例化后直接执行了 <code>reserve</code> 方法，那么这个懒加载的单例意义是什么</li><li>为什么不使用 <code>synchronized (this)</code>，包装了一个方法 <code>mutex()</code> 来返回锁对象</li></ul><p><strong>第一个问题</strong>：减少 <code>volatile</code> 对内存的读请求；<code>mutexDoNotUseDirectly</code> 是可见的，每次读取都会访问内存，使用临时变量对于不需要可见性的场景能减少访问内存的次数</p><blockquote><p>It avoids an additional volatile read of the field once it’s determined to be non-null.<br>详见 issue：<a href="https://github.com/google/guava/issues/3381">https://github.com/google/guava/issues/3381</a></p></blockquote><p><strong>第二个问题</strong>：源代码注释中也已经解释了目的：<code>// Can&#39;t be initialized in the constructor because mocks don&#39;t call the constructor.</code></p><p>作者是考虑到使用 Mockito 框架时，用 mock 方法创建 <code>RateLimiter</code> 的 mock 对象不会执行其构造器，该锁对象不会被实例化；并且成员变量直接赋值也会被解释为构造器的一部分</p><blockquote><p>Inline field initialization is syntactic sugar for initializing from the constructor.<br>详见 issue：<a href="https://github.com/google/guava/issues/3066">https://github.com/google/guava/issues/3066</a></p></blockquote><p><strong>第三个问题</strong>：更方便控制锁粒度，并且避免使用 <code>this</code> 作为锁对象是一种规范，因为无法得知外部是否也是用 <code>this</code> 作为锁来使用</p><blockquote><p>可以参考该回答：<a href="https://stackoverflow.com/questions/12397427/what-is-different-between-method-synchronized-vs-object-synchronized">https://stackoverflow.com/questions/12397427/what-is-different-between-method-synchronized-vs-object-synchronized</a></p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/60979444">超详细的Guava RateLimiter限流原理解析 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/egg1996911/article/details/103928573">Guava限流器RateLimiter中mutexDoNotUseDirectly&#x2F;锁的使用_DengDengLei的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/shenchaohao12321/article/details/112143092">RateLimiter 源码分析(Guava 和 Sentinel 实现)_一直不懂的博客-CSDN博客_sentinel ratelimiter</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> Guava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象创建与属性设置</title>
      <link href="/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE.html"/>
      <url>/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在 Spring 框架和 MVC 三层模式下，对于创建一个对象并对属性进行赋值的操作不需要复杂的设计</p><p>代码中创建的对象往往是一个 “贫血模型”，只用来充当数据的传递者</p><p>应该根据不同的类及其功能选择合适的对象创建方式</p><h1 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h1><h2 id="set-方法"><a href="#set-方法" class="headerlink" title="set 方法"></a>set 方法</h2><p>最常见的方式；创建对象后，使用 set 方法来对属性进行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">student.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">student.setAge(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><h2 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h2><p>对需要赋值的属性设置为有参构造中的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String alias;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用上使用有参构造器来创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h2 id="链式赋值"><a href="#链式赋值" class="headerlink" title="链式赋值"></a>链式赋值</h2><p>将 set 方法改造，将 <code>this</code> 对象返回达成链式赋值的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String alias;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">name</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">alias</span><span class="params">(String alias)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.alias = alias;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">age</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建对象和赋值操作更流畅</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>().name(<span class="string">&quot;张三&quot;</span>).age(<span class="number">20</span>).alias(<span class="string">&quot;张三三&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>Lombok</strong></p><p>Lombok 的 <code>@Accessors(chain = true, fluent = true)</code> 注解可以生成类似的模板代码；该注解主要是对 Bean 方法（<code>@Getter</code> 和 <code>@Setter</code>）的生成进行进一步的配置</p><p><code>@Accessors</code> 的参数：</p><ul><li>fluent - 为 true 时生成的 set 方法名称不会带上 <code>set</code> 前缀，即以变量名作为方法名</li><li>chain - 为 true 时生成的 set 方法会以当前对象作为返回值，达到链式赋值的效果</li><li>prefix - 过滤固定前缀的变量，不对所配置前缀的变量生成 set 方法</li></ul><h2 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h2><p>可以称为生成器设计模式</p><p>创建出一个 <code>Builder</code> 生成器来对对象的创建进行管理</p><p><code>Builder</code> 可以对创建对象过程中的流程进行优化，减少选配参数，可以在创建前就对属性进行校验（优点就是生成器模式的优点）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String alias;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StudentBuilder <span class="title function_">builder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StudentBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String alias;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">name</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">alias</span><span class="params">(String alias)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.alias = alias;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">age</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Student <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="comment">// name 和 age 必须赋值</span></span><br><span class="line">          <span class="comment">// 如果 alias 设置了，则以设置的值为准；如果没有设置则使用 name</span></span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">            student.setName(Assert.notBlank(<span class="built_in">this</span>.name));</span><br><span class="line">            student.setAge(Assert.notNull(<span class="built_in">this</span>.age));</span><br><span class="line">            student.setAlias(Optional.ofNullable(<span class="built_in">this</span>.alias).orElse(<span class="built_in">this</span>.name));</span><br><span class="line">            <span class="keyword">return</span> student;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>builder()</code> 方法创建生成器，对生成器赋值后调用 <code>build()</code> 方法创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> Student.builder().name(<span class="string">&quot;张三&quot;</span>).age(<span class="number">20</span>).build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// build 方法调用之前其实是一个 Builder 对象</span></span><br><span class="line"><span class="type">StudentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Student.builder().name(<span class="string">&quot;张三&quot;</span>).age(<span class="number">20</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> builder.build();</span><br></pre></td></tr></table></figure><p><strong>Lombok</strong></p><p>Lombok 中使用 <code>@Builder</code> 注解可以自动生成模板代码</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>set 方法</td><td>简单直接</td><td>写法繁杂；无法从整体控制变量赋值情况</td></tr><tr><td>有参构造</td><td>对属性赋值进行有力约束</td><td>不灵活，如果最终对象种类多会出现多个不同参数的有参构造器，或者大而全参数的构造器</td></tr><tr><td>链式赋值</td><td>写法流畅</td><td>简单的优化，但是也只解决了写法繁杂的问题</td></tr><tr><td>Builder</td><td>功能强大可扩展</td><td>过程中会创建更多对象；实现复杂</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/weixin_45796051/article/details/121946894">https://blog.csdn.net/weixin_45796051/article/details/121946894</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RECIPES - Crimson Sour</title>
      <link href="/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/RECIPES%20-%20Crimson%20Sour.html"/>
      <url>/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/RECIPES%20-%20Crimson%20Sour.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://assets-prd.punchdrink.com/wp-content/uploads/2022/09/14141915/Article-lactic-syrup-800x450.jpg" alt="Article-lactic-syrup-800x450.jpg (800×450) (punchdrink.com)"></p><h1 id="深红酸酒-Crimson-Sour"><a href="#深红酸酒-Crimson-Sour" class="headerlink" title="深红酸酒 Crimson Sour"></a>深红酸酒 Crimson Sour</h1><p><a href="https://punchdrink.com/recipes/crimson-sour/">Crimson Sour Vermouth Cocktail Recipe | PUNCH (punchdrink.com)</a></p><blockquote><p>Sour 作为名词直接有”酸味鸡尾酒“的意思</p><p>a drink made from strong alcohol, lemon, or lime juice, sugar, and ice</p><p>Whisky Sour 威士忌酸味鸡尾酒</p></blockquote><p>娜塔莎 · 大卫在她的书 <em>Drink Lightly</em> 中建议大家制作这杯鸡尾酒时使用大量应季的柑橘类水果</p><p>新鲜的血橙是这场秀的明星，“除了看起来光彩照人之外，它还拥有美丽的甜味，并且具有一种令人陶醉的、几乎熟透了的覆盆子味道”</p><h2 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h2><p><em>Serving: 1</em></p><ul><li>浓烈的甜味美思 - 1.5 盎司（<a href="https://www.diffordsguide.com/beer-wine-spirits/7232/lejon-sweet-vermouth">LeJon Sweet Vermouth</a>）</li><li>新鲜柠檬汁 - 0.75 盎司</li><li>新鲜血橙汁 - 0.75 盎司</li><li>可可豆碎金巴利 - 0.5 盎司（见注释）</li><li>香草乳酸糖浆 - 0.5 盎司（见注释）</li></ul><p><strong>装饰：</strong>血橙半圆切片（crescent）、柠檬轮</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>将所有原料和冰块混合，进行短暂的 shake</li><li>滤入装满碎冰的双层岩石杯（Double Rocks glass）；顶部补充更多的碎冰，像雪堆一样</li><li>使用血橙半圆切片和柠檬轮进行装饰，插上吸管</li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="可可豆碎金巴利（Cacao-Nib-Campari）"><a href="#可可豆碎金巴利（Cacao-Nib-Campari）" class="headerlink" title="可可豆碎金巴利（Cacao Nib Campari）"></a>可可豆碎金巴利（Cacao Nib Campari）</h3><ul><li>可可豆碎 - 25 克</li><li>金巴利 - 750 毫升</li></ul><p>将可可豆碎铺在烤盘，烘烤 3 到 4 分钟直到产生香味并变为深棕色</p><p>冷却后倒入一个可以密封的容器中与金巴利混合，盖上盖子静置 24 个小时，使用滤网（chinoise）过滤后装瓶冷藏</p><h3 id="香草乳酸糖浆（Vanilla-Lactic-Syrup）"><a href="#香草乳酸糖浆（Vanilla-Lactic-Syrup）" class="headerlink" title="香草乳酸糖浆（Vanilla Lactic Syrup）"></a>香草乳酸糖浆（Vanilla Lactic Syrup）</h3><ul><li>基础糖浆 - 500 克（糖水比 1:1）</li><li>Tahitian 香草提取物 - 4 克（<a href="https://www.amazon.com/-/zh/dp/B004QQ7YVM/ref=sr_1_1?__mk_zh_CN=%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%BD%91%E7%AB%99&crid=3JYYCZAUEANB5&keywords=Tahitian+vanilla+extract&qid=1672675608&sprefix=chinoise,aps,776&sr=8-1">Amazon.com: Cook’s Pure South Pacific Vanilla Extract 4 oz</a>）</li><li>乳酸粉 - 2 克</li><li>犹太盐（kosher salt） - 1 pinch</li></ul><blockquote><p>Kosher salt</p><p>Kosher salt 指的是完全不加碘盐，并且盐的晶体颗粒会比一般的盐要大一些</p><p>一般的食盐中都会加碘，这样会让盐带有碘的味道，也会影响到菜肴最终的味道，使用 Kosher salt 就不会有这些问题</p><p>另外，Kosher salt 由于晶体颗粒更大，能够更有效地从肉类中吸收水分，能够更好地帮助肉类进行符合犹太人教规处理（除去血液），这种处理后的食物称之为 Kosher food，这也是 Kosher salt 名字的由来</p></blockquote><blockquote><p>1 pinch</p><p>翻译为一撮</p><p>a pinch of salt 往往也表示 “不可尽信”</p><p>take … with a pinch of salt “对 … 不可尽信、持保留意见”</p></blockquote><p>在一个碗中混合糖浆、香草精、乳酸粉和盐</p><p>使用搅拌器搅拌，直到乳酸和盐溶解；倒入密封容器中冷藏 4 周</p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 宿醉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸡尾酒 </tag>
            
            <tag> recipes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES 的限制和疑难问题</title>
      <link href="/%E5%BC%80%E5%8F%91/ES/ES%20%E7%9A%84%E9%99%90%E5%88%B6%E3%80%81%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98.html"/>
      <url>/%E5%BC%80%E5%8F%91/ES/ES%20%E7%9A%84%E9%99%90%E5%88%B6%E3%80%81%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<blockquote><p> <em><strong>Programmers know the benefits of everything and the tradeoffs of nothing.</strong></em></p><p><em>程序员知道任何事情的收益，却不去权衡利弊</em></p><p><a href="https://www.simplethread.com/relational-databases-arent-dinosaurs-theyre-sharks/">Relational Databases Aren’t Dinosaurs, They’re Sharks - Simple Thread</a></p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>使用关系型数据的思想去操作 ES，会发现很多功能的实现和想象中有出入</p><p>或者 ES 能够实现很多操作，但同时又有很多限制，在解决了一些问题基础上（天然分布式适合大数据量、top hit 这种方便的功能、模糊搜索分词器），是否也引入了一些新问题</p><p>记录下 ES 难以处理的问题以及当前的处理方法，是否可以有更好的处理方式，或者选型中避免处理此类问题</p><h1 id="深度分页"><a href="#深度分页" class="headerlink" title="深度分页"></a>深度分页</h1><p>ES 作为天然的分布式系统，数据分散至各个 shard 进行存储</p><p>带来的问题就是随着分页深度的增加，成本的增加也会更加明显</p><p>ES 假设一页有 100 条数据，需要查询第 100 页数据（即 from &#x3D; 9900，size &#x3D; 100），那么对于每一个节点都需要查询 10000 条数据，汇总给协调节点后，再有协调节点排序，最终选取真实命中的 100 条数据返回</p><p>所以对于深度分页 ES 进行了限制，默认的配置是 from + size &lt; 10000，大于限制的查询操作会被拒绝</p><p><strong>现在是怎么处理的</strong></p><p>没有好的办法，限制跳页的深度，如果需要查询更精准的数据就增加查询条件来缩小范围</p><p>业务绝大多数场景应该也没有查看这么多页数据的必要</p><p>可以使用 search after、scroll 避免深度分页限制，但是都有各自场景的限制</p><h1 id="索引刷新间隔"><a href="#索引刷新间隔" class="headerlink" title="索引刷新间隔"></a>索引刷新间隔</h1><p>索引下会有一个参数值 <code>refresh_interval</code>，表示 ES 刷新索引的间隔</p><p>刚进行索引的文档并不会立即对搜索可见，而是满足一定的要求后才会将 buffer 中的数据建立索引写入文件区，其中 <code>refresh_interval</code> 参数指定一定的时间间隔后将数据进行索引</p><p><code>refresh_interval</code>  的单位：</p><ul><li>ms</li><li>s</li><li>m</li></ul><p>单位缺省值为 ms，如果配置为 <code>-1</code> 则表示不刷新索引，当需要导出大量数据时，可以将 <code>refresh_interval</code> 设置为 <code>-1</code> 加快导入速度，导入完成后再设置刷新间隔或者手动刷新</p><p><strong>设置 refresh_interval</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT /<span class="punctuation">&#123;</span>index<span class="punctuation">&#125;</span>/_settings</span><br><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">  <span class="attr">&quot;refresh_interval&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1s&quot;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>强制刷新</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST <span class="punctuation">&#123;</span>index<span class="punctuation">&#125;</span>/_doc?refresh</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>现在是怎么处理的</strong></p><p>根据业务情况合理设置刷新间隔，需要兼顾 ES 压力和数据实时性要求，暂时配置的 500 ms</p><p>但是 scroll + update by doc id 的更新方式是否会因为 scroll 的快照特性和索引刷新时间问题而导致数据错误？这种情况怎么避免</p><p>不及时刷新也会导致 update by query 操作冲突</p><h1 id="根据条件更新-update-by-query"><a href="#根据条件更新-update-by-query" class="headerlink" title="根据条件更新 update by query"></a>根据条件更新 update by query</h1><p>update by query 操作看起来类似 SQL 中的 <code>UPDATE FROM ... SET ... WHERE ...</code>，但使用起来也有很多限制</p><p>更新内容使用 script 指定，例如，姓名为 <code>张三</code> 的数据 age + 1 </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST my-index/_update_by_query</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;script&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctx._source.age++&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lang&quot;</span><span class="punctuation">:</span> <span class="string">&quot;painless&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>因为 ES 的锁机制比较简单，对于冲突只能选择两种操作</p><blockquote><p><strong><code>conflicts</code></strong></p><p>(Optional, string) What to do if update by query hits version conflicts: <code>abort</code> or <code>proceed</code>. Defaults to <code>abort</code>.</p></blockquote><p>同时需要进行手动刷新，否则可能会频繁冲突</p><blockquote><p><strong><code>refresh</code></strong></p><p>(Optional, Boolean) If <code>true</code>, Elasticsearch refreshes affected shards to make the operation visible to search. Defaults to <code>false</code>.</p></blockquote><p>此外，ES 客户端和服务端是通过 REST 进行交互，连接时间是存在限制的，默认是 30 s</p><p>当脚本具有一定的处理逻辑，并且数据量较大，很有可能在限制时间内没有处理完成，就会抛出超时异常</p><p><strong>现在是怎么处理的</strong></p><p>配置连接时间，减少更新的文档数量，每次写入都进行更新</p><h1 id="list-字段增删元素"><a href="#list-字段增删元素" class="headerlink" title="list 字段增删元素"></a>list 字段增删元素</h1><p>ES mapping 中字段是不限制元素数量的（感觉和索引的实现方式有关）</p><p>例如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /my-index/_mapping</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;my-index&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;field_1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;field_2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>数据可以是</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;field_1&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;field_2&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>那么在更新 list 字段时就需要考虑更新方式，如果是刷新文档进行覆盖，会不会出现数据错误？</p><p>假设一个操作要给字段增加一个元素 1，而另一个操作要删除元素 2</p><table><thead><tr><th align="center">时间</th><th align="center">线程 1</th><th align="center">线程 2</th></tr></thead><tbody><tr><td align="center">T1</td><td align="center">查询文档数据 doc，得到 field &#x3D; [2,3]</td><td align="center">&#x2F;</td></tr><tr><td align="center">T2</td><td align="center">处理得知，需要写入的数据 field &#x3D; [1,2,3]</td><td align="center">查询文档数据 doc，得到 field &#x3D; [2,3]</td></tr><tr><td align="center">T3</td><td align="center">写入 ES，field &#x3D; [1,2,3]</td><td align="center">处理得知，需要写入的数据 field &#x3D; [3]</td></tr><tr><td align="center">T4</td><td align="center">&#x2F;</td><td align="center">写入 ES，field &#x3D; [3]</td></tr></tbody></table><p>最终导致数据错误（没有 DB 的锁机制那么方便）</p><p><strong>update by query</strong></p><p>当然可以使用 update by query 来使用脚本进行操作，相当于把一部分运算逻辑放在了 ES 来执行</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST my-index/_update_by_query</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;script&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;if(ctx._source.projectIds == null)&#123;ctx._source.projectIds = [];ctx._source.projectIds.add(params.id);&#125;else&#123;def index = ctx._source.projectIds.indexOf(params.id);if(index == -1)&#123;ctx._source.projectIds.add(params.id);&#125;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lang&quot;</span><span class="punctuation">:</span> <span class="string">&quot;painless&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>现在是怎么处理的</strong></p><p>使用 update by query 脚本进行增删，配置连接时间，限制更新的数据量（时间作为条件）</p><h1 id="折叠、聚合不支持滚动查询"><a href="#折叠、聚合不支持滚动查询" class="headerlink" title="折叠、聚合不支持滚动查询"></a>折叠、聚合不支持滚动查询</h1><p>scroll，search after 可以不受深度分页的限制，现在的客户端对于 scroll 操作包装的比较简单（没法指定数据集 size），并且一次性取出所有数据进入内存</p><p>所以使用 search after 来实现对更大量数据的查询（导出）</p><p>但折叠（Collapse）和聚合（Aggregations）操作无法支持 scroll 或者 search after 的查询方式</p><p><strong>现在是怎么处理的</strong></p><p>对于折叠或者聚合的数据使用分页进行查询，无法避免深度分页的限制</p><h1 id="聚合桶数量限制"><a href="#聚合桶数量限制" class="headerlink" title="聚合桶数量限制"></a>聚合桶数量限制</h1><p>ES 的聚合从功能上可以分为 3 类：</p><ul><li>桶聚合（Bucket）：对数据进行分组（分桶）；类似 <code>GROUP BY</code><ul><li>Date histogram 日期直方图</li><li>Range 范围</li><li>Terms 字段值</li><li>…</li></ul></li><li>指标聚合（Metric）：对桶内数据进行指标的计算；类似聚合函数<ul><li>Avg 平均数</li><li>Max 最大值</li><li>Sum 求和</li><li>…</li></ul></li><li>管道聚合（Pipeline）：以其他聚合作为元数据的聚合；相当于在其他聚合的基础上再次进行操作<ul><li>Bucket selector 桶选择器</li><li>Bucket sort 桶排序</li><li>Max bucket 最大的桶</li><li>…</li></ul></li></ul><p>桶聚合中最常见的场景就是根据字段值进行分桶（相当于 <code>GROUP BY</code> 多个字段）</p><p>但是 ES 中对于桶的数量是有限制的，当一次请求超过桶数量限制（默认为 <code>123</code>），则查询会返回错误  <code>trying to create too many buckets. must be less than or equal to: [100000] but was [100001]</code></p><p>这是 6.x 以后版本的特性， 目的是限制大批量聚合操作， 规避性能风险</p><p>当然可以进行配置，但也就意味着可能承担更多的性能风险</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /_cluster/settings</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;persistent&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;search.max_buckets&quot;</span><span class="punctuation">:</span> <span class="number">20000</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>桶聚合的 size</strong></p><p>同时，桶聚合需要指定 <code>size</code> 参数，也就是说 ES 并不会直接计算出所有的桶</p><p>假设 <code>size</code> 设置为 <code>1000</code>，此时数据中根据某个维度分桶有 <code>1500</code> 个，那么 ES 只会选择 top 1000 个桶进行返回</p><p><strong>现在是怎么处理的</strong></p><p>对于桶聚合的 <code>size</code>，给定一个较大的值，在短期内应该不会出现这么桶，如果超出限制则由查询逻辑手动进行桶的划分，同时业务是不是业务要思考，需不需要关注一个维度数据下所有值的结果（比如只关注 top 的数据）</p><p>对于桶数量显示，使用默认值，定时聚合中间结果（牺牲实时性，对查询有利），聚合过程中可以手动拆分聚合维度来减少桶的数量</p><h1 id="聚合后排序和分页"><a href="#聚合后排序和分页" class="headerlink" title="聚合后排序和分页"></a>聚合后排序和分页</h1><p>聚合后是无法按照文档内字段顺序来进行排序的（这点在关系型数据库中应该也是如此），但是 ES 的折叠操作可以按照文档顺序进行</p><p>聚合后的排序肯定只能通过聚合维度来进行排序（桶聚合的 key 或者指数聚合的结果），排序和分页的实现使用管道聚合中的 <code>Bucket sort</code> 实现</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">POST /sales/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;sales_per_month&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;date_histogram&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;calendar_interval&quot;</span><span class="punctuation">:</span> <span class="string">&quot;month&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;total_sales&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;sum&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;price&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sales_bucket_sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;bucket_sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="punctuation">&#123;</span> <span class="attr">&quot;total_sales&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span> </span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">3</span>                                </span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>上述操作：</p><ul><li>对日期按月进行桶聚合</li><li>对 <code>price</code> 字段进行 <code>sum</code> 的指数聚合</li><li>对桶聚合进行排序和分页，按照指数聚合 <code>total_sales</code> 结果倒序，取 3 条数据</li></ul><p>这里会出现一个问题，如果是嵌套的桶聚合，<code>bucket_sort</code> 是无法对上层桶，或者对全局的桶进行分页操作</p><blockquote><p>ES 文档原文 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.5/search-aggregations-pipeline-bucket-sort-aggregation.html">Bucket sort aggregation | Elasticsearch Guide [8.5] | Elastic</a></p><p>The <code>bucket_sort</code> aggregation, like all pipeline aggregations, is executed after all other non-pipeline aggregations. This means the sorting only applies to whatever buckets are already returned from the parent aggregation. For example, if the parent aggregation is <code>terms</code> and its <code>size</code> is set to <code>10</code>, the <code>bucket_sort</code> will only sort over those 10 returned term buckets.</p></blockquote><p>在关系型数据库中，假设对 A、B 字段进行聚合操作，然后在其基础上进行分页后有 5 条数据</p><p>A - 1、A - 2、B - 1、B - 2、B - 3</p><p>那么使用 <code>bucket_sort</code> 分页后，假设 <code>from = 0，size = 1</code></p><p>理想情况下是只返回 A - 1 这一条</p><p>但因为只对 <code>parent</code> 桶有效，实际的返回会是</p><p>A - 1 和 B - 1，因为 <code>size</code> 只限制了 B 字段分桶的桶数量</p><blockquote><p>摘自网络 <a href="https://blog.csdn.net/weixin_29715563/article/details/112106227">https://blog.csdn.net/weixin_29715563/article/details/112106227</a></p><p>张超大佬指出：分析系统里跑全量的 group by 我觉得是合理的需求， clickhouse 很擅长做这种事，es 如果不在这方面加强，分析场景很多会被 clickhouse 替掉</p><p>腾讯大佬指出：聚合这块比较看场景。因为我这边有一些业务是做聚合，也就是 olap 场景，多维分析，ES 并不是特别擅长，如果有丰富的多维分析场景，还有比较高的性能要求。我建议可以调研下 clickhouse。我们这边测评过开源和内部的大部分场景 clickhouse 几十亿的级别，基本也在秒级返回甚至毫秒级</p></blockquote><p><strong>Kibana 是怎样实现的</strong></p><p>在 Kibana 上配置图表，看起来能直接实现很类似的功能</p><img src="/%E5%BC%80%E5%8F%91/ES/ES%20%E7%9A%84%E9%99%90%E5%88%B6%E3%80%81%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98/Kibana%E7%9A%84%E8%81%9A%E5%90%88%E5%9B%BE%E8%A1%A8.jpg" class=""><p>并且还支持跳页，不过看了其请求，在刷新时直接进行了一次大请求，返回了所有数据，最后应该是在内存中进行的分页操作</p><p>所以看起来 ES 的聚合本身就无法支持嵌套分页的操作</p><p><strong>现在是怎么处理的</strong></p><p>使用默认值，定时聚合中间结果（牺牲实时性，对查询有利），就可以根据中间结果进行分页了，业务也需要考虑是否有必要跳页，聚合后的结果是动态的、非直观的，跳页查询还有意义吗</p><p>同时对于嵌套聚合、折叠的场景，拼接一个用于聚合的 key 作为聚合字段（相当于业务数据手动拼接一个 key，使一层聚合实现嵌套聚合的效果，只能针对固定需求，丧失了灵活性）</p><h1 id="桶聚合准确性"><a href="#桶聚合准确性" class="headerlink" title="桶聚合准确性"></a>桶聚合准确性</h1><p>ES 的桶聚合会由各个分片聚合出结果后再交由协调节点汇总数据（也就是此时汇总数据是没有全局视野的），可能会导致桶的不准确</p><p>这个参数由桶聚合的 <code>shard_size</code> 进行控制，默认取值为 <code>size × 1.5 + 10</code></p><p>也就是每个节点只会聚合 <code>shard_size</code> 大小的结果返回给协调节点，再有协调节点合并结果，返回出 <code>size</code> 所需数量的桶（可以看出 <code>shard size</code> 不可能小于 <code>size</code>）</p><p>也就是最终结果的桶并不是绝对准确的，需要合理设置 <code>shard_size</code> 平衡准确性和性能</p><p><strong>现在是怎么处理的</strong></p><p>因为聚合桶数量限制，<code>size</code> 设置了一个短期来看足够大的值，所以 <code>shard_size</code> 同样很大</p><p>应该暂时不会存在桶不准确问题</p><h1 id="基数聚合准确性"><a href="#基数聚合准确性" class="headerlink" title="基数聚合准确性"></a>基数聚合准确性</h1><p>因为分页展示的要求，对于聚合或者折叠后，需要统计桶的数量</p><p>嵌套操作无法进行基数聚合，所以此处也使用了业务手动拼接的聚合 key，进行 <code>cardinality</code> 操作</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST /sales/_search?size=<span class="number">0</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;cardinality&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，基数聚合虽然可以统计出基数，但底层使用 HyperLogLog 进行实现，也就是带有一定的误差</p><p><img src="https://www.elastic.co/guide/en/elasticsearch/reference/8.5/images/cardinality_error.png" alt="cardinality_error.png (1000×400) (elastic.co)"></p><p>误差是比较小的，即使阈值低至 100，即使在百万 + 基数时，误差仍然很低（如上图所示，为1 - 6%）</p><p>允许误差存在会导致最终总页数不准确，或者每次查询都有所区别</p><p>不过 <code>cardinality</code> 支持精度参数 <code>precision_threshold</code>，如果基数数量在指定精度以内，那么就不存在误差</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST /sales/_search?size=<span class="number">0</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;cardinality&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;precision_threshold&quot;</span><span class="punctuation">:</span> <span class="number">100</span> </span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>现在是怎么处理的</strong></p><p>因为本身 ES 就有深度分页的限制（默认 10000），所以对于基数聚合也指定了 <code>precision_threshold = 10000</code></p><p>这样对于基数 10000 以内的数据会返回精确值，超过 10000 就不需要关注精确的值，只向前端返回 10000 限制跳页深度</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> ES </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua 基本语法</title>
      <link href="/%E5%BC%80%E5%8F%91/Redis/Lua%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html"/>
      <url>/%E5%BC%80%E5%8F%91/Redis/Lua%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p><strong>基本的操作</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">str = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br><span class="line"><span class="built_in">print</span>(str)</span><br></pre></td></tr></table></figure><p><strong>多重赋值语句</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a,b = <span class="number">1</span>,<span class="number">2</span>;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p><strong>值为 nil</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">--值为nil</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment">--值为nil</span></span><br></pre></td></tr></table></figure><p><strong>十六进制与科学计数法</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0x11</span></span><br><span class="line">b = <span class="number">2e10</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><h2 id="数字运算符"><a href="#数字运算符" class="headerlink" title="数字运算符"></a>数字运算符</h2><p><strong>Lua 支持加减乘除、幂等多种运算</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(a+b)</span><br><span class="line"><span class="built_in">print</span>(a-b)</span><br><span class="line"><span class="built_in">print</span>(a/b)</span><br><span class="line"><span class="built_in">print</span>(a*b)</span><br><span class="line"><span class="built_in">print</span>(b^a)</span><br><span class="line"><span class="built_in">print</span>(a^b)</span><br><span class="line"><span class="built_in">print</span>(a==b)</span><br><span class="line"><span class="built_in">print</span>(a~=b) <span class="comment">--lua的不等于符号为&quot;~=&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a&gt;=b)</span><br><span class="line"><span class="built_in">print</span>(a&lt;=b)</span><br></pre></td></tr></table></figure><h2 id="逻辑运算符与-true、false"><a href="#逻辑运算符与-true、false" class="headerlink" title="逻辑运算符与 true、false"></a>逻辑运算符与 true、false</h2><p><strong>注意：0 为 true，nil 为 false</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="literal">nil</span></span><br><span class="line">b = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">and</span> b)</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">or</span> b)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> b)</span><br></pre></td></tr></table></figure><p><strong>三元表达式</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(a &lt;=<span class="number">0</span> <span class="keyword">and</span> <span class="string">&quot;小于等于 0&quot;</span> <span class="keyword">or</span> <span class="string">&quot;大于 0&quot;</span>) <span class="comment">--输出&quot;小于等于 0&quot;</span></span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><strong>单引号双引号均可</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;hello world a&#x27;</span></span><br><span class="line">b = <span class="string">&quot;hello world b&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p><strong>转义字符</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;hello world\n换行&#x27;</span> <span class="comment">--\n换行</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p><strong>中括号保留原始值（忽略转义）</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">[[&#x27;hello world\n换行&#x27;]]</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p><strong>字符串使用 “..” 进行连接</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;hello &#x27;</span></span><br><span class="line">b = <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a..b)</span><br></pre></td></tr></table></figure><p><strong>tostring(param) 与 tonumber(param)</strong><br>如果tonumber()转换失败则值为nil</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">tostring</span>(<span class="number">1000</span>)</span><br><span class="line">b = <span class="string">&#x27;world&#x27;</span></span><br><span class="line">c = <span class="built_in">tonumber</span>(<span class="string">&quot;500&quot;</span>)</span><br><span class="line">d = <span class="built_in">tonumber</span>(<span class="string">&quot;str&quot;</span>) <span class="comment">--值为nil</span></span><br><span class="line"><span class="built_in">print</span>(a..b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure><p><strong>变量前加 ‘#’ 获取字符串长度</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(#a)</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>函数的基本形式</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(a,b)</span></span></span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>没有传参的参数值为 nil</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(a,b,c)</span></span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>可以 return 多个值，多个值可以配合多重赋值语句</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(a,b,c)</span></span></span><br><span class="line"><span class="keyword">return</span> a,b,c</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> aa,bb,cc = f(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(aa)</span><br><span class="line"><span class="built_in">print</span>(bb)</span><br><span class="line"><span class="built_in">print</span>(cc)</span><br></pre></td></tr></table></figure><h2 id="table-结构"><a href="#table-结构" class="headerlink" title="table 结构"></a>table 结构</h2><p><strong>table 类似数组，但是可以存数字、字符串、其他 table、函数在一个 table 中</strong><br><strong>table 下标从 1 开始</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tab = &#123;<span class="number">1</span>,<span class="string">&quot;hello world&quot;</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(tab[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><strong>下标越界的元素为 nil</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tab = &#123;<span class="number">1</span>,<span class="string">&quot;hello world&quot;</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(tab[<span class="number">10</span>])</span><br></pre></td></tr></table></figure><p><strong>指定位置插入元素</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tab = &#123;<span class="number">1</span>,<span class="string">&quot;hello world&quot;</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span>&#125;</span><br><span class="line">tab[<span class="number">10</span>] = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(tab[<span class="number">10</span>])</span><br></pre></td></tr></table></figure><p><strong>最后插入元素</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tab = &#123;<span class="number">1</span>,<span class="string">&quot;hello world&quot;</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span>&#125;</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(tab,<span class="string">&quot;no.n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tab[<span class="number">5</span>])</span><br></pre></td></tr></table></figure><p><strong>指定位置插入元素</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tab = &#123;<span class="number">1</span>,<span class="string">&quot;hello world&quot;</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span>&#125;</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(tab,<span class="number">3</span>,<span class="string">&quot;no.3&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tab[<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p><strong>删除元素</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tab = &#123;<span class="number">1</span>,<span class="string">&quot;hello world&quot;</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span>&#125;</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(tab,<span class="number">2</span>,<span class="string">&quot;no.2&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tab[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> del = <span class="built_in">table</span>.<span class="built_in">remove</span>(tab,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(tab[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(del)</span><br></pre></td></tr></table></figure><p><strong>字符串作为下标 key</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tab = &#123;</span><br><span class="line">a = <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">b = <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">c = <span class="number">100</span>,</span><br><span class="line">d = &#123;&#125;,</span><br><span class="line">e = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(tab.a)</span><br><span class="line"><span class="built_in">print</span>(tab.b)</span><br><span class="line"><span class="built_in">print</span>(tab.c)</span><br><span class="line"><span class="built_in">print</span>(tab.d)</span><br><span class="line"><span class="built_in">print</span>(tab.e)</span><br></pre></td></tr></table></figure><p><strong>特殊符号下标</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tab = &#123;</span><br><span class="line">a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tab[<span class="string">&quot;...&quot;</span>] = <span class="string">&quot;....&quot;</span></span><br><span class="line">tab[<span class="string">&quot;abc&quot;</span>] = <span class="string">&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(tab[<span class="string">&quot;...&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(tab[<span class="string">&quot;abc&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(tab.abc)</span><br></pre></td></tr></table></figure><p>字符串作为下标可以使用 <code>tab.abc</code>，特殊符号只能通过 <code>tab[&quot;...&quot;]</code> 形式指定下标</p><h2 id="分支判断"><a href="#分支判断" class="headerlink" title="分支判断"></a>分支判断</h2><p><strong>以 if 和 end 为代码块，支持 elseif</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line"><span class="keyword">if</span> a==<span class="number">10</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a==10&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a == <span class="number">9</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a==9&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a&gt;<span class="number">5</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&gt;5&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a&lt;=<span class="number">5</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&lt;=5&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>0 为 true，nil 为 false</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span></span><br><span class="line">b = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;0 is true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;0 is false&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> b <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nil is true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nil is false&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><strong>起始值为 0，到 10 结束</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">0</span>,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>起始值为 10，步长为 -1，到 0 结束</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">10</span>,<span class="number">0</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>循环中 i 的值不能更改（循环所用的值其实是变量 i 的值拷贝）</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">10</span>,<span class="number">0</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line">i = <span class="number">5</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>break 语句</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">10</span>,<span class="number">0</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">6</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>while 语句</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line"><span class="keyword">while</span> num &gt; <span class="number">5</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line">num = num - <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><strong>string.char() 支持十进制、十六进制等</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">string</span>.<span class="built_in">char</span>(<span class="number">104</span>,<span class="number">101</span>,<span class="number">108</span>,<span class="number">0x6C</span>,<span class="number">0x6f</span>) <span class="comment">--&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><p><strong>string.byte() 取出第 n 位字母的十进制</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">string</span>.<span class="built_in">char</span>(<span class="number">104</span>,<span class="number">101</span>,<span class="number">108</span>,<span class="number">0x6C</span>,<span class="number">0x6f</span>)</span><br><span class="line">n = <span class="built_in">string</span>.<span class="built_in">byte</span>(s,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure><p><strong>0x00 在 lua 字符串中不会影响字符串的结束，取值为 0</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">string</span>.<span class="built_in">char</span>(<span class="number">104</span>,<span class="number">101</span>,<span class="number">0x00</span>,<span class="number">108</span>,<span class="number">0x6C</span>,<span class="number">0x6f</span>)</span><br><span class="line">n = <span class="built_in">string</span>.<span class="built_in">byte</span>(s,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(n) <span class="comment">--&quot;0&quot;</span></span><br><span class="line"><span class="built_in">print</span>(#s) <span class="comment">--&quot;6&quot;</span></span><br></pre></td></tr></table></figure><h1 id="参考手册"><a href="#参考手册" class="headerlink" title="参考手册"></a>参考手册</h1><p><a href="https://www.runoob.com/manual/lua53doc/contents.html#contents">Lua 5.3 参考手册 - 目录 (runoob.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RECIPES - Añejo Highball</title>
      <link href="/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/RECIPES%20-%20A%C3%B1ejo%20Highball.html"/>
      <url>/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/RECIPES%20-%20A%C3%B1ejo%20Highball.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://assets-prd.punchdrink.com/wp-content/uploads/2022/11/17163411/Article-Anejo-Highball-500x687.jpg" alt="Article-Anejo-Highball-500x687.jpg (500×687) (punchdrink.com)"></p><h1 id="有年代的嗨棒-Anejo-Highball"><a href="#有年代的嗨棒-Anejo-Highball" class="headerlink" title="有年代的嗨棒 Añejo Highball"></a>有年代的嗨棒 Añejo Highball</h1><p><a href="https://punchdrink.com/recipes/flatliner/"><a href="https://punchdrink.com/recipes/anejo-highball/">Añejo Highball Cocktail Recipe | PUNCH (punchdrink.com)</a></a></p><blockquote><p>añejo (plural añejos) - A tequila or rum which has been aged.</p><p>陈年的龙舌兰或者朗姆</p></blockquote><p>在 90 年代风靡一时的苹果和荔枝味 “tinis” 中，出现了一类更为柔和的鸡尾酒，对世界各地的调酒方法产生了深远的影响</p><p>Añejo Highball 就是其中之一，它以朗姆酒、库拉索酒、青柠汁和姜汁啤酒的简单组合，却呈现出精彩一课</p><h2 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h2><p><em>Serving: 1</em></p><ul><li>陈年朗姆 - 1.5 盎司</li><li>库拉索酒 - 0.5 盎司（<a href="https://www.diffordsguide.com/beer-wine-spirits/734/pierre-ferrand-dry-curacao">Pierre Ferrand Dry Curacao</a>）</li><li>青柠汁 - 0.25 盎司</li><li>安高天娜苦精 - 2 dashes（<a href="https://www.diffordsguide.com/beer-wine-spirits/3505/angostura-orange-bitters">Angostura Orange Bitters</a>）<em>没有指明 Angostura 哪种苦精，感觉橙味可能性更大</em></li><li>姜汁啤酒 - 2 盎司</li></ul><p><strong>装饰：</strong>青柠轮，橙子切片</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>在盛满冰块的海波杯（Highball glass）中，加入朗姆酒、库拉索酒、莱姆汁和安高天娜苦精</li><li>顶部倒入姜汁啤酒</li><li>使用青柠轮和橙子片进行装饰</li></ol>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 宿醉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸡尾酒 </tag>
            
            <tag> recipes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RECIPES - Flatliner</title>
      <link href="/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/RECIPES%20-%20Flatliner.html"/>
      <url>/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/RECIPES%20-%20Flatliner.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://assets-prd.punchdrink.com/wp-content/uploads/2022/12/20113103/Article-Espresso-Martini-Telluride-Flatliner-Recipe-800x450.jpg"></p><h1 id="心脏停跳器-Flatliner"><a href="#心脏停跳器-Flatliner" class="headerlink" title="心脏停跳器 Flatliner"></a>心脏停跳器 Flatliner</h1><p><a href="https://punchdrink.com/recipes/flatliner/">Flatliner Espresso Martini Cocktail Recipe Riff | PUNCH (punchdrink.com)</a></p><p>丝般柔滑，泡沫四溢，科罗拉多州（Colorado）特莱瑞德（Telluride）的非正式酒单，和意式浓缩马天尼（Espresso Martini）和泥石流（Mudslide）相似，但对于滑雪小镇居民而言，它是当地的经典</p><p>尽管调酒师史蒂夫 · 福斯特（Steve Foster）起初是在 The Peaks Resort &amp; Spa 供应这一鸡尾酒，但配方已经传遍了整个城市</p><p>如今你会在 New Sheridan Chop House 看到福斯特正在 shaking Flatliner</p><h2 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h2><p><em>Serving: 1</em></p><ul><li>伏特加 - 1 盎司</li><li>甘露咖啡利口酒 - 1 盎司（<a href="https://www.diffordsguide.com/beer-wine-spirits/248/kahlua-coffee-liqueur">Kahlúa coffee liqueur</a>）</li><li>百利甜酒 - 1 盎司（<a href="https://www.diffordsguide.com/beer-wine-spirits/526/baileys-irish-cream-liqueur">Baileys Irish cream liqueur</a>）</li><li>意式浓缩咖啡 - 1 份 or 冷泡咖啡 - 1 盎司</li></ul><p><strong>装饰：</strong> 咖啡豆 - 3 粒</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>将所有原料加入装满冰块的摇壶，开始 shake</li><li>滤入蝶形杯（Coupe glass），然后用咖啡豆作为装饰</li></ol>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 宿醉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸡尾酒 </tag>
            
            <tag> recipes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精酿啤酒入门</title>
      <link href="/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/%E7%B2%BE%E9%85%BF%E5%95%A4%E9%85%92.html"/>
      <url>/%E4%BA%BA%E7%94%9F/%E5%AE%BF%E9%86%89/%E7%B2%BE%E9%85%BF%E5%95%A4%E9%85%92.html</url>
      
        <content type="html"><![CDATA[<h1 id="精酿"><a href="#精酿" class="headerlink" title="精酿"></a>精酿</h1><blockquote><p>在公司的技术分享周会上进行分享的文档</p><p>只是进了简单的介绍，并且很多地方都是简略地描述了一下</p><p>对于不了解精酿的朋友可以借此了解一下 Craft Beer</p></blockquote><h2 id="什么是-Craft-Beer"><a href="#什么是-Craft-Beer" class="headerlink" title="什么是 Craft Beer"></a>什么是 Craft Beer</h2><p><strong>美国的精酿运动</strong></p><p>20 世纪开始，美国先后经历一战、禁酒令、二战，导致啤酒迅速退出市场</p><p>20 世纪 70 年代，关于家酿啤酒的书籍从英国流出，书中呼吁使用糖浆之类奇特的原料；弗雷德.埃克哈德（Fred Eckhardt）出版了一本题为《拉格啤酒论》的书，虽是薄薄一册，但技术上描述非常详细。可以毫不夸张的说，家酿方式为精酿啤酒运动提供了思想、激情和人物，是重要的源泉</p><p>1976 年，美国开始出现最早的精酿酒厂，生产瓶中发酵的波特、世涛和淡色艾尔供应给早已习惯淡味拉格的酒吧</p><p>1978 年 10 月 14 号，总统 Jimmy Carter 签署了 1337 号议案。这份议案将家庭酿造小量自产自用的啤酒或红酒合法化。从此，美国见证了酿酒文化的复兴和小型酒厂的蓬勃发展。到 1986 年 3 月，5 家自酿酒吧在美国营业</p><p>美国酒厂的总数从 1978 年的 42 家变成 2012 年的 2750 家，甚至超过了美国殖民地时代的大约数字；增长的其中绝大多数都是小型独立酒厂</p><p><strong>精酿的类官方定义</strong></p><p>精酿并不是啤酒的概念，而是啤酒厂的概念</p><p>美国啤酒酿造商协会（Brewers Association）出台的标准，对精酿酒厂的定义为：<strong>小型</strong>、<strong>独立</strong>、<strong>传统</strong></p><ul><li>小型：年产量在 600 万及 600 万桶以下</li><li>独立：其产权不能为其它非精酿酒厂的酒类企业购买，管理或控股超过 25%</li><li>传统：要使用传统或创新的原材料，遵循传统或创新的酿造方法来实现其酿造出啤酒的口味</li></ul><blockquote><p>鹅岛：<a href="https://item.jd.com/100008724119.html">京东链接</a></p><p>拳击猫：<a href="http://www.boxingcatbrewery.com/cn/">Boxing Cat Brewery</a></p></blockquote><p><strong>和工业啤酒的区别</strong></p><ul><li>更高的原料成本</li><li>更丰富的啤酒风格</li><li>更多创意</li><li>啤酒 Pub 门店，提供简餐</li><li>更艺术的美学设计</li><li>更贵</li></ul><p><strong>工厂店</strong></p><p>Craft Beer 的酒厂规模较小，为了突出精酿的理念往往会将生产工厂对外开放，可以预约参观</p><p>工厂店摒弃了分级批发商、分级代理等中间繁冗环节可以降低成本</p><p><a href="https://vitaminseabrewing.com/">VSB (vitaminseabrewing.com)</a></p><p><a href="https://treehousebrew.com/">Tree House Brewing Company</a></p><h2 id="啤酒风格"><a href="#啤酒风格" class="headerlink" title="啤酒风格"></a>啤酒风格</h2><p><strong>BJCP</strong></p><p>啤酒品酒师资格认证协会(BJCP，Beer Judge Certification Program) 于 1985 年创建于美国</p><p>宗旨是推广与传播啤酒相关的各类知识与文化，提升大众对啤酒的认知、品酒和评估水平；创造一个啤酒行业规范的评价程序，引导啤酒爱好者如何正确评价及饮用啤酒，便于对这些酒类进行排名和评比</p><p>BJCP 定期推出啤酒分类指南对啤酒加以科学分类，该指南也已成为世界啤酒市场的风向标，有助于啤友品鉴、自酿比赛筹办、酿友参赛、甚至新啤酒风格的创新</p><p><a href="D:\Relax\Beer\BJCP世界啤酒分类指南中文2015版.pdf">BJCP世界啤酒分类指南中文2015版</a></p><p><a href="https://www.bjcp.org/">Beer Judge Certification Program – Promoting beer literacy, recognizing beer tasting and evaluation skills. (bjcp.org)</a></p><p><strong>错误的分类方式</strong></p><p>啤酒经常会被按照颜色进行分类，比如黑啤、黄啤、白啤</p><p>但是这种分类方式是错误的，因为风格和颜色无关；一种风格往往有一定的色度范围，但并不决对，并且色度范围可能也很大，所以不可能通过颜色去区分啤酒的风格</p><p>啤酒的色度更多来源于酿造时所用的深色麦芽比重，想酿造黑色的 IPA、更浅的世涛也未尝不可</p><p><strong>工业啤酒也有风格</strong></p><p>常说的工业啤酒其实是属于拉格（Lager）这个大分类下</p><blockquote><p>拉格本身也是啤酒分类中的一种创新，本身拉格也是较难酿造的啤酒，因为它的难点在于低温。最早只有在德国北部一些偏冷地区将啤酒放在冰冷的山洞里窖藏才形成了这种风格（Lager 在德语里是窖藏的意思）</p></blockquote><p>那么拉格啤酒风靡世界的原因：</p><ul><li>口味清淡，更清爽</li><li>价格便宜</li><li>度数较低，社交属性</li><li>发酵难度小于艾尔啤酒</li><li>更容易工业生产</li><li>风格稳定</li><li>主流国家的推动，先入为主</li></ul><p><strong>艾尔和拉格</strong></p><p>艾尔（Ale）和拉格（Lager）最初指的是不同的酵母类型，而酵母类型能带来不同的风味</p><p><strong>艾尔</strong>酵母需要更高的温度（15℃~25℃），发酵过程中产生更多的代谢物质，其中包括给啤酒提供复杂香气的酯类、酚类、醛类等风味的物质，也包括不好的物质如双乙酰等；发酵时会产生更多的热量</p><p><strong>拉格</strong>酵母需要温度更低（4℃~12℃），发酵更加彻底，代谢产物较少，味道更加清冽，干净，爽口</p><p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252037761.jpg" alt="img"></p><p><strong>美式风格</strong></p><p>精酿运动发起于美国，所以如今的啤酒风格中经常能看到以 American 开头的风格名称</p><p>美式风格和传统风格（Pale Ale 和 American Pale Ale、Lager 和 American Lager）最大的区别在于使用<strong>美式酒花</strong>替代<strong>传统酒花</strong>，基于此啤酒风格也经常被分类为欧式和美式两大类（并不严谨）</p><p>美式酒花也被称为新世界酒花，传统的欧洲酒花更倾向于提供苦度、辛辣和草本风味，美式酒花更倾向于提供香味、柑橘类、瓜果、热带水果等味道</p><blockquote><p>卡斯卡特 1972 年商品化</p><p>西楚 2008 年商品化</p><p>金牌 1790 年商品化</p></blockquote><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/image-20220315235328107.png" alt="image-20220315235328107" style="zoom: 67%;" /><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252038370.png" alt="image-20220315235403042" style="zoom:67%;" /><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252038169.png" alt="image-20220315235344666" style="zoom: 67%;" /><p><strong>举一些有特点的风格</strong></p><p>（下面的风格名称并不严谨，更多的是商业化风格的叫法）</p><ul><li><strong>印度淡色艾尔（IPA）</strong>：更多的啤酒花带来更高的苦度以及更多的风味 <a href="https://item.jd.com/100011983501.html">北平机器百花深处IPA</a></li><li><strong>古斯（Gose）</strong>：乳酸、盐水、香料 <a href="https://item.jd.com/10030440794661.html">牛啤堂帝都海盐</a></li><li><strong>兰比克（Lambics）</strong>：野菌发酵，更酸，变体是水果兰比克和法柔 <a href="https://item.jd.com/7907410.html">林德曼</a></li><li><strong>牛奶世涛（Milk Stout）</strong>：加了乳糖的世涛，往往追求更高的糊精比重 <a href="https://item.jd.com/100012559742.html">打嗝海狸花生牛奶世涛</a></li><li><strong>小麦啤酒（Wheat）</strong>：小麦作为重要原料，有一定酸度<ul><li><strong>德式小麦</strong>：原料单一（1516 年《德国纯净啤酒法》） <a href="https://item.jd.com/100018726016.html">海底捞德式小麦</a></li><li><strong>比利时小麦</strong>：香料的加入，甜橙皮、芫荽籽 <a href="https://item.jd.com/100020388832.html">1664白啤</a></li></ul></li><li><strong>西打（Cider）</strong>：苹果酒（也可能是其他水果），更多的残糖 <a href="https://item.jd.com/53259108790.html">诱惑（TEMPT）7号</a></li><li><strong>修道院（Trappist &amp; Abbey）</strong>：比利时啤酒，由修道院（Trappist）或修道院授权（Abbey）酿造，收入用于慈善或社区服务，全球共有11家修道院酒厂；传统、高酒精度、厚重、焦糖，辅料大多数加入了比利时棕糖 <a href="https://item.jd.com/3306054.html">罗斯福（Rochefort）10号</a></li></ul><p><strong>更多创意</strong></p><p>精酿运动除了复刻历史上的传统啤酒风格（IPA - 18 世纪、古斯 - 16 世纪），也带来了更多风格创意的探索</p><ul><li><strong>香槟IPA（Brut IPA）</strong>：2017 年首创，使用葡萄糖淀粉酶，更低的苦味，更低的残糖意味着更干的口感</li><li><strong>酒花干投（Dry Hop）</strong>：一种酒花添加方式，适用于各种突出酒花风味类的风格，啤酒花不参与煮沸和旋沉阶段，而在冷却、发酵过程中加入啤酒花，目的是降低苦度增加香味</li><li><strong>燕麦世涛（Oatmeal Stout）</strong>：添加燕麦，追求更重的酒体</li><li><strong>酒花拉格（Hoppy Lager）</strong>：新时代风格，在传统拉格风格下加入大量新世界酒花，拉格的口感和更多的酒花香味和苦度</li><li><strong>水果啤酒（Fruit Beer）</strong>：酿造过程中加入水果甚至果泥（我觉得很难喝）</li></ul><h2 id="快点开喝"><a href="#快点开喝" class="headerlink" title="快点开喝"></a>快点开喝</h2><p><strong>啤酒的属性</strong></p><p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252038639.png" alt="img"></p><p>啤酒的酒标上标注了这瓶啤酒的基本信息</p><ul><li>酒厂（Brand）：Brew Dog</li><li>名称（Name）：Layer Cake</li><li>风格（Style）：Marshmallow &amp; Chocolate Stout 棉花糖 &amp; 巧克力世涛（酒厂自己定义的风格）</li><li>酒精度（ABV）：7%</li><li>容量（volume）：440 ml</li></ul><p>除此之外啤酒的信息</p><ul><li><p>苦度（IBU）：不同的风格苦度差异会很大，IPA（40 ~ 100）、英式苦啤（30 ~ 70）、捷克拉格（20 ~ 40）、西打酒（5 ~ 20）</p></li><li><p>啤酒色度（EBC）：啤酒色度，白 -&gt; 黄 -&gt; 棕 -&gt; 黑</p></li><li><p>终了比重（FG）：数值越大意味着越高的残糖，也可能有更厚重的酒体</p></li><li><p>二次发酵方式：瓶中二发，还是只有一发后打入二氧化碳装瓶</p></li><li><p>罐装杀菌方式：国产啤酒，生啤、纯生</p></li><li><p>其他操作：原浆、一番榨</p></li></ul><p><strong>一些名词</strong></p><ul><li>干 &amp; 甜：干指的是更少的残糖，甜则相反（干红、半干、甜红）</li><li>轻 &amp; 重：酒体中糊精、蛋白质的含量，更重的酒体意味着更厚的口感</li><li>泡沫：一方面来自二氧化碳的含量，一般而言越清爽的风格越追求更多的二氧化碳；另一方面更重的酒体更能产生更绵密的泡沫</li></ul><p><strong>适饮温度</strong></p><p>一定要冰镇</p><p>艾尔类可以比拉格类温度稍高，有助于风味的散发，但肯定要远远低于室温（没有暖气的冬天除外）</p><p><strong>配餐</strong></p><p>啤酒本身就是大众的酒种，喝啤酒的时候搭配高热量的简餐感觉就更爽了，这也是为什么啤酒吧往往都提供简餐；也可以搭配甜品</p><p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039603.png"></p><p><a href="https://www.brewdog.com/uk/bar_pages/bar/locator">Bar Locator (brewdog.com)</a></p><h1 id="酿造"><a href="#酿造" class="headerlink" title="酿造"></a>酿造</h1><h2 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h2><p>酿造啤酒的本质就是粉碎麦芽、糖化麦芽、煮沸麦汁、冷却麦汁、发酵麦汁</p><p><strong>粉碎麦芽</strong>需要用到<strong>粉碎机</strong>，一般使用对碾结构，因为最好的粉碎程度是挤出麦胚但保留麸皮，因为麸皮在后续流程中可以对麦汁进行过滤，减少蛋白质等物质，使酒体更清澈、更稳定</p><p><strong>糖化麦芽</strong>需要<strong>保温桶</strong>，因为需要一定的温度（65℃ 左右）让麦芽内的酶进行工作，分解淀粉为麦芽糖、糊精以及其他产物，麦芽糖就是酒精的来源</p><p><strong>煮沸麦汁</strong>需要<strong>煮沸桶</strong>，保持高温煮沸，让异味物质蒸发（二甲基硫醚），以及投放酒花、辅料通过煮沸来萃取风味，还有最重要的一点就是杀菌</p><p><strong>冷却麦汁</strong>需要用到<strong>冷却盘管</strong>，更高级的设备可以使用<strong>换热器</strong>以及<strong>冷水机</strong>，目的是让麦汁尽可能快速地冷却到适宜投放酵母的温度，减少氧化</p><p><strong>发酵麦汁</strong>需要用到<strong>发酵桶</strong>，密闭、能够安装<strong>单向阀</strong>（发酵过程中会产生大量的热和二氧化碳需要排出）</p><h2 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h2><p><strong>基本原料</strong></p><p>啤酒的四大原料：</p><ul><li>麦芽：大麦麦芽，某些风格可能会使用小麦麦芽</li><li>啤酒花：蛇麻科植物，最早是用来保鲜，现在用来赋予啤酒香味和苦味</li><li>酵母：各种酵母，但总体分为艾尔和拉格两类，酵母生产厂家会有针对此类酵母的详细参数<br><a href="http://wxtest.seastad.com/fermentation-solutions/you-create-beer/you-create-beer.html?id=1">酿啤酒的你 • Fermentis (seastad.com)</a></li><li>水：这个就不解释了</li></ul><p><strong>各种辅料</strong></p><p>除了最基本的原料，啤酒中往往还加入不同的辅料，有的可能是因为风格需要，也有的可能是酿造者的创意</p><p>比如：</p><ul><li>比利时小麦需要加入甜橙皮和芫荽籽</li><li>比利时修道院啤酒需要加入棕糖</li><li>牛奶世涛需要加入乳糖</li><li>燕麦世涛需要加入燕麦</li><li>烟熏啤酒需要加入烟熏木</li><li>蜂蜜酒需要加入蜂蜜</li><li>以及各种创意加入花椒（<a href="https://item.jd.com/10028156058690.html">啤休酿造花椒生姜风味</a>）、花茶（<a href="https://item.jd.com/69394013613.html">高大师</a>）、果汁、香草等等</li></ul><p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039419.png" alt="image-20220316014349585"></p><p><strong>麦芽的种类</strong></p><p>酿造用的麦芽通常称为基础麦芽和特种麦芽，基础麦芽是麦汁中麦芽糖的主体和基本特征，而特种麦芽主要带来更多的风味和色度</p><p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039668.png" alt="image-20220316014132216"></p><p>比如很多名称中带有 “巧克力” 的啤酒，可能并不是添加了巧克力，而是特种麦芽带来的巧克力风味</p><p><strong>啤酒花的种类</strong></p><p>啤酒花的香味来自于植物中所包含的 α—酸、β—酸和香精油，α—酸和β—酸经过高温后会成为啤酒中的苦味物质，但经过高温异构后才能更多溶于水，带来啤酒花的香味，所以啤酒花往往是苦味和香味并存</p><p>干投的方式可以避免啤酒花的苦味进入啤酒，但也减少了香味，所以干投往往需要更大量的啤酒花</p><p>啤酒花有不同的品种，在煮沸过程中不同的时间投入煮沸桶，来达到增加苦味和香味的目的</p><p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039251.png" alt="image-20220316015005883"></p><p><strong>单一酒花</strong></p><p>有的酒款会标注自己是<strong>单一酒花（Single-Hopped）</strong>，意思是所使用的原料里只包含一种品种的啤酒花</p><p>一般所使用的酒花是最新培育出的、风味更独特的新品种，能够更好的感知到这种酒花的风味</p><p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039769.png" alt="image-20220316015127042"></p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul><li><p>第一次发酵（2 周）</p><ul><li><p>粉碎麦芽</p></li><li><p>糖化</p></li><li><p>洗糟</p></li><li><p>煮沸</p></li><li><p>添加辅料、酒花</p></li><li><p>冷却</p></li><li><p>测糖（初始比重）</p></li><li><p>装发酵桶</p></li><li><p>投放酵母</p></li><li><p>液封</p></li></ul></li><li><p>第二次发酵（至少 2 周）</p><ul><li><p>测糖（终了比重）</p></li><li><p>配置二发用糖</p></li><li><p>装瓶</p></li><li><p>冷藏</p></li></ul></li></ul><p>从煮沸后的整个流程都需要对器材进行消毒，特别是发酵桶以及管道，如果这桶酒被杂菌污染，就该扔了</p><p><a href="https://www.youtube.com/watch?v=Wxo9PHc3jNw">How to Make Beer, the Animation. - YouTube</a></p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><strong>评分网站</strong></p><p><a href="https://untappd.com/">Untappd – Drink Socially – Free iOS and Android App</a></p><p><a href="https://www.jiuhuar.com/">精酿啤酒和啤酒世界-酒花儿 (jiuhuar.com)</a></p><p><strong>配方模拟</strong></p><p><a href="https://web.brewfather.app/tabs/tools">Brewfather</a></p><h2 id="还有"><a href="#还有" class="headerlink" title="还有"></a>还有</h2><p><strong>是否安全</strong></p><p>新闻经常报道喝假酒甲醇中毒的案例</p><p>家酿啤酒从工艺到设备肯定无法和酒厂相比，确实相对应的异味物质和不好的产物（甲醇等）会更多</p><p>但啤酒属于酿造酒，酿造酒所产生的酒精度就是比较低的，所以其他代谢产物会更少，甲醇中毒往往来自于蒸馏酒类，本身的甲醇浓度会在蒸馏后变得很高从而超过阈值；其次甲醛的主要来源是果胶，对于啤酒来说原料里果胶的来源非常少</p><p>所使用的酵母往往也是生物公司研制的产品，所带来的负面代谢产物会更少</p><p>食品检测也很方便，啤酒相关物质检测的价格在 200 元左右</p><p><strong>大师杯</strong></p><blockquote><p> 2012 年，中国第一批家酿爱好者和啤酒发烧友开始成立社团、协会，组织各种交流活动。2012 年 8 月，第一本中文啤酒家酿书《喝自己酿的啤酒》作者高岩，在南京创办了大师杯全国家酿啤酒大奖赛（以下简称大师杯），评选出优秀的家酿作品和酿造者，以颂扬酿造的艺术和科学</p><p>大师杯吸纳了诸多国内深耕于行业的先行者，形成大师杯全国家酿啤酒大奖赛组委会，制定并遵循组委会章程，秉承“公平、合理、科学”的价值观，不断提升大师杯的影响力和公信力。</p></blockquote><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039610.jpg" style="zoom: 50%;" /><p><a href="https://mp.weixin.qq.com/s/A2HxAoD_XUNVORqIWppcQA">2022 塔罗斯·大师杯 家酿赛，赛制说明&amp;分组规则</a></p><p><a href="https://mp.weixin.qq.com/s/vQdHVW-YuGWcpzzNXmcabA">2022 塔罗斯·大师杯 广州站报名开始</a></p><p><strong>我酿的啤酒</strong></p><p>曾经参过 2020 年大师杯，评分</p><p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039065.jpg" style="zoom:33%;" /><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039471.jpg" style="zoom:33%;" /></p><p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039794.jpg"></p><h1 id="艺术和文化"><a href="#艺术和文化" class="headerlink" title="艺术和文化"></a>艺术和文化</h1><h2 id="酒厂-amp-酒标"><a href="#酒厂-amp-酒标" class="headerlink" title="酒厂 &amp; 酒标"></a>酒厂 &amp; 酒标</h2><p><strong>打嗝海狸（Belching Beaver）</strong></p><p><a href="https://belchingbeaver.com/">Belching Beaver Brewery</a></p><p><strong>北酿（North Brewing）</strong></p><p><a href="https://shop.northbrewing.com/">North Brewing Co Online Shop</a></p><p><strong>岬角（Ballast Point）</strong></p><p><a href="https://ballastpoint.com/">Homepage - Ballast Point Brewing</a></p><p><strong>伟大理念（Great Notion）</strong></p><p><a href="https://greatnotion.com/">Great Notion | Home</a></p><p><strong>美奇乐（Mikkeller）</strong></p><p><a href="https://mikkeller.com/">Mikkeller</a></p><p><strong>联合艺术（Collective Arts）</strong></p><p><a href="https://collectiveartsbrewing.com/de/">Home - Collective Arts Germany (collectiveartsbrewing.com)</a></p><h2 id="衍生活动"><a href="#衍生活动" class="headerlink" title="衍生活动"></a>衍生活动</h2><p><strong>合酿</strong></p><p>合酿就是两个或多个不同的精酿厂牌在一起合作酿造一款酒，就有点儿像邻居之间的串门一样，今天我去你那儿，明天你来我这儿，大家坐一坐，聊一聊，吃个饭</p><p>除了联络感情，合酿还有一个重要意义就是能够将彼此的产品特点融合在一起，创造出更具特色的产品；合酿的过程其实也是个技术交流与分享的过程，取彼之长，补己之短</p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039709.png" alt="image-20220320171652123" style="zoom: 50%;" /><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039981.png" alt="image-20220320171714327" style="zoom:50%;" /><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039874.png" alt="image-20220320171722436" style="zoom: 50%;" /><p><strong>酒头接管</strong></p><p>啤酒吧引入一批某酒厂的啤酒而举办的带有广告性质、主题性质、促销性质的营销活动</p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039483.png" alt="image-20220320171908796" style="zoom:50%;" /><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039798.png" alt="image-20220320171914991" style="zoom:50%;" /><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252039116.png" alt="image-20220320171926205" style="zoom:50%;" /><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252040917.png" alt="image-20220320173347954" style="zoom:50%;" /><p><strong>展览会 &amp; 啤酒节</strong></p><p><a href="https://www.jiuhuar.com/news/6225b9248ba5b044278b4569.html">「Design精酿」艺术展和春季啤酒畅饮大会来啦！ (jiuhuar.com)</a></p><p><a href="https://mp.weixin.qq.com/s/8zT6i8Alnaw2D7Tg7nwPYg">2021京A八乘八参节指南，这个周末等你来玩！ (qq.com)</a></p><p><a href="https://mp.weixin.qq.com/s/36PlJmIOa5tvlmFWGIVARQ">啤酒节来了！ | 第二届『跳啤拍档』广州精酿啤酒节，下周见！ (qq.com)</a></p><p><strong>啤酒跑</strong></p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252040418.png" alt="image-20220320172308492" style="zoom:50%;" /><p><a href="https://mp.weixin.qq.com/s/DCBIJeQYdWRUF_XcpCydlQ">我们赞助了一场快乐的【2020厦门啤酒跑∣RUN FOR BEER】 (qq.com)</a></p><p><strong>节日活动</strong></p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252040128.png" alt="image-20220320173409737" style="zoom: 67%;" /><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252040081.png" alt="image-20220320173420348" style="zoom:50%;" /><p><a href="https://mp.weixin.qq.com/s/woOyTmWUATl7-0p-K6EDkw">煎饼节后遗症｜京津大战全回顾 (qq.com)</a></p><p><strong>跨界</strong></p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252040229.png" alt="image-20220320173649555" style="zoom:50%;" /><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252040814.png" alt="image-20220320173657609" style="zoom:50%;" /><p><a href="https://mp.weixin.qq.com/s/qW5M9Eduzz0jn2H-o9bZHw">文末有福利｜道酿 X FIRST青年电影展 (qq.com)</a></p><h2 id="《都在酒里》"><a href="#《都在酒里》" class="headerlink" title="《都在酒里》"></a>《都在酒里》</h2><p>最后推荐一部机核的纪录片</p><p><a href="https://www.bilibili.com/video/BV1R5411s7ZY?spm_id_from=333.999.0.0">「4K重制版」坐在一起，为生活干杯：精酿啤酒纪录片《都在酒里》第三集《美式周末》_哔哩哔哩_bilibili</a></p><p><img src="https://kuga-pic-1258855810.cos.ap-beijing.myqcloud.com/202212252042908.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 宿醉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 精酿啤酒 </tag>
            
            <tag> 吃喝玩乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥接模式 - Bridge</title>
      <link href="/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%20-%20Bridge.html"/>
      <url>/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%20-%20Bridge.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>桥接（bridge）模式首先的场景是内部实现逻辑分为多个模块，每个模块又可能对应多种实现</p><p>在桥接内部，这些不同类型的模块按照组合或聚合的方式组织在一起，将逻辑模块抽象部分与实现部分相分离</p><p><strong>目的</strong><br>降低内部多种类型逻辑模块的耦合，扩展变成以各模块为单位，更为灵活</p><p><strong>现实世界类比</strong><br><a href="https://vans.com.cn/customs.html">Vans自由定制鞋_Vans(范斯)中国官方网站</a></p><p>球鞋定制，从选择款式开始，对不同的部位（鞋头、鞋腰、侧边条纹、鞋带等）选择不同的设计（颜色、图案、材质等），最终产出最终产品（桥接模式的最终成品可以认为是组合了多个模块逻辑的执行器）</p><p>针对不同部位选择不同的设计，而不是平铺出笛卡尔积式的配置表，就是桥接模式希望实现的解耦的目的</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>模拟一个场景，比如服务内希望实现一个消息通知功能</p><p>消息分为多种记录方式：缓存、数据库</p><p>通知的方式也分为多种方式：邮件、微信</p><p>服务内定义什么级别的消息通过什么方式进行通知</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果将所需要的发送方式进行实现，需要实现 4 种执行器（2 × 2），哪怕是服务中可以进行选择，也需要全部进行实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheEmailNotifier</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;缓存数据&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送电子邮件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheWeChatNotifier</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;缓存数据&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送微信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>如果后续有调整，增加了新的记录方式或者通知方式，那么需要需要创建的类就更多了，并且可能还存在相同的逻辑被实现了多份不便于维护</p><p>问题出现的原因是因为将记录方式和通知方式这两种互不关联的模块<strong>在实现中耦合在一起</strong></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="通知方式"><a href="#通知方式" class="headerlink" title="通知方式"></a>通知方式</h3><p><strong>定义接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String msg)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进行实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 电子邮件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailSender</span> <span class="keyword">implements</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="keyword">final</span> String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送电子邮件:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeChatSender</span> <span class="keyword">implements</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="keyword">final</span> String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送微信:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="记录方式"><a href="#记录方式" class="headerlink" title="记录方式"></a>记录方式</h3><p><strong>定义接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Recorder</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进行实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheRecorder</span> <span class="keyword">implements</span> <span class="title class_">Recorder</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(<span class="keyword">final</span> String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;记录到缓存:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DbRecorder</span> <span class="keyword">implements</span> <span class="title class_">Recorder</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(<span class="keyword">final</span> String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;记录到数据库:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组织者"><a href="#组织者" class="headerlink" title="组织者"></a>组织者</h3><p><strong>抽象组织者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractNotifier</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Recorder recorder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Sender sender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractNotifier</span><span class="params">(<span class="keyword">final</span> Recorder recorder, <span class="keyword">final</span> Sender sender)</span> &#123;</span><br><span class="line">        Assert.notNull(recorder);</span><br><span class="line">        Assert.notNull(sender);</span><br><span class="line">        <span class="built_in">this</span>.recorder = recorder;</span><br><span class="line">        <span class="built_in">this</span>.sender = sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        recorder.record(msg);</span><br><span class="line">        sender.send(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承构造模块的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomNotifier</span> <span class="keyword">extends</span> <span class="title class_">AbstractNotifier</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomNotifier</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">DbRecorder</span>(), <span class="keyword">new</span> <span class="title class_">EmailSender</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="业务扩展"><a href="#业务扩展" class="headerlink" title="业务扩展"></a>业务扩展</h3><p>需要增加新的发送方式，比如短信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShortMessageSender</span> <span class="keyword">implements</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="keyword">final</span> String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送短信:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要进行新的 notifier 的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlusNotifier</span> <span class="keyword">extends</span> <span class="title class_">AbstractNotifier</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PlusNotifier</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">CacheRecorder</span>(), <span class="keyword">new</span> <span class="title class_">ShortMessageSender</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>JDBC 驱动为所有的关系型数据库提供一个通用的标准，这就是一个桥接模式的典型应用</p><h3 id="进行连接"><a href="#进行连接" class="headerlink" title="进行连接"></a>进行连接</h3><p>先回顾一下 JDBC 的使用，使用 JDBC 连接 MySQL 数据库主要分为这样几步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.加载 MySQL 驱动注入到 DriverManager</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.提供 JDBC 连接的 URL、用户名和密码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test_db?&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建数据库的连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.创建 statement 实例</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.执行 SQL 语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">query</span> <span class="operator">=</span> <span class="string">&quot;select * from test&quot;</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(query);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.关闭连接对象</span></span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><h3 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h3><p><code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</code> 获取了 Driver 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注册驱动</span></span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 <code>DriverManager</code> 静态方法 <code>registerDriver()</code> 方法来将 MySQL 驱动注册到 <code>DriverManager</code></p><h3 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h3><p><code>registerDriver()</code> 方法具体如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">registerDriver</span><span class="params">(java.sql.Driver driver)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"><span class="comment">// 直接调用下面的同名静态方法</span></span><br><span class="line">    registerDriver(driver, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">registerDriver</span><span class="params">(java.sql.Driver driver,DriverAction da)</span><span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">// registeredDrivers 是一个 list,用 DriverInfo 实例封装 Driver</span></span><br><span class="line">    <span class="keyword">if</span>(driver != <span class="literal">null</span>) &#123;</span><br><span class="line">        registeredDrivers.addIfAbsent(<span class="keyword">new</span> <span class="title class_">DriverInfo</span>(driver, da));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This is for compatibility with the original DriverManager</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;registerDriver: &quot;</span> + driver);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>registeredDrivers</code> 静态变量是一个 list</p><p>泛型 <code>DriverInfo</code> 是驱动信息的包装类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DriverManager</span> &#123;</span><br><span class="line">    <span class="comment">// List of registered JDBC drivers</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DriverInfo"><a href="#DriverInfo" class="headerlink" title="DriverInfo"></a>DriverInfo</h3><p><code>DriverInfo</code> 类中封装了 <code>java.sql.Driver</code> 接口，类似 Driver 信息管理者的角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DriverInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Driver driver;</span><br><span class="line">    DriverAction da;</span><br><span class="line">    DriverInfo(Driver driver, DriverAction action) &#123;</span><br><span class="line">        <span class="built_in">this</span>.driver = driver;</span><br><span class="line">        da = action;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p>接下来进行连接的获取，<code>Connection connection = DriverManager.getConnection(url, username, password);</code></p><p><code>Connection</code> 接口是和特定数据库的连接会话，<strong>不同的数据库的连接会话都不相同</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Connection</span>  <span class="keyword">extends</span> <span class="title class_">Wrapper</span>, AutoCloseable &#123;</span><br><span class="line"></span><br><span class="line">    Statement <span class="title function_">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>DriverManager</code> 中的 <code>getConnection</code> 方法，从 <code>registeredDrivers</code> 进行选择对应数据库驱动下的连接实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">(String url,String user, String password)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    java.util.<span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Properties();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">        info.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="literal">null</span>) &#123;</span><br><span class="line">        info.put(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实际上调用的是下面的静态方法 getConnection</span></span><br><span class="line"><span class="comment">//  Worker method called by the public getConnection() methods.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">(</span></span><br><span class="line"><span class="params">    String url, java.util.Properties info, Class&lt;?&gt; caller)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * When callerCl is null, we should check the application&#x27;s</span></span><br><span class="line"><span class="comment">         * (which is invoking this class indirectly)</span></span><br><span class="line"><span class="comment">         * classloader, so that the JDBC driver class outside rt.jar</span></span><br><span class="line"><span class="comment">         * can be loaded from here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">callerCL</span> <span class="operator">=</span> caller != <span class="literal">null</span> ? caller.getClassLoader() : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(DriverManager.class) &#123;</span><br><span class="line">        <span class="comment">// synchronize loading of the correct classloader.</span></span><br><span class="line">        <span class="keyword">if</span> (callerCL == <span class="literal">null</span>) &#123;</span><br><span class="line">            callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(url == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;The url cannot be null&quot;</span>, <span class="string">&quot;08001&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;DriverManager.getConnection(\&quot;&quot;</span> + url + <span class="string">&quot;\&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Walk through the loaded registeredDrivers attempting to make a connection.</span></span><br><span class="line">    <span class="comment">// Remember the first exception that gets raised so we can reraise it.</span></span><br><span class="line">    <span class="type">SQLException</span> <span class="variable">reason</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">        <span class="comment">// If the caller does not have permission to load the driver then</span></span><br><span class="line">        <span class="comment">// skip it.</span></span><br><span class="line">        <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;    trying &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> aDriver.driver.connect(url, info);</span><br><span class="line">                <span class="keyword">if</span> (con != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Success!</span></span><br><span class="line">                    println(<span class="string">&quot;getConnection returning &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                    <span class="keyword">return</span> (con);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (reason == <span class="literal">null</span>) &#123;</span><br><span class="line">                    reason = ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;    skipping: &quot;</span> + aDriver.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we got here nobody could connect.</span></span><br><span class="line">    <span class="keyword">if</span> (reason != <span class="literal">null</span>)    &#123;</span><br><span class="line">        println(<span class="string">&quot;getConnection failed: &quot;</span> + reason);</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;getConnection: no suitable driver found for &quot;</span>+ url);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;No suitable driver found for &quot;</span>+ url, <span class="string">&quot;08001&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Connection-实现"><a href="#Connection-实现" class="headerlink" title="Connection 实现"></a>Connection 实现</h3><p>在 <code>Connection</code> 接口的具体实现部分，MySQL 的连接是通过两层实现完成抽象部分的实现</p><p>不同的数据库会进行不同的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionImpl</span> <span class="keyword">implements</span> <span class="title class_">JdbcConnection</span>, SessionEventListener, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">4009476458425101761L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SQLPermission</span> <span class="variable">SET_NETWORK_TIMEOUT_PERM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SQLPermission</span>(<span class="string">&quot;setNetworkTimeout&quot;</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JdbcConnection</span> <span class="keyword">extends</span> <span class="title class_">Connection</span>, MysqlConnection, TransactionEventHandler &#123;</span><br><span class="line">    JdbcPropertySet <span class="title function_">getPropertySet</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">changeUser</span><span class="params">(String var1, String var2)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>DriverManager</code> 作为组织者，组织了 <code>Driver</code>（由管理者 <code>DriverInfo</code> 进行管理）和 <code>Connection</code> 两类模块</p><p>根据使用的数据库不同灵活地进行连接的选择</p><p>对应的类图：</p><img src="/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%20-%20Bridge/jdbc%E7%B1%BB%E5%9B%BE.drawio.png" class="" title="jdbc类图.drawio"><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>当存在一段逻辑中分为多类模块时，可以考虑将各模块分别实现再进行组织降低耦合</p><ul><li><p>优点</p><ul><li>可以将庞大的类拆分成更有层次的结构，层次之间不存在耦合</li><li>便于模块实现的扩展（开闭）</li><li>切换不同的实现更加方便</li><li>每个模块又可以定义出抽象部分和实现部分（单一职责）</li></ul></li><li><p>缺点</p><ul><li>在已存在的功能上进行改造工程量较大（不同于适配器模式）</li><li>高内聚的类进行桥接设计会使代码更加复杂</li></ul></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://refactoringguru.cn/design-patterns/bridge">桥接设计模式 (refactoringguru.cn)</a></p><p><a href="https://blog.csdn.net/MY9526/article/details/108738263">桥接模式的实际使用_最后一个NPE的博客-CSDN博客_桥接模式实战</a></p><p><a href="https://www.cnblogs.com/EthanWong/p/16079803.html">设计模式学习笔记（九）桥接模式及其应用 - 归斯君 - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布隆 &amp; 布谷鸟过滤器</title>
      <link href="/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%83%E9%9A%86%20&amp;%20%E5%B8%83%E8%B0%B7%E9%B8%9F%E8%BF%87%E6%BB%A4%E5%99%A8.html"/>
      <url>/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%83%E9%9A%86%20&amp;%20%E5%B8%83%E8%B0%B7%E9%B8%9F%E8%BF%87%E6%BB%A4%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><strong>特征 or 全部</strong></p><p>在实际需求中，往往存在类似需求：</p><ul><li>黑白名单；例如手机号、网站等，需要过滤掉在黑名单中的数据，或者放行在白名单中的数据</li><li>推荐去重；首页新闻、视频等资源已经给用户推荐过的不进行重复推送</li><li>缓存穿透；保证缓存层能正常工作，不被特殊请求大量造成缓存穿透</li></ul><p>最容易想到的，就是通过一个集合例如 Map、List 等结构将数据存储起来，判断是否存在于集合中</p><p>这样相当于把所有的数据都进行了一遍存储，如果需要的只是过滤功能，而不需要将数据全部存储下来，只需要存储数据的特征值，就可以节省大量的空间</p><p>所以出现了布隆过滤器等概率型结构（probabilistic data structure），可以在使用很少空间的情况下对数据进行过滤操作，当然通过特征值进行存储可能会有以下问题：</p><ul><li>误判率</li><li>扩缩容依然需要数据全集（数据量不匹配会导致空间浪费或误判率上升）</li><li>删除操作难以实现</li></ul><p>需要在技术和业务两方面进行取舍</p><h1 id="布隆"><a href="#布隆" class="headerlink" title="布隆"></a>布隆</h1><p>布隆过滤器（bloom filter）由一串很长的二进制向量组成（位图 bitmap），可以将其看成一个二进制数组</p><p>当一个元素进入时，不是存储该元素本身，而是通过多个哈希算法，计算出该元素的多个下标，随后在位图中将对应的下标打上标记（bit 位置为 1），当需要判断是否存在某个元素时，也是进行哈希后，判断其需要的下标是否全为 1</p><p>可以看出，布隆过滤器带有一定的误判率，如果很多元素的下标正好复合了某一个元素的位置，那么该元素就会被误判存在：</p><ul><li>说存在但不一定存在</li><li>说不存在一定不存在</li></ul><p>图示模拟流程：<a href="https://www.jasondavies.com/bloomfilter/">https://www.jasondavies.com/bloomfilter/</a></p><p><strong>参数选择</strong></p><p>也可以看出布隆过滤器的误判率和以下参数相关：</p><ul><li>过滤器中位图的位数</li><li>哈希算法的数量和质量</li></ul><p><a href="https://hur.st/bloomfilter/?n=400000000&p=0.01&m=&k=">Bloom filter calculator (hur.st)</a> 可以进行布隆过滤器参数的预估</p><table><thead><tr><th align="center">参数值</th><th align="center">含义</th><th align="center">公式</th></tr></thead><tbody><tr><td align="center">n</td><td align="center">过滤器中的元素数量</td><td align="center"><code>n = ceil(m / (-k / log(1 - exp(log(p) / k))))</code></td></tr><tr><td align="center">p</td><td align="center">误判率</td><td align="center"><code>p = pow(1 - exp(-k / (m / n)), k)</code></td></tr><tr><td align="center">m</td><td align="center">过滤器使用的空间大小</td><td align="center"><code>m = ceil((n * log(p)) / log(1 / pow(2, log(2))));</code></td></tr><tr><td align="center">k</td><td align="center">哈希算法数量</td><td align="center"><code>k = round((m / n) * log(2));</code></td></tr></tbody></table><p><strong>无法删除</strong></p><p>布隆过滤器是无法删除元素的，因为一旦存储特征后，删除会导致连带其他元素的标记一起删除</p><p>为了能让布隆过滤器支持删除操作，衍生出了变体结构，计数布隆过滤器（counting bloom filter）</p><p><strong>实际应用</strong></p><p><a href="https://toutiao.io/posts/mtrvsx/preview">Now 直播发现页短视频瀑布流优化 - 开发者头条 (toutiao.io)</a></p><h1 id="计数布隆"><a href="#计数布隆" class="headerlink" title="计数布隆"></a>计数布隆</h1><p>使用一个 counter 数组来替代之前的位图，在进行标记时可以记录一共标记了多少次，显而易见空间占用会扩大不少</p><p>在进行判断时 <code>counter &gt; 0</code> 即表示了之前的 <code>index == 1</code> 操作</p><p>计数器也无法避免误删，只是能大幅度降低误删概率</p><h1 id="布谷鸟"><a href="#布谷鸟" class="headerlink" title="布谷鸟"></a>布谷鸟</h1><p>布谷鸟过滤器是布隆过滤器的升级，有如下优势：</p><ul><li>支持动态的新增和删除元素</li><li>提供了比传统布隆过滤器更高的查找性能，即使在接近满空间的情况下（访问内存次数低）</li><li>要求一定误判率下，空间占用一般更小</li></ul><p><strong>布谷鸟 hash</strong></p><blockquote><p>当发现鸟蛋占用了自己的位置时，就把它推走</p></blockquote><p>假设有两个 hash 表，记为 T1 和 T2</p><p>同时有两套 hash 算法，记为 H1 和 H2</p><p>添加元素流程如下：</p><ol><li>根据 H1 计算其在 T1 的位置下标</li><li>如果该位置没有标记则进行标记，如果标记了则继续</li><li>根据 H2 计算其在 T2 的位置下标</li><li>如果该位置没有标记则进行标记，如果标记了则说明所有位置都已经被占用，随机踢出 T1 或者 T2 上该下标的元素，将自己放入下标</li><li>被踢出的元素重复上述流程查找自己的位置</li><li>经过 <code>MaxLoop </code> 阈值后还存在元素没有合适的位置，则元素添加失败，说明需要进行扩容了</li></ol><p>图示模拟流程：<a href="http://www.lkozma.net/cuckoo_hashing_visualization/">http://www.lkozma.net/cuckoo_hashing_visualization/</a></p><p><strong>过滤器的 hash</strong></p><p>布谷鸟过滤器的 hash 是对布谷鸟 hash 的改进</p><p>布谷鸟 hash 中，哈希表存储的是元素的原始值 x，下标 p1 p2 的计算公式为</p><ul><li><code>p1 = hash1(x) % L</code></li><li><code>p2 = hash2(x) % L</code></li></ul><p>而布谷鸟过滤器对于下标的计算为：</p><ul><li><code>h1(x) = hash(x)</code></li><li><code>h2(x) = h1(x) ⊕ hash(x&#39;s fingerprint)</code></li></ul><p>我们可以看到，计算 h2（位置 2）时，对 x 的 fingerprint 进行了一个 hash 计算，公式中的异或操作获得了一个重要的特性：位置 h2 可以通过位置 h1 和 h1 中存储的 fingerprint 计算出来，即当元素被踢出时，根据当前位置和元素的指纹，就可以得到元素的下一个位置</p><p><strong>异或与对偶</strong></p><p>由 h2 的计算公式 <code>h2(x) = h1(x) ⊕ hash(x&#39;s fingerprint)</code>，两个位置具有对偶性</p><p>只要保证 <code>hash(x&#39;s fingerprint) !=0</code>，那么就可以确保 <code>h2 != h1</code>，也就可以确保，不会出现自己踢自己的死循环问题</p><p>为什么需要对指纹进行哈希运算呢？因为如果指纹的长度是 8 bit，那么异或操作只会改变当前位置  h1(x)  的低 8 位，高位不会改变，就算低 8 位完全不一样，最后计算出来的位置最远也只有 256 位，为了散列更充分，所以对指纹先进行一次哈希操作</p><p><strong>指纹</strong></p><p>指纹其实就是元数据的特征值，进行哈希后取的固定 n 个 bit 位</p><p><strong>空间利用率</strong></p><p>由于指纹是对数据进行哈希运算后固定的 bit 位，所以必然会出现误判的情况</p><p>在完美的情况下，也就是没有发生哈希冲突之前，它的空间利用率最高只有 50%</p><p>如果对数组进行展开，当一个位置可以存放多个数据时，空间利用率会提升；如果一个下标可以放 2、4、8 个元素的时候，空间利用率就会飙升到 84%、95%、98%</p><p><strong>删除的限制</strong></p><p>如果需要布谷鸟过滤器支持删除，它必须知道一个数据插入过多少次（否则也会误删）</p><p>并且不能让同一个数据插入 <code>kb+1</code> 次；个人认为如果插入超过了 <code>kb+1</code> 次，就会导致插入一定失败</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>布谷鸟的优缺点：</p><p><strong>优点：</strong></p><ul><li>访问内存次数低</li><li>Hash 函数计算简单</li><li>支持删除操作</li></ul><p><strong>缺点：</strong></p><ul><li>内存空间不联系，CPU 消耗大</li><li>容易出现装填循环问题，空间占用越多碰撞越多，插入效率越低</li><li>查询误判率</li><li>删除操作限制多，会影响插入性能和误删除</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf">https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf</a></p><p><a href="https://zhuanlan.zhihu.com/p/348865590">布隆，牛逼！布谷鸟，牛逼！ - 知乎 (zhihu.com)</a></p><p><a href="https://juejin.cn/post/6844903861749055502">布隆过滤器过时了，未来属于布谷鸟过滤器？ - 掘金 (juejin.cn)</a></p><p><a href="https://zhuanlan.zhihu.com/p/462815302">布隆过滤器与布谷鸟过滤器 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>管道模式 - Pipeline</title>
      <link href="/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%A1%E9%81%93%E6%A8%A1%E5%BC%8F%20-%20Pipeline.html"/>
      <url>/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%A1%E9%81%93%E6%A8%A1%E5%BC%8F%20-%20Pipeline.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>管道模式（Pipeline Pattern）是责任链模式（Chain of Command Pattern）的变体；区别在于责任链是将处理器按照链条组织起来，待处理的上下文按照链条找到能够处理自己的处理器，一般只有唯一的一个处理器；而管道模式是链条中的每一个处理器都需要对上下文进行处理</p><p><strong>目的</strong><br>降低业务逻辑流程的耦合性，将整个过程中所有的处理器隔离开，更方便扩展流程上新的业务逻辑</p><p><strong>现实世界类比</strong><br>工厂的生产流水线，车架 -&gt; 发送机 -&gt; 外壳 -&gt; 内饰 -&gt; 总装 -&gt; 质检，整辆车在传送带又一个环节运输至另一个环节，每个处理环节都对汽车处理自己的部分，最终产出成品</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>模拟一个场景，比如订单服务内查询接口把最终订单实体组装为一个 VO</p><p>除了原有的实体属性，比如内部数据需要对优惠金额进行计算，外部数据需要补充用户信息、商品信息等</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果将所有步骤抽为方法，则代码一般会实现为这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> OrderInfoVo <span class="title function_">buildVO</span><span class="params">(OrderBo bo)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">OrderInfoVo</span> <span class="variable">vo</span> <span class="operator">=</span> <span class="built_in">this</span>.wrapVo(bo);</span><br><span class="line">    <span class="built_in">this</span>.calMitigateSum(vo);</span><br><span class="line">    <span class="built_in">this</span>.buildUserInfo(vo);</span><br><span class="line">    <span class="built_in">this</span>.buildCommodityInfo(vo);</span><br><span class="line">    <span class="keyword">return</span> vo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面如果对 VO 的字段有了新的要求，比如增加物流信息；或者对生成 VO 的流程有了新的要求，比如根据查询条件进行缓存，就会有以下坏处：</p><ul><li>在 <code>buildVO</code> 中实现缓存逻辑，违反了方法的单一职责，维护在外面可能又需要维护一个统一的入口</li><li>将来每加入一个新的处理步骤或者删除某个步骤，都要修改 <code>buildVO</code> 方法</li></ul><p>这种情况下可以使用管道模式解决以上缺点</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>上下文维护着整个业务链条中间的结果和最终的结果数据</p><p><strong>管道上下文父类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传递到管道的上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理开始时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime startTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理结束时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime endTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体的业务数据上下文</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderVOContext</span> <span class="keyword">extends</span> <span class="title class_">PipelineContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单业务模型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> OrderBO bo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单 VO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> OrderVO vo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模型创建出错时的错误信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String errorMsg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他参数</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;build OrderVO&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p><strong>处理器父类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 管道中的上下文处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ContextHandler</span>&lt;T <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理输入的上下文数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 处理时的上下文数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 true 则表示由下一个 ContextHandler 继续处理，返回 false 则表示处理结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">(T context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>计算优惠金额</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@sl4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalMitigateSumHandler</span> <span class="keyword">implements</span> <span class="title class_">ContextHandler</span>&lt;OrderVOContext&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">(InstanceBuildContext context)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;--计算优惠金额--&quot;</span>);</span><br><span class="line">        <span class="comment">// 计算流程</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">mitigateSum</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        context.getVo().setMitigateSum(mitigateSum);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造用户信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@sl4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">buildUserInfoHandler</span> <span class="keyword">implements</span> <span class="title class_">ContextHandler</span>&lt;OrderVOContext&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">(InstanceBuildContext context)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;--构造用户信息--&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userClient.getUserById(context.getBo().getUserId());</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">            context.setErrorMsg(<span class="string">&quot;查询用户信息为空，id=&quot;</span> + context.getBo().getUserId());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        context.getVo().setUserName(user.getName());</span><br><span class="line">        context.getVo().setUserAge(user.getAge());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造商品信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@sl4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">buildGoodsInfoHandler</span> <span class="keyword">implements</span> <span class="title class_">ContextHandler</span>&lt;OrderVOContext&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">(InstanceBuildContext context)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;--构造商品信息--&quot;</span>);</span><br><span class="line">        <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> goodsClient.getGoodsBySku(context.getBo().getGoodsSku());</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(goods)) &#123;</span><br><span class="line">            context.setErrorMsg(<span class="string">&quot;查询商品信息为空，id=&quot;</span> + context.getBo().getGoodsSku());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        context.getVo().setGoodsSku(goods.getSku());</span><br><span class="line">        context.getVo().setGoodsName(goods.getName());</span><br><span class="line">context.getVo().setGoodsPrice(goods.getPrice());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组织处理器"><a href="#组织处理器" class="headerlink" title="组织处理器"></a>组织处理器</h3><p>现在业务 Context 和 Handler 都定义好了，那么使用什么方式将 Handler 组织起来呢？有如下几种：</p><ul><li>Handler 对象持有下一个 Handler 的信息，比如使用 <code>nextHandler</code> 属性来保存下一个处理器；缺点是无法直观了解整个业务链条都有哪些处理器，并且增删处理器需要修改其他处理器的属性</li><li>自定义注解将顺序信息和 Handler 的实现绑定；这样也无法直观了解到一段业务都有多少个处理器</li><li>维护一个路由表，基于 Spring 的自动注入来实现和管理路由表，使用一个执行器角色只有处理器集合作为入口</li></ul><p><strong>构造路由表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 管道路由的配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineRouteConfig</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据类型-&gt;管道中处理器类型列表 的路由</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span></span><br><span class="line">    Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;,</span><br><span class="line">        List&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">ContextHandler</span>&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;&gt;&gt;&gt; PIPELINE_ROUTE_MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在这里配置各种上下文类型对应的处理管道：键为上下文类型，值为处理器类型的列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        PIPELINE_ROUTE_MAP.put(OrderVOContext.class,</span><br><span class="line">                               Arrays.asList(</span><br><span class="line">                                       CalMitigateSumHandler.class,</span><br><span class="line">                                       buildUserInfoHandler.class,</span><br><span class="line">                                       buildGoodsInfoHandler.class</span><br><span class="line">                               ));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将来其他 Context 的管道配置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 Spring 启动时，根据路由表生成对应的管道映射关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;pipelineRouteMap&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;, List&lt;? <span class="keyword">extends</span> <span class="title class_">ContextHandler</span>&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;&gt;&gt; getHandlerPipelineMap() &#123;</span><br><span class="line">        <span class="keyword">return</span> PIPELINE_ROUTE_MAP.entrySet()</span><br><span class="line">                                 .stream()</span><br><span class="line">                                 .collect(Collectors.toMap(Map.Entry::getKey, <span class="built_in">this</span>::toPipeline));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据给定的管道中 ContextHandler 的类型的列表，构建管道</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;? <span class="keyword">extends</span> <span class="title class_">ContextHandler</span>&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;&gt; toPipeline(</span><br><span class="line">            Map.Entry&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;, List&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">ContextHandler</span>&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;&gt;&gt;&gt; entry) &#123;</span><br><span class="line">        <span class="keyword">return</span> entry.getValue()</span><br><span class="line">                    .stream()</span><br><span class="line">                    .map(appContext::getBean)</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext appContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        appContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>管道执行器</strong></p><p>管道执行器根据传入的上下文数据的类型，找到其对应的管道，然后将上下文数据放入管道中去进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 管道执行器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipelineExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用 PipelineRouteConfig 中的 pipelineRouteMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt;,</span><br><span class="line">                List&lt;? <span class="keyword">extends</span> <span class="title class_">ContextHandler</span>&lt;? <span class="built_in">super</span> PipelineContext&gt;&gt;&gt; pipelineRouteMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步处理输入的上下文数据</span></span><br><span class="line"><span class="comment">     * 如果处理时上下文数据流通到最后一个处理器且最后一个处理器返回 true，则返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 输入的上下文数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 处理过程中管道是否畅通，畅通返回 true，不畅通返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acceptSync</span><span class="params">(PipelineContext context)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(context, <span class="string">&quot;上下文数据不能为 null&quot;</span>);</span><br><span class="line">        <span class="comment">// 拿到数据类型</span></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">PipelineContext</span>&gt; dataType = context.getClass();</span><br><span class="line">        <span class="comment">// 获取数据处理管道</span></span><br><span class="line">        List&lt;? <span class="keyword">extends</span> <span class="title class_">ContextHandler</span>&lt;? <span class="built_in">super</span> PipelineContext&gt;&gt; pipeline = pipelineRouteMap.get(dataType);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(pipeline)) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;&#123;&#125; 的管道为空&quot;</span>, dataType.getSimpleName());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 管道是否畅通</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">lastSuccess</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ContextHandler&lt;? <span class="built_in">super</span> PipelineContext&gt; handler : pipeline) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 当前处理器处理数据，并返回是否继续向下处理</span></span><br><span class="line">                lastSuccess = handler.handle(context);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                lastSuccess = <span class="literal">false</span>;</span><br><span class="line">                logger.error(<span class="string">&quot;[&#123;&#125;] 处理异常，handler=&#123;&#125;&quot;</span>, context.getName(), handler.getClass().getSimpleName(), ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不再向下处理</span></span><br><span class="line">            <span class="keyword">if</span> (!lastSuccess) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lastSuccess;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用管道"><a href="#使用管道" class="headerlink" title="使用管道"></a>使用管道</h3><p>原来的 <code>buildVO</code> 可以引入管道来进行实现了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> OrderInfoVo <span class="title function_">buildVO</span><span class="params">(OrderBo bo)</span> &#123;</span><br><span class="line">    <span class="type">OrderVOContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.createContext(bo);</span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> pipelineExecutor.acceptSync(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流程成功</span></span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        <span class="keyword">return</span> CommonResponse.success(data.getInstanceId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logger.error(<span class="string">&quot;build vo 失败：&#123;&#125;&quot;</span>, data.getErrorMsg());</span><br><span class="line">    <span class="keyword">return</span> CommonResponse.failed(data.getErrorMsg());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增加处理器"><a href="#增加处理器" class="headerlink" title="增加处理器"></a>增加处理器</h3><p>如果需要在流程中增加新业务</p><p><strong>创建新的处理器实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@sl4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">newTaskHandler</span> <span class="keyword">implements</span> <span class="title class_">ContextHandler</span>&lt;OrderVOContext&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">(InstanceBuildContext context)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;--执行新业务--&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改手动维护的静态路由表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    PIPELINE_ROUTE_MAP.put(OrderVOContext.class,</span><br><span class="line">                           Arrays.asList(</span><br><span class="line">                               CalMitigateSumHandler.class,</span><br><span class="line">                               buildUserInfoHandler.class,</span><br><span class="line">                               newTaskHandler.class, <span class="comment">// 流程中增加了新逻辑</span></span><br><span class="line">                               buildGoodsInfoHandler.class</span><br><span class="line">                           ));</span><br></pre></td></tr></table></figure><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>对于步骤繁多的任务，很多时候我们更需要的是异步处理，比如某些耗时长的定时任务，管道处理异步化非常的简单</p><p>在 PipelineExecutor 中引入异步的处理方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 管道线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> ThreadPoolTaskExecutor pipelineThreadPool; <span class="comment">// 处理异步的线程池</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步处理输入的上下文数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context  上下文数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callback 处理完成的回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acceptAsync</span><span class="params">(PipelineContext context, BiConsumer&lt;PipelineContext, Boolean&gt; callback)</span> &#123;</span><br><span class="line">    pipelineThreadPool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> acceptSync(context);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="literal">null</span>) &#123;</span><br><span class="line">            callback.accept(context, success);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过管道模式，可以大幅降低了系统的耦合度和提升了内聚程度与扩展性：</p><ul><li><p>优点</p><ul><li><code>buildVO</code> 所在的类只负责处理引导 BO 进入管道的业务流程，而不关注具体业务逻</li><li><code>PipelineExecutor </code> 抽象定义，不关心业务细节</li><li>每个 <code>ContextHandler </code> 只负责自己的业务，不需要知道链路结构，与其他处理器解耦</li><li>对于处理器新增、删除、调整顺序等操作，只需要修改路由表，和业务逻辑脱离</li></ul></li><li><p>缺点</p><ul><li>大的 Context 对象，让业务数据粒度很粗（上帝对象）</li><li>和策略一样，可能造成实现类膨胀</li><li>错误信息需要保存在 Context 对象中，走完所有处理器才会将错误返回</li></ul></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/370363597">设计模式最佳套路2 —— 基于 Spring 实现管道模式的最佳实践 - 知乎 (zhihu.com)</a></p><p><a href="https://refactoringguru.cn/design-patterns/chain-of-responsibility">责任链设计模式（职责链模式） (refactoringguru.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ 最佳实践</title>
      <link href="/%E5%BC%80%E5%8F%91/MQ/RocketMQ%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html"/>
      <url>/%E5%BC%80%E5%8F%91/MQ/RocketMQ%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html</url>
      
        <content type="html"><![CDATA[<h1 id="Topic-与-Tag"><a href="#Topic-与-Tag" class="headerlink" title="Topic 与 Tag"></a>Topic 与 Tag</h1><p>在 RocketMQ 中，Topic 和 Tag 都是业务上用来归类的标识，通过合理的使用 Topic 和 Tag 可以让业务结构清晰，更可以提高效率</p><p><strong>Topic</strong> 是消息主题，通过 Topic 对不同的业务消息进行分类<br><strong>Tag</strong>  是消息标签，用来进一步区分某个 Topic 下的消息分类，是消息生产时即由消息生产者设置的属性  </p><p>Topic 和 Tag 的选择，建议从以下几个方面判断：</p><ul><li><strong>消息类型是否一致：</strong>普通消息、事务消息、延迟消息、顺序消息；不同消息使用不同的 Topic，无法通过 Tag 进行区分</li><li><strong>业务是否相关联：</strong>没有关联的业务应该使用不同的 Topic</li><li><strong>消息优先级是否一致：</strong>同一个 Topic 内应该是同样优先级的消息</li><li><strong>量级是否相当：</strong>业务量小但实时性高的消息和业务量大的消息放在一个 Topic 内，可能会导致饥饿</li></ul><p>以电商系统为例，订单消息和支付消息属于不同的业务，设置 TOPIC_ORDER 和 TOPIC_PAY<br>其中订单消息根据商品种类再划分为不同的 tag，例如电器类、服装类、图书类等<br>支付消息根据不同的支付渠道划分，例如银行卡、支付宝、微信支付等</p><h1 id="消费幂等"><a href="#消费幂等" class="headerlink" title="消费幂等"></a>消费幂等</h1><p>为了防止消息重复消费导致业务处理异常，RocketMQ 消费者在接收消息后，有必要根据业务上的唯一 Key 对消息进行幂等处理</p><p>个人认为需要注意的是，这个业务上的唯一 Key，无论是在 Consumer 层做去重实现业务幂等（去重表），还是业务逻辑上做幂等（状态机、版本校验），都应该是使用业务意义上的唯一标识，而不是依赖 Message ID</p><p><strong>消息重复的场景</strong></p><ul><li><strong>Producer 端：</strong>发送消息时，Brocker 已经收到消息并持久化，但 ACK 由于网络原因未成功返回给生产者，为了保证消息不丢失，生产者会再一次发送消息；或者上游业务认为失败重新进行了调用，就可能会发送重复的消息，并且是不同的 Message ID</li><li><strong>Brocker 端：</strong>投递消息给消费者，消费者的 offset 因为网络等原因提交失败，为了保证消息至少一次，Brocker 会再次投递消息</li><li><strong>Consumer 端：</strong>服务扩缩容导致的 rebalance 操作，本质上也是消费者的 offset 没有及时提交</li></ul><p>因为不同的 Message ID 对应的消息内容可能相同，有可能出现冲突（重复）的情况，所以真正安全的幂等处理，不建议以 Message ID 作为处理依据</p><p>最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息 Key 设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(<span class="string">&quot;ons_test&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> message.getKey()</span><br><span class="line">        <span class="comment">// 根据业务唯一标识的 Key 做幂等处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="订阅关系"><a href="#订阅关系" class="headerlink" title="订阅关系"></a>订阅关系</h1><p>订阅关系需要保持一致，一致的定义是：<strong>同一个消费者组下所有 Consumer 实例所订阅的 Topic、Tag、Tag 的顺序必须完全一致</strong></p><p>如果订阅关系不一致，消息消费的逻辑就会混乱，甚至导致消息丢失</p><p><strong>为什么会丢失？</strong></p><p>当一个 Consumer 消费一个 Queue 时，会在 ConsumerQueue 中保存该消费者和消息的相关信息</p><p>ConsumerQueue 中保存了如下信息：</p><ul><li>前 8 个字节记录消息在 CommitLog 中的偏移量</li><li>中间 4 个字节记录消息大小</li><li>最后 8 个字节记录消息中 tag 的 hashcode</li></ul><p>假如一个 Consumer 订阅了 Topic1 中的 Tag1，那这个 Consumer 拉取消息时，首先从 Name Server 获取订阅关系，得到当前 Consumer 订阅的所有 tag 的 hashcode 集合 codeSet；每次从 ConsumerQueue 获取一条记录，就要判断最后 8 个字节 tag hashcode 是否在 codeSet 中，比如 Tag2 不在 codeSet 中，就会被过滤掉</p><p>所以不正确的订阅关系会导致该 ConsumerQueue 中的消息被错误丢弃了</p><h1 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h1><p>当客户端消费速度跟不上服务端消息发送的速度，便会出现消息堆积</p><p>消息堆积的主要影响：</p><ul><li>消费延迟</li><li>生产者无法成功发送消息（无法生产）</li></ul><p>以下场景需要着重关注消息堆积和延迟问题：</p><ul><li>业务系统上下游能力不匹配造成的持续堆积，且无法自行恢复</li><li>业务系统对消息的消费实时性要求较高，即使是短暂的堆积造成的消息延迟也无法接受</li></ul><p>客户端 Push 模式到消费消息有两个阶段：</p><ul><li><strong>获取消息：</strong>通过长轮询批量拉取的方式从 Brocker 拉取消息，这一阶段吞吐量较高，所以一般不会成为性能瓶颈</li><li><strong>消费 &amp; 提交：</strong>依赖业务的处理耗时和消费逻辑的并发度</li></ul><p>所以通过消息消费的两大步骤来看，消息堆积的主要问题出现在第二阶段，即<strong>消费耗时</strong>和<strong>消费并发度</strong>    </p><p><strong>消费耗时</strong></p><p>影响消费耗时的消费逻辑主要分为 CPU 内存计算和外部 IO 操作；由于大部分服务器场景都是 IO 密集型，业务代码在正常情况下不会涉及复杂的运算，内部耗时相比 IO 耗时来说可以忽略不记</p><p>IO 操作通常包含以下逻辑：</p><ul><li>读写外部数据库，例如 MySQL</li><li>读写外部缓存系统，例如 Redis</li><li>下游系统调用，例如 Dubbo 调用或者下游 HTTP 接口调用</li></ul><p><strong>消费并发度</strong></p><p>不同的消息类型对应不同的并发度配置策略</p><table><thead><tr><th>消息类型</th><th>并发度</th></tr></thead><tbody><tr><td>普通消息</td><td>单节点线程数 × 节点数量</td></tr><tr><td>定时和延时消息</td><td>单节点线程数 × 节点数量</td></tr><tr><td>事务消息</td><td>单节点线程数 × 节点数量</td></tr><tr><td>顺序消息</td><td>Min（单节点线程数 × 节点数量，分区数）</td></tr></tbody></table><p>此外单节点的并发度需要谨慎设置，不能盲目直接调大线程数，设置过大的线程数反而会带来大量的线程切换的开销</p><p>理想环境下单节点的最优线程数计算模型如下：</p><ul><li>单机 CPU 核数为 C</li><li>线程切换耗时忽略不计，IO 操作不消耗 CPU</li><li>线程有足够消息等待处理，且内存充足</li><li>逻辑中 CPU 计算耗时为 T1，外部 IO 操作为 T2</li></ul><p>则单个线程能达到的 TPS 为 <code>1 / (T1 + T2)</code>，如果CPU使用率达到理想状态 100%，那么单机达到最大能力时需要设置 <code>C × (T1 + T2) / T1</code> 个线程</p><h1 id="读写队列"><a href="#读写队列" class="headerlink" title="读写队列"></a>读写队列</h1><p>新建 Topic 需要配置相关的属性 <code>writeQueueNums</code> 和 <code>readQueueNums</code>，分别代表写队列的数量和读队列的数量</p><p>其中 <code>writeQueueNums</code> 和 <code>readQueueNums</code> 的参数可以自由配置，<strong>为什么可以自由配置呢而不是必须相等呢？</strong></p><blockquote><p><strong>备注</strong>：读写队列和读写分离不是同一个概念</p><p>读写分离指的是主节点和从节点关于读写请求分配的问题</p><p>读写队列在做路由信息时使用，在消息发送时，使用写队列个数返回路由信息，而消息消费时按照读队列个数返回路由信息，在物理文件层面，只有写队列才会创建文件</p></blockquote><p><strong>读写队列数量不匹配时会发生什么</strong></p><ul><li>写多读少：多出来的写队列无法被消费</li><li>读多写少：Consumer 对应的多出来的读队列没有消息，也就不会从该读队列消费任何消息</li></ul><p><strong>为什么要这么设计</strong></p><p>设置读写队列数的目的在于方便队列的缩容和扩容</p><p>一个 Topic 在每个 Brocker 上创建了 128 个队列，现在需要将队列缩容到 64 个，怎么做才能 100% 不会丢失消息，并且无需重启应用程序</p><p>解决办法：</p><ol><li>先将写队列缩容（128 调整为 64）；后续数据请求会进入 0 至 63 的写队列中，由之前的 Consumer 进行消费</li><li>等待 64 至 127 队列中的消息被消费完成</li><li>缩容读队列（128 调整为 64）；此时 Consumer 重新分配，对应 64 个写队列</li></ol><p><strong>同时缩容写队列和读队列可能会导致部分消息未被消费</strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://help.aliyun.com/document_detail/69109.html">最佳实践 (aliyun.com)</a></p><p><a href="https://www.cnblogs.com/liaowenhui/p/15717353.html">RocketMQ订阅关系不一致 - JustJavaIt - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/qian_348840260/article/details/108975241">rocketmq中的读写队列_八荒六合唯我独尊-CSDN博客_rocketmq读写队列</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> MQ </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES cardinality 和 HyperLogLog</title>
      <link href="/%E5%BC%80%E5%8F%91/ES/ES%20cardinality%20%E5%92%8C%20HyperLogLog.html"/>
      <url>/%E5%BC%80%E5%8F%91/ES/ES%20cardinality%20%E5%92%8C%20HyperLogLog.html</url>
      
        <content type="html"><![CDATA[<h1 id="基数聚合"><a href="#基数聚合" class="headerlink" title="基数聚合"></a>基数聚合</h1><p>基数聚合属于聚合中的度量聚合，计算不同值的<strong>近似计数</strong></p><p>需要注意，聚合出的结果是一个近似值，原因是底层结构使用的 HyperLogLog，具有一定误差</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>假定 index 存储的售卖数据，希望查询有多少种不同的商品类型</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST /sales/_search?size=<span class="number">0</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;cardinality&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以之前的学生 index 为例，查询有几个班级下有女学生</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;female&quot;</span> <span class="comment">// 结果集查询性别为女性</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="comment">// 不关注 hits 结果集</span></span><br><span class="line"><span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;class_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;cardinality&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;class&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>返回结果，选取 <code>hits</code> 和 <code>aggregations</code> 部分</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;relation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eq&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;max_score&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;aggregations&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;class_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>因为 <code>size</code> 为 0，所以 <code>hits</code> 中没有返回的文档</p><p><code>aggregations</code> 下自定义结果集名称 <code>class_count</code> 返回的值为 2，说明班级下有女学生的班级数量为 2</p><h2 id="近似值与精确阈值参数"><a href="#近似值与精确阈值参数" class="headerlink" title="近似值与精确阈值参数"></a>近似值与精确阈值参数</h2><p>由于返回结果是一个近似值，所以 <code>cardinality</code> 支持 <code>precision_threshold</code> 参数，用来设置精确阈值</p><p>阈值参数的本质是使用空间换取准确性，默认是 3000，最大支持 40000，超过 40000 的设置为按照 40000 来处理</p><p>低于阈值的计数更符合准确值，高于阈值的计数则会更加模糊</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;female&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;class_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;cardinality&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;class&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;precision_threshold&quot;</span><span class="punctuation">:</span> <span class="number">200000</span> <span class="comment">// 精度阈值，事实上内部将该参数视为 40000</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>计算精确的计数需要将值加载至哈希集合并返回大小，当基数特别大时，需要占用非常多资源</p><p>所以 ES 选择 HyperLogLog 算法来实现 <code>cardinality</code>，这种方式基于值的哈希计数，有一些特性：</p><ul><li>可配置的精度，可以选择用内存换取精度</li><li>低基数集合中是精准的</li><li>固定的内存使用率，无论唯一值有多少，只取决于设置的精度</li></ul><p>HyperLogLog + + 算法依赖于散列值的前导零，数据集中散列的精确分布会影响基数的准确性</p><p>ES 官方文档提供的数据显示，具体的准确性取决于数据集情况，但大部分场景的准确性都还是良好的，<strong>即使阈值设置为 100，在百万、千万基数下，误差范围也控制在了 1% ~ 6%；当阈值设置为 10000，误差基本在 1% 左右</strong></p><h2 id="脚本-runtime-field"><a href="#脚本-runtime-field" class="headerlink" title="脚本 runtime field"></a>脚本 runtime field</h2><p><code>cardinality</code> 像其他聚合操作一样，是可以使用脚本拼接字段的</p><p>如果希望对两个字段的组合进行操作，创建一个 runtime field 组合他们然后进行基数聚合</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;runtime_mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;gender_and_age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;script&quot;</span><span class="punctuation">:</span> <span class="string">&quot;emit(doc[&#x27;gender&#x27;].value + &#x27;&amp;&#x27; + doc[&#x27;age&#x27;].value)&quot;</span> <span class="comment">// 拼接 gender 和 age 字段</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type_promoted_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;cardinality&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gender_and_age&quot;</span> <span class="comment">// 根据 runtime field 进行基数操作</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>返回结果是 6，因为有两个文档的 runtime field <code>gender_and_age</code> 值都为 <code>male&amp;20</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;aggregations&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type_promoted_count&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">6</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><p>HyperLogLog 是一种基数计数的算法，旨在使用较少内存的情况下得到基数数量的近似精确值</p><h2 id="基数计数方式"><a href="#基数计数方式" class="headerlink" title="基数计数方式"></a>基数计数方式</h2><p>基数计数（cardinality counting）通常用来统计一个集合中不重复的元素个数，例如统计某个网站的 UV，或者用户搜索网站的关键词数量等</p><p>如何计算计数常见的有多种方式</p><ul><li>B 树<ul><li>利用树存储具体元素</li><li>优点：插入和查找效率高，统计数据时可以快速做到记录与去重，计算基数时只需要统计叶子节点个数即可</li><li>缺点：没有节省内存，需要存储数据全集</li></ul></li><li>bitmap<ul><li>使用 bit 位进行标记，即抛弃具体元素内容只存储特征值</li><li>优点：节约内存，结果可以进行方便的位运算操作（合并 - 与，差集 - 或）</li><li>缺点：空间占用仍然较大</li></ul></li><li>概率算法<ul><li>目前用于基数计数的概率算法有：LC、LLC、HLL 等</li><li>优点：LL、HLL 等能够在空间更小的情况下进行基数计算</li><li>缺点：有一定误差</li></ul></li></ul><h2 id="HLL"><a href="#HLL" class="headerlink" title="HLL"></a>HLL</h2><p>HLL 中实际存储的是一个长度为 m 的大数组 S，将待统计的数据集合划分成 m 组，每组根据算法记录一个统计值存入数组中</p><p>数组的大小 m 由算法实现方自己确定，Redis 中这个数组的大小是 16834，m 越大误差越小，但需要的内存空间也越大</p><p>HLL 的数学原理看不懂，大致就是 n 重伯努利原理</p><p>通过多次抛硬币，直到抛到正面为止，这是一次伯努利过程；当一直抛硬币，直到多次出现正面，将出现正面的投掷次数值记为 k1、k2、k3…kn，最大值记为 kmax，那么可以得到以下结论：</p><ul><li>n 次伯努利过程的投掷次数都不大于 kmax</li><li>n 次伯努利过程，至少有一次投掷次数等于 kmax</li></ul><p>最后经过一系列复杂的推论，最终的结果就是：<strong>进行了 n 次进行抛硬币实验，每次分别记录下第一次抛到正面的抛掷次数 k，那么可以用 n 次实验中最大的抛掷次数 kmax 来预估实验组数量 n</strong>；这就是 HLL 算法的数学理论基础</p><p>此外 HLL 为了提高准确性也做了其他优化</p><p><strong>分桶平均</strong></p><p>HLL 的基本思想是利用集合中数字的比特串第一个1出现位置的最大值来预估整体基数，但是这种预估方法存在较大误差，为了改善误差情况，HLL 中引入分桶平均的概念</p><p>为了避免一组实验中的运气影响，将统计数据划分多个桶，每个桶各自统计自己的 kmax 计算基数预估值，最终对各个桶的基数预估值进行合并，使用调和平均数的方式进一步降低误差</p><p><strong>偏差修正</strong></p><p>虽然调和平均数能够适当修正算法误差，但作者给出一种分阶段修正算法</p><p>当 HLL 算法开始统计数据时，统计数组中大部分位置都是空数据，并且需要一段时间才能填满数组，这种阶段引入一种小范围修正方法；当 HLL 算法中统计数组已满的时候，需要统计的数据基数很大，这时候 hash 空间会出现很多碰撞情况，这种阶段引入一种大范围修正方法</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.5/search-aggregations-metrics-cardinality-aggregation.html#search-aggregations-metrics-cardinality-aggregation">Cardinality aggregation | Elasticsearch Guide 8.5 </a></p><p><a href="https://juejin.cn/post/7067816471128342564">神奇的HyperLogLog算法【转载 #涉及到数学原理】 - 掘金 (juejin.cn)</a></p><p><a href="http://content.research.neustar.biz/blog/hll.html">Sketch of the Day: HyperLogLog — Cornerstone of a Big Data Infrastructure – AK Tech Blog (neustar.biz)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> ES </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
            <tag> ES 碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES 折叠操作</title>
      <link href="/%E5%BC%80%E5%8F%91/ES/ES%20%E6%8A%98%E5%8F%A0%E5%92%8C%E8%81%9A%E5%90%88.html"/>
      <url>/%E5%BC%80%E5%8F%91/ES/ES%20%E6%8A%98%E5%8F%A0%E5%92%8C%E8%81%9A%E5%90%88.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="折叠和聚合"><a href="#折叠和聚合" class="headerlink" title="折叠和聚合"></a>折叠和聚合</h2><p>日常会有很多场景希望将平面数据按照一定的条件组合起来，并按照一定规则进行计算</p><p>聚合将您的数据汇总为指标、统计或其他分析</p><p>可以帮助你回答类似如下问题：</p><ul><li>我的网页平均加载时间是多少？</li><li>根据交易量谁是我最有价值的客户？</li><li>在我的网站上大文件的衡量标准是多少？</li><li>每个产品类别有多少种产品？</li></ul><p>在关系型数据库中，聚合以 <code>GROUP BY</code> 关键字和聚合函数的方式进行实现</p><p>例如统计每个班级下男生的人数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `classId`,<span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> <span class="string">&#x27;number&#x27;</span> <span class="keyword">FROM</span> `student` <span class="keyword">WHERE</span> `gender` <span class="operator">=</span> &quot;male&quot; <span class="keyword">GROUP</span> <span class="keyword">BY</span> `classId`;</span><br></pre></td></tr></table></figure><p>按照班级即 <code>classId</code> 字段进行聚合，使用 <code>COUNT()</code> 聚合函数来统计数量</p><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>模拟一个场景来使用 ES 实现需求，设置这样一个索引</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PUT /student-index/_mapping</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;float&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>模拟数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /student-index/_doc</span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">22</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;male&quot;</span><span class="punctuation">,</span><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">70</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;李四&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">19</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;male&quot;</span><span class="punctuation">,</span><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">72.5</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;王五&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">20</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;male&quot;</span><span class="punctuation">,</span><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span><span class="number">3</span><span class="punctuation">,</span><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">80</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;小明&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">21</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;male&quot;</span><span class="punctuation">,</span><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">75</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;小红&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">19</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;female&quot;</span><span class="punctuation">,</span><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">50</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;小兰&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">18</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;female&quot;</span><span class="punctuation">,</span><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span><span class="number">3</span><span class="punctuation">,</span><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">51</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;蛋蛋&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">20</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;male&quot;</span><span class="punctuation">,</span><span class="attr">&quot;class&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">90</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h1><p>在 ES 除了聚合 <code>aggregations</code> 外，有一种类似聚合的操作 <code>collapse</code> 折叠</p><blockquote><p>你可以使用 collapse 参数来基于字段值查询结果；每个折叠仅选择排序靠前的文档来完成折叠</p></blockquote><p>这里就可以看出折叠和聚合还是有使用上的区别的，聚合更关注的是聚合后的结果，而折叠是在原结果集基础上将字段去重，并且可以像分页一样对折叠结果进行分页</p><p>例如这样一组数据</p><table><thead><tr><th align="center">name</th><th align="center">class</th><th align="center">time</th></tr></thead><tbody><tr><td align="center">张三</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">李四</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">王五</td><td align="center">1</td><td align="center">3</td></tr></tbody></table><p>根据 <code>time</code> 倒序，按照 <code>class</code> 进行折叠，<code>size</code> 为 1，返回的结果应该是 <code>class = 1</code> 的数据，因为命中了 <code>name = &quot;王五&quot;</code> 的文档</p><p>当 <code>from</code> 为 1 时，返回 <code>class = 2</code>，此时所有折叠后的数据都已经查询完成</p><p>折叠更像是对于查询的一种特殊操作，其参数使用也和 <code>query</code> 在同一层级，返回体中也是在 <code>hits</code> 中返回文档</p><h2 id="折叠查询"><a href="#折叠查询" class="headerlink" title="折叠查询"></a>折叠查询</h2><p>对于模拟的数据，对 <code>class</code> 字段折叠，班级的顺序按照男生的年龄排序，取第二名</p><p>即全校年龄第二大的男性学生所在的班级</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">POST /student-index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;collapse&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;class&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="comment">// 不查询第一条</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>返回的结果，只取 hits 部分</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;student-index&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;k-mmzoQBCTaFCHoW7hai&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小明&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;class&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="number">75</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;class&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="number">2</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="number">21</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>_source</code> 结果选取了折叠所命中的第一个文档（折叠的依据）；<code>fields</code> 则是折叠的字段，说明年龄第二大的男生所在的班级是 2 班</p><h2 id="扩展结果"><a href="#扩展结果" class="headerlink" title="扩展结果"></a>扩展结果</h2><p>上面折叠的简单操作可以看到，返回的 hits 中包含了一个折叠依据的文档（排序条件的第一个文档）</p><p>如果需要返回折叠字段下的所有文档（我认为更像是分组操作），可以使用 <code>inner_hit</code> 参数实现</p><p>取全校年龄第二大的男性学生所在的班级下面的所有学生，且按照身高正序排列</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">POST /student-index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;collapse&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;class&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;inner_hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;student_in_class&quot;</span><span class="punctuation">,</span> <span class="comment">// 自定的结果集名字</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span> <span class="comment">// inner_hits 内文档数量</span></span><br><span class="line"><span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// 这个排序参数是 inner hit，内部文档的排序</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// 这个排序参数是查询条件的排序</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>返回结果前半部分和折叠查询一样，只取 <code>inner_hit</code> 字段下的结果集</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;inner_hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;student_in_class&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;relation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eq&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;max_score&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;student-index&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kemmzoQBCTaFCHoWyxaJ&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李四&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">19</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;class&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="number">72.5</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="number">72.5</span></span><br><span class="line">                    <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;student-index&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;k-mmzoQBCTaFCHoW7hai&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小明&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;class&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="number">75</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="number">75</span></span><br><span class="line">                    <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到 <code>inner_hits</code> 下是 <code>student_in_class</code> 自定的结果集名称，也就意味着一次 <code>inner_hits</code> 可以设置多个不同规则的结果集请求（<code>inner_hits</code> 参数是个数组）</p><p>返回的结果中包含了 2 班下的两名学生，并且根据 <code>height</code> 字段进行了排序</p><h2 id="search-after"><a href="#search-after" class="headerlink" title="search after"></a>search after</h2><p>折叠操作同样支持 search after 操作</p><p>因为本质上 ES 也是排序后根据文档顺序对折叠字段进行操作，当 search after 字段略过该值后，继续对未折叠字段值进行折叠操作</p><p>但是需要注意，<strong>只有当折叠字段和排序字段是同一字段时才能使用该方式，同时不允许二级排序</strong></p><p>语法和基本查询一致</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GET /search&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;collapse&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user.id&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;user.id&quot;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;search_after&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;dd5ce1ad&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="二级折叠"><a href="#二级折叠" class="headerlink" title="二级折叠"></a>二级折叠</h2><p>对某一个字段折叠后，<code>inner_hits</code> 内还可以对其他字段再进行一次折叠</p><p>但二次折叠无法使用 <code>inner_hits</code> 参数，即折叠只能支持到二级</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;collapse&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;class&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;inner_hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;student_in_class&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;collapse&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;height&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>根据 <code>class</code> 折叠后的内部文档，再根据 <code>height</code> 进行折叠操作</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> ES </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
            <tag> ES 碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES 的 from size 和 scroll 和 search after</title>
      <link href="/%E5%BC%80%E5%8F%91/ES/ES%20%E7%9A%84%20from%20size%20%E5%92%8C%20scroll%20%E5%92%8C%20search%20after.html"/>
      <url>/%E5%BC%80%E5%8F%91/ES/ES%20%E7%9A%84%20from%20size%20%E5%92%8C%20scroll%20%E5%92%8C%20search%20after.html</url>
      
        <content type="html"><![CDATA[<h1 id="from-size"><a href="#from-size" class="headerlink" title="from size"></a>from size</h1><p>from size 是最常见的分页方式，类比 MySQL 的 offset limit</p><p>由于 ES 是天然分布式的，数据分散在各个 shards 上，所以需要查询 <code>from + size</code> 的条数时，coordinate node 就向该 index 的其余的  shards 发送同样的请求，等汇总到 <code>(shards × (from + size))</code> 条数时在 coordinate node 再进行一次排序，最终抽取出真正 from 后的 size 条结果</p><p>显而易见，当 shards 较多、分页深度很大时，这种方式存在很大的性能问题，这也是 ES 默认深度为 <code>from + size &lt;= 10000</code> 的原因</p><h2 id="Routing-机制"><a href="#Routing-机制" class="headerlink" title="Routing 机制"></a>Routing 机制</h2><p>写入文档时指定存储的分片</p><p>官方提供的公式如下：<code>shard_num = hash(_routing) % num_primary_shards</code></p><ul><li><code>_routing</code> 代表提供路由的字段。默认情况下为文档的 ID</li><li><code>num_primary_shards</code> 代表的为 primary shard 的个数，这个在每个索引类型创建之前就被设置了，可以手动设置也可以让 ES 默认设置。因为 ES 版本不同，设置的默认值也不同。该值在第一次创建索引类型被设置完成之后无法无法修改（修改路由机制就代表需要迁移数据）</li><li><code>shard_num</code> 代表数据落在的 shard 编号</li></ul><p>基本流程是 ES 根据路由字段计算其哈希值，再与主分片数量取余，计算得出数据落在的分片编号</p><p>此外如果只根据 <code>_routing</code> 会出现数据倾斜，可以采取折中方案，使用 <code>routing_partition_size</code> 参数，来使同一类 <code>_routing</code> 路由到主分片的一个子集中</p><p><code>shard_num = (hash(_routing) + hash(_id) % routing_partition_size) % num_primary_shards</code></p><h2 id="restful"><a href="#restful" class="headerlink" title="restful"></a>restful</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST /hero-index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;must_not&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// searchRequest</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hero-index&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询条件</span></span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">    <span class="comment">// 分页条件</span></span><br><span class="line">    searchSourceBuilder.from(<span class="number">0</span>);</span><br><span class="line">    searchSourceBuilder.size(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// term name = &quot;&quot;</span></span><br><span class="line">    <span class="type">TermQueryBuilder</span> <span class="variable">termQueryBuilder</span> <span class="operator">=</span> QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// bool 类型为 must not</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery().mustNot(termQueryBuilder);</span><br><span class="line">    <span class="comment">// 查询条件组装进 searchSourceBuilder</span></span><br><span class="line">    searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line">    searchSourceBuilder.timeout(<span class="keyword">new</span> <span class="title class_">TimeValue</span>(<span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">search</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;totalHits:&quot;</span> + search.getHits().getTotalHits().value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="search-after"><a href="#search-after" class="headerlink" title="search after"></a>search after</h1><p>ES 5 引入的新机制</p><p>简单概括 search after 如何使用：</p><ul><li>必须先指定排序规则（需要获取排序坐标）</li><li>比如从第一页开始（从中间开始也无法知道中间的具体位置）</li><li>从第一页开始以后每次都带上<code>search_after=lastEmittedDocFieldValue</code><br><code>lastEmittedDocFieldValue</code> 就是下一页开始的 keyset 坐标（也就是这个参数把深度分页变成了常数级分页）</li></ul><p><strong>和 from size 相比，无论去到第几页，coordinate node 向其它 node 发送的请求始终就是请求 size 个 docs；即无论分页深度是多少，都是常量级的开销</strong></p><p>其实现原理和关系型数据库常使用的 keyset 分页思想一致，业务妥协（只能按顺序分页而不能跳转页数）来实现性能的提升</p><p>但需要注意，看似 search after 是一个 O(1) 级别的操作，但随着分页深度的增加，其内部逻辑扫描的 doc 数量也在不断增加，依然会影响查询性能，只是相比 from size 方式有一定提升（MySQL 单表查询的分页也是如此）</p><p>此外，如果字段区分度不高，则会忽略某些数据；例如根据 age 作为排序条件，此时如果每页数据取 1000 条，而某个 age 数据 count &gt; 1000，则会忽略后续数据；<strong>解决方法是排序字段唯一，或者组合后的多个排序条件唯一</strong></p><h2 id="restful-1"><a href="#restful-1" class="headerlink" title="restful"></a>restful</h2><p>第一次查询和普通查询一致</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">POST /hero-index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;must_not&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>随后的查询增加 <code>search_after</code> 查询条件，值为最后一条数据排序字段的值</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">POST /hero-index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;must_not&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;search_after&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="number">35</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;i-mnlIQBCTaFCHoWJhbM&quot;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h2><p>同 from size 一致</p><p>第二次查询及之后需要 <code>searchSourceBuilder.searchAfter(new Object[1]);</code> 来设置 <code>search_after</code> 参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">searchAfter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// searchRequest</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hero-index&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询条件</span></span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">    <span class="comment">// 分页条件</span></span><br><span class="line">    searchSourceBuilder.from(<span class="number">0</span>);</span><br><span class="line">    searchSourceBuilder.size(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// term name = &quot;&quot;</span></span><br><span class="line">    <span class="type">TermQueryBuilder</span> <span class="variable">termQueryBuilder</span> <span class="operator">=</span> QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// bool 类型为 must not</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery().mustNot(termQueryBuilder);</span><br><span class="line">    <span class="comment">// 查询条件组装进 searchSourceBuilder</span></span><br><span class="line">    searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line">    searchSourceBuilder.timeout(<span class="keyword">new</span> <span class="title class_">TimeValue</span>(<span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上批数据最后一条的排序字段值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastHitOrderFieldValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// set 进 searchAfter 属性中</span></span><br><span class="line">    searchSourceBuilder.searchAfter(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;lastHitOrderFieldValue&#125;);</span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">search</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;totalHits:&quot;</span> + search.getHits().getTotalHits().value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h1><p>如果一开始就明确地查询全量的数据，无论使用 from size 还是 search after 都不是一个好的选择，要么依然存在深度分页的问题，要么需要多次请求，所以引入了 scroll 方式</p><p>scroll 就是把一次的查询结果缓存一定的时间，如 <code>scroll = 1m</code> 则把查询结果在下一次请求上来时暂存 1 分钟</p><p>response 比传统的返回多了一个 <code>scroll_id</code>，下次带上这个 <code>scroll_id</code> 即可找回这个缓存的结果</p><p>本质上是让各个 shard 将结果缓存，此外也有很多优化（单 shard 减少请求数量、剪枝等）来提高性能</p><h2 id="restful-2"><a href="#restful-2" class="headerlink" title="restful"></a>restful</h2><p>第一次请求</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">POST /hero-index/_search?scroll=<span class="number">1</span>m</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;must_not&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>随后</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /_search/scroll</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;scroll&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1m&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;scroll_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;FGluY2x1ZGVfY29udGV4dF91dWlkDXF1ZXJ5QW5kRmV0Y2gBFlN0TlRCWW5pUktHLWxvMEdDN3Zya2cAAAAAAAAA_hZkVXh5THJ1SFR1dVVPQlJJX3JDZWRR&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scrollSearch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// searchRequest</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hero-index&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询条件</span></span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">    <span class="comment">// 分页条件</span></span><br><span class="line">    searchSourceBuilder.from(<span class="number">0</span>);</span><br><span class="line">    searchSourceBuilder.size(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// term name = &quot;&quot;</span></span><br><span class="line">    <span class="type">TermQueryBuilder</span> <span class="variable">termQueryBuilder</span> <span class="operator">=</span> QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// bool 类型为 must not</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery().mustNot(termQueryBuilder);</span><br><span class="line">    <span class="comment">// 查询条件组装进 searchSourceBuilder</span></span><br><span class="line">    searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line">    searchSourceBuilder.timeout(<span class="keyword">new</span> <span class="title class_">TimeValue</span>(<span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 scroll</span></span><br><span class="line">    <span class="type">Scroll</span> <span class="variable">scroll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scroll</span>(TimeValue.timeValueMinutes(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    searchRequest.scroll(scroll);</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">search</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;totalHits:&quot;</span> + search.getHits().getTotalHits().value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后应该循环查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scrollAfterSearch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义 scroll</span></span><br><span class="line">    <span class="type">Scroll</span> <span class="variable">scroll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scroll</span>(TimeValue.timeValueMinutes(<span class="number">1</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">scrollId</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">SearchScrollRequest</span> <span class="variable">searchScrollRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchScrollRequest</span>(scrollId);</span><br><span class="line">    searchScrollRequest.scroll(scroll);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    searchScrollRequest.scroll(scroll);</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">search</span> <span class="operator">=</span> client.scroll(searchScrollRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;totalHits:&quot;</span> + search.getHits().getTotalHits().value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>文章 <strong>《业界难题 - ”跨库分页” 的四种方案》</strong></p><h2 id="需求产生"><a href="#需求产生" class="headerlink" title="需求产生"></a>需求产生</h2><p><strong>分页需求</strong></p><p>对于数据的查询，很多业务都有分页拉取数据的需求，例如：分页拉取聊天记录、商品信息、图片数据等</p><p>除了对数据集拆分，往往还需要业务字段进行排序</p><p>比如取第 3 页的订单数据，每页 100 条，根据创建时间倒序；可以根据创建时间建立索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">order</span>` <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span> LIMIT <span class="number">200</span>,<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><strong>分库分表</strong></p><p>随着业务的发展，为了应对数据量大、请求量大等问题，对数据库进行了横向扩展</p><p>引入分库分表后，数据根据 patition key 路由规则写入不同的库表中</p><p>同时为了让读写压力尽可能均匀分布在各个库中，往往会设置合适的 patition key</p><p>当分库分表后需要进行示例的分页需求时，就无法通过简单的请求一个库实现目的了（假设分表键不是使用的创建时间，事实上使用创建时间范围作为分表键也没任何意义）</p><p>排序的依据是时间，分表的依据是其他字段，因此数据库丧失了创建时间排序的全局视野</p><p>本文就在讨论如何满足 跨越多个水平拆分数据库的分页查询问题</p><h2 id="全局视野"><a href="#全局视野" class="headerlink" title="全局视野"></a>全局视野</h2><p>当数据分布在两个库中，无论哪个分库的第三页，都不一定会是全局排序的第三页数据</p><p>情况如下：</p><ul><li>一般情况：两个库各占第三页数据的一部分</li><li>极端情况：两个库各占一半</li><li>极端情况：第三页数据完全来自于一个库</li></ul><p>由于查询前并不清楚数据到底是如何分布在各个分库上的，所以每个库都返回 3 页数据，所得到的 6 页数据再进行排序，此时获得了根据创建时间排序的全局视野，再从 6 页数据中抽取需要的第 3 页数据</p><p><strong>优点：</strong></p><ul><li>业务无损，精准返回</li></ul><p><strong>缺点：</strong></p><ul><li><p>每次需要向各分库查询的数据量和 shard 数量倍数级相关，和页码（深度）指数级相关</p></li><li><p>需要二次排序</p></li><li><p>需要更多 IO 资源</p></li></ul><h2 id="禁止跳页"><a href="#禁止跳页" class="headerlink" title="禁止跳页"></a>禁止跳页</h2><p>由业务进行妥协，不允许进行页数的随意跳转，只允许依次进行 下一页 操作，就能减少深度分页带来的性能影响</p><p>被称为 keyset 分页、search after 等</p><p>首先这种方式需要先进行排序，比如使用创建时间作为排序字段，第一页时各分库执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">order</span>` <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span> LIMIT <span class="number">0</span>,<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>当点击下一页时，根据第一页数据的最后一条，即第一页中最小创建时间的数据（假设是 1669820860000），各分库执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">order</span>` <span class="keyword">WHERE</span> `createdTime` <span class="operator">&gt;</span> <span class="number">1669820860000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span> LIMIT <span class="number">0</span>,<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>可以发现，除第一次查询时，后面每次查询都需要带上排序条件下，上一次查询最后数据的排序值，这也是无法进行跳页的原因，因为不通过查询无法知道所需页数据的 search after 条件是多少</p><p>禁止跳页后每个分库一次都只查询一页数据，查询数据量只和分库数量倍数级相关</p><p><strong>优点：</strong></p><ul><li>性能相对较好，不受全局视野中深度分页指数级影响</li></ul><p><strong>缺点：</strong></p><ul><li>业务进行不能跳页的妥协</li><li>排序字段需要具有区分度</li></ul><h2 id="允许精度损失"><a href="#允许精度损失" class="headerlink" title="允许精度损失"></a>允许精度损失</h2><p>正常情况下，patition key 规则都尽可能使数据均匀分布在各分库中</p><p>所以可以理想认为，每个分库都完整包含了数据的一部分</p><p>假设需要取第 100 页数据，有 2 个分库，可以各取每个分库的半页数据再得到数据的并集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">order</span>` <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span> LIMIT <span class="number">9450</span>,<span class="number">50</span>;</span><br></pre></td></tr></table></figure><p>这种方式最终结果只能是近似结果，并不精准</p><p><strong>优点：</strong></p><ul><li>性能相对较好，不受全局视野中深度分页指数级影响</li></ul><p><strong>缺点：</strong></p><ul><li>业务进行精度损失的妥协</li></ul><h2 id="二次查询"><a href="#二次查询" class="headerlink" title="二次查询"></a>二次查询</h2><p>这种方式既能做到精准数据，也能减少查询量</p><p>基本的思想是通过多次查询来获得全局视野，再根据全局视野在结果集中抽取需要的数据</p><p>假设一页查询 5 条数据，查询第 201 页，有三个分库；单表查询如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">order</span>` <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span> LIMIT <span class="number">1000</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure><p><strong>第一步：</strong></p><p>改写查询，各分库按理想情况下数据分布进行查询，即</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">order</span>` <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span> LIMIT <span class="number">333</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>返回结果</p><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">C</th></tr></thead><tbody><tr><td align="center">523</td><td align="center">423</td><td align="center">500</td></tr><tr><td align="center">423</td><td align="center">421</td><td align="center">400</td></tr><tr><td align="center">323</td><td align="center">400</td><td align="center">300</td></tr><tr><td align="center">223</td><td align="center">320</td><td align="center">200</td></tr><tr><td align="center">123</td><td align="center">320</td><td align="center">100</td></tr></tbody></table><p><strong>第二步：</strong></p><p>结果集排序后，找到排序字段第一位的值，<code>createdTime DESC</code>，即创建时间的最大值</p><p>可以得到是分库 A 返回的 523</p><p><strong>第三步：</strong></p><p>扩大查询范围，查询条件使用 <code>between</code> 语句，最大值为全局最大值（523），最小值为该分库返回结果集的最大值（B-423，C-500）</p><p>因为最大值在分库 A 结果集中，所以 A 是不需要二次请求的（523 和 123 数据中必然还是上一次的结果集）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `order_B` <span class="keyword">WHERE</span> `createdTime` <span class="keyword">BETWEEN</span> <span class="number">523</span> <span class="keyword">AND</span> <span class="number">423</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `order_C` <span class="keyword">WHERE</span> `createdTime` <span class="keyword">BETWEEN</span> <span class="number">523</span> <span class="keyword">AND</span> <span class="number">500</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `createdTime` <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>B、C 可能会返回更多的数据，结果集更新为</p><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">C</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center">520</td></tr><tr><td align="center"></td><td align="center">499</td><td align="center">510</td></tr><tr><td align="center">523</td><td align="center">423</td><td align="center">500</td></tr><tr><td align="center">423</td><td align="center">421</td><td align="center">400</td></tr><tr><td align="center">323</td><td align="center">400</td><td align="center">300</td></tr><tr><td align="center">223</td><td align="center">320</td><td align="center">200</td></tr><tr><td align="center">123</td><td align="center">320</td><td align="center">100</td></tr></tbody></table><p><strong>第四步：</strong></p><p>推断全局视野</p><p>在分库 A 中，523 是第 333 条数据</p><p>在分库 B 中，加上新返回的 1 条数据，523 是第 333 - 1 - 1 &#x3D; 331 条数据</p><p>在分库 C 中，加上新返回的 2 条数据，523 是第 333 - 2 -1 &#x3D; 330 条数据</p><p>此时得到整个结果集中的最大值 523 在全局的 offset 应该是 333 + 331 + 330 &#x3D; 994</p><p><strong>第五步：</strong></p><p>已经有了 523 这个数据的全局视野，offset 994</p><p>又有了结果集 18 条数据</p><p>那么排序后就可以在结果集中找到 offset 1000 limit 5 的数据集了</p><p><strong>优点：</strong></p><ul><li>既能精准获取结果，又能避免深度分页</li></ul><p><strong>缺点：</strong></p><ul><li><p>逻辑复杂</p></li><li><p>需要多次查询</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th align="center">方式</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">全局视野</td><td align="center">精确</td><td align="center">性能问题</td></tr><tr><td align="center">禁止跳页</td><td align="center">避免深度分页</td><td align="center">业务妥协</td></tr><tr><td align="center">允许精度损失</td><td align="center">避免深度分页</td><td align="center">业务妥协</td></tr><tr><td align="center">二次查询</td><td align="center">精确 + 避免深度分页</td><td align="center">多次查询</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/91d03b16af77">Elasticsearch 5.x 源码分析（3）from size, scroll 和 search after - 简书 (jianshu.com)</a></p><p><a href="https://developer.aliyun.com/article/713865">业界难题-“跨库分页”的四种方案-阿里云开发者社区 (aliyun.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> ES </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
            <tag> ES 碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象六大原则</title>
      <link href="/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99.html"/>
      <url>/%E5%BC%80%E5%8F%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99.html</url>
      
        <content type="html"><![CDATA[<h1 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h1><table><thead><tr><th>设计原则</th><th>概述</th><th>目的</th></tr></thead><tbody><tr><td>开闭原则</td><td>对扩展开放，对修改关闭</td><td>易于维护</td></tr><tr><td>单一职责</td><td>一个类只干一件事，实现类要单一</td><td>提升可读性</td></tr><tr><td>里氏替换</td><td>不要重写父类的方法</td><td>健壮性、防止错误继承</td></tr><tr><td>迪米特法则</td><td>最少知道，对象之间少建立联系</td><td>低耦合</td></tr><tr><td>接口隔离</td><td>一个接口只干一件事，接口要精简单一</td><td>高内聚</td></tr><tr><td>依赖倒置</td><td>高层不应该依赖低层，要面向接口编程</td><td>利于结构升级</td></tr></tbody></table><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><blockquote><p><em>Software entities like classes,modules and functions should be open for extension but closed for modifications.</em></p><p><em>一个软件实体如类，模块和函数应该对扩展开放，对修改关闭</em></p></blockquote><p>随着业务发展需要增加新的方法，有几种方式：</p><ul><li><strong>在接口上添加新方法</strong><ul><li>导致每一个实现类都需要进行实现，改动量大</li><li>不一定所有的实现类都需要该方法</li></ul></li><li><strong>修改实现类旧方法</strong><ul><li>替代原有旧方法功能，如果同时需要使用旧方法则无法采用此方式 （<code>getPrice()</code> 获取的是原价格还是打折后价格？如果需要同时获取原价和打折后价格如何处理）</li></ul></li><li><strong>面向扩展，使用新接口或者新类继承父类</strong><ul><li>新接口方法接口，需要的类进行实现</li><li>新类继承父类，在父类基础上增加方法</li></ul></li></ul><p><strong>明显面向扩展更容易维护，这就是开闭原则的目的</strong></p><h2 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h2><blockquote><p><em>There should never be more than one reason for a class to change. —— Robert C. Martin</em></p><p><em>一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分</em></p></blockquote><p>控制业务实现的粒度问题；一个类可以具备任意数量的方法，但都属于同一个功能簇中</p><p><strong>严格控制类中方法的粒度，必要时进行分析与拆分</strong></p><h2 id="里氏替换"><a href="#里氏替换" class="headerlink" title="里氏替换"></a>里氏替换</h2><blockquote><p><em>Inheritance should ensure that any property proved about supertype objects also holds for subtype objects. —— Liskov</em></p><p><em>继承必须确保父类所拥有的性质在子类中仍然成立</em></p></blockquote><p>在里氏替换原则的指导方针下，可得出：仅仅依据两个类之间有没有 “is a” 的关系，来判断两个类能不能发生继承关系是不够的</p><p>应该遵守一个大原则：<strong>任何使用父类的地方，都能被透明的替换成子类，且替换成子类后，程序行为不会发生问题</strong></p><p>不应该滥用继承关系，鸵鸟是否是鸟的子类（不会飞），鲸鱼是否是鱼的子类（没有腮），继承具有侵入性，当需要使用继承关系时需要辨明是否是真正的继承，<strong>父类的每个方法都必须适用于子类</strong></p><ol><li>子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法</li><li>子类可以增加自己特有的方法</li><li>子类重载父类方法时，方法的形参要比父类方法更为宽松</li><li>子类实现父类抽象方法时，方法的返回值要比父类方法更为严格</li></ol><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><blockquote><p><em>talk only to your immediate friends. —— Ian Holland</em></p><p><em>只和直接的朋友交流</em></p></blockquote><p>迪米特法则也称为最少知道原则，最少知道包含两个目的：</p><ul><li><strong>只和直接的朋友交互</strong><ul><li>例如 MVC 架构，视图层和业务层交互，业务层和持久层交互，视图层不应该和持久层产生联系</li></ul></li><li><strong>较少对朋友的了解</strong><ul><li>类门面模式（门面指暴露重要工作的简单入口，而迪米特法则在于只暴露该暴露的入口，还是有所区别）思想，对外只暴露能够满足外部需要的内容</li></ul></li></ul><p><strong>目的在于降低类之间的耦合关系</strong></p><h2 id="接口隔离"><a href="#接口隔离" class="headerlink" title="接口隔离"></a>接口隔离</h2><blockquote><p><em>Interface Segregation Principle, ISP</em></p><p><em>低耦合、高内聚中的高内聚</em></p></blockquote><p>接口隔离原则中所说的接口并不是狭意的指 Java 中的 Interface，而是一切的提供方法定义的对象，例如 Java 中的接口、抽象类、实体类</p><p>接口隔离的原则：</p><ul><li>客户端不依赖不需要的接口</li><li>类间依赖关系建立在最小的接口上</li><li>接口应该细化，不应该具备臃肿的方法</li></ul><p>例如发送方式的实现类 <code>Send</code>，此时具备两种发送方式：邮件和短信，如果将方法都放在 <code>Send</code> 类中，则应该分别定义 <code>sendEmail()</code> 和 <code>sendNotice()</code> 两个方法，不利于后面的拓展；好的解决方法应该是定义接口，然后分别创建 <code>EmailSend</code> 和 <code>NoticeSend</code> 两个实现类，这就是接口隔离的目的</p><p>接口隔离和单一原则看似冲突，目标是达到二者的平衡</p><p><strong>避免接口污染</strong></p><h2 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h2><blockquote><p><em>Dependence Inversion Principle,DIP</em></p><p><em>不依赖于具体实现，而依赖于抽象</em></p></blockquote><p>不正确的依赖关系是上层调用下层，上层依赖下层</p><p>面向对象其实就是依赖倒置的一种体现，依赖倒置让下层依赖上层，比如接口，接口方法的扩展会影响所有实现类，但抽象层的变动远远少于实现层，所以依赖倒置可以很好地避免频繁的修改</p><p><strong>面向接口编程</strong></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="如何满足里氏替换原则"><a href="#如何满足里氏替换原则" class="headerlink" title="如何满足里氏替换原则"></a>如何满足里氏替换原则</h2><p>里氏替换的原则指：需要使用父类的地方可以替换为子类使用，因为父类的方法在子类上应该保持一致</p><p>在实际中遇到直接继承不能满足里氏替换的场景，就<strong>说明抽象不足，需要向上抽象</strong></p><p>如果一个 <code>Add</code> 类的 <code>compute(int n)</code> 操作为加法，减法也想要进行实现，则继承 <code>Add</code> 类后重写了 <code>compute(int n)</code> 方法，此时则违反了里氏替换原则，整个方法的实现被重写了</p><p>向上抽象出 <code>Compute</code> 接口，即可以实现里氏替换原则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Compute</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span> <span class="keyword">implements</span> <span class="title class_">Compute</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subtract</span> <span class="keyword">implements</span> <span class="title class_">Compute</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;减法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://refactoringguru.cn/design-patterns">常用设计模式有哪些？ (refactoringguru.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
